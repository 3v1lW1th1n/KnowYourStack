{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":26,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":38,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7896820874","Type":"IssuesEvent","CreatedAt":"2018-06-29T09:52:53","Actor":"tomkerkhove","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/104","RelatedDescription":"Opened issue \"About still mentions CodePlex\" (#104) at dotnet/home","RelatedBody":"About still mentions CodePlex which is now in archive mode.\r\n\r\n![image](https://user-images.githubusercontent.com/4345663/42086259-e0b7d008-7b92-11e8-96c9-02ee61ddc457.png)\r\n\r\nIs this something that I can PR?"},{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7903807729","Type":"PullRequestEvent","CreatedAt":"2018-07-01T22:43:17","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18736","RelatedDescription":"Merged pull request \"Fix some build breaks seen with the older VS we use to build with on …\" (#18736) at dotnet/coreclr","RelatedBody":"…desktop.\r\n\r\n```\r\nsrc\\jit\\alloc.cpp(113): warning C4815: 's_pagePool' : zero-sized array in stack object will have no elements (unless the object is an aggregate that has been aggregate initialized)\r\nsrc\\jit\\disasm.cpp(867): error C2678: binary '!=' : no operator found which takes a left-hand operand of type 'CompAllocator' (or there is no acceptable conversion)\r\nsrc\\jit\\alloc.cpp(203): warning C4702: unreachable code\r\n```"},{"Id":"7903409151","Type":"IssuesEvent","CreatedAt":"2018-07-01T17:50:17","Actor":"dotnet-mc-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18739","RelatedDescription":"Opened issue \"Official Build failure: Link\" (#18739) at dotnet/coreclr","RelatedBody":"Opened on behalf of @RussKeldorph\n\nWarnings: 1\nStatus Message: failed\n\nBuild : Master - 20180701.03 (Product Build)\nFailing configurations:\n- Alpine3.6\n  - Build-Tests-R2R-Release\n  - Build-Tests-Release\n- RedHat6\n  - Build-Tests-R2R-Release\n  - Build-Tests-Release\n- RedHat 7\n  - Build-Tests-R2R-Release\n  - Build-Tests-Release\n- OSX\n  - Build-Tests-R2R-Release\n  - Build-Tests-Release\n- Windows\n  - Build-Tests-R2R-Release-arm64\n  - Build-Tests-Release-arm64\n  - Build-Tests-R2R-Release\n  - Build-Tests-Release\n[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180701.03/workItem/Orchestration/analysis/external/Link)\n"},{"Id":"7903182826","Type":"PullRequestEvent","CreatedAt":"2018-07-01T15:07:49","Actor":"tannergooding","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18738","RelatedDescription":"Opened pull request \" Adding support for the `byte` overload of `Ssse3.Shuffle`\" (#18738) at dotnet/coreclr","RelatedBody":"FYI. @CarolEidt, @fiigii, @eerhardt "},{"Id":"7902999983","Type":"PullRequestEvent","CreatedAt":"2018-07-01T13:02:06","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18737","RelatedDescription":"Merged pull request \"Fix recursive inlining of PInvoke stubs\" (#18737) at dotnet/coreclr","RelatedBody":"PInvoke stubs can be inlined into a regular methods in CoreRT. PInvoke transition\r\nhas to be inlined as well when that happens. Otherwise, there is a risk of recursive\r\ninlining in corner cases."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7897871958","Type":"IssuesEvent","CreatedAt":"2018-06-29T13:42:16","Actor":"4creators","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/787","RelatedDescription":"Opened issue \"nsboard GitHub team is not public\" (#787) at dotnet/standard","RelatedBody":"> There is also a (public) GitHub team [nsboard](https://github.com/orgs/dotnet/teams/nsboard) you can\r\nuse when you want the board to take a look at a particular issue\r\n\r\nActually nsboard team is not public. Following the above link leads to:\r\n\r\n\r\n![nsboard](https://user-images.githubusercontent.com/801959/42095457-f63bf5a6-7bb2-11e8-8e98-dff65911b038.png)\r\n\r\n\r\n\r\n"},{"Id":"7894690813","Type":"PullRequestEvent","CreatedAt":"2018-06-28T22:34:51","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/768","RelatedDescription":"Merged pull request \"Update version\" (#768) at dotnet/standard","RelatedBody":""},{"Id":"7894686205","Type":"IssuesEvent","CreatedAt":"2018-06-28T22:33:25","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/127","RelatedDescription":"Closed issue \"Request for a Formal Proposal Process\" (#127) at dotnet/standard","RelatedBody":"I'm very excited for .NET Standard; however, I am concerned that there is no formal process for changing it.\r\n\r\nFor example, **how does one propose APIs to be added**?\r\n\r\nThe [FAQ](https://github.com/dotnet/standard/blob/master/docs/faq.md#who-decides-what-is-in-net-standard) says that the board (a closed group of a few runtime vendors) decide.\r\n\r\nI do not think that this is sufficient to keep Standard evolving with the demands of developers. I worry that only features that these vendors are interested in will get added and the larger .NET community will be voiceless.\r\n\r\nI would like to see a formal proposal process, open to anyone, that we can track, to see changes made to Standard.\r\n\r\nWhat is the current state here? Are we supposed to use github issues to change the standard? If that is the case, then perhaps a proposal_instructions.md doc should be written so that people have a template or something to work from."},{"Id":"7894686139","Type":"PullRequestEvent","CreatedAt":"2018-06-28T22:33:24","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/764","RelatedDescription":"Merged pull request \"Detail governance model for .NET Standard\" (#764) at dotnet/standard","RelatedBody":"This updates the previously fairly vague definition of the .NET Standard review board and outlines the process by which we decide whether APIs will be added to .NET Standard. Key aspects:\r\n\r\n* Anybody can submit API standardization requests\r\n* The API request needs a sponsor that is on the .NET Standard review board\r\n* The API needs an implementation in at least one .NET implementation\r\n* The .NET Standard review board has representatives from all existing .NET implementations. @migueldeicaza will act as the chairman, which is fancy way to say he'll act as the tie-breaker.\r\n\r\n@migueldeicaza @dotnet/fxdc @dotnet/nsboard "}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7904369937","Type":"IssuesEvent","CreatedAt":"2018-07-02T04:01:08","Actor":"nomadsoar","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30685","RelatedDescription":"Closed issue \"Running Microsoft/Mobius with .NetCore 2.1.301 occurs SerializationException: \"Serializing delegates is not supported on this platform\"\" (#30685) at dotnet/corefx","RelatedBody":"I tried to run [Microsoft/Mobius](https://github.com/Microsoft/Mobius) with .NetCore v2.1.301 instead of mono because .NetCore has better performance than mono.\r\n\r\nHowever, for some action functions such as first(), take(), fold() and etc. in Mobius will occur below exception:\r\n\r\n ```\r\nUnhandled Exception: System.Runtime.Serialization.SerializationException: Serializing delegates is not supported on this platform.\r\n   at System.MulticastDelegate.GetObjectData(SerializationInfo info, StreamingContext context)\r\n   at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder)\r\n   at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo)\r\n   at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph, BinaryFormatterWriter serWriter, Boolean fCheck)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream, Object graph, Boolean check)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream, Object graph)\r\n   at Microsoft.Spark.CSharp.Core.SparkContext.BuildCommand(CSharpWorkerFunc workerFunc, SerializedMode deserializerMode, SerializedMode serializerMode) in /home/neil/CathayLia/CathayLia_v5.0-NetCoreSpark/Adapter/Core/SparkContext.cs:line 607\r\n   at Microsoft.Spark.CSharp.Core.PipelinedRDD`1.get_RddProxy() in /home/neil/CathayLia/CathayLia_v5.0-NetCoreSpark/Adapter/Core/PipelinedRDD.cs:line 97\r\n   at Microsoft.Spark.CSharp.Core.RDD`1.GetNumPartitions() in /home/neil/CathayLia/CathayLia_v5.0-NetCoreSpark/Adapter/Core/RDD.cs:line 197\r\n   at Microsoft.Spark.CSharp.Core.RDD`1.Take(Int32 num) in /home/neil/CathayLia/CathayLia_v5.0-NetCoreSpark/Adapter/Core/RDD.cs:line 803\r\n   at Microsoft.Spark.CSharp.Core.RDD`1.First() in /home/neil/CathayLia/CathayLia_v5.0-NetCoreSpark/Adapter/Core/RDD.cs:line 854\r\n   at Cathaylife.CathayLiability.Main(String[] args) in /home/neil/CathayLia/CathayLia_v5.0-NetCoreSpark/NetCoreSparkLiability/Program.cs:line 122\r\n```\r\n\r\nThis exception will not occur if I run Microsoft/Mobius with mono.\r\n\r\nBelow is my environment information:\r\nOS: CentOS 7.5\r\nNetCore: 2.1.301\r\nMono: 5.12\r\nMicrosoft/Mobius: 2.0.200\r\nReferred Nuget package:\r\n- log4net: 2.0.8\r\n- Microsoft.Extensions.Configuration.Xml: 2.1.1\r\n- Newtonsoft.Json: 11.0.2\r\n- Razorvine.Pyrolite.NetCore: 1.0.0\r\n- Razorvine.Serpent.NetCore: 1.18.0\r\n\r\nIs there any solution for it ? \r\n\r\nThank you.\r\n"},{"Id":"7904224535","Type":"IssuesEvent","CreatedAt":"2018-07-02T02:56:52","Actor":"JeremyKuhne","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/issues/2808","RelatedDescription":"Reopened issue \"Synchronized colors in the console\" (#2808) at dotnet/corefx","RelatedBody":"TLDR: I believe that there is currently no way to correctly write colored messages to the console in a multi-threaded environment. There should be one.\n\nLong version:\n\nWhen you want to write a colored message to the console, the common pattern looks something like:\n\n``` c#\nConsole.ForegroundColor = ConsoleColor.Red;\nConsole.WriteLine(\"ERROR!\");\nConsole.ResetColor();\n```\n\nThis approach is not thread-safe, since other writers can also write while the color is set.\n\nAn improvement is [to lock on a private object](http://stackoverflow.com/a/13861466/41071):\n\n``` c#\nstatic object lockObj = new object();\n\n...\n\nlock (lockObj)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.WriteLine(\"ERROR!\");\n    Console.ResetColor();\n}\n```\n\nThis will synchronize correctly among writers that use the same lock object, but other writers can still end up with incorrect color.\n\nOn the Desktop .Net, writing to the console uses [`SyncTextWriter`](http://referencesource.microsoft.com/#mscorlib/system/io/textwriter.cs,9e3dd0323cf4ee8b) as `Console.Out` which locks on itself. This means that locking on `Console.Out` will synchronize correctly with other non-colored writers (those that just call `Console.WriteLine` without any additional synchronization) and colored writers which also lock on `Console.Out`:\n\n``` c#\nlock (Console.Out)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.WriteLine(\"ERROR!\");\n    Console.ResetColor();\n}\n```\n\nOn CoreFX, [a different version of `SyncTextWriter`](https://github.com/dotnet/corefx/blob/fa6e6a1e6300cdbffa31998a8c70d3bb9b7d06c3/src/System.Console/src/System/IO/SyncTextWriter.cs) is used, which locks on its own private lock object. This is generally considered a better practice than locking on `this`, but it also means there is no way to write a colored message to the console that is correctly synchronized with non-colored writers.\n\nIt would be nice if there was an officially supported pattern to write a colored message to the console with correct synchronization on both Desktop and Core. Failing that, I think that `SyncTextWriter` on Core should be implemented the same way as the Desktop version, so that the `lock (Console.Out)` version also worked on Core, event if it's relying on an implementation detail.\n"},{"Id":"7903997512","Type":"PullRequestEvent","CreatedAt":"2018-07-02T01:07:01","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30778","RelatedDescription":"Opened pull request \"Update CoreClr, CoreSetup to preview1-26702-01, preview1-26701-03, respectively (master)\" (#30778) at dotnet/corefx","RelatedBody":""},{"Id":"7903693936","Type":"IssuesEvent","CreatedAt":"2018-07-01T21:17:17","Actor":"Drawaes","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30777","RelatedDescription":"Opened issue \"API Proposal - NetworkPipe\" (#30777) at dotnet/corefx","RelatedBody":"## Rationale\r\nCurrently pipelines has made it to the BCL however in almost all use cases (networking files etc) in order to actually use these primitives you either need to roll your own or \"hook\" the pipeline up to a stream which breaks the model somewhat of shared pooled buffers being pushed up from the source.\r\n\r\nWe can see a number of proprietory and OSS implementations of a \"network pipe\" as well as internal implementations in AspNetCore. @mgravell has an \"unofficial\" nuget package that is a temporary implementation that is currently out there. However I believe this is a \"core\" library function and should be a minimal amount of code that is highly performance critical and needs many eyes on it.\r\n\r\n## API Shape\r\n\r\nThe following API is proposed to both align with the \"natural\" way that pipelines works and \"looks\" but to also to be very close to the shape (for the constructor anyway) that NetworkStream uses.\r\n\r\n``` csharp\r\nnamespace System.Net.Sockets\r\n{\r\n    public class NetworkPipe : IDuplexPipe, IDisposable\r\n    {\r\n        public NetworkPipe(Socket socket, PipeOptions pipeOptions)\r\n            : this(socket, pipeOptions, FileAccess.ReadWrite, true) { }\r\n\r\n        public NetworkPipe(Socket socket, PipeOptions pipeOptions, bool ownsSocket)\r\n            : this(socket, pipeOptions, FileAccess.ReadWrite, ownsSocket) { }\r\n\r\n        public NetworkPipe(Socket socket, PipeOptions pipeOptions, FileAccess access, bool ownsSocket) { }\r\n\r\n        public PipeReader Input => throw new NotImplementedException();\r\n        public PipeWriter Output => throw new NotImplementedException();\r\n        public void Dispose() => throw new NotImplementedException();\r\n    }\r\n}\r\n```\r\n\r\nOpen questions\r\n1. I am not precious about the API shape so have at it\r\n2. It might be a good idea to allow recycling here ? Or maybe its not worth it on a per connection basis?\r\n3. Are there more options that would be needed?\r\n\r\nObviously other classes can be built up from here (listerner, connection etc) but this class underpins both a server and client side implementation\r\n\r\n/cc @mgravell @benaadams @NickCraver @davidfowl @stephentoub \r\n"},{"Id":"7903519724","Type":"PullRequestEvent","CreatedAt":"2018-07-01T19:10:16","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30773","RelatedDescription":"Merged pull request \"Update CoreClr, CoreSetup to preview1-26701-03, preview1-26701-01, respectively (master)\" (#30773) at dotnet/corefx","RelatedBody":""},{"Id":"7903498791","Type":"IssuesEvent","CreatedAt":"2018-07-01T18:55:49","Actor":"tarekgh","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30593","RelatedDescription":"Reopened issue \"mac:dotnet new FailFast (ja_JP.UTF-8)\" (#30593) at dotnet/corefx","RelatedBody":"I have an error below, when I run \"dotnet new --all\" command after installed a pkg of \"dotnet-sdk-2.1.300-osx-x64.pkg\" on macOS High Sierra v10.13.5. \r\n\r\nFailFast:\r\nInfinite recursion during resource lookup within System.Private.CoreLib.  This may be a bug in System.Private.CoreLib, or potentially in certain extensibility points such as assembly resolve events or CultureInfo names.  Resource name: Argument_InvalidResourceCultureName\r\n\r\n   at System.Environment.FailFast(System.String)\r\n   at System.SR.InternalGetResourceString(System.String)\r\n   at System.SR.GetResourceString(System.String, System.String)\r\n   at System.Globalization.CultureInfo.VerifyCultureName(System.String, Boolean)\r\n   at System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)\r\n   at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet(System.Globalization.CultureInfo, System.Collections.Generic.Dictionary`2<System.String,System.Resources.ResourceSet>, Boolean, Boolean, System.Threading.StackCrawlMark ByRef)\r\n   at System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef)\r\n   at System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo, Boolean, Boolean)\r\n   at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo)\r\n   at System.SR.InternalGetResourceString(System.String)\r\n   at System.SR.GetResourceString(System.String, System.String)\r\n   at System.Globalization.CultureInfo.VerifyCultureName(System.String, Boolean)\r\n   at System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)\r\n   at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet(System.Globalization.CultureInfo, System.Collections.Generic.Dictionary`2<System.String,System.Resources.ResourceSet>, Boolean, Boolean, System.Threading.StackCrawlMark ByRef)\r\n   at System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef)\r\n   at System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo, Boolean, Boolean)\r\n   at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo)\r\n   at System.SR.InternalGetResourceString(System.String)\r\n   at System.SR.GetResourceString(System.String, System.String)\r\n   at Interop.GetExceptionForIoErrno(ErrorInfo, System.String, Boolean)\r\n   at Interop.ThrowExceptionForIoErrno(ErrorInfo, System.String, Boolean, System.Func`2<ErrorInfo,ErrorInfo>)\r\n   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(System.String, OpenFlags, Int32)\r\n   at System.IO.FileStream..ctor(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare, Int32, System.IO.FileOptions)\r\n   at Microsoft.Extensions.EnvironmentAbstractions.FileWrapper.OpenFile(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare, Int32, System.IO.FileOptions)\r\n   at Microsoft.DotNet.Configurer.NuGetCacheSentinel.SetInProgressSentinel()\r\n   at Microsoft.DotNet.Configurer.NuGetCacheSentinel..ctor(Microsoft.DotNet.Configurer.CliFolderPathCalculator)\r\n   at Microsoft.DotNet.Cli.Program.ProcessArgs(System.String[], Microsoft.DotNet.Cli.Telemetry.ITelemetry)\r\n   at Microsoft.DotNet.Cli.Program.Main(System.String[])\r\nAbort trap: 6\r\n"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7904130542","Type":"PullRequestEvent","CreatedAt":"2018-07-02T02:15:05","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6038","RelatedDescription":"Merged pull request \"Update ryujit\" (#6038) at dotnet/corert","RelatedBody":""},{"Id":"7904047562","Type":"PullRequestEvent","CreatedAt":"2018-07-02T01:36:00","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6038","RelatedDescription":"Opened pull request \"Update ryujit\" (#6038) at dotnet/corert","RelatedBody":""},{"Id":"7900734072","Type":"PullRequestEvent","CreatedAt":"2018-06-30T03:14:10","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6037","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6037) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @tannergooding"},{"Id":"7900671377","Type":"PullRequestEvent","CreatedAt":"2018-06-30T02:20:15","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6037","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6037) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7900561532","Type":"PullRequestEvent","CreatedAt":"2018-06-30T00:52:56","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6036","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr,corefx\" (#6036) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr,corefx\n\n\n**Please REBASE this PR when merging**\n\n cc @stephentoub @ViktorHofer"},{"Id":"7900474792","Type":"PullRequestEvent","CreatedAt":"2018-06-29T23:59:35","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6036","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr,corefx\" (#6036) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr,corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7899944447","Type":"PullRequestEvent","CreatedAt":"2018-06-29T20:54:52","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6035","RelatedDescription":"Opened pull request \"[WIP] Make the generic composition details RVAs\" (#6035) at dotnet/corert","RelatedBody":"Marking this as WIP because eventually I'll need to submit this through the TFS side and update rhbind as well. I would like to do most of the code review through Git though because CoreRT is just a nicer place to prototype in.\r\n\r\nI'm looking at size regressions between .NET Native 1.7 and the current mainline branch. A thing that stood out is universally bigger EETypes. A contributor to this was getting rid of GenericInstanceDescs between 1.7 and 2.0 and replacing them by direct references to generic composition details from the EEType. Size-wise, this was mostly a wash, but we can actually do better - these new fields are not critical to be pointer-sized.\r\n\r\nThis change turns them into relative pointers. This saves 33 kB on a hello world app. I expect around 100 kB savings on the UWP People app based on my back-of-the-envelope calculation.\r\n\r\nWe could apply the same treatment to the optional fields pointer and the generic composition data."}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1013052742326280192","CreatedAt":"2018-06-30T13:32:50+00:00","UserScreenname":"dotnet","Text":"Tune in for Jeff's Saturday show, learn how to use C# and @ASPNET Core.  Always a good time https://t.co/KJoRPYHnHt","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":28,"FavoriteCount":8,"RawContent":null},{"Id":"1010269960948465665","CreatedAt":"2018-06-22T21:15:03+00:00","UserScreenname":"dotnet","Text":".NET Core 2.0 End of Life Extended to October 1, 2018 https://t.co/KQAlfqjfGv","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":55,"FavoriteCount":51,"RawContent":null},{"Id":"1010268594725269504","CreatedAt":"2018-06-22T21:09:37+00:00","UserScreenname":"dotnet","Text":".NET Core 2.1 June Update https://t.co/GJkOJkg0zJ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":135,"FavoriteCount":85,"RawContent":null},{"Id":"1010144767924154368","CreatedAt":"2018-06-22T12:57:34+00:00","UserScreenname":"dotnet","Text":"It's #fsharp Friday on Fritz and Friends with our friend @csharpfritz  -- tune in today and learn about… https://t.co/tBMBYu7qnC","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":21,"FavoriteCount":11,"RawContent":null}]}},"RunOn":"2018-07-02T05:30:33.5867965Z","RunDurationInMilliseconds":7055}