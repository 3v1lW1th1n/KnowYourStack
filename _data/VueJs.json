{"Data":{"Vue":{"Events":[{"Id":"6725137586","Type":"IssuesEvent","CreatedAt":"2017-10-17T03:11:41","Actor":"yyx990803","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue/issues/6827","RelatedDescription":"Closed issue \"push   shift causes rerender of all items\" (#6827) at vuejs/vue","RelatedBody":"### Version\r\n2.5.2\r\n\r\n### Reproduction link\r\n[https://jsfiddle.net/hastom/uomhejLe/4/](https://jsfiddle.net/hastom/uomhejLe/4/\r\n\r\n### Steps to reproduce\r\n1. Inspect list with dev tools\r\n2. Click add to end button\r\n3. All <li> nodes highlithed that means they were updated\r\n\r\n### What is expected?\r\nFirst item dropped, new item inserted at the end of the list, other items stay still\r\n\r\n### What is actually happening?\r\nAll items dropped, new items inserted\r\n\r\n---\r\nI first discovered this behavior while trying to create a dynamic list moving up and down with transiotion (of \"top\" property) on each element. Moving down was OK, transition applied correctly. Moving up was just moving elements without any trasition. I went deeper and discovered whole list was rerendered so transition was not applied.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"},"Router":{"Events":[{"Id":"6723031704","Type":"IssuesEvent","CreatedAt":"2017-10-16T17:06:08","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1816","RelatedDescription":"Closed issue \"Nested routers do not produce external urls and are not navigable to without clicking\" (#1816) at vuejs/vue-router","RelatedBody":"### Version\r\n3.0.1\r\n\r\n### Reproduction link\r\n[https://github.com/vuejs/vue-router/tree/dev/examples/nested-router](https://github.com/vuejs/vue-router/tree/dev/examples/nested-router)\r\n\r\n### Steps to reproduce\r\nIn a clone of vue-router:\r\n- npm run dev\r\n- open http://localhost:8080/nested-router/\r\n- Click nested-router\r\n- Hover over the nested foo link\r\n- Copy that link and try it in a new browser window\r\n- Click the nested foo link and look at the browser address bar - it does not change.\r\n\r\n\r\n### What is expected?\r\nThe url for the nested foo should be \r\nhttp://localhost:8080/nested-router/nested-router/bar\r\n\r\nThis should work in a new browser. \r\n\r\n\r\n### What is actually happening?\r\nThe url for the nested foo is actually\r\nhttp://localhost:8080/bar, which is in the parent directory of the example.\r\n\r\nThis obviously does not work in a new browser.\r\n\r\n---\r\nThis appears externally just like changing a component based on internal data, even though the route mechanism is used.\r\nI thought this would be useful for modularity of components. It appears only a global flat list of routes works well currently.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"6722984426","Type":"IssuesEvent","CreatedAt":"2017-10-16T16:55:28","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1817","RelatedDescription":"Closed issue \"router.beforeEach with alias '/' is wrong matching in to.matched \" (#1817) at vuejs/vue-router","RelatedBody":"### Version\r\n2.7.0\r\n\r\n### Reproduction link\r\n[http://jsfiddle.net/tjunussov/n8hbzauv/1/](http://jsfiddle.net/tjunussov/n8hbzauv/1/)\r\n\r\n### Steps to reproduce\r\n```\r\nroutes: [\r\n    {\r\n      path: '/tasks',\r\n      alias: '/',\r\n      component: TaskList,\r\n      children: [\r\n        {\r\n          path: ':taskId',\r\n          component: TaskForm\r\n        },\r\n        {\r\n          path: '',\r\n          component: TaskDashboard\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      path: '/login',\r\n      component: WelcomeLogin,\r\n      meta: { isPublic: true }\r\n    },\r\n    { path: '*', redirect: '/' }\r\n  ]\r\n```\r\nand in beforeEach\r\n\r\n```\r\nrouter.beforeEach((to, from, next) => {\r\n  console.log('beforeEach',to.matched);\r\n  next('/login')\r\n})\r\n```\r\n\r\n\r\n### What is expected?\r\nIf we navigate to `/login` in `router.beforeEach` `to.matched` parameter should contain { /login , WelcomeLogin  } \r\n\r\n### What is actually happening?\r\nbut it matched default alias and children of alias\r\n{ TaskList, taskForm }\r\n\r\n---\r\nI saw this issue, https://github.com/vuejs/vue-router/issues/1427 but it looks like it still persist in 2.7.0 router\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"6722915431","Type":"PullRequestEvent","CreatedAt":"2017-10-16T16:40:35","Actor":"Jinjiang","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue-router/pull/1820","RelatedDescription":"Opened pull request \"[zh-cn] synced from #10b7de7 to #ef4a046\" (#1820) at vuejs/vue-router","RelatedBody":"[wip]\r\n\r\nref: `/docs/en/*` parts of https://github.com/vuejs/vue-router/compare/10b7de7...ef4a046#files_bucket\r\n\r\n/ping @Justineo "},{"Id":"6722878565","Type":"IssuesEvent","CreatedAt":"2017-10-16T16:32:33","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1819","RelatedDescription":"Closed issue \"Store navigation state for multiple independent widgets/components on one page\" (#1819) at vuejs/vue-router","RelatedBody":"### What problem does this feature solve?\r\nI need to organize the following page behavior - one page, several components, the state of which is reflected in the address bar (for ex hash)\r\n\r\n#component1:/current/state/of/c1;component2:/current/state/of/c2\r\n\r\n### What does the proposed API look like?\r\nMay be for hash based navigation pass \"segment\"\r\n```\r\n<router-link to=\"/current/state/of/c1\" segment=\"component1\"></router-link>\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"6722301260","Type":"IssuesEvent","CreatedAt":"2017-10-16T14:44:02","Actor":"im4LF","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1819","RelatedDescription":"Opened issue \"Store navigation state for multiple independent widgets/components on one page\" (#1819) at vuejs/vue-router","RelatedBody":"### What problem does this feature solve?\r\nI need to organize the following page behavior - one page, several components, the state of which is reflected in the address bar (for ex hash)\r\n\r\n#component1:/current/state/of/c1;component2:/current/state/of/c2\r\n\r\n### What does the proposed API look like?\r\nMay be for hash based navigation pass \"segment\"\r\n```\r\n<router-link to=\"/current/state/of/c1\" segment=\"component1\"></router-link>\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"},"Vuex":{"Events":[{"Id":"6724300309","Type":"IssuesEvent","CreatedAt":"2017-10-16T21:56:30","Actor":"rodneyrehm","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/995","RelatedDescription":"Opened issue \"provide errorHandler, warnHandler or re-use handlers from Vue.config\" (#995) at vuejs/vuex","RelatedBody":"### What problem does this feature solve?\r\nMy unit tests of Vue components (using a stubbed store) frequently show messages like the following\r\n\r\n```\r\nERROR LOG: '[vuex] unknown getter: alpha/bravo'\r\n```\r\n\r\nIf I had a way to intercept those messages (like `Vue.config.errorHandler()` and `Vue.config.warnHandler()` provide) I could instruct my test runner to fail tests raising such errors and warnings.\r\n\r\nUnfortunately strict mode does not help in this case.\r\n\r\n### What does the proposed API look like?\r\nIt would be great if the messages could be piped to `Vue.config.errorHandler()` and `Vue.config.warnHandler()`, possibly making those functions accept another argument for passing the plugin's name to maintain the `[name]` prefix.\r\n\r\nFrom a Vue perspective I'd likely make [writing a plugin](https://vuejs.org/v2/guide/plugins.html#Writing-a-Plugin) hint at the following in order to make other plugin authors pick up on how to allow the user to define custom handlers in case [Vue's global handlers](https://vuejs.org/v2/api/#errorHandler) should not be used:\r\n\r\n```js\r\nVue.use(ThePlugin, {\r\n  errorHandler (…) { console.log(…) },\r\n  warnHandler (…) { console.log(…) },\r\n})\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"6723157343","Type":"IssuesEvent","CreatedAt":"2017-10-16T17:34:25","Actor":"blake-newman","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/994","RelatedDescription":"Opened issue \"Feature: Manually install `vuex/types/vue.d.ts`\" (#994) at vuejs/vuex","RelatedBody":"# This is a breaking change\r\n\r\n### What problem does this feature solve?\r\nWith module merging in TS, we can override module interfaces. However it is limited, in the case of the Vuex types it's impossible to compose full typing layer in components.\r\n\r\nIf we make it optional to install `vuex/types/vue.d.ts` then we can do our own manual declaration. Which will enable fully typed structures. I would also rename to `vuex/types/install.d.ts`\r\n\r\n### What does the proposed API look like?\r\nOnce we allow custom installation we can do something similar to this to enable full typing layer. \r\n\r\n```\r\nimport Vue from 'vue'\r\nimport * as Vuex from 'vuex'\r\nimport { RootState } from 'store/types'\r\n\r\nVue.use(Vuex);\r\n\r\nexport class Store {\r\n  store: Vuex.Store<RootState>;\r\n\r\n  static instance: Store;\r\n\r\n  constructor() {\r\n    this.store = new Vuex.Store<RootState>{\r\n      strict: true\r\n    });\r\n  }\r\n\r\n  get() {\r\n    return this.store\r\n  }\r\n}\r\n\r\ndeclare module \"vue/types/options\" {\r\n  interface ComponentOptions<V extends Vue> {\r\n    store?: Vuex.Store<RootState>;\r\n  }\r\n}\r\n\r\ndeclare module \"vue/types/vue\" {\r\n  interface Vue {\r\n    $store: Vuex.Store<RootState>;\r\n  }\r\n}\r\n\r\nexport default Store\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"6722075691","Type":"IssuesEvent","CreatedAt":"2017-10-16T14:02:25","Actor":"blake-newman","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vuex/issues/789","RelatedDescription":"Closed issue \"`registerModule` resets the sub-state of the module being registered\" (#789) at vuejs/vuex","RelatedBody":"### Version\r\n2.3.0\r\n\r\n### Reproduction link\r\n[https://codepen.io/sirlancelot/pen/EmOxWZ](https://codepen.io/sirlancelot/pen/EmOxWZ)\r\n\r\n### Steps to reproduce\r\nSuppose you have a SPA-style app with Vue, Vuex, and Vue-Router, with a Vuex module for each page. The Vuex module gets registered during `router.beforeResolve` on both server & client.\r\n\r\nBoth the server & client will render the page properly. However, when loading the page fresh in the browser, it seems that `registerModule` is resetting the module's sub-state upon registration.\r\n\r\n### What is expected?\r\nWhen Vuex is registering modules, it should see if that sub-state already exists in its store and use that instead of starting fresh.\r\n\r\n### What is actually happening?\r\nIt seems that the module's sub-state is getting cleared during `registerModule` phase in the browser.\r\n\r\n---\r\nI hacked together the repro steps without Vue-Router because it's not strictly part of the problem. I tried to explain at what point portions of code run. Let me know if you need more explanation.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"}},"RunOn":"2017-10-17T05:30:31.8523192Z","RunDurationInMilliseconds":1863}