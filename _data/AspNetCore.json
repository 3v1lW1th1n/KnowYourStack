{
	"Data": {
		"Home-Issues": {
			"Issues": [{
				"Id": "342826066",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:56:48",
				"Actor": "DanFTRX",
				"Number": "3342",
				"RawContent": null,
				"Title": "Add Enabled flag to Microsoft.AspNetCore.Diagnostics.ExceptionHandlerFeature",
				"State": "closed",
				"Body": "It would be nice to be able to enable/disable the exception handler pages on the fly in [Microsoft.AspNetCore.Diagnostics.ExceptionHandlerFeature](https://github.com/aspnet/Diagnostics/blob/master/src/Microsoft.AspNetCore.Diagnostics/ExceptionHandler/ExceptionHandlerFeature.cs) similar to how:  [Microsoft.AspNetCore.Diagnostics.StatusCodePagesFeature](https://github.com/aspnet/Diagnostics/blob/master/src/Microsoft.AspNetCore.Diagnostics/StatusCodePage/StatusCodePagesFeature.cs#L11) allows. \r\n",
				"Url": "https://github.com/aspnet/Home/issues/3342",
				"RelatedDescription": "Closed issue \"Add Enabled flag to Microsoft.AspNetCore.Diagnostics.ExceptionHandlerFeature\" (#3342)"
			},
			{
				"Id": "343732570",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:52:04",
				"Actor": "ryanbrandenburg",
				"Number": "3354",
				"RawContent": null,
				"Title": "Flaky tests: EnsureCreateIdentityTokenSigningCertificate_CreatesACertificate_WhenThereAreNoHttpsCertificates et al",
				"State": "open",
				"Body": "This test [fails](http://aspnetci/viewLog.html?buildId=512272&buildTypeId=Releases_22xPublic_HighSierraOsxUniverse) occasionally with the following error:\r\n```\r\nAssert.Equal() Failure\r\nExpected: Succeeded\r\nActual:   ErrorSavingTheCertificateIntoTheCurrentUserPersonalStore\r\n   at Microsoft.AspNetCore.Certificates.Generation.Tests.CertificateManagerTests.EnsureCreateIdentityTokenSigningCertificate_CreatesACertificate_WhenThereAreNoHttpsCertificates() in /_/test/Microsoft.Extensions.Internal.Test/CertificateManagerTests.cs:line 220\r\n```\r\nPossibly this is an agent state issue since we only have one High-Sierra agent and no code appears to have changed before the failures started.",
				"Url": "https://github.com/aspnet/Home/issues/3354",
				"RelatedDescription": "Open issue \"Flaky tests: EnsureCreateIdentityTokenSigningCertificate_CreatesACertificate_WhenThereAreNoHttpsCertificates et al\" (#3354)"
			},
			{
				"Id": "343729098",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:41:22",
				"Actor": "pranavkm",
				"Number": "3353",
				"RawContent": null,
				"Title": "[CORS] Normalize internationalized domain names when adding to CORS",
				"State": "open",
				"Body": "Follow up to https://github.com/aspnet/CORS/pull/170. `CorsPolicyBuilder` should normalize IDNs to use punycode. This would match the format browsers send for IDN urls.",
				"Url": "https://github.com/aspnet/Home/issues/3353",
				"RelatedDescription": "Open issue \"[CORS] Normalize internationalized domain names when adding to CORS\" (#3353)"
			},
			{
				"Id": "343530599",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:18:48",
				"Actor": "jkotas",
				"Number": "3351",
				"RawContent": null,
				"Title": "memory leak during the use of reloadOnChange: true with ConfigurationBuilder",
				"State": "closed",
				"Body": "_From @abelpalaty on July 23, 2018 7:39_\r\n\r\n  Hi,\r\nWe have dotnet core driver which connects to our product (CICS TG).\r\nIn the driver we create a connection and closes it after each transaction.\r\nWhile creating the connection we have the following code.\r\n\r\n```c#\r\n     var  builder = new ConfigurationBuilder()\r\n           .SetBasePath(Directory.GetCurrentDirectory())\r\n           .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true);\r\n```\r\n\r\nWith the setting reloadOnChange: true we see the memory leak with time eventhough the connection is closed after each request.\r\n\r\nWe tried with the following code\r\n\r\n```c#\r\n     var  builder = new ConfigurationBuilder()\r\n           .SetBasePath(Directory.GetCurrentDirectory())\r\n           .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: false);\r\n```\r\n\r\nwith the setting reloadOnChange: false we see the memory usage is constant with time.\r\n\r\nThe sample we ran runs same application in a loop of like 2500 times where each time new object is created and closed.\r\nOur customer reported this issue and its recreating every time. Its high priority .\r\nIs there any fix available already or is it a known issue?\r\nIs there a way we can make sure memory usage is constant (maybe additional  code to release FileSystemWatcher after the connection is closed.)\r\n\r\nWe created a memory profiling report and we see that the function which allocated the most memory is System.IO.FileSystemWatcher.AllocateBuffer().\r\nI am attaching the screenshots of the observation we did during our testing.\r\n![70910eb8a8b6afd3](https://user-images.githubusercontent.com/41566819/43063074-769bc604-8e78-11e8-8e85-89b2e4abe863.jpg)\r\n![748aa0170f472bc9](https://user-images.githubusercontent.com/41566819/43063075-76d0beb8-8e78-11e8-9892-9bff9e5c5ba8.jpg)\r\n![7e81d48d0df38b32](https://user-images.githubusercontent.com/41566819/43063076-770d7a56-8e78-11e8-8e69-16700d9bddba.jpg)\r\n\r\n\r\n\r\n_Copied from original issue: dotnet/coreclr#19080_",
				"Url": "https://github.com/aspnet/Home/issues/3351",
				"RelatedDescription": "Closed issue \"memory leak during the use of reloadOnChange: true with ConfigurationBuilder\" (#3351)"
			},
			{
				"Id": "343478075",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:16:09",
				"Actor": "MhAllan",
				"Number": "3349",
				"RawContent": null,
				"Title": "How to get used InputFormatter and OutputFormatter in ActionFilter?",
				"State": "closed",
				"Body": "Hi,\r\n\r\nSo I have added Message Pack formatter beside Json. now in an action filter I want to get that formatter to deserialize some request header. how can I get access to the current formatter?",
				"Url": "https://github.com/aspnet/Home/issues/3349",
				"RelatedDescription": "Closed issue \"How to get used InputFormatter and OutputFormatter in ActionFilter?\" (#3349)"
			},
			{
				"Id": "343511416",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:15:57",
				"Actor": "Abarbz",
				"Number": "3350",
				"RawContent": null,
				"Title": "Strange behavior while getting method parameter from body in ApiController",
				"State": "closed",
				"Body": "Hello,\r\nWhile testing one of the methods in my Asp.Net Core Web API, I witnessed a strange behavior.\r\nThe method, sitting in an `[ApiController]`, has the following signature:\r\n```\r\n[HttpPost(\"myPath\")]\r\n[ProducesResponseType(200)]\r\npublic IActionResult MyMethod(MyObject obj)\r\n```\r\n\r\nAnd the `MyObject` looks like this:\r\n```\r\npublic struct MyObject\r\n{\r\n\t    public readonly bool MyBoolean;\r\n\t    public MyObject(bool myBoolean)\r\n\t    {\r\n\t\t    MyBoolean= myBoolean;\r\n\t    }\r\n}\r\n```\r\n\r\nI was manually testing some behaviors using Postman, and when posting the following objects, I was surprised by the results:\r\n* `{ afdqgdqgdsgqdgdg: false }` : yields a proper MyObject instance, with its MyBoolean field set to `false`\r\n* `{ afdqgdqgdsgqdgdg: false, myBoolean: true }` yields a proper MyObject instance, with its MyBoolean field set to `true`\r\n* `{ afdqgdqgdsgqdgdg: false, jfghdfhfdhf: true }` yields a proper MyObject instance, with its MyBoolean field set to `false`\r\n* `{ afdqgdqgdsgqdgdg: 3 }`: yields a proper MyObject instance, with its MyBoolean field set to `false`\r\n\r\nIn those 5 cases, I was actually expecting an error due to model mismatch (except maybe in the second case, where at least one of the properties was matching).\r\nWhat is happening here? Is this behavior expected?\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3350",
				"RelatedDescription": "Closed issue \"Strange behavior while getting method parameter from body in ApiController\" (#3350)"
			},
			{
				"Id": "343662123",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T16:15:18",
				"Actor": "jmhmaine",
				"Number": "3352",
				"RawContent": null,
				"Title": "Contribute Link 404",
				"State": "closed",
				"Body": "The \"How to contribute\" link on [Wiki](https://github.com/aspnet/Home/wiki) points to a DEV location that no longer exists. It should point to: https://github.com/aspnet/Home/blob/master/CONTRIBUTING.md\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3352",
				"RelatedDescription": "Closed issue \"Contribute Link 404\" (#3352)"
			},
			{
				"Id": "342908821",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T15:33:15",
				"Actor": "Tratcher",
				"Number": "3344",
				"RawContent": null,
				"Title": "High CPU usage after await (with sample repo)",
				"State": "closed",
				"Body": "_From @daddyman on July 19, 2018 21:47_\n\nSince moving to .NET Core 2.1 we have been seeing our aspnet core web api spike to 99% CPU usage on Linux. This does not happen when running on Windows.\r\n\r\nWhat we observe in our application is if we make 4 or 5 API calls in quick succession then the CPU goes to 99% and stays there for a few minutes.\r\n\r\nI was able to strip down our app and reproduce the issue in a simple app. The repo is here: https://github.com/daddyman/dotnetcorecpu\r\n\r\nI am running .NET Core 2.1.2 using SDK 2.1.302 on Ubuntu 16.04.\r\n\r\nIt seems to have something to do with \"await\". In the reproduction case I have one controller that handles a POST. \r\n* Performing an `await Task.CompletedTask;` does not cause a problem.\r\n* Performing an `away DummyWait();` where DummyWait is `return Task.Delay(1);` causes high CPU after hitting the server with many requests in a short time. The requests complete quickly but then the CPU goes to 99% and stays there.\r\n\r\nIn our real app I did the same change of using the `await Task.CompletedTask;` and 'await Task.DummyWait();` and saw the same difference with the CPU usage.\r\n\r\n\n\n_Copied from original issue: dotnet/corefx#31208_",
				"Url": "https://github.com/aspnet/Home/issues/3344",
				"RelatedDescription": "Closed issue \"High CPU usage after await (with sample repo)\" (#3344)"
			},
			{
				"Id": "342608332",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T09:05:10",
				"Actor": "lserafin",
				"Number": "3340",
				"RawContent": null,
				"Title": "AutomaticDecompression not working with HttpClientFactory",
				"State": "closed",
				"Body": "I'm trying to set up **automatic gzip decompression** with the new **HttpClientFactory**.\r\nSomehow this is not working for me.\r\nCan you please let me know if I am doing something wrong ? \r\n\r\n```  C#\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing Serilog;\r\nusing System;\r\nusing System.Net;\r\nusing System.Net.Http;\r\nusing System.Net.Http.Headers;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace GzipTest\r\n{\r\n    class Program\r\n    {\r\n        // C# 7.1\r\n        static async Task Main()\r\n        {\r\n            await Go();\r\n        }\r\n\r\n        static async Task Go()\r\n        {\r\n            Log.Logger = new LoggerConfiguration()\r\n                .MinimumLevel.Debug()\r\n                .WriteTo.Console()\r\n                .CreateLogger();\r\n\r\n            var services = new ServiceCollection()\r\n                .AddLogging(builder =>\r\n                {\r\n                    // Add Serilog\r\n                    builder.AddSerilog();\r\n                });\r\n\r\n            // Register a HTTP Client\r\n            services.AddHttpClient<GzipTestClient>().ConfigureHttpMessageHandlerBuilder(config => new HttpClientHandler\r\n            {\r\n                AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip\r\n            });\r\n\r\n            var serviceProvider = services.BuildServiceProvider();\r\n\r\n            // This is the Microsoft Logging interface\r\n            var logger = serviceProvider.GetRequiredService<ILogger<Program>>();\r\n            logger.LogInformation(\"We are using Serilog!\");\r\n\r\n            // Get a HTTP Client and make a request\r\n            var google = serviceProvider.GetRequiredService<GzipTestClient>();\r\n            await google.Get();\r\n        }\r\n    }\r\n\r\n    class GzipTestClient\r\n    {\r\n        HttpClient HttpClient { get; }\r\n        public GzipTestClient(HttpClient client)\r\n        {\r\n            HttpClient = client;\r\n            HttpClient.BaseAddress = new Uri(\"http://httpbin.org\");\r\n            HttpClient.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"gzip\"));\r\n            HttpClient.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"deflate\"));\r\n        }\r\n        public async Task<HttpResponseMessage> Get()\r\n        {\r\n            var request = new HttpRequestMessage(HttpMethod.Get, \"/gzip\");\r\n            var response = await HttpClient.SendAsync(request);\r\n            //var response = await HttpClient.GetAsync(\"/gzip\"); Also not working\r\n            var payload = response.Content.ReadAsStringAsync().Result;\r\n            Console.WriteLine(\"Decompressed Content:\\n{0}\", payload);\r\n            response.EnsureSuccessStatusCode();\r\n            return response;\r\n        }\r\n    }\r\n}\r\n```\r\n**Output**\r\n\r\n`[16:57:48 INF] We are using Serilog!\r\n[16:57:48 INF] Start processing HTTP request GET http://httpbin.org/gzip\r\n[16:57:48 INF] Sending HTTP request GET http://httpbin.org/gzip\r\n[16:57:48 INF] Received HTTP response after 440.1212ms - OK\r\n[16:57:48 INF] End processing HTTP request after 476.972ms - OK\r\nDecompressed Content:\r\n\u001f ?\u0003N[\u0002?\u001d?A\r\n?0\u0010E??Bf\u001d\u0003?\u0016?H??\u00025\u0019??:\u0013?qc??M]????/\u0010??3\u0006?|?@?)`??/p?\u001e?\u001e\u0006?\u0012?#???\u0003??I\u0011\f?\u0019??p+?,u?w??bR?Ob+%?j?????8<?$?\"m+w??l??\u001e/\u000e??\u000f??6N?\r\nPress any key to continue . . .`\r\n\r\n### Environment / dotnet Info\r\n\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.302\r\n Commit:    9048955601\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17134\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.302\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.2\r\n  Commit:  811c3ce6c0\r\n\r\n.NET Core SDKs installed:\r\n  1.1.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.104 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.201 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300-rc1-008673 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0-rc1-final [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0-rc1-final [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0-rc1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n```\r\n\r\nSame code seems to be working without the HttpClientFactory (https://github.com/dotnet/corefx/issues/31121)",
				"Url": "https://github.com/aspnet/Home/issues/3340",
				"RelatedDescription": "Closed issue \"AutomaticDecompression not working with HttpClientFactory\" (#3340)"
			},
			{
				"Id": "343380904",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-22T06:17:52",
				"Actor": "georgiosd",
				"Number": "3348",
				"RawContent": null,
				"Title": "Correctly handling exceptions in middleware",
				"State": "open",
				"Body": "Hey gents,\r\n\r\nI have a simple middleware class that will write a \"virtual file\" i.e. - if the client requests `/foo.path` it will write a response, otherwise it will pass the request down the pipeline.\r\n\r\nMy problem is that when an exception occurs somewhere along the rest of the pipeline, it is reported to App Insights like coming from my middleware because the `next(context)` call is awaited. And it has to be awaited because `context.Response` only has `Async` methods to write. \r\n\r\nCode:\r\n\r\n```\r\npublic async Task InvokeAsync(HttpContext context)\r\n        {\r\n            if (context.Request.Path == \"/foo.path\")\r\n            {\r\n                    await context.Response.WriteAsync(\"content\");\r\n                    return;\r\n            }\r\n\r\n            await next(context);\r\n        }\r\n```\r\n\r\nHow do I go about cleaning this up??",
				"Url": "https://github.com/aspnet/Home/issues/3348",
				"RelatedDescription": "Open issue \"Correctly handling exceptions in middleware\" (#3348)"
			},
			{
				"Id": "343271006",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-21T00:54:18",
				"Actor": "jacobslusser",
				"Number": "3347",
				"RawContent": null,
				"Title": "Dependency injection interceptor/wrapper/chain",
				"State": "closed",
				"Body": "Apologies if this has been asked and/or answers already...\r\n\r\nI want to be able to register a service in the traditional way:\r\n```cs\r\nservices.AddSingleton<IRepository, Repository>();\r\n```\r\nbut when I call for the service I want to get a wrapped/intercepted version that does caching. i.e. the caching service would implement the same service and wrap the original service:\r\n\r\n```cs\r\npublic class CachingRepository : IRepository\r\n{\r\n    private readonly IRepository originalRepository;\r\n    public CachingRepository(IRepository originalRepository)\r\n    {\r\n        this.originalRepository = originalRepository; // Would be instance of Repository\r\n    }\r\n}\r\n```\r\nIt might help to think of this in the way that middleware calls the next middleware in the chain...\r\n\r\nIs there a good way to do this? Maybe with a factory? I can't quite put my finger on it and the approach I'm currently using feels kludge-y.",
				"Url": "https://github.com/aspnet/Home/issues/3347",
				"RelatedDescription": "Closed issue \"Dependency injection interceptor/wrapper/chain\" (#3347)"
			},
			{
				"Id": "342887491",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T23:49:36",
				"Actor": "ArifKuttayi",
				"Number": "3343",
				"RawContent": null,
				"Title": "InvalidOperationException: Unable to resolve service for type",
				"State": "closed",
				"Body": "I'm using Core 2.1 razor pages with repository. Showing error while opening register page even I have registered Email sender in Startup.cs. Please see below error log.\r\n![error log](https://user-images.githubusercontent.com/17797408/42969720-c8cbbaa4-8baf-11e8-89a3-f0c74cfaa137.JPG)\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3343",
				"RelatedDescription": "Closed issue \"InvalidOperationException: Unable to resolve service for type\" (#3343)"
			},
			{
				"Id": "343254956",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T21:38:05",
				"Actor": "sungam3r",
				"Number": "3346",
				"RawContent": null,
				"Title": "Microsoft.Extensions.DiagnosticAdapter does not map properties from ancestor classes",
				"State": "open",
				"Body": "Microsoft.Extensions.DiagnosticAdapter package provides easy opportunity to wrap execution flow into the suitable well-configured methods like this\r\n```\r\n[DiagnosticName(\"Microsoft.EntityFrameworkCore.Database.Command.CommandExecuting\")]\r\npublic void OnCommandExecuting(DbCommand command, DbCommandMethod executeMethod, Guid commandId, Guid connectionId, DateTimeOffset startTime)\r\n{\r\n}\r\n```\r\ninitializing all known specified parameters in method signature, but it does not work with properties in ancestor classes, e.g [CommandExecutedEventData](https://github.com/aspnet/EntityFrameworkCore/blob/master/src/EFCore.Relational/Diagnostics/CommandExecutedEventData.cs) because of this line of code ([link](https://github.com/aspnet/EventNotification/blob/28b77e7fb51b30797ce34adf86748c98c040985e/src/Microsoft.Extensions.DiagnosticAdapter/Internal/ProxyMethodEmitter.cs#L60)):\r\n```\r\nvar properties = inputType.GetTypeInfo().DeclaredProperties.ToArray();\r\n```\r\nIt uses only those properties, which are declared in this particular **inputType** type. And in case of CommandExecutedEventData there are only one property - Result. All other properties from CommandEndEventData, CommandEventData and EventData will be ignored. \r\n\r\nConsider to change the line of code mentioned above to\r\n```\r\nvar properties = inputType.GetTypeInfo().GetProperties();\r\n```\r\nto allow mapping to any property in the chain of class inheritance, so we can use such methods:\r\n```\r\n[DiagnosticName(\"Microsoft.EntityFrameworkCore.Database.Command.CommandExecuted\")]\r\npublic void OnCommandExecuted(object result, bool async, TimeSpan duration, DbCommand command, Guid commandId)\r\n{\r\n}\r\n```\r\nNow all arguments except *result* have their default values - null for reference types and zeros for structs.",
				"Url": "https://github.com/aspnet/Home/issues/3346",
				"RelatedDescription": "Open issue \"Microsoft.Extensions.DiagnosticAdapter does not map properties from ancestor classes\" (#3346)"
			},
			{
				"Id": "343051996",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T10:15:05",
				"Actor": "ststeiger",
				"Number": "3345",
				"RawContent": null,
				"Title": "Impossible to check if HttpContext-body is null/empty...",
				"State": "open",
				"Body": "In ASP.NET-Core, there is no way to check if the request's body is NULL/empty...\r\n\r\nI make a fetch request \r\n```\r\n    let result = <any>await fetch(markerUrl, {\r\n        \"method\": 'POST',\r\n        // \"headers\": {'auth': '1234','content-type': 'application/json'},\r\n        // https://stackoverflow.com/questions/38156239/how-to-set-the-content-type-of-request-header-when-using-fetch-api\r\n        \"headers\": new Headers({ 'content-type': 'application/json' }),\r\n        \"body\": null \r\n    })\r\n    .then(function (response) { return response.json(); })\r\n    ;\r\n```\r\neither with setting body to NULL or by omiting body altogether. \r\n\r\nIn ASP.NET-Core, I get:\r\n\r\n\r\n```\r\ncontext.Responst.Body: is not NULL \r\ncontext.Request.Body.Length: System.NotSupportedException \r\ncontext.Request.Body.Position: System.NotSupportedException \r\ncontext.Request.Body.Seek(0, System.IO.SeekOrigin.End): System.NotSupportedException \r\nand\r\ncontext.Request.Body._body.IsEmpty: true \r\n```\r\nthere is no public empty property on Body...\r\n\r\nConsequentially, it's not possible to read the stream directly into a JSON-object, because there's no way to tell if there actually is a stream/empty-stream...\r\n\r\n```\r\n            if (string.Equals(context.Request.ContentType, \"application/json\", System.StringComparison.InvariantCultureIgnoreCase))\r\n            {\r\n                Newtonsoft.Json.Linq.JObject jsonData = null;\r\n\r\n                // Can only be read ONCE ! \r\n                using (System.IO.StreamReader reader = new System.IO.StreamReader(context.Request.Body, System.Text.Encoding.UTF8, false, 4096, true))\r\n                {\r\n                    using (Newtonsoft.Json.JsonTextReader jsonReader = new Newtonsoft.Json.JsonTextReader(reader))\r\n                    {\r\n                       // KABOOM ! \r\n                        var a = Newtonsoft.Json.Linq.JToken.Load(jsonReader);\r\n                        System.Console.WriteLine(a);\r\n                        jsonData = Newtonsoft.Json.Linq.JObject.Load(jsonReader);\r\n                    } // End Using jsonReader \r\n\r\n                } // End Using reader \r\n```\r\n\r\nI don't want to use exceptions for this, because this is slowwwww...\r\nI don't want to read it into a string, because that shouldn't be necessary either...",
				"Url": "https://github.com/aspnet/Home/issues/3345",
				"RelatedDescription": "Open issue \"Impossible to check if HttpContext-body is null/empty...\" (#3345)"
			},
			{
				"Id": "342223969",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T05:24:25",
				"Actor": "yashwanthreddyg",
				"Number": "3337",
				"RawContent": null,
				"Title": "Way to configure IIS reverse proxy without aspnetcore module",
				"State": "closed",
				"Body": "I have Kestrel running as a Windows service using dotnet core portal runtime and a DLL.\r\nCan I make IIS run as a reverse proxy for my application?\r\nI want to avoid installing the dotnethostingbundle as I already have a portable runtime.",
				"Url": "https://github.com/aspnet/Home/issues/3337",
				"RelatedDescription": "Closed issue \"Way to configure IIS reverse proxy without aspnetcore module\" (#3337)"
			},
			{
				"Id": "342697577",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T11:56:58",
				"Actor": "tmds",
				"Number": "3341",
				"RawContent": null,
				"Title": "aspnet/FileSystem Polling broken?",
				"State": "open",
				"Body": "I set DOTNET_USE_POLLING_FILE_WATCHER to see how it affects aspnet/Configuration refresh.\r\nI saw no polling of the configuration files.\r\n\r\nLooking at the implementation, it seems events are triggered by FileSystemWatcher, even when polling: https://github.com/aspnet/FileSystem/blob/faf1f007208001988d30618eca934481ea61dcda/src/FS.Physical/PhysicalFileProvider.cs#L78\r\n\r\nMy understanding is DOTNET_USE_POLLING_FILE_WATCHER is meant for filesystems like NFS where FileSystemWatcher does not work.\r\nSo, the configuration reload is probably broken on such filesystems, even when setting DOTNET_USE_POLLING_FILE_WATCHER.\r\n\r\nCC @natemcmaster @pranavkm",
				"Url": "https://github.com/aspnet/Home/issues/3341",
				"RelatedDescription": "Open issue \"aspnet/FileSystem Polling broken?\" (#3341)"
			},
			{
				"Id": "342477325",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T20:51:57",
				"Actor": "ggirard07",
				"Number": "3339",
				"RawContent": null,
				"Title": "Unable to debug ASP.Net Core 2.0 app running in ISS on .Net Framework",
				"State": "closed",
				"Body": "**Steps to reproduce**\r\n1. File > New > Project\r\n2. Select ASP.Net Core Web Application\r\n3. In popup window, select \"API\" and change target framework for \".Net Framework\" on top of the window (ASP.Net Core 2.0 should be default)\r\n4. Create the project\r\n5. Add a breakpoint in ValuesController in Get() method then start debug on ISS target\r\n\r\n**Expected Result**\r\nBreakpoint is hit then when debug is resumed response from the controller is displayed in the browser\r\n\r\n**Actual Result**\r\nBreakpoint is never hit and Visual Studio freeze\r\n\r\n**Versions**\r\n- Visual Studio 15.7.5\r\n- Default Nuget package versions from ASP.Net Core WebAPI template\r\n  - Microsoft.AspNetCore 2.0.4\r\n  - Microsoft.AspNetCore.Mvc 2.0.4\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3339",
				"RelatedDescription": "Closed issue \"Unable to debug ASP.Net Core 2.0 app running in ISS on .Net Framework\" (#3339)"
			},
			{
				"Id": "342249475",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T17:05:52",
				"Actor": "Edward-Zhou",
				"Number": "3338",
				"RawContent": null,
				"Title": "How To Bind Model Value From Body by Custom Binder",
				"State": "closed",
				"Body": "I am trying this document [Custom Model Binding in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-2.1), I could get the model value when passing by `Query String`.\r\nBut, I want to bind the model to Request Body, how could I fetch value from Request body when I sending request with `application/json`.",
				"Url": "https://github.com/aspnet/Home/issues/3338",
				"RelatedDescription": "Closed issue \"How To Bind Model Value From Body by Custom Binder\" (#3338)"
			},
			{
				"Id": "341734126",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T02:11:40",
				"Actor": "moogle001",
				"Number": "3334",
				"RawContent": null,
				"Title": "NET 2.1: Breaking Change in TestServer?",
				"State": "closed",
				"Body": "I have a website built on NET Core 2.0 with unit tests that confirm routing using the RestEase library. A unit test looks like this:\r\n\r\n\r\n\r\n        [Fact]\r\n        public async Task GetAll()\r\n        {\r\n            var webHostBuilder = CreateWebHostBuilder();\r\n            using (var server = new TestServer(webHostBuilder))\r\n            {\r\n                var client = CreateClient(server);\r\n                var objs = await client.GetAll();\r\n\r\n                Assert.NotNull(objs);\r\n                Assert.True(objs.Count > 0);\r\n            }\r\n        }\r\n\r\n        public IWebHostBuilder CreateWebHostBuilder()\r\n        {\r\n            var config = new ConfigurationBuilder()\r\n                .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true)\r\n                .Build();\r\n\r\n            var host = new WebHostBuilder()\r\n                .UseConfiguration(config)\r\n                .UseStartup<TestStartup>();\r\n\r\n            return host;\r\n        }\r\n\r\n        public ITransactionsApi CreateClient(TestServer server)\r\n        {\r\n            HttpClient client = server.CreateClient();\r\n            ITransactionsApi toReturn = RestClient.For<ITransactionsApi>(client);\r\n            return toReturn;\r\n        }\r\n \r\n\r\n\r\nEverything runs and passes under 2.0. However, upon upgrading to 2.1, all tests fail with 404. Aside from the introduction of WebApplicationFactory, I don't see anything in the notes about changes to unit testing. It should also be noted that when debugging the routes work under both versions, which is why I'm suspect of TestServer. I can provide diffs for the main project and test project if needed. I appreciate any insight anyone can provide.",
				"Url": "https://github.com/aspnet/Home/issues/3334",
				"RelatedDescription": "Closed issue \"NET 2.1: Breaking Change in TestServer?\" (#3334)"
			},
			{
				"Id": "341785089",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T06:39:59",
				"Actor": "hishamco",
				"Number": "3336",
				"RawContent": null,
				"Title": "Adding AddRequestCultureProvider as extension method",
				"State": "open",
				"Body": "For all that are familiar with localization, adding new culture provider is something confusing, because the developer expect that the newly added provider is winner provider, but it's not!!\r\n\r\nHave a look to [this](https://github.com/aspnet/Localization/blob/master/samples/LocalizationSample/Startup.cs#L34) we should use `Insert` instead of `Add`, to let our culture provider wins over the other predefined culture providers.\r\n\r\nUsing this\r\n```csharp\r\noptions.AddRequestCultureProvider(new CustomRequestCultureProvider(async context =>\r\n{\r\n\r\n}));\r\n```\r\n\r\nis slightly better than\r\n```csharp\r\noptions.RequestCultureProviders.Insert(0, new CustomRequestCultureProvider(async context =>\r\n{\r\n\r\n}));\r\n```\r\n\r\n/cc @ryanbrandenburg ",
				"Url": "https://github.com/aspnet/Home/issues/3336",
				"RelatedDescription": "Open issue \"Adding AddRequestCultureProvider as extension method\" (#3336)"
			},
			{
				"Id": "341783484",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T06:32:50",
				"Actor": "hishamco",
				"Number": "3335",
				"RawContent": null,
				"Title": "Move localization builder APIs into an extension methods",
				"State": "open",
				"Body": "After revising the localization builder APIs that we introduce in `2.1`, it would be nice to move those into an extensions methods, because they rely on the existing members",
				"Url": "https://github.com/aspnet/Home/issues/3335",
				"RelatedDescription": "Open issue \"Move localization builder APIs into an extension methods\" (#3335)"
			},
			{
				"Id": "341383119",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T01:44:58",
				"Actor": "scottsauber",
				"Number": "3333",
				"RawContent": null,
				"Title": "2.1.302 SDK, but AspNetCore.App only downloads 2.1.1 instead of 2.1.2",
				"State": "closed",
				"Body": "Hello, not really sure where to put this so I'm starting here.\r\n\r\nOn two different machines, I'm unable to get the AspNetCore.App package with no explicit version number to download 2.1.1 instead of 2.1.2.\r\n\r\nThis is on a dotnet new and is happening on two different machines.  On one of them, I even uninstalled all older SDK's other than 2.1.302.\r\n\r\nAm I doing something wrong?\r\n\r\nScreenshots:\r\n![image](https://user-images.githubusercontent.com/10823939/42742518-ddcfc896-8880-11e8-99f0-73488fe5218e.png)\r\n![image](https://user-images.githubusercontent.com/10823939/42742524-e1562afa-8880-11e8-9751-c4f1eda0d112.png)\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3333",
				"RelatedDescription": "Closed issue \"2.1.302 SDK, but AspNetCore.App only downloads 2.1.1 instead of 2.1.2\" (#3333)"
			},
			{
				"Id": "341289408",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T15:36:17",
				"Actor": "thammadi",
				"Number": "3330",
				"RawContent": null,
				"Title": "Controllers declared in class library, returning 404 with AWS Lambda C#2.1",
				"State": "closed",
				"Body": "I created an AWS Serverless solution with a Web API and Class Library projects (2.1.0). Class Library is referenced by the Web API project.\r\n\r\nController in Web API:\r\n```\r\n[Route(\"api/[controller]\")]\r\npublic class ValuesController : Controller\r\n{\r\n        [HttpGet]\r\n        public IEnumerable<string> Get()\r\n        {\r\n            return new string[] { \"value1\", \"value2\" };\r\n        }\r\n}\r\n```\r\nReferences: Microsoft.AspNetCore.App (2.1.0) and Microsoft.NETCore.App (2.1.0)\r\nCompatability version set in Startup.cs:\r\n```\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n}\r\n```\r\n\r\nController in Class Library: \r\n```\r\n[Route(\"api/[controller]\")]\r\npublic class ClassesController : Controller\r\n{\r\n        [HttpGet]\r\n        public IEnumerable<string> Get()\r\n        {\r\n            return new string[] { \"class1\", \"class2\" };\r\n        }\r\n}\r\n```\r\nReferences: Microsoft.AspNetCore.App (2.1.0) and Microsoft.NETCore.App (2.1.0)\r\nSDK reference in Class Library project file is updated from Microsoft.NET.Sdk to Microsoft.NET.Sdk.Web\r\n\r\nDeployed the above to AWS lambda (dotnet lambda package -c \"Release\")\r\n\r\nWhen tested, '/api/values' works as expected but '/api/classes' returns 404\r\nThis used to work with 2.0 version.\r\n\r\nDid I miss anything?",
				"Url": "https://github.com/aspnet/Home/issues/3330",
				"RelatedDescription": "Closed issue \"Controllers declared in class library, returning 404 with AWS Lambda C#2.1\" (#3330)"
			},
			{
				"Id": "341312593",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-15T11:07:48",
				"Actor": "ygoe",
				"Number": "3332",
				"RawContent": null,
				"Title": "Internal redirect for UseStatusCodePages",
				"State": "open",
				"Body": "The [documentation](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-2.1) explains how to use `app.UseStatusCodePages();` to show some content when a controller action returns `NotFound()` or something. This only shows very basic plain text. I could also redirect the user to another URL that has more content like /Error/404. But that would redirect the user away from the originating URL that caused the error. Redirecting the user away from the actual error page to a static page that always shows an error message is a bad thing. The user will not be able to verify the URL and probably find the problem. Also, reloading the page will not bring back the expected content when the error has been resolved meanwhile. Reloading the /Error/404 page will always show the error even if it doesn't exist anymore.\r\n\r\nSo what I need is an internal redirect to a more rich page that fits my site design, but doesn't change the visible URL.\r\n\r\nHow can I do that?",
				"Url": "https://github.com/aspnet/Home/issues/3332",
				"RelatedDescription": "Open issue \"Internal redirect for UseStatusCodePages\" (#3332)"
			},
			{
				"Id": "341295314",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-15T06:09:58",
				"Actor": "huazhenhz",
				"Number": "3331",
				"RawContent": null,
				"Title": "Session OnStart and Session OnEnd",
				"State": "open",
				"Body": "To reopen the issue #3025 \r\nhttps://github.com/aspnet/Home/issues/3025\r\n\r\nI hope Session can have \"Session_Start\" and \"Session_End\" event mechanism.\r\n\r\nIf the mechanism is the same as Spring Session in Java Web, that's preferred.\r\n\r\nSpring Session has the similiar events such as \"SessionCreatedEvent\" and \"SessionDestroyedEvent\" (\"SessionDestroyedEvent\" includes \"SessionDeletedEvent\" and \"SessionExpiredEvent\".).\r\n\r\nThe relevant web sites about Spring Session below:\r\n\r\nSessionCreatedEvent:\r\nhttps://docs.spring.io/spring-session/docs/1.3.0.RELEASE/reference/html5/#api-redisoperationssessionrepository-sessioncreatedevent\r\n\r\nSessionDestroyedEvent:\r\nhttps://docs.spring.io/spring-session/docs/1.3.0.RELEASE/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent\r\n\r\nI think the mechanism is important to .NET developers, and it can make ASP.NET Core more perfect.\r\n\r\nSo, \"Session_Start\" and \"Session_End\" events should be provided continuously in ASP.NET Core.\r\n\r\nThanks!\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3331",
				"RelatedDescription": "Open issue \"Session OnStart and Session OnEnd\" (#3331)"
			},
			{
				"Id": "340940743",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T16:00:14",
				"Actor": "stap123",
				"Number": "3326",
				"RawContent": null,
				"Title": "Refactoring/Renaming Inside Razor Views",
				"State": "closed",
				"Body": "Is there a way to to have refactoring (specifically renaming things) work inside razor view files within VS2017? I thought I'd heard Damien mention that it was possible in a community stand up video a while ago but can't work out how to do it.\r\n\r\nIf it's not possible is it planned at all?\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3326",
				"RelatedDescription": "Closed issue \"Refactoring/Renaming Inside Razor Views\" (#3326)"
			},
			{
				"Id": "341072710",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T15:57:05",
				"Actor": "Eilon",
				"Number": "3329",
				"RawContent": null,
				"Title": "Suggest:The IOC resolves the relationship and displays the available implementation in the error message",
				"State": "open",
				"Body": "_From @hjkl950217 on May 8, 2018 8:28_\n\n.net environment：\r\nsdk:   .net core 2.1.104\r\nVS: 2017 Community\r\nsystem: windows 10 1709 pro N\r\n\r\nHopefully when ‘IOC’ parses an error, give some more detailed error information\r\n\r\nfor examples：\r\n\r\nIHttpContextAccessor interface，it injected when VS in debug mode。but release project，project does not contain the IHttpContextAccessor 。 this error message should show:\r\n\r\n“This interface is no corresponding implementation”\r\n\r\nbut However, sometimes this interface will be forcibly injected，This interface corresponding to the two to achieve。 this error message should show:\r\n\r\nThere are multiple implementations of this interface:\r\n{xxxx.xxxx.xxxx.IHttpContextAccessor }\r\n{bbbb.bbbb.bbbb.IHttpContextAccessor }\r\n\r\nThis can be more convenient positioning problem！\r\n\r\n##  about me project\r\n\r\nI am writing the company's basic class library，Use IHttpContextAccessor in the basic class library.\r\nBut,Other web api project Report this interface to resolve errors。\r\n\r\nPossible situations:\r\n1.Internal references to projects lead to。\r\n2.Used by other libraries referenced by the base class library。\r\n3.Library version issues\r\n4.other issues.\r\n\r\n\r\nI know that the official blog has described this issue，but it did not help me solve the problem.\r\nOccasionally, this problem will still occur, but it can hardly be solved.\r\n\r\n\r\n\r\n\n\n_Copied from original issue: dotnet/core#1514_",
				"Url": "https://github.com/aspnet/Home/issues/3329",
				"RelatedDescription": "Open issue \"Suggest:The IOC resolves the relationship and displays the available implementation in the error message\" (#3329)"
			},
			{
				"Id": "341070392",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T15:50:04",
				"Actor": "Eilon",
				"Number": "3328",
				"RawContent": null,
				"Title": "Not allowing to post huge data in AJAX call in ASP .net core 2",
				"State": "open",
				"Body": "_From @SattarMomin on May 16, 2018 9:52_\n\n# Issue Title\r\n\r\nNot allowing to post huge data in AJAX call in ASP .net core 2\r\n\r\n# General\r\n\r\nI have created 1 page in ASP .net core 2 MVC. Now I am posting data of form by AJAX call and calling Controller Action. But when data is huge on page it is giving error \"Failed to load resource: the server responded with a status of 500 (Internal Server Error)\", same is working fine when data is less.\r\n\r\nI am sure issue is due to exceeding data size limit. \r\n\r\nI have tried '[DisableRequestSizeLimit]' at action level and .UseKestrel(options => { options.Limits.MaxRequestBodySize = null; }) at global level, but giving same error.\r\n\r\nKindly suggest\r\n\n\n_Copied from original issue: dotnet/core#1566_",
				"Url": "https://github.com/aspnet/Home/issues/3328",
				"RelatedDescription": "Open issue \"Not allowing to post huge data in AJAX call in ASP .net core 2\" (#3328)"
			},
			{
				"Id": "340956108",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T09:55:00",
				"Actor": "Edward-Zhou",
				"Number": "3327",
				"RawContent": null,
				"Title": "CORS did not add valid Origins to Response if Method is not Allowed",
				"State": "open",
				"Body": "I have configured CORS like below:\r\n```\r\nservices.AddCors(x =>\r\n            {\r\n                x.AddPolicy(CORS.AllowPostMethod,\r\n                    policyBuilder =>\r\n                    {\r\n                        policyBuilder\r\n                            .WithOrigins(\"https://localhost:44326\")\r\n                            .WithMethods(HttpMethods.Post)\r\n                            .AllowAnyHeader();\r\n                    });\r\n            });\r\n```\r\nAnd use it like this:   \r\n```\r\n[HttpPut(\"{id}\")]\r\n        [EnableCors(CORS.AllowPostMethod)] \r\n        public void Put(int id)\r\n        {\r\n        }\r\n```\r\nIf I send request like this:\r\n```\r\n$.ajax({\r\n    url: \"https://localhost:44329/api/User/12\",\r\n    type: \"PUT\",\r\n});\r\n```\r\nIt will throw error below instead of \"Method PUT is not allowed by Access-Control-Allow-Methods in preflight response\".\r\n\r\n> Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'https://localhost:44326' is therefore not allowed access.\r\n\r\nAfter checking the source code [EvaluatePreflightRequest](https://github.com/aspnet/CORS/blob/8e4d3aacb3153f2a1338e228f0ea096e242d746a/src/Microsoft.AspNetCore.Cors/Infrastructure/CorsService.cs#L111). It did not add the valid `Origin` to `CorsResult `.\r\n\r\nShould the `EvaluatePreflightRequest` like below?\r\n\r\n```\r\n                 public virtual void EvaluatePreflightRequest(HttpContext context, CorsPolicy policy, ref CorsResult result)\r\n        {\r\n            var origin = context.Request.Headers[CorsConstants.Origin];\r\n            if (!IsOriginAllowed(policy, origin))\r\n            {\r\n                return;\r\n            }\r\n            result.AllowedOrigin = origin;\r\n\r\n            var accessControlRequestMethod = context.Request.Headers[CorsConstants.AccessControlRequestMethod];\r\n            if (StringValues.IsNullOrEmpty(accessControlRequestMethod))\r\n            {\r\n                return;\r\n            }\r\n\r\n            var requestHeaders =\r\n                context.Request.Headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders);\r\n\r\n            if (!policy.AllowAnyMethod)\r\n            {\r\n                var found = false;\r\n                for (var i = 0; i < policy.Methods.Count; i++)\r\n                {\r\n                    var method = policy.Methods[i];\r\n                    result.AllowedMethods.Add(method);\r\n                    if (string.Equals(method, accessControlRequestMethod, StringComparison.OrdinalIgnoreCase))\r\n                    {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found)\r\n                {\r\n                    _logger?.PolicyFailure();\r\n                    _logger?.AccessControlMethodNotAllowed(accessControlRequestMethod);\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            if (!policy.AllowAnyHeader &&\r\n                requestHeaders != null)\r\n            {\r\n                foreach (var requestHeader in requestHeaders)\r\n                {\r\n                    if (!CorsConstants.SimpleRequestHeaders.Contains(requestHeader, StringComparer.OrdinalIgnoreCase) &&\r\n                                                  !policy.Headers.Contains(requestHeader, StringComparer.OrdinalIgnoreCase))\r\n                    {\r\n                        _logger?.PolicyFailure();\r\n                        _logger?.RequestHeaderNotAllowed(requestHeader);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            AddOriginToResult(origin, policy, result);\r\n            result.SupportsCredentials = policy.SupportsCredentials;\r\n            result.PreflightMaxAge = policy.PreflightMaxAge;\r\n            result.AllowedMethods.Add(accessControlRequestMethod);\r\n            AddHeaderValues(result.AllowedHeaders, requestHeaders);\r\n            _logger?.PolicySuccess();\r\n        }\r\n```",
				"Url": "https://github.com/aspnet/Home/issues/3327",
				"RelatedDescription": "Open issue \"CORS did not add valid Origins to Response if Method is not Allowed\" (#3327)"
			},
			{
				"Id": "340821013",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T22:32:12",
				"Actor": "avechuche",
				"Number": "3325",
				"RawContent": null,
				"Title": "Cannot capture 405 error with CORS - CORE API",
				"State": "open",
				"Body": "Hi, I am trying to get a 405 method not allowed error but it is impossible and I do not know why. I have the following configuration.\r\n\r\n```\r\n//Startup.cs\r\nservicesCollection.AddCors(x =>\r\n{\r\n    x.AddPolicy(CORS.AllowPutMethod,\r\n        policyBuilder =>\r\n        {\r\n            policyBuilder.WithOrigins(\"http://localhost:4200\")\r\n                .WithMethods(HttpMethods.Put).AllowAnyHeader();\r\n        });\r\n    x.AddPolicy(CORS.AllowPostMethod,\r\n        policyBuilder =>\r\n        {\r\n            policyBuilder.WithOrigins(\"http://localhost:4200\")\r\n                .WithMethods(HttpMethods.Post).AllowAnyHeader();\r\n        });\r\n});\r\n\r\npublic static class CORS\r\n{\r\n    public const string AllowPutMethod = nameof(AllowPutMethod);\r\n\r\n    public const string AllowPostMethod = nameof(AllowPostMethod);\r\n}\r\n\r\n[ApiController]\r\n[Route(\"api/[controller]\")]\r\npublic class UserController : ControllerBase\r\n{\r\n    // PUT: api/User/5\r\n    [HttpPut(\"{id}\")]\r\n    [EnableCors(CORS.AllowPostMethod)]\r\n    public void Put(int id, UserDTO currentUser)\r\n    {\r\n    }\r\n\r\n}\r\n```\r\nMy intention is that this method only accepts a PUT request, to which I add [EnableCors (CORS.AllowPostMethod)] to force an error, but this does not generate any errors, it works perfectly, but if I comment that part // [EnableCors (CORS .AllowPostMethod)] method does not work and returns error 500. Its a ASP CORE bug or or i am the bug?",
				"Url": "https://github.com/aspnet/Home/issues/3325",
				"RelatedDescription": "Open issue \"Cannot capture 405 error with CORS - CORE API\" (#3325)"
			}],
			"ResultType": "GitHubIssue"
		}
	},
	"RunOn": "2018-07-24T05:30:22.990787Z",
	"RunDurationInMilliseconds": 17242
}
