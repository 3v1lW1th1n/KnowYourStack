{"Data":{"GitHub":{"Issues":[{"Id":"511647697","IsPullRequest":true,"CreatedAt":"2019-10-24T01:10:25","Actor":"dotnet-maestro[bot]","Number":"2105","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191023.3\r\n- **Date Produced**: 10/24/2019 12:57 AM\r\n- **Commit**: 58d0d0d7e1c8c14bda53a9c1ac014e84f5b5df95\r\n- **Branch**: refs/heads/release/3.1\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.1-preview1.19523.3\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.App** -> 3.1.0-preview2.19523.6 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Configuration.ConfigurationManager** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Diagnostics.EventLog** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.DirectoryServices** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Drawing.Common** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.Emit** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.MetadataLoadContext** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.AccessControl** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Cryptography.Xml** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Permissions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Principal.Windows** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Windows.Extensions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.Platforms** -> 3.1.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.IO.Packaging** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILDAsm** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **Microsoft.NETCore.Runtime.CoreCLR** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILAsm** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **System.Resources.Extensions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2105","RelatedDescription":"Open PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#2105)"},{"Id":"511643114","IsPullRequest":true,"CreatedAt":"2019-10-24T01:05:25","Actor":"dotnet-maestro[bot]","Number":"2104","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191023.2\r\n- **Date Produced**: 10/24/2019 12:38 AM\r\n- **Commit**: fb02fe818f8b410259776e4fa6ca0c5cdd43e07c\r\n- **Branch**: refs/heads/release/3.1\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.1-preview1.19523.2\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2104","RelatedDescription":"Closed or merged PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#2104)"},{"Id":"511629257","IsPullRequest":true,"CreatedAt":"2019-10-23T23:52:51","Actor":"rladuca","Number":"2103","RawContent":null,"Title":"[Release/3.1] Hit testing by geometry fails if more than one matrix trasformation is applied to a geometry.","State":"open","Body":"On behalf of @Simon-IT :\r\n\r\nThis is related to my issue 642. In the hit testing by geometry algotithm, the order in which the transformations are crosses is wrong. In the issue 642 there is a project to test in very simple manner the problem.\r\n\r\n3.1 port related to https://github.com/dotnet/wpf/pull/1761","Url":"https://github.com/dotnet/wpf/pull/2103","RelatedDescription":"Open PR \"[Release/3.1] Hit testing by geometry fails if more than one matrix trasformation is applied to a geometry.\" (#2103)"},{"Id":"511613394","IsPullRequest":true,"CreatedAt":"2019-10-23T22:55:34","Actor":"vatsan-madhavan","Number":"2102","RawContent":null,"Title":"[release/3.0] Prevent NULL HWND's from being parented under SystemResources listener windows","State":"open","Body":"Addresses #2089 \r\n.NET 5 PR: #2100 \r\n.NET Core 3.1 PR: #2101 \r\n\r\n## Description (Summary)\r\n\r\nWhen `HwndHost` hosted `HWND`'s need to be \"parked\" while the `HwndHost` is not being actively shown, WPF will reparent such `HWND`'s under temporary message-only windows maintained inside the `SystemResources` class. \r\n\r\nThere is a bug that causes null `HWND`'s to be parented under such message-only windows. When this happens in High-DPI applications that use mixed-mode DPI capabilities introduced by WPF in .NET 4.8 (parent and child windows with different `DPI_AWARENESS_CONTEXT `values),  a crash ensues. \r\n\r\n## Customer Impact \r\n\r\nThis is a fix for a crash affecting several applications including Visual Studio, and Azure Information Protection Add-in for Office \r\n\r\nThis was fixed recently in .NET 4.8, and is being forwarded ported to .NET Core for consistency. \r\n\r\n## Regresssion \r\n\r\nNot a regression in .NET Core, but this was a regression introduced by .NET 4.8. \r\n\r\n## Risk \r\n\r\nThe fix is small and well understood, and has been tested well. The .NET Framework version of this fix has been validated by Visual Studio (the codebases are identical in this area and .NET Framework testing is a reliable proxy for this change in .NET Core). \r\n\r\n## Details \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2102","RelatedDescription":"Open PR \"[release/3.0] Prevent NULL HWND's from being parented under SystemResources listener windows\" (#2102)"},{"Id":"511612931","IsPullRequest":true,"CreatedAt":"2019-10-23T22:54:12","Actor":"vatsan-madhavan","Number":"2101","RawContent":null,"Title":"[release/3.1] Prevent NULL HWND's from being parented under SystemResources listener windows ","State":"open","Body":"Addresses #2089 \r\n.NET 5 PR: #2100 \r\n\r\n## Description (Summary)\r\n\r\nWhen `HwndHost` hosted `HWND`'s need to be \"parked\" while the `HwndHost` is not being actively shown, WPF will reparent such `HWND`'s under temporary message-only windows maintained inside the `SystemResources` class. \r\n\r\nThere is a bug that causes null `HWND`'s to be parented under such message-only windows. When this happens in High-DPI applications that use mixed-mode DPI capabilities introduced by WPF in .NET 4.8 (parent and child windows with different `DPI_AWARENESS_CONTEXT `values),  a crash ensues. \r\n\r\n## Customer Impact \r\n\r\nThis is a fix for a crash affecting several applications including Visual Studio, and Azure Information Protection Add-in for Office \r\n\r\nThis was fixed recently in .NET 4.8, and is being forwarded ported to .NET Core for consistency. \r\n\r\n## Regresssion \r\n\r\nNot a regression in .NET Core, but this was a regression introduced by .NET 4.8. \r\n\r\n## Risk \r\n\r\nThe fix is small and well understood, and has been tested well. The .NET Framework version of this fix has been validated by Visual Studio (the codebases are identical in this area and .NET Framework testing is a reliable proxy for this change in .NET Core). \r\n\r\n## Details \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2101","RelatedDescription":"Open PR \"[release/3.1] Prevent NULL HWND's from being parented under SystemResources listener windows \" (#2101)"},{"Id":"511608382","IsPullRequest":true,"CreatedAt":"2019-10-23T22:39:30","Actor":"vatsan-madhavan","Number":"2100","RawContent":null,"Title":"Prevent NULL HWND's from being parented under SystemResources listener windows","State":"open","Body":"Addresses #2089 \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2100","RelatedDescription":"Open PR \"Prevent NULL HWND's from being parented under SystemResources listener windows\" (#2100)"},{"Id":"511600847","IsPullRequest":true,"CreatedAt":"2019-10-23T22:17:59","Actor":"vatsan-madhavan","Number":"2099","RawContent":null,"Title":"[release/3.0] Context Menus are sometimes not shown in High-DPI applications ","State":"open","Body":"Addresses #2088 \r\n.NET 5 PR: #2097 \r\n.NET Core 3.1 PR: #2098 \r\n\r\n## Description (Summary)\r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nThis previous fix depended upon a private helper-method (`Popup.DestroyWindow`) that had side-effects that were not accounted for in the original fix. One of the side effects is that the `ContextMenu` is not sown consistently. \r\n\r\nThe solution modifies (refactors) the private method to extract the useful portion and uses it to improve the previous fix. \r\n\r\n## Customer Impact\r\n\r\nThis is a forward-port from from .NET 4.8. This was reported by a customer, and has also been discovered by Visual Studio internally. \r\n\r\n## Regression \r\n\r\nRegression introduced by .NET 4.8. .NET Core 3.0 shipped with this bug. \r\n\r\n## Risk \r\n\r\nLow - this has been well tested internally and validated by multiple customers. The fix is well understood and small/scoped. \r\n\r\n## Details \r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2099","RelatedDescription":"Open PR \"[release/3.0] Context Menus are sometimes not shown in High-DPI applications \" (#2099)"},{"Id":"511600421","IsPullRequest":true,"CreatedAt":"2019-10-23T22:16:54","Actor":"vatsan-madhavan","Number":"2098","RawContent":null,"Title":"[release/3.1] Context Menus are sometimes not shown in High-DPI applications","State":"open","Body":"Addresses #2088 \r\n.NET 5 PR: #2097 \r\n\r\n## Description (Summary)\r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nThis previous fix depended upon a private helper-method (`Popup.DestroyWindow`) that had side-effects that were not accounted for in the original fix. One of the side effects is that the `ContextMenu` is not sown consistently. \r\n\r\nThe solution modifies (refactors) the private method to extract the useful portion and uses it to improve the previous fix. \r\n\r\n## Customer Impact\r\n\r\nThis is a forward-port from from .NET 4.8. This was reported by a customer, and has also been discovered by Visual Studio internally. \r\n\r\n## Regression \r\n\r\nRegression introduced by .NET 4.8. .NET Core 3.0 shipped with this bug. \r\n\r\n## Risk \r\n\r\nLow - this has been well tested internally and validated by multiple customers. The fix is well understood and small/scoped. \r\n\r\n## Details \r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2098","RelatedDescription":"Open PR \"[release/3.1] Context Menus are sometimes not shown in High-DPI applications\" (#2098)"},{"Id":"511464037","IsPullRequest":true,"CreatedAt":"2019-10-23T17:20:07","Actor":"vatsan-madhavan","Number":"2097","RawContent":null,"Title":"Context Menus are sometimes not shown in High-DPI applications","State":"open","Body":"Addresses #2088 \r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2097","RelatedDescription":"Open PR \"Context Menus are sometimes not shown in High-DPI applications\" (#2097)"},{"Id":"510620655","IsPullRequest":true,"CreatedAt":"2019-10-23T13:19:16","Actor":"dotnet-maestro[bot]","Number":"2078","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Build**: 20191023.4\r\n- **Date Produced**: 10/23/2019 11:10 AM\r\n- **Commit**: 75c121fe7ad3fd480338581db262a7a297287665\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng** -> 5.0.0-alpha1.19523.4\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2078","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#2078)"},{"Id":"511276661","IsPullRequest":true,"CreatedAt":"2019-10-23T13:13:37","Actor":"dotnet-maestro[bot]","Number":"2095","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191022.8\r\n- **Date Produced**: 10/22/2019 10:28 PM\r\n- **Commit**: b809e63d8ef475faaf6fecbe8bf77180f8e3550c\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19522.8\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2095","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2095)"},{"Id":"511279817","IsPullRequest":false,"CreatedAt":"2019-10-23T12:09:51","Actor":"DarkIrata","Number":"2096","RawContent":null,"Title":"Adding a SpinEdit / NumericUpDown Control to WPF","State":"open","Body":"The NumericUpDown control is available in WinForms, and also should be in WPF. Especially since it is much easier to make custom styles for controls in WPF. \r\nIt is annoying to rebuild that control everytime you need it and can't reuse older code. Sure there are ready to use libraries like MahApps, but it should never be a requirement for basic controls to add a dependency. Even worse when you use style libraries like MaterialDesignInXaml which restyle many basic controls. (Yes, i know that an self-made problem) \r\n\r\nI am suprised that there is no request issue open for this.\r\nBut yeah, would be happy to get that control. ","Url":"https://github.com/dotnet/wpf/issues/2096","RelatedDescription":"Open issue \"Adding a SpinEdit / NumericUpDown Control to WPF\" (#2096)"},{"Id":"511088306","IsPullRequest":true,"CreatedAt":"2019-10-23T05:55:23","Actor":"dotnet-maestro[bot]","Number":"2094","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.10\r\n- **Date Produced**: 10/23/2019 5:26 AM\r\n- **Commit**: b34582761bea089eb0d19aba8e43c4b90d90c98e\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.10\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2094","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2094)"},{"Id":"511020760","IsPullRequest":true,"CreatedAt":"2019-10-23T02:05:28","Actor":"dotnet-maestro[bot]","Number":"2093","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.7\r\n- **Date Produced**: 10/23/2019 1:15 AM\r\n- **Commit**: 4f9ddf34914d9b014fde363b8cc37f2a590b03b9\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.7\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2093","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2093)"},{"Id":"510986717","IsPullRequest":true,"CreatedAt":"2019-10-22T23:36:35","Actor":"arpitmathur","Number":"2092","RawContent":null,"Title":"Adding border to ToggleButton when checked in high-contrast themes","State":"open","Body":"Fixes #1458\r\n\r\n5.0 PR: https://github.com/dotnet/wpf/pull/1976\r\n\r\n# Description\r\n\r\nIn non-high contrast themes, when you check a ToggleButton and navigate to another control, we display the checked status by highlighting the button with a lighter shade of the selection color.\r\n\r\nWe don't follow this behavior in high contrast themes. The text is slightly-depressed upon checking but that is not visually apparent . When the ToggleButton does not have focus, there is a slight border which again, is not apparent.\r\n![highcontrastwhitetogglebutton_without_change](https://user-images.githubusercontent.com/5456126/65924723-e6ecda80-e3a2-11e9-860d-66c72212c0e0.png)\r\n\r\nIn the image above, the 'S', 'C' and 'I' buttons are checked. However, it's barely noticeable that 'S' and 'C' are checked. The checked status of the 'I' button is also not noticeable when it receives focus.\r\n\r\n\r\nThe fix here is to check for a toggle button to be checked when in a high-contrast theme, we then add a border around the button. When a checked button also has keyboard focus, we add a border in the background-color. When the user navigates away, the border color is the same as the selection-color.\r\n\r\nIn the image below, the 'S', 'C' and 'I' buttons are checked again. Here, it's visually apparent that they are all currently checked.\r\n![highcontrastwhitetogglebutton_with_change](https://user-images.githubusercontent.com/5456126/65924964-c709e680-e3a3-11e9-8eab-fd1016e4c3b3.png)\r\n\r\nIn this pull request, relevant changes are in lines 673:693 in Button.xaml, the remaining files are generated off those changes.\r\n# Customer Impact\r\n\r\nIn high contrast themes, when you check a ToggleButton, it is not visually apparent that the ToggleButton has been checked, both when the ToggleButton has keyboard focus and when it does not.\r\n# Regression\r\nNo. This was discovered during accessibility testing on .Net Core 3.0\r\n\r\n# Risk - Low\r\nThis change only affects the ToggleButton control when HighContrast mode is turned on.","Url":"https://github.com/dotnet/wpf/pull/2092","RelatedDescription":"Open PR \"Adding border to ToggleButton when checked in high-contrast themes\" (#2092)"},{"Id":"510983505","IsPullRequest":true,"CreatedAt":"2019-10-22T23:35:46","Actor":"dotnet-maestro[bot]","Number":"2091","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.5\r\n- **Date Produced**: 10/22/2019 10:54 PM\r\n- **Commit**: 66b697b2c010c8f49d01af11863212a0caf18824\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.5\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2091","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2091)"},{"Id":"510975056","IsPullRequest":true,"CreatedAt":"2019-10-22T22:58:41","Actor":"arpitmathur","Number":"2090","RawContent":null,"Title":"Removing separators from SizeOfSet and PositionInSet counts","State":"open","Body":"Fixes #1467\r\n\r\n5.0 PR: https://github.com/dotnet/wpf/pull/1977\r\n\r\n# Description\r\n\r\nScreen readers were reading incorrect values of the number of menu items and their position since we were counting separators as MenuItems in the automation tree.\r\n\r\nI filtered for separators in the current MenuItems to fix the SizeOfSet count.\r\n\r\nI filtered for separators again for PositionInSet but added a short-circuit to break when you're at the element whose position you're trying to find. This short-circuit was added to not remove separators below the relevant MenuItem from the PositionInSet count.\r\n\r\n# Customer Impact\r\n\r\nNarrator and other screen readers read the wrong values of SizeOfSet and PositioninSet for each individual menu item. This is confusing for users with visual disabilities as they can not accurately tell what is being visually represented on the screen.\r\n\r\n# Regression\r\nNo. This was discovered during accessibility testing on .Net Core 3.0\r\n\r\n# Risk - Low\r\nWe're iterating over the menu items another time in a place where we're already iterating. Running another iteration through an enumerable does invalidate some caching but there doesn't seem to be an obviously better way to make this change. We rejected an approach storing the number of separators in a variable as the memory cost would always be paid and be higher than the time cost of another iteration.","Url":"https://github.com/dotnet/wpf/pull/2090","RelatedDescription":"Open PR \"Removing separators from SizeOfSet and PositionInSet counts\" (#2090)"},{"Id":"510962028","IsPullRequest":false,"CreatedAt":"2019-10-22T22:27:38","Actor":"vatsan-madhavan","Number":"2089","RawContent":null,"Title":"NULL HWND's attempted to be parented under SystemResources listener window cause unhanded exception","State":"open","Body":"When an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent. \r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now. \r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that have resulted in this bug becoming a crashing bug. In addition to calling `kernel32!SetParent `on a `NULL HWND`, WPF attempts to perform several other operations on the `HWND`, including querying its DPI characteristics (which returns invalid information). Once of the subsidiary steps returns an invalid value that in turn results in a crash with the following stack:\r\n\r\n```\r\nSystem.Collections.Generic.KeyNotFoundException: 'The given key was not present in the dictionary.'\r\nmscorlib.dll!System.Collections.Generic.Dictionary<System.__Canon, System.__Canon>.this[System.__Canon].get(System.__Canon key) Line 183\tC#\r\n \tPresentationFramework.dll!System.Windows.SystemResources.GetDpiAwarenessCompatibleNotificationWindow(System.Runtime.InteropServices.HandleRef hwnd) Line 1731\tC#\r\n \tPresentationFramework.dll!System.Windows.Interop.HwndHost.BuildOrReparentWindow() Line 1196\tC#\r\n \tPresentationFramework.dll!System.Windows.Interop.HwndHost.OnSourceChanged(object sender, System.Windows.SourceChangedEventArgs e) Line 1077\tC#\r\n \tPresentationCore.dll!System.Windows.SourceChangedEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget) Line 142\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target) Line 341\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs) Line 81\tC#\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised) Line 203\tC#\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args) Line 2354\tC#\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e) Line 432\tC#\r\n \tPresentationCore.dll!System.Windows.PresentationSource.UpdateSourceOfElement(System.Windows.DependencyObject doTarget, System.Windows.DependencyObject doAncestor, System.Windows.DependencyObject doOldParent) Line 861\tC#\r\n \tPresentationCore.dll!System.Windows.PresentationSource.RootChanged(System.Windows.Media.Visual oldRoot, System.Windows.Media.Visual newRoot) Line 566\tC#\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value) Line 699\tC#\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.Dispose(bool disposing) Line 2895\tC#\t\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.OnHwndDisposed(object sender, System.EventArgs args) Line 2819\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.Dispose(bool disposing, bool isHwndBeingDestroyed) Line 230\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) Line 360\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) Line 494\tC#\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) Line 104\tC#\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) Line 37\tC#\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) Line 1445\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) Line 398\tC#\r\n```\r\n\r\nThis issue is related to, but not a duplicate of, #1198/#1953. That said, it affects the same sorts of scenarios described in #1198.  \r\n\r\n```C#\r\n// ****BUG*** \r\n// unconditional else block\r\n// hwnd.Handle could be IntPtr.Zero, bad things can happen here\r\n// ****BUG*** \r\n```\r\nhttps://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/HwndHost.cs#L979-L997\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/2089","RelatedDescription":"Open issue \"NULL HWND's attempted to be parented under SystemResources listener window cause unhanded exception\" (#2089)"},{"Id":"510955831","IsPullRequest":false,"CreatedAt":"2019-10-22T22:16:24","Actor":"vatsan-madhavan","Number":"2088","RawContent":null,"Title":"Context Menus (Popup) are sometimes broken in High-DPI applications in .NET 4.8 ","State":"open","Body":"https://github.com/microsoft/dotnet/issues/1036#issue-443322868\r\n\r\n> After installing .NET 4.8 we have observed that Context menus via the Popup class show strange effects.\r\n> \r\n> 1. Popup is placed at top left corner\r\n> 2. Popup comes up empty\r\n> 3. Popup has no styles applied\r\n> 4. Alternating behavior:\r\n>    a) Popup works.\r\n>    b) Popup comes up empty\r\n>    ....\r\n> \r\n> I have debugged that issue and found that the is Popup is sometimes destroyed while the popup window is meant to be created:\r\n> \r\n> The diff from .NET 4.7.2 to 4.8 shows this new code was added:\r\n> \r\n> ![image](https://user-images.githubusercontent.com/408821/57610465-28562800-7571-11e9-9168-b0c036706a22.png)\r\n> \r\n> This leads to the call stack that the popup is killed while it is beeing created:\r\n> \r\n> ```\r\n> 0:000> !ClrStack\r\n> OS Thread Id: 0x2180 (0)\r\n> Call Site\r\n> System.Windows.Controls.Primitives.Popup.DestroyWindow()\r\n> System.Windows.Controls.Primitives.Popup.CreateWindow(Boolean)\r\n> \r\n> System.Windows.Controls.Primitives.Popup.OnIsOpenChanged(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex, System.Windows.DependencyProperty, System.Windows.PropertyMetadata, System.Windows.EffectiveValueEntry, System.Windows.EffectiveValueEntry ByRef, Boolean, Boolean, System.Windows.OperationType)\r\n> System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty, Boolean)\r\n> System.Windows.Data.BindingExpressionBase.Invalidate(Boolean)\r\n> System.Windows.Data.BindingExpression.TransferValue(System.Object, Boolean)\r\n> MS.Internal.Data.ClrBindingWorker.NewValueAvailable(Boolean, Boolean, Boolean)\r\n> MS.Internal.Data.PropertyPathWorker.UpdateSourceValueState(Int32, System.ComponentModel.ICollectionView, System.Object, Boolean)\r\n> MS.Internal.Data.PropertyPathWorker.OnDependencyPropertyChanged(System.Windows.DependencyObject, System.Windows.DependencyProperty, Boolean)\r\n> System.Windows.Data.BindingExpression.HandlePropertyInvalidation(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.Data.BindingExpressionBase.OnPropertyInvalidation(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.Data.BindingExpression.OnPropertyInvalidation(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependentList.InvalidateDependents(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex, System.Windows.DependencyProperty, System.Windows.PropertyMetadata, System.Windows.EffectiveValueEntry, System.Windows.EffectiveValueEntry ByRef, Boolean, Boolean, System.Windows.OperationType)\r\n> System.Windows.DependencyObject.SetValueCommon(System.Windows.DependencyProperty, System.Object, System.Windows.PropertyMetadata, Boolean, Boolean, System.Windows.OperationType, Boolean)\r\n> System.Windows.DependencyObject.SetCurrentValueInternal(System.Windows.DependencyProperty, System.Object)\r\n> \r\n> System.Windows.Controls.PopupControlService.**RaiseContextMenuOpeningEvent**(System.Windows.IInputElement, Double, Double, Boolean)\r\n> \r\n> System.Windows.Controls.PopupControlService.ProcessMouseUp(System.Object, System.Windows.Input.MouseButtonEventArgs)\r\n> System.Windows.Controls.PopupControlService.OnPostProcessInput(System.Object, System.Windows.Input.ProcessInputEventArgs)\r\n> System.Windows.Input.InputManager.RaiseProcessInputEventHandlers(System.Windows.Input.ProcessInputEventHandler, System.Windows.Input.ProcessInputEventArgs)\r\n> System.Windows.Input.InputManager.ProcessStagingArea()\r\n> System.Windows.Input.InputManager.ProcessInput(System.Windows.Input.InputEventArgs)\r\n> System.Windows.Input.InputProviderSite.ReportInput(System.Windows.Input.InputReport)\r\n> System.Windows.Interop.HwndMouseInputProvider.ReportInput(IntPtr, System.Windows.Input.InputMode, Int32, System.Windows.Input.RawMouseActions, Int32, Int32, Int32)\r\n> System.Windows.Interop.HwndMouseInputProvider.FilterMessage(IntPtr, MS.Internal.Interop.WindowMessage, IntPtr, IntPtr, Boolean ByRef)\r\n> System.Windows.Interop.HwndSource.InputFilterMessage(IntPtr, Int32, IntPtr, IntPtr, Boolean ByRef)\r\n> ```\r\n> \r\n> To me this looks like an error. The window should not be killed when it is already (partially) active. This call should therefore be moved to the check where BuildWindow is beeing called.\r\n> After setting the AppContext switch\r\n> \r\n> ```\r\n>   <runtime>\r\n>     <AppContextSwitchOverrides value=\"Switch.System.Windows.DoNotScaleForDpiChanges=true\" />\r\n>   </runtime>\r\n> ```\r\n> \r\n> the issue does go away. This has therefore something to do with the monitor scaling flag during Popup.CreateWindow.\r\n","Url":"https://github.com/dotnet/wpf/issues/2088","RelatedDescription":"Open issue \"Context Menus (Popup) are sometimes broken in High-DPI applications in .NET 4.8 \" (#2088)"},{"Id":"510935378","IsPullRequest":true,"CreatedAt":"2019-10-22T21:55:24","Actor":"dotnet-maestro[bot]","Number":"2087","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.4\r\n- **Date Produced**: 10/22/2019 9:17 PM\r\n- **Commit**: e260e163967f49417bc8a6d537ea6fbeb80d8d80\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.4\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2087","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2087)"},{"Id":"510907133","IsPullRequest":true,"CreatedAt":"2019-10-22T21:10:25","Actor":"dotnet-maestro[bot]","Number":"2086","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.3\r\n- **Date Produced**: 10/22/2019 8:39 PM\r\n- **Commit**: f56aec1e41265912770e661a34400725da78d541\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.3\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2086","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2086)"},{"Id":"510870246","IsPullRequest":false,"CreatedAt":"2019-10-22T19:50:31","Actor":"rladuca","Number":"2085","RawContent":null,"Title":"Update XPS Serialization Stack for Packaging/Compression Semantic Changes","State":"open","Body":"In .NET Core 3, WPF changes to use the packaging and compression in Microsoft.NetCore.App instead of carrying WPF specific libraries in WindowsBase.dll.\n\nThis resulted in several compatibility problems with XPS document creation and manipulation.\n\n#575\n#597\n#1063\n#1363\n#1985\nWorkarounds have been generally done for much of these and some of these workarounds are encoded into the product itself.\n\nWPF should be updated in order to work well with the new sematics from System.IO.Packaging and System.IO.Compression. This will require a lot of investigation in several areas:\n\nXPS document creation and serialization\nPrinting\nGeneral package usage\nCreating this as an epic for now. Once more investigation is done into the scope for these changes, we can add specific tasks.","Url":"https://github.com/dotnet/wpf/issues/2085","RelatedDescription":"Open issue \"Update XPS Serialization Stack for Packaging/Compression Semantic Changes\" (#2085)"},{"Id":"510861086","IsPullRequest":true,"CreatedAt":"2019-10-22T19:40:33","Actor":"dotnet-maestro[bot]","Number":"2083","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.2\r\n- **Date Produced**: 10/22/2019 7:13 PM\r\n- **Commit**: 646c002c3df9ef61aa6afeb5233d9a59e911ce36\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.2\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.NETCore.App** -> 5.0.0-alpha1.19514.1 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILDAsm** -> 5.0.0-alpha1.19513.3 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **Microsoft.NETCore.Runtime.CoreCLR** -> 5.0.0-alpha1.19513.3 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILAsm** -> 5.0.0-alpha1.19513.3 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2083","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2083)"},{"Id":"510386152","IsPullRequest":true,"CreatedAt":"2019-10-22T19:22:42","Actor":"vatsan-madhavan","Number":"2075","RawContent":null,"Title":"[release/3.1] Use correct PresentationBuildTasks.dll for VS and MSBuild builds","State":"closed","Body":"Port of https://github.com/dotnet/wpf/pull/1999\r\nFixes #1998 \r\n\r\n## Description \r\n\r\nThe PresentationBuildTasks.dll built out of the .NET Core codebase is not being used for msbuild based builds (i.e., when `$(MSBuildRuntimeType)==Full`) of WPF projects that use WindowsDesktop SDK. Instead, the PresentationBuildTasks.dll from GAC, i.e., the DLL that shipped with .NET Framework, is being used for builds instead.\r\n\r\nThis is because the *first* occurance of an `UsingTask` element that applies to a `TaskName` will always be used - it can not be overridden by subsequent `UsingTask` entries (this is unlike `Property` and `Item` behavior). See note in https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/msbuild/usingtask-element-msbuild.md immediate after the **Syntax** section (Note: The msbuild team added this note after identifying this behavior as part of investiaging this PresentationBuildTasks.dll issue).\r\n\r\nThis fix ensures that the `UsingTask` declarations supplied by the WindowsDesktop SDK precede those supplied by .NET Framework's copy of `Microsoft.WinFX.targets` by introducing a new `.props` file - `Microsoft.WinFX.props` - and moving a small number of `Property` and `UsingTask` declartions into it. Since `.props` are imported before `targets`, the `UsingTask` declarations supplied by WindowsDesktop SDK will thus take precedence.\r\n\r\nNote that `Pbt.props` is used only for building this repo - it doesn't ship.\r\n\r\n## Customer Impact \r\n\r\nMulti-targeted builds targeting .NET Framework will be produced incorrectly under some conditions, specifically when building using VS. There may be no problems initially due to the strong backwards compatibility between .NET Core and .NET Framework WPF assemblies - but errors in XAML/markup compilation may lead to hard-to-identify/debug problems. \r\n\r\n## Regression \r\n\r\nNot a regression. This was a missed corner case not caught until now. \r\n\r\n## Risk \r\n\r\n- The changes are scoped and  safe. \r\n- They have been tested by building a corpus of WPF samples \r\n- The fix has been in .NET 5 for 2 weeks now without any adverse reports. \r\n","Url":"https://github.com/dotnet/wpf/pull/2075","RelatedDescription":"Closed or merged PR \"[release/3.1] Use correct PresentationBuildTasks.dll for VS and MSBuild builds\" (#2075)"},{"Id":"510396211","IsPullRequest":true,"CreatedAt":"2019-10-22T18:56:18","Actor":"vatsan-madhavan","Number":"2076","RawContent":null,"Title":"[release/3.0] Use correct PresentationBuildTasks.dll for VS and MSBuild builds","State":"closed","Body":"Port of https://github.com/dotnet/wpf/pull/1999\r\nFixes #1998 \r\n\r\n## Description \r\n\r\nThe PresentationBuildTasks.dll built out of the .NET Core codebase is not being used for msbuild based builds (i.e., when `$(MSBuildRuntimeType)==Full`) of WPF projects that use WindowsDesktop SDK. Instead, the PresentationBuildTasks.dll from GAC, i.e., the DLL that shipped with .NET Framework, is being used for builds instead.\r\n\r\nThis is because the *first* occurance of an `UsingTask` element that applies to a `TaskName` will always be used - it can not be overridden by subsequent `UsingTask` entries (this is unlike `Property` and `Item` behavior). See note in https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/msbuild/usingtask-element-msbuild.md immediate after the **Syntax** section (Note: The msbuild team added this note after identifying this behavior as part of investiaging this PresentationBuildTasks.dll issue).\r\n\r\nThis fix ensures that the `UsingTask` declarations supplied by the WindowsDesktop SDK precede those supplied by .NET Framework's copy of `Microsoft.WinFX.targets` by introducing a new `.props` file - `Microsoft.WinFX.props` - and moving a small number of `Property` and `UsingTask` declartions into it. Since `.props` are imported before `targets`, the `UsingTask` declarations supplied by WindowsDesktop SDK will thus take precedence.\r\n\r\nNote that `Pbt.props` is used only for building this repo - it doesn't ship.\r\n\r\n## Customer Impact \r\n\r\nMulti-targeted builds targeting .NET Framework will be produced incorrectly under some conditions, specifically when building using VS. There may be no problems initially due to the strong backwards compatibility between .NET Core and .NET Framework WPF assemblies - but errors in XAML/markup compilation may lead to hard-to-identify/debug problems. \r\n\r\n## Regression \r\n\r\nNot a regression. This was a missed corner case not caught until now. \r\n\r\n## Risk \r\n\r\n- The changes are scoped and  safe. \r\n- They have been tested by building a corpus of WPF samples \r\n- The fix has been in .NET 5 for 2 weeks now without any adverse reports. \r\n","Url":"https://github.com/dotnet/wpf/pull/2076","RelatedDescription":"Closed or merged PR \"[release/3.0] Use correct PresentationBuildTasks.dll for VS and MSBuild builds\" (#2076)"},{"Id":"510730574","IsPullRequest":true,"CreatedAt":"2019-10-22T17:58:21","Actor":"rladuca","Number":"2081","RawContent":null,"Title":"[Release/3.1] Change XPS document creation to use FileAccess.ReadWrite instead of FileAccess.Write","State":"closed","Body":"Related to #1985\r\n\r\n5.0 PR: https://github.com/dotnet/wpf/pull/2073\r\n\r\n# Description\r\n\r\nIn .NET Core 3.0 System.IO.Compression's ZipArchive does not support multiple ZipArchiveEntries to be open concurrently when using FileAccess.Write. This is a requirement of the XPS serialization stack in WPF. As such, we need to create XPS documents as FileAccess.ReadWrite in order to allow this behavior.\r\n\r\nNOTE: These sort of changes have been used as a workaround in different, but related cases pre-GA of .NET Core 3 and have worked well.  Codifying them in the product itself helps move developers forward and gives some time to consider a re-design of the XPS serialization stack.\r\n\r\n# Customer Impact\r\nXPS creation when a customer chooses FileAccess.Write will get an exception from:\r\nhttps://github.com/dotnet/corefx/blob/861259bf87d8e4ee2c4f8dab31b73d377faff77d/src/System.IO.Compression/src/System/IO/Compression/ZipArchive.cs#L411\r\n\r\nDevelopers have been instructed to use FileAccess.ReadWrite as a workaround, but this isn't always applicable to library code.\r\n\r\n# Regression\r\nYes.  This is a regression from .NET Framework 4.8 due to switching to `System.IO.Compression` and `System.IO.Packaging` and can potentially block developers from moving their applications to .NET Core.\r\n\r\n# Risk - Low\r\nThe public facing functions that need altering here are on creation of an XPS document where there would generally have been Write access.  Switching to ReadWrite should present no problem.  There is potential for some optimizations to be lost from within the compression and packaging libs, but that is preferable to throwing an exception.\r\n\r\nThe internal functions are being changed as a precaution but are generally concerned with printing streams which are, generally, ReadWrite underneath.  This merely creates the package in the same access mode as the stream. ","Url":"https://github.com/dotnet/wpf/pull/2081","RelatedDescription":"Closed or merged PR \"[Release/3.1] Change XPS document creation to use FileAccess.ReadWrite instead of FileAccess.Write\" (#2081)"},{"Id":"510762636","IsPullRequest":false,"CreatedAt":"2019-10-22T16:14:09","Actor":"scalablecory","Number":"2082","RawContent":null,"Title":"Would be nice if the controls color theme would take over the theme from the windows settings","State":"open","Body":"_From @PeterPann23 on Tuesday, October 22, 2019 7:01:37 AM_\r\n\r\n# Windows Settings for theme is not applied to controls on winforms elements\r\n\r\n\r\n# General\r\nOne can go over the Windows.UI.ViewManagement.UISettings and apply the themes as development time however as we are starting a new implementation one could already take the theme from windows and apply this on the form, or have a property on the form class that states UseTheme so if the user has \"Dark-Mode\" then the form draws \"Dark-Mode\" for as much as that's possible in a non WPF app. \r\n\r\n\r\n\r\n_Copied from original issue: dotnet/core#3676_","Url":"https://github.com/dotnet/wpf/issues/2082","RelatedDescription":"Open issue \"Would be nice if the controls color theme would take over the theme from the windows settings\" (#2082)"},{"Id":"510709849","IsPullRequest":false,"CreatedAt":"2019-10-22T14:49:10","Actor":"nvmkpk","Number":"2080","RawContent":null,"Title":"VisualState.StateTriggers and VisualState.Setters","State":"open","Body":"Any plans on bringing StateTriggers and Setters from UWP to WPF? These are much simpler to use than the story boards when animation is not required.","Url":"https://github.com/dotnet/wpf/issues/2080","RelatedDescription":"Open issue \"VisualState.StateTriggers and VisualState.Setters\" (#2080)"},{"Id":"510609626","IsPullRequest":true,"CreatedAt":"2019-10-22T13:18:55","Actor":"dotnet-maestro[bot]","Number":"2077","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191021.4\r\n- **Date Produced**: 10/21/2019 9:44 PM\r\n- **Commit**: f104bcb28e4936b0c0ab7c0d8cb73892ab515e60\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19521.4\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19521.4\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19521.4\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19521.4\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19521.4\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2077","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2077)"},{"Id":"510639255","IsPullRequest":false,"CreatedAt":"2019-10-22T12:59:58","Actor":"DragDropAP","Number":"2079","RawContent":null,"Title":"DragDrop.DoDragDrop not working in wpf , when drag to windows explorer in windows10 #2007","State":"open","Body":"i am using below code to drag and drop the file or folder to windows explorer, it works perfectly for winforms but fails for wpf. \r\nIn WPF the code not work in windows 10 \r\n\r\nstring path = @\"C:\\Rajesh\\documents\\bug\\5.07 testing folder drag\"; StringCollection collection = new StringCollection() { path }; string[] files = { path }; var data = new DataObject(DataFormats.FileDrop, files); data. SetData(DataFormats.Text, files[0]); // Clipboard.SetData(DataFormats.FileDrop, files); // Perform dragdrop DragDrop.DoDragDrop(this, data, DragDropEffects.Copy);","Url":"https://github.com/dotnet/wpf/issues/2079","RelatedDescription":"Open issue \"DragDrop.DoDragDrop not working in wpf , when drag to windows explorer in windows10 #2007\" (#2079)"}],"ResultType":"GitHubIssue"}},"RunOn":"2019-10-24T05:31:00.9976941Z","RunDurationInMilliseconds":551}