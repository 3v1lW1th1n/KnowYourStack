{"Data":{"GitHub":{"Issues":[{"Id":"386637374","IsPullRequest":false,"CreatedAt":"2018-12-03T02:41:46","Actor":"asthana86","Number":"1806","RawContent":null,"Title":"Usage of Matrix Factorization Trainer for Recommendation ","State":"open","Body":"When using Matrix Factorization Trainer:\r\n\r\n ```csharp\r\nvar trainer = mlcontext.Recommendation().Trainers.MatrixFactorization\r\n                                                     (\"userIdEncoded\", \"movieIdEncoded\", \"rating\"));\r\n```\r\nWhen using other trainers:\r\n\r\n ```csharp\r\nvar trainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent\r\n                                                       (label: \"Label\", features: \"Features\");\r\n``` \r\n\r\nIs the difference in usage prop vs. method by design? Also there is a difference in the order of parameters being passed. First parameter is Label vs. Features being used. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/1806","RelatedDescription":"Open issue \"Usage of Matrix Factorization Trainer for Recommendation \" (#1806)"},{"Id":"386508048","IsPullRequest":true,"CreatedAt":"2018-12-02T15:54:15","Actor":"yaeldekel","Number":"1805","RawContent":null,"Title":"Calibrator trainer needs to clear data before retraining","State":"closed","Body":"This caused an incorrect calibrator to be trained in OVA and PKPD, since these trainers use the same ICalibratorTrainer to train multiple calibrators.\r\nFixes #1387 .","Url":"https://github.com/dotnet/machinelearning/pull/1805","RelatedDescription":"Closed or merged PR \"Calibrator trainer needs to clear data before retraining\" (#1805)"},{"Id":"386506053","IsPullRequest":true,"CreatedAt":"2018-12-01T22:53:27","Actor":"yaeldekel","Number":"1804","RawContent":null,"Title":"Add test coverage for VBuffer","State":"open","Body":"Add unit tests for VBuffer operations.\r\nFixes #1803 .","Url":"https://github.com/dotnet/machinelearning/pull/1804","RelatedDescription":"Open PR \"Add test coverage for VBuffer\" (#1804)"},{"Id":"385973073","IsPullRequest":true,"CreatedAt":"2018-12-01T20:09:15","Actor":"GalOshri","Number":"1785","RawContent":null,"Title":"Add release notes for ML.NET 0.8","State":"closed","Body":"This adds release notes for ML.NET 0.8.","Url":"https://github.com/dotnet/machinelearning/pull/1785","RelatedDescription":"Closed or merged PR \"Add release notes for ML.NET 0.8\" (#1785)"},{"Id":"386489059","IsPullRequest":false,"CreatedAt":"2018-12-01T19:29:54","Actor":"yaeldekel","Number":"1803","RawContent":null,"Title":"Bug in ApplyInto() method","State":"open","Body":"When the result of applying the function is dense, indices might be null, but this is not checked.","Url":"https://github.com/dotnet/machinelearning/issues/1803","RelatedDescription":"Open issue \"Bug in ApplyInto() method\" (#1803)"},{"Id":"386487666","IsPullRequest":false,"CreatedAt":"2018-12-01T19:13:11","Actor":"yaeldekel","Number":"1802","RawContent":null,"Title":"SSE bug when scaling a vector by a negative number","State":"open","Body":"When the number of elements is not divisible by 4, the sign of the result sometimes wrong.\r\nHere is an explanation from @eerhardt .\r\n\r\nWe are “double computing” at the end of the vector when there are remaining elements (1, 2, or 3 hanging elements). We then mask out the “double computed” elements in temp (which should have all 0s for the ‘double computed’ elements).\r\n\r\nHowever, when doing `temp = _mm_mul_ps(temp, x1);`, since ‘x1’ is negative, multiplying the 0s in temp against a negative number is turning them into -0 (negative zero).\r\n\r\nWe then `_mm_or_ps(temp, result);` which then switches the sign of the ‘double computed’ elements – which is incorrect.\r\n\r\nSo that’s why some of the elements are getting the wrong sign. Because we are OR’ing them with negative zero, which changes the sign.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1802","RelatedDescription":"Open issue \"SSE bug when scaling a vector by a negative number\" (#1802)"},{"Id":"386478969","IsPullRequest":true,"CreatedAt":"2018-12-01T17:33:39","Actor":"TomFinley","Number":"1801","RawContent":null,"Title":"Delete IColumn","State":"open","Body":"Fixes #1755.\r\n\r\nAt least initially staged as three commits, where we change some places, change the more difficult and rote places like tests and whatnot, then remove everything.","Url":"https://github.com/dotnet/machinelearning/pull/1801","RelatedDescription":"Open PR \"Delete IColumn\" (#1801)"},{"Id":"386443439","IsPullRequest":false,"CreatedAt":"2018-12-01T09:57:43","Actor":"asthana86","Number":"1800","RawContent":null,"Title":"Simpler Scenario Focused (getting started API) for ML.NET","State":"open","Body":"ML.NET is a machine learning framework focused on bringing .NET developers to the world of machine learning. Given the complexity of machine learning there are a number of concepts for developers to get familiar with before becoming successful right from the get-go.  \r\n\r\nIs there a way to provide a more templated/recipe-driven scenario focused set of API which represent common machine learning task for developers like Recommendation, Sentiment Analysis, Forecasting, Image Classification etc. This can help them get started quickly and progressively graduate to machine learning using the Dynamic API guarenting both short-term and long term success with ML. \r\n\r\ne.g. (Recommendation: Just a quick ugly mockup)\r\n\r\nCurrently for the recommendation scenario for Matrix Factorization the input feature are limited to UserId, OrderId, Rating or for co-purchase scenarios limited to UserId, OrderId. Given the nature of these features the transforms (categorical) and trainers (Matrix Factorization/One Class Matrix Factorization) are somewhat pre-known. \r\n\r\nIs it potentially possible to simplify the API to as follows:\r\n\r\n            //STEP 1: Create MLContext to be shared across the model creation workflow objects \r\n            var mlcontext = new MLContext();\r\n\r\n            //STEP 2: Create a reader by defining the schema for reading the movie recommendation datasets\r\n            var reader = mlcontext.Data.TextReader(new TextLoader.Arguments()\r\n            {\r\n                Separator = \"tab\",\r\n                HasHeader = true,\r\n                Column = new[]\r\n                {\r\n                    new TextLoader.Column(\"userId\", DataKind.Text, 0),\r\n                    new TextLoader.Column(\"movieId\", DataKind.Text, 1),\r\n                    new TextLoader.Column(\"Rating\", DataKind.R4, 2)\r\n                }\r\n            });\r\n\r\n            //STEP 3: Read in training data \r\n            var trainingDataView = reader.Read(new MultiFileSource(TrainingDataLocation));\r\n\r\n            //STEP 4: Create default Recommendtion model \r\n            var model = mlcontext.CreateRecommendationModel(trainingDataView);\r\n\r\n            //STEP 5: Read in test data \r\n            var testDataView = reader.Read(new MultiFileSource(TestDataLocation));\r\n\r\n            //STEP 6: Use Recommendation model to evaluate performance of test data \r\n            var prediction = model.Transform(testDataView);\r\n            var metrics = model.Evaluate(prediction, label: \"Label\", score: \"Score\");\r\n\r\nThis for getting started purposes avoids .NET developers to necessarily dive into understanding the concept of estimators, transforms, choice of learners etc. \r\n\r\n  var pipeline = mlcontext.Transforms.Categorical.MapValueToKey(\"userId\", \"userIdEncoded\")\r\n                                    .Append(mlcontext.Transforms.Categorical.MapValueToKey(\"movieId\", \"movieIdEncoded\")\r\n                                    .Append(new MatrixFactorizationTrainer(mlcontext, \"Label\", \"userIdEncoded\", \"movieIdEncoded\")));\r\n\r\nOther ML Frameworks focused on developers and AutoML approaches out there provide a simpler set of APIs targeting developers already. Is there something we can learn on that front given ML.NET already has some AutoML smarts based upon the static rule based engine. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1800","RelatedDescription":"Open issue \"Simpler Scenario Focused (getting started API) for ML.NET\" (#1800)"},{"Id":"386441449","IsPullRequest":false,"CreatedAt":"2018-12-01T09:26:48","Actor":"asthana86","Number":"1799","RawContent":null,"Title":"Logging and Tracing in ML.NET","State":"open","Body":"In EntityFramework there exists a context log property which allows for logging SQL generated by dbcontext.\r\n\r\nFor MLContext is there a similar log property which allows for logging some of the diags currently printed to Console when using various transforms or learners? Additionally is there a way to control log location and verbosity? \r\n\r\n**_E.g.: When using Matrix Factorization:_** \r\nSample: https://github.com/dotnet/machinelearning-samples/blob/master/samples/csharp/getting-started/MatrixFactorization_MovieRecommendation/MovieRecommendation/Program.cs\r\n\r\n=============== Training the model ===============\r\niter   tr_rmse          obj\r\n   0    0.0002   4.8456e+02\r\n   1    0.0002   7.8940e+02\r\n   2    0.0002   1.1160e+03\r\n   3    0.0002   1.2787e+03\r\n   4    0.0002   1.6045e+03\r\n   5    0.0002   2.0909e+03\r\n   6    0.0002   2.5788e+03\r\n   7    0.0002   2.9040e+03\r\n   8    0.0002   3.2300e+03\r\n   9    0.0002   3.2758e+03\r\n  10    0.0001   2.8742e+03\r\n  11    0.0001   2.5185e+03\r\n  12    0.0000   2.0396e+03\r\n  13    0.0000   1.9213e+03\r\n  14    0.0000   1.6839e+03\r\n  15    0.0000   1.3291e+03\r\n  16    0.0000   1.2107e+03\r\n  17    0.0000   9.7367e+02\r\n  18    0.0000   9.7325e+02\r\n  19    0.0000   9.7242e+02\r\nreal tr_rmse = 0.0000\r\n\r\nEF provides the following to users:\r\n\r\n**Output directly to console:**\r\nusing (var context = new YourDbContext()) \r\n{ \r\n    context.Database.Log = Console.Write; \r\n     // rest of you code goes here... \r\n}\r\n\r\n**_Log output to the trace window_**\r\nusing (var context = new YourDbContext()) \r\n{ \r\n    context.Database.Log = message => Trace.Write(message);\r\n    // rest of you code goes here\r\n}\r\n\r\n**_Already have a logging framework in place_**\r\nusing Common.Logging;\r\n\r\npublic class SomeClass\r\n{\r\n    private static readonly ILog log = LogManager.GetCurrentClassLogger();\r\n\r\n    public void SomeMethod()\r\n    {\r\n        context.Database.Log = message => log.Debug(message);\r\n    }\r\n}\r\n\r\nThanks. \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1799","RelatedDescription":"Open issue \"Logging and Tracing in ML.NET\" (#1799)"},{"Id":"386392122","IsPullRequest":false,"CreatedAt":"2018-11-30T23:53:47","Actor":"TomFinley","Number":"1798","RawContent":null,"Title":"Creation of components through MLContext: advanced options and other feedback","State":"open","Body":"In our estimators and other similar components often have advanced settings, because, sometimes people have unusual circumstances. At the same time, there is a 95% or 99% scenario for \"simple\" usage that most people will be happy with. For this reason we have often made a distinction between common and advanced settings, as we see here.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/cb37c7e7f1e1b29b5608a2755db793c5435d10b1/src/Microsoft.ML.FastTree/TreeTrainersCatalog.cs#L29-L38\r\n\r\nThere are some possible things that excited feedback:\r\n\r\n1. Echoing feedback seen in #1690, these things where we're making something should have the prefix `Create`, even in situations where this a catalog where we are *always* creating. Note: `Create` preferred to `Make`.\r\n\r\n2. The worth of ASP.NET style configuration was questioned (seen above as `Action<FastTreeRegressionTrainer.Arguments> advancedSettings`), e.g., there may not be much purpose in having a delegate. The older style where it just takes the `Arguments` *period* was preferred.\r\n\r\n3. Having this `Arguments` object as a nested class the component being created was viewed as positive, but this would be more idiomatically called `Options` -- `Arguments` was a holdover name from when these were exclusively for command line arguments, but for the API this is not a great name. So while keeping the general structure of how they are placed currently, they should probably be renamed to `Options`.\r\n\r\n4. It is good to have the convenience for the simple arguments, however, if we have both simple and advanced settings, we should not mix them but have instead two distinct constructors/extension methods. (E.g., in the above, we would have two methods, one that took the advanced options.) To do otherwise is to invite confusion about which \"wins\" if we have the setting set in both.\r\n\r\n    * Note that phase setting \"set in both,\" which suggests that these settings object should retain the \"simpler\" settings in them. This reinforces feedback elsewhere as seen [here](https://github.com/dotnet/machinelearning/pull/1352#discussion_r228319239).\r\n\r\n5. If the simple arguments are totally sufficient, then there is no need to expose this `Arguments` class in hte public API. (For practical reasons relating to command line and entry-point usage, we still need to always have these `Arguments` objects, but if they serve no purpose for the API the class can simply be made internal.)\r\n\r\n/cc @KrzysztofCwalina, @terrajobst , on whose feedback this list is primarily based, and who can correct me and provide clarification in case I misspoke.","Url":"https://github.com/dotnet/machinelearning/issues/1798","RelatedDescription":"Open issue \"Creation of components through MLContext: advanced options and other feedback\" (#1798)"},{"Id":"386380493","IsPullRequest":false,"CreatedAt":"2018-11-30T22:55:06","Actor":"TomFinley","Number":"1797","RawContent":null,"Title":"Remove TextLoader.Read(string), promote IDataReader<MSS> extension","State":"open","Body":"Pursuant to #1090 and #1041 there was agreement that we should be able to just pass a *string* into a data reader that reads from streams, rather than have to muck about with the creation of this `IMultiStreamSource` object.\r\n\r\nAs it happens, this one request was done in two separate ways:\r\n\r\n1. #1252 where this instance method on `TextLoader` was created:\r\n  \r\n https://github.com/dotnet/machinelearning/blob/cb37c7e7f1e1b29b5608a2755db793c5435d10b1/src/Microsoft.ML.Data/DataLoadSave/Text/TextLoader.cs#L1340\r\n\r\n2. #1281 where an extension method on top of `IDataReader<IMultiStreamSource>` was introduced.\r\n\r\nClearly we don't need both, and the second being more flexible and more broadly applicable was the one that should be checked in, so let us remove the class specific method introduced in #1252. The extension method should however be moved to a namespace where it is more likely to be picked up (probably `Microsoft.ML`) since right now it's a bit buried and generally people would never see this extension method.","Url":"https://github.com/dotnet/machinelearning/issues/1797","RelatedDescription":"Open issue \"Remove TextLoader.Read(string), promote IDataReader<MSS> extension\" (#1797)"},{"Id":"386378043","IsPullRequest":false,"CreatedAt":"2018-11-30T22:43:44","Actor":"TomFinley","Number":"1796","RawContent":null,"Title":"Rename types inside MLContext as Catalogs","State":"open","Body":"We had an idea in #949 to have \"context\" objects that enabled the easy and convenient creation of training algorithms. We eventually came to like this idea so much that it expanded considerably, until we came to think it actually a good idea that *most* components (whether trainers or not) could work through this object, to the point where eventually in in #1098, there was a \"master\" context, of which the formerly independent contexts became properties of that master context.\r\n\r\nThe newer things that were added were then called \"catalogs,\" for example:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/cb37c7e7f1e1b29b5608a2755db793c5435d10b1/src/Microsoft.ML.Data/MLContext.cs#L47\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/cb37c7e7f1e1b29b5608a2755db793c5435d10b1/src/Microsoft.ML.Data/MLContext.cs#L52\r\n\r\nHowever the old objects retained the type names they had back when they were independent.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/cb37c7e7f1e1b29b5608a2755db793c5435d10b1/src/Microsoft.ML.Data/MLContext.cs#L25\r\n\r\nWe ought to probably standardize the name of these things as being \"catalogs.\" E.g., things in here with the type name suffix `Context` should change that to `Catalog`, things that are catalogs but aren't named that yet (`DataOperations`) should be standardized as well.","Url":"https://github.com/dotnet/machinelearning/issues/1796","RelatedDescription":"Open issue \"Rename types inside MLContext as Catalogs\" (#1796)"},{"Id":"386330600","IsPullRequest":true,"CreatedAt":"2018-11-30T21:51:37","Actor":"rogancarr","Number":"1792","RawContent":null,"Title":"Update the PFI Binary Classification XML Docs","State":"closed","Body":"This PR updates the Permutation Feature Importance (PFI) for Binary Classification XML docs with the latest version of the documentation. It also fixes one typo in the Regression XML Docs (the name of the class of objects returned).\r\n\r\nFixes #1764 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/1792","RelatedDescription":"Closed or merged PR \"Update the PFI Binary Classification XML Docs\" (#1792)"},{"Id":"386358567","IsPullRequest":false,"CreatedAt":"2018-11-30T21:34:28","Actor":"wschin","Number":"1795","RawContent":null,"Title":"Evaluator of one-class matrix factorizaition is missing","State":"open","Body":"One class matrix factorization is solved as a regression problem but common metrics in practices are top-k accuracy, nDCG, etc.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1795","RelatedDescription":"Open issue \"Evaluator of one-class matrix factorizaition is missing\" (#1795)"},{"Id":"386356570","IsPullRequest":false,"CreatedAt":"2018-11-30T21:28:09","Actor":"montebhoover","Number":"1794","RawContent":null,"Title":"Time series improvements","State":"open","Body":"Mainly for @codemzs, I wanted to ask what additional work is needed for time series.  Here are few things I noticed:\r\n\r\n1. Add support for doubles in SSA and IID estimators. Currently we check to verify floats, for all other types we throw an exception.\r\n2. Create class with named properties for output metrics of Martingale, P-Value, Alert, and Score.  Currently we output a column of vector type that contains these four values. Alternate approach would be to have four output columns.\r\n3. Move everything under namespace `Microsoft.ML.Runtime.TimeSeriesProcessing` into `Microsoft.ML.TimeSeries`.  Is there a reason why we need both namespaces?\r\n4. Add missing unit tests.  I believe we are missing tests for IID transformers, and we don't have code coverage over types such double, int, etc.\r\n5. Improve naming for estimator arguments.  Currently we have `Source` for our input column and `Name` for our output column.  It would make more sense to be `Source` and `Dest` or `InputColumn` and `OutputColumn`.\r\n6. Format the samples for the docs site.  For each transformer we have the option of using the transformer on a batch of data or creating a prediction engine - which should we be displaying as the sample on the docs site? Both on separate pages?","Url":"https://github.com/dotnet/machinelearning/issues/1794","RelatedDescription":"Open issue \"Time series improvements\" (#1794)"},{"Id":"386348176","IsPullRequest":true,"CreatedAt":"2018-11-30T20:59:33","Actor":"rogancarr","Number":"1793","RawContent":null,"Title":"Adding a binary classification PFI Example","State":"open","Body":"This PR adds a binary classification example. I added it to the same file as the regression example, and refactored out the file loading so that the examples focus more on the technique and less on file-loading. I also added a discussion on random fluctuations in PFI values.\r\n\r\nFixes #1766","Url":"https://github.com/dotnet/machinelearning/pull/1793","RelatedDescription":"Open PR \"Adding a binary classification PFI Example\" (#1793)"},{"Id":"386324624","IsPullRequest":false,"CreatedAt":"2018-11-30T19:44:28","Actor":"artidoro","Number":"1791","RawContent":null,"Title":"Feature Contribution Calculation should become Transformer","State":"open","Body":"We should make the `FeatureContributionCalculationTransform` a transfomrer, and add a related estimator that produces it so that it can become part of a pipeline. Below I show how it could look like with the new API:\r\n\r\n```csharp\r\n// Define a pipeline for feature extraction with a trainer at the end\r\nvar pipeline_1 = mlContext.BinaryClassification.Trainers.trainerEstimator(arguments);\r\n// Train model and cast it to IPredictor\r\nvar predictor = pipeline.Fit(data).Model;\r\n```\r\nTwo ways of applying FeatureContributionCalculation:\r\n```csharp\r\n// 1 First Way: Define another pipeline with FeatureContributionCalculation and possibly more \r\n// estimators appended to it\r\nvar pipeline_2 = mlContext.Model.Explainability.FeatureContributionCalculatingEstimator(arguments, predictor);\r\nvar outputData = pipeline_2.Fit(data).Transform(data);\r\n``` \r\n\r\n```csharp\r\n// 2 Second Way: Use the transformer directly, as it is not a trainable transformer\r\nvar transformer = new FeatureContributionCalculatingTransformer(mlContext, arguments, predictor);\r\nvar outputData = transformer.Transform(data);\r\n```\r\n\r\nIn either cases the output data will contain a `score` column along with a `FeatureContribution` column.\r\n\r\ncc: @rogancarr, @TomFinley, @Zruty0, @Ivanidzo4ka ","Url":"https://github.com/dotnet/machinelearning/issues/1791","RelatedDescription":"Open issue \"Feature Contribution Calculation should become Transformer\" (#1791)"},{"Id":"386318747","IsPullRequest":false,"CreatedAt":"2018-11-30T19:26:57","Actor":"shmoradims","Number":"1790","RawContent":null,"Title":"Support scoring on ARM","State":"open","Body":"This issue is a concrete work item from question #1662.\r\n\r\nMotivation:\r\nWe need ARM for scoring models on IoT devices and for mobile devices running Xamarin apps on iOS or Android. All those workloads are important for .NET.","Url":"https://github.com/dotnet/machinelearning/issues/1790","RelatedDescription":"Open issue \"Support scoring on ARM\" (#1790)"},{"Id":"386312702","IsPullRequest":false,"CreatedAt":"2018-11-30T19:08:06","Actor":"shmoradims","Number":"1789","RawContent":null,"Title":"Provide sample and documentation for PredictionFunction object-pooling for ASP.NET applications","State":"open","Body":"This is the concrete work item from discussions in #1718.\r\n\r\nMotivation:\r\nMajority of .NET Core apps use ASP.NET Core. In order to get the best developer experience we should provide a sample that implements object pooling approach for PredictionFucntion (which is not trivial) and also document it in docs.microsoft.com.\r\n\r\nBased on feedback from users, we might add this functionality to ML.NET. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/1789","RelatedDescription":"Open issue \"Provide sample and documentation for PredictionFunction object-pooling for ASP.NET applications\" (#1789)"},{"Id":"385979997","IsPullRequest":true,"CreatedAt":"2018-11-30T18:18:22","Actor":"eerhardt","Number":"1786","RawContent":null,"Title":"Remove IRandom and replace with System.Random.","State":"closed","Body":"Also make TauswortheHybrid internal/BestFriend.\r\n\r\nFix #1316\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1786","RelatedDescription":"Closed or merged PR \"Remove IRandom and replace with System.Random.\" (#1786)"},{"Id":"386284789","IsPullRequest":true,"CreatedAt":"2018-11-30T17:40:33","Actor":"montebhoover","Number":"1788","RawContent":null,"Title":"SSA time series samples","State":"open","Body":"Samples for SsaChangePointDetectorPrediction and SsaSpikeDetectorPrediction.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1788","RelatedDescription":"Open PR \"SSA time series samples\" (#1788)"},{"Id":"386276592","IsPullRequest":false,"CreatedAt":"2018-11-30T17:16:01","Actor":"eerhardt","Number":"1787","RawContent":null,"Title":"Delete the Legacy API","State":"open","Body":"Before shipping v1.0, we need to delete all the APIs that are marked \"legacy\" and \"obsolete\". Specifically, after this work is completed https://github.com/dotnet/machinelearning/tree/master/src/Microsoft.ML.Legacy should be completely removed, and any assets in it that need to remain should be migrated elsewhere. For example #1565 is for migrating the entry-points that we still need.","Url":"https://github.com/dotnet/machinelearning/issues/1787","RelatedDescription":"Open issue \"Delete the Legacy API\" (#1787)"},{"Id":"385926412","IsPullRequest":true,"CreatedAt":"2018-11-29T23:38:27","Actor":"abgoswam","Number":"1782","RawContent":null,"Title":"Add LDA example to Microsoft.ML.Samples","State":"closed","Body":"- Adding a LDA example to Microsoft.ML.Samples . This was a pending comment on #1410 ","Url":"https://github.com/dotnet/machinelearning/pull/1782","RelatedDescription":"Closed or merged PR \"Add LDA example to Microsoft.ML.Samples\" (#1782)"},{"Id":"385952794","IsPullRequest":true,"CreatedAt":"2018-11-29T22:23:12","Actor":"artidoro","Number":"1784","RawContent":null,"Title":"Clean up of TextLoader constructor","State":"open","Body":"Fixes #1611.\r\n\r\n1. Hid the constructor of `TextLoader` that takes Arguments, and exposed `HasHeader` and `SeparatorChars` as non-advanced parameters. \r\n2. Made Create methods internal and modified the code accordingly. \r\n3. Added comments for the public facing constructor that was retained.","Url":"https://github.com/dotnet/machinelearning/pull/1784","RelatedDescription":"Open PR \"Clean up of TextLoader constructor\" (#1784)"},{"Id":"385940933","IsPullRequest":false,"CreatedAt":"2018-11-29T21:49:02","Actor":"sfilipi","Number":"1783","RawContent":null,"Title":"Change the <a> tags to <image> tags","State":"open","Body":"In the RankerMetrics the `<a>`  tags for images will need to get converted to `<image>` tags, so the images display. \r\n\r\nhttps://github.com/dotnet/machinelearning/blob/master/src/Microsoft.ML.Data/Evaluators/Metrics/RankerMetrics.cs#L23","Url":"https://github.com/dotnet/machinelearning/issues/1783","RelatedDescription":"Open issue \"Change the <a> tags to <image> tags\" (#1783)"},{"Id":"385549124","IsPullRequest":true,"CreatedAt":"2018-11-29T20:16:54","Actor":"Anipik","Number":"1777","RawContent":null,"Title":"Correcting Documentation, adding asserts and disabling failing ci tests","State":"closed","Body":"- Adding Some More Asserts\r\n- Correcting netcoreapp 3.0 documentation\r\n- Disabling\\correcting netcoreapp 3.0 tests \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1777","RelatedDescription":"Closed or merged PR \"Correcting Documentation, adding asserts and disabling failing ci tests\" (#1777)"},{"Id":"385900239","IsPullRequest":false,"CreatedAt":"2018-11-29T19:53:45","Actor":"daholste","Number":"1781","RawContent":null,"Title":"FastTree uses lots of memory with dropout on","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10\r\n- **.NET Version (eg., dotnet --info)**: .NET Core 2.1\r\n\r\n### Issue\r\n\r\n- **What did you do?**\r\nRan FastTreeRegressor with DropoutRate > 0.\r\n\r\n- **What happened?**\r\nConsumed around 15 GB of memory. Memory usage increased linearly with # of trees\r\n\r\nRunning FastTreeRegressor with DropoutRate > 0 leads to much higher memory consumption than when DropoutRate = 0. It used approx 14 GB more for 200 trees, and ran into an out of memory exception for 500 trees. Perhaps there is a leak? (Turning on DropoutRate seemed to consistently cause memory footprint to rise significantly.)","Url":"https://github.com/dotnet/machinelearning/issues/1781","RelatedDescription":"Open issue \"FastTree uses lots of memory with dropout on\" (#1781)"},{"Id":"385859737","IsPullRequest":true,"CreatedAt":"2018-11-29T18:07:11","Actor":"wschin","Number":"1780","RawContent":null,"Title":"Remove auto-cache mechanism","State":"open","Body":"Fixes #1604.","Url":"https://github.com/dotnet/machinelearning/pull/1780","RelatedDescription":"Open PR \"Remove auto-cache mechanism\" (#1780)"},{"Id":"385749720","IsPullRequest":true,"CreatedAt":"2018-11-29T14:00:24","Actor":"Jungmaus","Number":"1779","RawContent":null,"Title":"Microsoft.ML.Api - Code cleaned and if else blocks improved","State":"open","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [ ] There's a descriptive title that will make sense to other developers some time from now. \r\n- [ ] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [x] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1779","RelatedDescription":"Open PR \"Microsoft.ML.Api - Code cleaned and if else blocks improved\" (#1779)"},{"Id":"385558004","IsPullRequest":false,"CreatedAt":"2018-11-29T04:06:37","Actor":"markusweimer","Number":"1778","RawContent":null,"Title":"Consider adding convenience functions to load / save models from / to files","State":"closed","Body":"In order to load a model from disk, one currently has to do something like this:\r\n\r\n```cs\r\nITransformer trainedModel;\r\nusing (var stream = new FileStream(ModelPath, FileMode.Open, FileAccess.Read, FileShare.Read))\r\n{\r\n  trainedModel = mlContext.Model.Load(stream);\r\n}\r\n```\r\n\r\n(Code taken from our sample [here](https://github.com/dotnet/machinelearning-samples/blob/ff0ae26e3bd2366c1fe55e8e8fbee17b4596cc61/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs#L101)\r\n\r\nWe should consider adding convenience methods for this common case to allow for code like this:\r\n\r\n```cs\r\nITransformer trainedModel = mlContext.Model.LoadFromFile(ModelPath);\r\n```\r\n\r\nSimilarly, we could consider adding a convenience method to save to a file to allow for code like this:\r\n\r\n```cs\r\nmlContext.Model.SaveToFile(trainedModel, ModelPath);\r\n```\r\n\r\nOf course, we might also want the `*Async` variants thereof.","Url":"https://github.com/dotnet/machinelearning/issues/1778","RelatedDescription":"Closed issue \"Consider adding convenience functions to load / save models from / to files\" (#1778)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-12-03T05:31:15.4265632Z","RunDurationInMilliseconds":1120}