{"Data":{"Blog":{"FeedItems":[{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":69,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803)","PublishedOn":"2018-05-24T01:49:57+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/23/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-april-2018-update-version-1803/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update)","PublishedOn":"2018-05-21T22:44:05+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/21/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-1709-fall-creators-update/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10","PublishedOn":"2018-05-17T17:20:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1703 (Creators Update) and Windows 10 1607 (Anniversary Update). Quality and Reliability This release contains the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/17/net-framework-may-2018-preview-of-quality-rollup-for-windows-10/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup","PublishedOn":"2018-05-15T18:10:24+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup. Quality and Reliability This release contains the following quality and reliability improvements. CLR Resolves an issue in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/15/net-framework-may-2018-preview-of-quality-rollup/","RawContent":null},{"Title":".NET Core May 2018 Update","PublishedOn":"2018-05-08T22:31:30+00:00","CommentsCount":15,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core May 2018 Update. This update includes .NET Core 2.1.200 SDK and ASP.NET Core 2.0.8. Security Microsoft is releasing this security advisory to provide information...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-core-may-2018-update/","RawContent":null},{"Title":".NET Framework May 2018 Security and Quality Rollup","PublishedOn":"2018-05-08T21:18:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Security and Quality Rollup. Security CVE-2018-1039 – Windows Security Feature Bypass Vulnerability A security feature bypass vulnerability exists in Windows which...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-framework-may-2018-security-and-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""},{"Id":"7697516495","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:04:23","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/101","RelatedDescription":"Merged pull request \"Create mlnet.md\" (#101) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7816355022","Type":"IssuesEvent","CreatedAt":"2018-06-13T04:06:53","Actor":"poizan42","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18450","RelatedDescription":"Opened issue \"Binding duplicated handle to ThreadPool fails?\" (#18450) at dotnet/coreclr","RelatedBody":"When I run the following code I get a System.ArgumentException: ''handle' has already been bound to the thread pool, or was not opened for asynchronous I/O.'\r\n\r\nThis seems weird since it is a copy of the handle bound and it is definitely opened for async I/O. From a glance it looks like the error ultimately comes from CreateIoCompletionPort, but that is weird because the documentation is actually recommending that you use DuplicateHandle to share a handle registered to an IO completion port to avoid this problem:\r\n\r\n> It is best not to share a file handle associated with an I/O completion port by using either handle inheritance or a call to the DuplicateHandle function. Operations performed with such duplicate handles generate completion notifications. Careful consideration is advised.\r\n\r\nIs the framework doing something funky here, or is the reality more complicated than the documentation for CreateIoCompletionPort would lead you to think?\r\n\r\n```CSharp\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.ComponentModel;\r\nusing System.Diagnostics;\r\nusing System.IO.Pipes;\r\nusing System.Runtime.InteropServices;\r\nusing System.Security.Principal;\r\n\r\nnamespace NamedPipeDuplicateHandleTestCore\r\n{\r\n  class Program\r\n  {\r\n    /* Easiest way to get secure IPC is by making the channels anonymous and marking the handles non-inheritable\r\n     * in the master process and explicitly copying them into the slave. */\r\n    [DllImport(\"kernel32.dll\", EntryPoint = \"DuplicateHandle\", SetLastError = true)]\r\n    [return: MarshalAs(UnmanagedType.Bool)]\r\n    private static extern bool _DuplicateHandleSU(IntPtr hSourceProcessHandle,\r\n       SafeHandle hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle,\r\n       uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwOptions);\r\n\r\n    /// <summary>\r\n    /// Copies the handle specified by hSourceHandle into the process opened with the handle hTargetProcessHandle.\r\n    /// The handle is copied with the same access as the original handle.\r\n    /// </summary>\r\n    /// <param name=\"hSourceHandle\"></param>\r\n    /// <param name=\"hTargetProcessHandle\"></param>\r\n    /// <returns></returns>\r\n    public static IntPtr DuplicateHandle(SafeHandle hSourceHandle, IntPtr hTargetProcessHandle)\r\n    {\r\n      const int DUPLICATE_SAME_ACCESS = 0x00000002;\r\n      IntPtr targetHandle;\r\n      if (!_DuplicateHandleSU(Process.GetCurrentProcess().Handle, hSourceHandle, hTargetProcessHandle, out targetHandle,\r\n        0, false, DUPLICATE_SAME_ACCESS))\r\n      {\r\n        throw new Win32Exception(Marshal.GetLastWin32Error());\r\n      }\r\n      return targetHandle;\r\n    }\r\n\r\n    static void Main(string[] args)\r\n    {\r\n      string pipename = \"foopipe\" + Guid.NewGuid().ToString(\"N\");\r\n      var pipeServer = new NamedPipeServerStream(pipename, PipeDirection.InOut, 1, PipeTransmissionMode.Byte, PipeOptions.Asynchronous,\r\n        4096, 4096);\r\n      pipeServer.BeginWaitForConnection(ar => { pipeServer.EndWaitForConnection(ar); }, null);\r\n\r\n      IntPtr handle2;\r\n      using (var clientStream1 = new NamedPipeClientStream(\".\", pipename, PipeDirection.InOut, PipeOptions.Asynchronous, TokenImpersonationLevel.None,\r\n        System.IO.HandleInheritability.None))\r\n      {\r\n        clientStream1.Connect();\r\n        handle2 = DuplicateHandle(clientStream1.SafePipeHandle, Process.GetCurrentProcess().Handle);\r\n      }\r\n      var clientStream2 = new NamedPipeClientStream(PipeDirection.InOut, true, true, new SafePipeHandle(handle2, true));\r\n      pipeServer.WriteAsync(new byte[] { 42 }, 0, 1);\r\n      Console.WriteLine(clientStream2.ReadByte());\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis is tested on dotnet core 2.1.30 and Windows 10.0.17686.1003."},{"Id":"7816303536","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:45:24","Actor":"Petermarcu","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18449","RelatedDescription":"Opened issue \"IL Linker does not remove unused classes / methods\" (#18449) at dotnet/coreclr","RelatedBody":"@a-student commented on [Sun May 20 2018](https://github.com/dotnet/core/issues/1572)\n\nIt is stated [here](https://github.com/dotnet/core/blob/master/samples/linker-instructions.md) that\r\n> The linker removes code in your application and dependent libraries that are not reached by any code paths\r\n\r\nI am following [these instructions](https://github.com/dotnet/core/blob/master/samples/linker-instructions.md#instructions). Before publishing the app I add unused class to the project:\r\n```\r\necho internal class UnusedClass { private class UnusedNestedClass { private void UnusedMethod() { System.Console.WriteLine(\"This method is never called.\");}}}> UnusedClass.cs\r\n```\r\nTo make sure the linker processes the main assembly add these lines to the `testapp.csproj` file:\r\n```xml\r\n<PropertyGroup>\r\n    <ExtraLinkerArgs>-c link -u link -t -l none -b true --skip-unresolved true --verbose</ExtraLinkerArgs>\r\n</PropertyGroup>\r\n```\r\nMy publish command:\r\n```\r\ndotnet publish -c release -r win-x64 -o out /p:ShowLinkerSizeComparison=true\r\n```\r\nAfter publishing decompile `out/testapp.dll` (I use ILSpy).\r\n\r\n_Expected_: UnusedClass is removed.\r\n_Actual_: UnusedClass is still there.\r\n\r\n**dotnet --version**: 2.1.300-preview2-008533\r\n**IL Linker** from [this package](https://dotnet.myget.org/feed/dotnet-core/package/nuget/ILLink.Tasks/0.1.5-preview-1461378)\r\n\n\n"},{"Id":"7816238991","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:19:48","Actor":"Petermarcu","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18448","RelatedDescription":"Opened issue \"System.BadImageFormatException: 'Bad IL format.'\" (#18448) at dotnet/coreclr","RelatedBody":"@atpyk commented on [Wed May 30 2018](https://github.com/dotnet/core/issues/1622)\n\n\r\nI've upgraded dotnetcore2.0 to 2.1, and upgraded all packages too.\r\nWhen I startup my web application, the exception prompts.\r\n\r\nStackTrace:\r\n   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException& hostingStartupErrors)\r\n   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()\r\n   at GrapeLEAF.AdminService.Program.BuildWebHost(String[] args) in E:\\workspace\\dotnet\\XXX\\XXX.AdminService\\XXX.AdminService\\Program.cs:line 16\r\n   at GrapeLEAF.AdminService.Program.Main(String[] args) in E:\\workspace\\dotnet\\XXX\\XXX.AdminService\\XXX.AdminService\\Program.cs:line 12\r\n\n\n---\n\n@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393436939)\n\nI uninstall original .net core sdk and runtime; and reinstall VS2017 and 2.1 sdk. \r\nI create a new webapi application by scaffold, it doesn't work.\r\n\n\n---\n\n@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393459163)\n\nhttps://blogs.msdn.microsoft.com/webdev/2018/05/07/asp-net-core-2-1-0-rc1-now-available/\n\n---\n\n@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393465743)\n\nSo sad, it doesn't work too.\n\n---\n\n@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393482909)\n\nMake sure you have installed the latest VS and try to reinstall .net core.\r\nRoolback your changes to .net core 2.0 and follow the instruction I have sent you\n\n---\n\n@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393746933)\n\nI debug into Microsoft.AspNetCore.Hosting and find out the error line:\r\n var hostingServices = BuildCommonServices(out var hostingStartupErrors);\r\n\r\nIt will throw the exception: 'Bad IL format.'\r\n\r\nBut if I rename this method to BuildCommonServices111 or other, It works.\r\nSo weird~\r\nIt seems like the namespace \"Microsoft.AspNetCore.Hosting\"  conflicts with others, the .net runtime involves dlls of different version at same time.\n\n---\n\n@VladislavAntonyuk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393803561)\n\nmake sure you have installed version 2.1.300 and try to uninstall all previous versions. Also doublecheck you have finished all steps in the instruction I've sent you \n\n---\n\n@atpyk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393810220)\n\nI have reinstall my OS, it works.\r\nThanks.\n\n---\n\n@mangod3 commented on [Sat Jun 02 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394127431)\n\nDid you have NewRelic monitoring your .net app by any chance when you ran into the issue?\n\n---\n\n@Merurino commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394201129)\n\n@mangod3 I was about to comment here. My issue seemed to be Newrelic. Was returning the IL issue. I was building it and running it on docker.\r\n\r\n\n\n---\n\n@mangod3 commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394224256)\n\n@Merurino Thanks for responding. After debugging the issue it looks like the 2.1 changes related to code versioning (https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/code-versioning-profiler-breaking-changes.md) are causing issues with profiling APIs. @noahfalk who should we follow up with to get this investigated, looks like the ILHeader is not getting initialized correctly after updating a method IL using SetILFunctionBody\n\n---\n\n@noahfalk commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394493650)\n\n Sorry you are running into trouble! Feel free to start with me as the investigator and I can pull in others as needed. To help get us started:\r\n1) Could you post steps I can follow to try reproducing the problem?\r\n2) Can you let me know what you observed while debugging that lead you to your conclusions?\n\n---\n\n@mangod3 commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394511301)\n\nThanks for your response @noahfalk. Will package up a repro and send over email. \n\n---\n\n@joseclament commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395119603)\n\nI have a web job built on netcoreapp2.1 console application, targeting the win10-x64 and getting the  \"Unhandled Exception: System.BadImageFormatException: Could not load file or assembly exception\". \r\nI haven't had any issue with locally. Deployed using the visual studio directly to the app service. Any thoughts?\n\n---\n\n@noahfalk commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395221204)\n\n@joseclament - Are you aware of any .NET profiler or monitoring agent being used in your deployment environment? If not we should probably a open a new issue because there would be a decent chance that the root cause for you will be unrelated to the root cause here.\n\n---\n\n@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395337310)\n\n@noahfalk , I am using AppInsight to push the logs, other than no profiling or tooling.\r\nLet me know if I need to open a new issue.\r\n\n\n---\n\n@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395442460)\n\n@noahfalk I am seeing a similar issue using the [AppDynamics .NET Core profiler agent](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) on a netcoreapp2.1 application and .NET Core SDK 2.1.300. \r\n\r\nWhen the application starts, the following exception is thrown:\r\n\r\n```\r\nSystem.BadImageFormatException\r\n  HResult=0x8007000B\r\n  Message=Bad IL format.\r\n  Source=System.Private.CoreLib\r\n  StackTrace:\r\n   at System.AppDomainManager..ctor()\r\n   at System.Reflection.Assembly.GetEntryAssembly()\r\n   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException& hostingStartupErrors)\r\n   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()\r\n   at MyApp.Web.Startup.Main(String[] args) \r\n```\r\n\n\n---\n\n@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395448692)\n\n@noahfalk  and @nil4 , I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit\r\n\r\nYour core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:\r\n\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300\r\n Commit:    32f29b6eb9\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.14393\r\n OS Platform: Windows\r\n RID:         win10-x86\r\n _Base Path:   D:\\Program Files (x86)\\dotnet\\sdk\\2.1.300\\_ [**You  can see only the x86 version here**]\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0\r\n  Commit:  caa7b7e2ba\r\n\r\n.NET Core SDKs installed:\r\n  1.1.8 [D:\\Program Files (x86)\\dotnet\\sdk]\r\n  2.1.101 [D:\\Program Files (x86)\\dotnet\\sdk]\r\n  2.1.300 [D:\\Program Files (x86)\\dotnet\\sdk]\r\n\r\nYou may be able to debug this locally \"Any CPU\" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the \"32\" bit.\r\n\r\n\n\n---\n\n@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395465136)\n\nI am not using Azure. The error occurs on my local PC when launching the application, with IIS Express, under the VS debugger, regardless of whether IIS Express 64-bit or 32-bit is selected.\r\n\r\nThe application starts up correctly if I remove the AppDynamics.Agent.Windows NuGet package, or set `CORECLR_ENABLE_PROFILING` environment variable to `0` in my Web.config (disabling the profiler).\n\n---\n\n@mangod3 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395478892)\n\nis it possible for you to capture a full native stack of the exception? That might help with identifying if you are hitting the same issue or something different. \n\n---\n\n@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395487431)\n\n@noahfalk  Here are the steps to reproduce the issue I see. In a command prompt, run:\r\n\r\n```cmd\r\nmkdir Repro1622 && pushd Repro1622\r\ndotnet new web\r\ndotnet add package AppDynamics.Agent.Windows --version 4.4.3\r\n```\r\nOpen the project in Visual Studio, and build it once. \r\n\r\nA number of files brought by the AppDynamics package show up under the project, including `Repro1622.AppDynamicsConfig.json`. Edit this file and replace its content with:\r\n\r\n```json\r\n{\r\n  \"controller\": {\r\n    \"host\": \"localhost\",\r\n    \"port\": 443,\r\n    \"account\": \"customer1\",\r\n    \"password\": \"c025be84-d72d-4f6e-b5b4-b33ce264992b\",\r\n    \"ssl\": true,\r\n    \"enable_tls12\": true\r\n  },\r\n  \"application\": {\r\n    \"name\": \"irrelevant\",\r\n    \"tier\": \"irrelevant\",\r\n    \"node\": \"irrelevant\"\r\n  }\r\n}\r\n```\r\n\r\nThese values are not important, they just need to be different than the default placeholders for the profiler to activate.\r\n\r\nAdd a `Web.config` file to the project, with the following content:\r\n\r\n```xml\r\n<configuration>\r\n  <system.webServer>\r\n    <handlers>\r\n      <add name=\"aspNetCore\" path=\"*\" verb=\"*\" modules=\"AspNetCoreModule\" resourceType=\"Unspecified\" />\r\n    </handlers>\r\n    <aspNetCore processPath=\"%LAUNCHER_PATH%\" arguments=\"%LAUNCHER_ARGS%\">\r\n      <environmentVariables>\r\n        <environmentVariable name=\"CORECLR_ENABLE_PROFILING\" value=\"1\" />\r\n        <environmentVariable name=\"CORECLR_PROFILER\" value=\"{39AEABC1-56A5-405F-B8E7-C3668490DB4A}\" />\r\n\r\n        <environmentVariable name=\"CORECLR_PROFILER_PATH_32\" value=\"D:\\Repro1622\\bin\\Debug\\netcoreapp2.1\\AppDynamics.Profiler_x86.dll\"/>\r\n        <environmentVariable name=\"CORECLR_PROFILER_PATH_64\" value=\"D:\\Repro1622\\bin\\Debug\\netcoreapp2.1\\AppDynamics.Profiler_x64.dll\"/>\r\n      </environmentVariables>\r\n    </aspNetCore>\r\n  </system.webServer>\r\n</configuration>\r\n```\r\n\r\n⚠️ Per the [AppDynamics docs](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows), the two `CORECLR_PROFILER_PATH_*` variables must be full paths; **adjust as required**.\r\n\r\nStart debugging (F5) with IIS Express and note `BadImageFormatException` is thrown at `System.AppDomainManager..ctor()` when the application starts.\r\n\r\nFind the newest `.log` file under *%ProgramData%\\AppDynamics\\DotNetAgent\\Logs\\Profiler*, which should be similar to:\r\n```\r\n2018-06-07 18:22:31.086553<info>:Use CoreCLR profiler\r\n2018-06-07 18:22:31.089553<info>:Should instrument standalone profiler process (config found at D:\\Repro1622\\bin\\Debug\\netcoreapp2.1\\Repro1622.AppDynamicsConfig.json): dotnet as app Repro1622.dll\r\n2018-06-07 18:22:31.092555<info>:Agent Configuration: {\"controller\":{\"account\":\"customer1\",\"enableTls12\":true,\"ssl\":true,\"host\":\"localhost\",\"password\":\"***\",\"port\":443},\"application\":{\"tier\":\"irrelevant\",\"node\":\"irrelevant\",\"name\":\"irrelevant\"}}\r\n2018-06-07 18:22:31.092555<info>:Enabled rejit normally, disabled all NGEN images.\r\n2018-06-07 18:22:31.163553<error>:InjectMEE failed.\r\n2018-06-07 18:22:31.935346<info>:Transforming 57540:clrhost:System.Void System.AppDomainManager..ctor() with [[],[]]\r\n```\n\n---\n\n@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395550918)\n\n@joseclament - Glad you were able to get the bottom of it and very appreciated that you came back to post your findings in case others hit the same issue in the future! Indeed it looks like your issue had a similar symptom but different root cause than the other ones here. I created #1670 to track any further work there.\r\n\r\n@nil4 - Thanks for the repro! Let me try repro your issue so we can figure out if this is the same root cause or something else. \n\n---\n\n@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395614005)\n\n@nil4 - Thanks, I was able to reproduce the problem easily using your excellent instructions! Although the AppDynamics issue is slighly different than the NewRelic one (AppDynamics does not call ICorProfilerInfo::SetILFunctionBody or ICorProfilerFunctionControl::SetILFunctionBody) , the fix I submitted earlier today (#18322) does solve both issues at the same time.\r\n\r\nI wasn't sure if you were an employee with AppDynamics or a customer of AppDynamics? For potential short term resolutions to the issue you could either continue to use .Net Core 2.0 or use a daily build of .Net Core that has this fix as soon as the installers are ready for download (I'll write back again when they are). A little further in the future I'm attempting to get this fix into the official servicing releases for 2.1. I can also try to reach out to AppDynamics to see if there are any additional solutions available for the issue.\r\n\r\nLet me know if you've got any other questions or concerns?\n\n---\n\n@nil4 commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395689332)\n\n@noahfalk glad I could help, and thank you for the update, much appreciated! I am a customer, and have opened an AppDynamics support ticket about this; will update it shortly with a link to this issue.\n\n"},{"Id":"7816230089","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:16:07","Actor":"Petermarcu","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18447","RelatedDescription":"Opened issue \".Net Core and Native dll's always throw BadImageFormat\" (#18447) at dotnet/coreclr","RelatedBody":"@SharperC commented on [Sun Jun 10 2018](https://github.com/dotnet/core/issues/1678)\n\n# BadImageFormatException, everytime...\r\n\r\nAfter a LOT of times trying to load native code or rather call a native method using `DllImport`, I'm reporting this as a issue, because it seems like there is no solution.\r\n\r\n## So what did I try?\r\n\r\nFirst of all, I tried the way it works with .Net Framework, what of course didn't work.\r\nI searched in the Internet for solutions but i only found the same problems with \"could work\" solutions. For example compiling the .Net Core application and the native libary in 64 bit (what i did).\r\nI also tried a non .Net c++ compiler (MinGW) and the default Visual Studio c++ compiler.\r\nBoth give the same `BadImageFormat` Exception.\r\n\r\n## The code i used\r\n\r\n### The c# part\r\n```cs\r\n[DllImport(@\"testlib.dll\", EntryPoint = \"test\")]\r\nstatic extern int Test();\r\n\r\nstatic void Main(string[] args)\r\n{\r\n    Console.WriteLine(Test());\r\n    Console.ReadLine();\r\n}\r\n```\r\n\r\n### The c++ part\r\n```cpp\r\n#define EXTERN extern \"C\" __declspec(dllexport)\r\n\r\nEXTERN int test()\r\n{\r\n    return 1234;\r\n}\r\n```\r\n\r\nI also tried it on Linux using the g++ compiler, for some reason it worked on Linux.\r\n\r\nThanks for taking the time to read.\n\n---\n\n@markusschaber commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396199666)\n\nIn my experience, the main reason for this exception is when you try to load a 32-bit DLL into a 64 Bit process, or the other way round.\r\n\r\nMismatch between x86/ARM is also possible, in theory. :-)\r\n\r\nNote that sometimes, .NET core on Windows runs in an unexpected CPU architecture, as some tools (e. G. Visual Studio, xUnit etc.) tend to ignore the target CPU architecture defined in the project, and just run the code in the first installation they find in PATH, so if both 32 and 64 bit runtimes or SDKs are installed, it's random which one you get.\r\n\r\nWe had to change the order of entries in PATH environment variable to run our code with x86, as the native DLL we depend on is not (yet) 64 bit.\n\n---\n\n@dasMulli commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396203170)\n\nfor `dotnet` it will use the version of `dotnet.exe` that's in the path - either the 32bit or 64bit `dotnet.exe` host.\r\nThere will be some changes that will allow patching the csproj to allow `dotnet run` to switch architectures (when launching a sub-process) but until then, it's a bit of a pain - https://github.com/dotnet/sdk/issues/1905\n\n---\n\n@SharperC commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396254074)\n\n@markusschaber I know that you mean, but i tried both using a 32bit and a 64bit for c++ and dotnet, and yes a already noticed that dotnet tends to totaly ignore if you set the assembly in vs to 32 bit\n\n"},{"Id":"7816221409","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:12:40","Actor":"Petermarcu","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18446","RelatedDescription":"Opened issue \"SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib.\" (#18446) at dotnet/coreclr","RelatedBody":"@iga1976 commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1687)\n\nSUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. This may be a bug in System.Private.CoreLib, or potentially in certain extensibility points such as assembly resolve events or CultureInfo names. Resource name: ArgumentNull_Generic \r\nhttps://github.com/dotnet/corefx/issues/30208\r\n\r\n\n\n"},{"Id":"7816217562","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:11:00","Actor":"tannergooding","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18445","RelatedDescription":"Opened issue \"EEJitManager::SetCpuInfo is not exactly matching the ISA hierarchy described by the architecture manuals\" (#18445) at dotnet/coreclr","RelatedBody":"SSE/SSE2 support requires:\r\n* Check for CPUID support\r\n* Check the SSE and/or SSE2 flag\r\n\r\nSSE3 support requires:\r\n* Check for SSE/SSE2 support\r\n* Check the SSE3 flag\r\n\r\nSSSE3 support requires:\r\n* Check for SSE/SSE2 support\r\n* Check the SSSE3 flag\r\n\r\nSSE4.1 support requires:\r\n* Check for SSE/SSE2 Support\r\n* Check for SSE3 Support\r\n* Check for SSSE3 Support\r\n* Check the SSE4.1 flag\r\n\r\nSSE4.2 support requires:\r\n* Check for SSE/SSE2 Support\r\n* Check for SSSE3 Support\r\n* Check for SSE4.1 Support\r\n* Check the SSE4.1 flag\r\n\r\netc..."},{"Id":"7815876822","Type":"IssuesEvent","CreatedAt":"2018-06-13T01:01:11","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17600","RelatedDescription":"Closed issue \"Bug in CodeGen::getFirstArgWithStackSlot()\" (#17600) at dotnet/coreclr","RelatedBody":"There is a typo in `CodeGen::getFirstArgWithStackSlot()` where it uses\r\n\r\n```\r\n#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)\r\n```\r\n\r\ninstead of, apparently, `FEATURE_UNIX_AMD64_STRUCT_PASSING` (presumably it is a `D=>R` typo, not a `ARM64=>AMR64` typo, since nobody sets or uses the version with `ARM64`).\r\n\r\nThus, the Unix amd64 code is not doing what it was written to do since the mistyped `#ifdef` is never defined:\r\n```\r\n#if defined(FEATURE_UNIX_AMD64_STRUCT_PASSING) || defined(_TARGET_ARMARCH_)\r\n    unsigned baseVarNum = 0;\r\n#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)\r\n    baseVarNum = compiler->lvaFirstStackIncomingArgNum;\r\n\r\n    if (compiler->lvaFirstStackIncomingArgNum != BAD_VAR_NUM)\r\n    {\r\n        baseVarNum = compiler->lvaFirstStackIncomingArgNum;\r\n    }\r\n    else\r\n#endif // FEATURE_UNIX_ARM64_STRUCT_PASSING\r\n    {\r\n        // Iterate over all the local variables in the Lcl var table.\r\n        // They contain all the implicit arguments - thisPtr, retBuf,\r\n        // generic context, PInvoke cookie, var arg cookie,no-standard args, etc.\r\n        LclVarDsc* varDsc = nullptr;\r\n        for (unsigned i = 0; i < compiler->info.compArgsCount; i++)\r\n        {\r\n            varDsc = &(compiler->lvaTable[i]);\r\n\r\n            // We are iterating over the arguments only.\r\n            assert(varDsc->lvIsParam);\r\n\r\n            if (varDsc->lvArgReg == REG_STK)\r\n            {\r\n                baseVarNum = i;\r\n#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)\r\n                compiler->lvaFirstStackIncomingArgNum = baseVarNum;\r\n#endif // FEATURE_UNIX_ARM64_STRUCT_PASSING\r\n                break;\r\n            }\r\n        }\r\n        assert(varDsc != nullptr);\r\n    }\r\n\r\n    return baseVarNum;\r\n```\r\n"},{"Id":"7815777198","Type":"PullRequestEvent","CreatedAt":"2018-06-13T00:21:40","Actor":"dotnet-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18444","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/corefx\" (#18444) at dotnet/coreclr","RelatedBody":"This PR contains mirrored changes from dotnet/corefx\n\n\n**Please REBASE this PR when merging**"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7816396633","Type":"PullRequestEvent","CreatedAt":"2018-06-13T04:24:37","Actor":"mmitche","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/cli/pull/9474","RelatedDescription":null,"RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7816396581","Type":"PullRequestEvent","CreatedAt":"2018-06-13T04:24:35","Actor":"mmitche","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/9474","RelatedDescription":"Closed pull request \"Update coresetup, msbuild, nugetclient, roslyn to preview1-26216-03, 15.7.177, preview1.5116, beta6-62923-07, respectively (release/2.1.3xx)\" (#9474) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7816231656","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:16:45","Actor":"Petermarcu","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9476","RelatedDescription":"Opened issue \"Nuget packages restore failed (Yellow triangle)\" (#9476) at dotnet/cli","RelatedBody":"@fatih905 commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1674)\n\nThis my error message,  help me pls.\r\n\r\n'C:\\Users\\erol_\\source\\repos\\WebApplication38\\WebApplication38\\obj\\project.assets.json' not found. Run a NuGet package restore to generate this file.\tWebApplication38\tC:\\Program Files\\dotnet\\sdk\\2.1.300\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.PackageDependencyResolution.targets\t198\t\r\n\n\n---\n\n@Petermarcu commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1674#issuecomment-396792771)\n\nCan you try running 'dotnet restore' on your project from the command line? \n\n"},{"Id":"7816179709","Type":"PullRequestEvent","CreatedAt":"2018-06-13T02:56:31","Actor":"AndyGerlicher","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9475","RelatedDescription":"Opened pull request \"MSBuild 15.8.101\" (#9475) at dotnet/cli","RelatedBody":"This would be in favor of #9468, but I left the old one open since it seemed to have issues that I'm not clear of the cause yet.\r\n\r\nThis insertion contains https://github.com/Microsoft/msbuild/pull/3376 which revs the version of `System.Collections.Immutable` and `System.Reflection.Metadata` to `1.5.0` and `1.6.0`. This is part of a large coordinated change for all of VS."},{"Id":"7816156258","Type":"PullRequestEvent","CreatedAt":"2018-06-13T02:47:36","Actor":"dotnet-maestro-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9474","RelatedDescription":"Opened pull request \"Update coresetup, msbuild, nugetclient, roslyn to preview1-26216-03, 15.7.177, preview1.5116, beta6-62923-07, respectively (release/2.1.3xx)\" (#9474) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7815209945","Type":"IssuesEvent","CreatedAt":"2018-06-12T21:33:08","Actor":"GoldenCrystal","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/774","RelatedDescription":"Opened issue \"Idea/Proposal: Split .NET Standard into multiple smaller standards by relying on tooling\" (#774) at dotnet/standard","RelatedBody":"First, let me start by saying that this is not supposed to be a final proposal, but more like a rough draft / general idea, that I hope to tranform into a valid proposal with the help of everyone here.\r\nI fear this is going to be a controversial topic, but I've had this idea in the back of my head for a few days now, and I'd like to at least try explaining it there, so as to have your feedback.\r\nSo, please bear with me until the end of this topic. 😅\r\n\r\n# Abstract\r\n\r\n[Like many others](https://github.com/dotnet/standard/issues/682), I do wish .NET Standard 2.1 was already a thing.\r\nBut I do also perfectly understand the concerns about .NET Core 2.1 being the only implementation already ahead in the standard. And because of that I do fear that .NET Standard 2.0 will be the last .NET Standard version ever. (But at the same time, I'm kinda going to propose replacing it by something else here… 😒)\r\n\r\nAside of that, the fact that .NET Standard 2.0 is not compatible with .NET 4.5 can sometimes be an obstacle in the migration process to .NET Core. (That's something we are faced with everyday in my current job)\r\n\r\nSo I wondered, what if, instead of having *one unique standard*, there were *many smaller standards* that could be implemented à-la-carte by runtimes/frameworks/NuGet ?\r\nWhat if we could already define something such as a \"Span Standard 1.0\" ?\r\n\r\nAnd yes, I know that the original design of DNX / .NET Standard 1.0 was more modular, I know that there were once such a thing as Assembly Neutral Interfaces, and I know all of this did not work out that well. This did obviously lead to the acceptable compromise that is .NET Standard 2.0.\r\n\r\nBut, I assure you, I am *not* proposing to reiterate the exact same mistakes as in .NET Standard 1 era. (Which is not to say that I'm not taking strong inspiration on what has/had already been done. 😉)\r\n\r\nWhat I'm thinking of is a mechanism that should help reduce coupling **without** requiring changes in the existing runtimes, and could work reasonably well with support in the tooling.\r\n\r\n# The general idea\r\n\r\nWe would define many ````feature```` sets that can overlap eachother. At the begining, features would likely be defined based on current .NET Standard 1.0~2.0 APIs, by splitting unrelated features away from eachother. (Basically what I call a ````feature```` here is like a much smaller .NET Standard) \r\n\r\nA ````feature```` would be defined very *similarly* to a reference assembly (i.e. no implementation), and define what API a consumer should expect when **depending** on the ````feature````.\r\n\r\nI'll take as an example the current hot topic of ````Span<T>```` and .NET Standard 2.0/2.1 to illustrate how ````features```` could help:\r\n````Span<T>```` is available to altmost anyone, but only .NET Core 2.1 supports the fast ````Span<T>```` and the new Span-based APIs:\r\n\r\n - Assume that there is no such thing as ````.NET Standard````\r\n - We could define ````Feature.Span, Version=1.0```` for the portable span, as implemented in ````System.Memory````\r\n - We could define ````Feature.Span, Version=1.1```` for the fast span, as implemented in .NET Core 2.1\r\n - Let's assume that we already have ````Feature.Sockets, Version=2.0```` representing the ````System.Net.Sockets```` feature from .NET Framework 2.0.\r\n - We could define ````Feature.Span.Sockets, Version=1.0````:\r\n   - This feature would have a feature dependecy on both ````Feature.Span, Version=1.0```` and ````Feature.Net.Sockets, Version=2.0````\r\n   - This feature would define all the new Span-related members introduced on Sockets\r\n - Let's assume that we have ````Feature.IO, Version=4.5```` representing the ````System.IO```` subset from the NuGet package with the same name.\r\n - We could define ````Feature.Span.Streams, Version=1.0````:\r\n   - This feature would have a feature dependecy on both ````Feature.Span, Version=1.0```` and ````Feature.IO, Version=4.5````\r\n   - This feature would define all the new Span-related members introduced on System.IO.Stream\r\n - We could go on with all the other places where Span-related API were introduced, but I'm sure you get the idea…\r\n\r\nℹ️ Note: Don't pay too much attention about the fictional boundaries of the features yet, I'm pretty sure I wouldn't want the feature to be shaped _exactly_ like described above. 😉\r\n\r\nWith such ````features```` defined, I could write a database client library, and declare that it depends on ````Feature.Runtime````, ````Feature.CSharp, Version=7.3````, ````Feature.Net.Sockets````, ````Feature.Span.Sockets````, ````Feature.Collections````, and ````Feature.Data.Common````.\r\nThis would allow my library to run on any runtime, provided that it at least supports all the ````features```` I used.\r\n\r\n# The (Draft) Proposal\r\n\r\n## Defining features\r\n\r\nA ````feature```` is an API shape, or contract (similar to .NET Standard), whose concrete implementation is provided by either a runtime (e.g. .NET Core) **or** by NuGet packages.\r\n\r\nWe would ideally reserve a prefix on NuGet for official .NET features. (e.g. ````Feature.````)\r\n\r\n - In the initial version, features would only ever be created by Microsoft / .NET Foundation\r\n - A ````feature```` is represented as a **single** assembly, typically exposed as a NuGet package.\r\n - A ````feature```` assembly contains only metadata (no implementation), like would any reference assembly.\r\n - A ````feature```` assembly contains only public types and members. (public types, public members and protected members)\r\n - A ````feature```` assembly can (will) have dependencies on other ````feature```` assemblies. (Dependencies would be supported via NuGet packages)\r\n - A ````feature```` assembly defines only the exact API surface that it supports\r\n   - A ````feature```` can only provide complete interface definitions. (Interface versioning problem: it is not possible to add or remove interface members)\r\n   - A ````feature```` can provide delegates. (Complete definition, not that any other form would be valid anyway)\r\n   - A ````feature```` provides only partial type definitions for structs, classes, and enums: Only publicly visible members that are provided by the ````feature````, are included in the metadata.\r\n   - ````features```` don't need to provide public constructors to type they augment\r\n   - A ````feature```` cannot add an abstract method to a pre-existing type (TBD: How can this be enforced ? Maybe based on the presence of a public constructor ?)\r\n   - (Obvious) Every type that is referenced in the ````feature```` assembly must exist either in the ````feature```` assembly itself or in one of its dependent ````feature```` assemblies.\r\n - Multiple ````features```` can provide the same member on the same type, if they both provide it for different reasons\r\n - Across ````feature```` assemblies, type identity is only determined by their full name \r\n - ````features```` follow Semantic Versioning (TBD)\r\n   - A ````feature```` of minor version M > N must always depend on the ````feature```` version N (Version M should only include the new types and members)\r\n   - A ````feature```` of major version M > N can depend on ````feature```` version N if it doesn't include breaking changes (In the current state of affairs, I expect that there would never be breaking changes)\r\n\r\nI expect that ````feature```` assemblies will never be referenced by concrete runtime, library or application assemblies.\r\n\r\nFor the rest of this proposal, I will address the proposed feature (sorry 😑) as ````feature````:\r\nA ````feature```` is either ````provided```` or ````depended upon````. Usage of any other term is likely a mistake on my part.\r\n\r\n## Wiring up features\r\n\r\n### Within libraries\r\n\r\nA new TFM ````features```` is created, acting similarly to ````netstandard```` TFMs.\r\nLibrary projects can target the TFM ````features```` like they would target .NET Standard, .NET FX, .NET Core or other TFMs.\r\n\r\nWhen targeting the TFM ````features````, the library project must reference all features it depends on:\r\n\r\n - We could assume that the TFM ````features```` provide **zero** API by default. (But maybe it provide some kind of minimal subset ?)\r\n - Features could be bundled in larger feature packages to avoid referencing hundreds of feature packages. (Similar to ````Microsoft.AspNetCore.All````)\r\n - The project can reference other libraries that are based on the ````features```` TFM, and will transitively inherit feature dependencies.\r\n\r\nAt build time, the toochain will load all ````feature```` assemblies and construct a model of the global feature set required by the library by merging all type definitions in the feature assemblies.\r\nThis can be done in the compiler or before calling the compiler, via an external tool. (I feel it might be easier to add this in the MSBuild build process than in Roslyn.)\r\n\r\nAll metadata references to ````features```` would be mapped to a non-existant and well-known ````features```` assembly (possibly signed, and in that case, the signing key would have to be public).\r\n\r\n⚠️ Important: The feature dependencies still need to be stored somewhere inside the resulting assembly… But I don't know how they should be stored. (Custom attributes, or regular .NET assembly references ?)\r\n\r\n### Within applications\r\n\r\nWhat is true today will still hold true with features: Applications are expected to target a concrete framework.\r\nHowever, application projects would gain the ability to reference features-based projects and libraries.\r\n\r\nWhen an application references a features-based project, the toolchain (NuGet & MSBuild) must always validate that the current TFMs for the project support all of the required ````features````, directly, or via compatibility NuGet packages.\r\n\r\nAt build time, the toochain will load all ````feature```` assemblies indirectly referenced by the project and construct a **shim** assembly covering all of the required ````features````:\r\n\r\n - This assembly will have the well-known name ````features```` (identical to what is referenced by ````feature````-based library projects)\r\n - This assembly will contain ````TypeForwardedToAttribute```` attributes for each and every type referenced by the features. (That's assuming that feature support has already verified for the project, so that all the members of forwarded types are guaranteed to exist)\r\n - The assembly is (likely) signed with the well-known signing key.\r\n\r\nThe generated ````features```` **shim** assembly will be bundled with the application, and act as the glue between features-based libraries and the underlying framework. (This should be very similar to how .NET Standard works, if I'm not mistaken)\r\n\r\nℹ️ NB: In the end, what I propose is that, rather than the runtime(s), the **application** is responsible for **providing** (wire-up) the features that the libraries depend upon. (But that this is handled by the toolchain)\r\n\r\n## Providing features (i.e. Concrete implementations)\r\n\r\nSplitting type definitions across multiple reference-like assemblies should not break typical .NET expectations:\r\n\r\n - A concrete type implementation can only be provided by **one** assembly\r\n - Where the concrete type implementation ends up being (i.e. in which assembly) is dependent on the runtime, and *should not matter to the library developer*\r\n - The runtime is never aware of the partial type definitions that were used to build libraries\r\n\r\nThere must exist a mapping between runtimes/frameworks and features, and features could likely be always provided via NuGet packages.\r\nThis would provide a single source of metadata for the toolchain to generate its shim assemblies.\r\n\r\nThis is basically what we could expect:\r\n\r\n - A NuGet package can declare a list of implemented ````features````.\r\n - If a NuGet package claims to **provide** a ````feature````, it must **provide** this ````feature```` entirely, even if that means that some method would throw ````NotImplementedException````\r\n   - Implementation of the feature could, however, rely on other dependencies (via ````TypeForwardedToAttribute````)\r\n   - Implementation of a feature is always relative to a valid TFM that **is not** ````features```` (but it could be ````netstandard2.0````)\r\n - For each framework, a NuGet package with the correct Major.Minor version would exist. (e.g. ````Framework.NETCoreApp, Version=2.1.0````)\r\n   - Framework NuGet packages would **not** contain the framework itself\r\n   - Framework NuGet packages would define which features the framework supports, and how they are mapped\r\n   - Framework NuGet packages could be updated incrementally to add features as they are standardized\r\n   - Framework NuGet packages would be flagged specifically\r\n\r\n## Features on the NuGet side\r\n\r\nAll of the above requirements would likely require adaptations on the NuGet side:\r\n\r\n - As said earlier, Microsoft or .NET Foundation should reserve a NuGet prefix for features (e.g. ````Feature.````) to ease discovery of features and avoid pollution\r\n - Microsoft or .NET Foundation should reserve a NuGet prefix for frameworks (e.g. ````Framework.````) to ease discovery of framework-feature mappings\r\n - A NuGet package must be identifiable as a ````feature````\r\n   - ````features```` are to be always considered framework agnostic\r\n   - ````feature```` packages should only contain one reference assembly (Named the same as the feature ?)\r\n   - ````feature```` packages should be ignored by older NuGet implementations\r\n - A NuGet package must be able to **depend on** a ````feature````\r\n   - That might be as simple as declaring a regular package dependency\r\n - A NuGet package must be able to **provide** a ````feature````\r\n   - The features which are provided must be listed in the package… (How ?)\r\n   - A NuGet package implementing one ore more feature must contain, for each TFM where it applies, exactly **one** well-known assembly named ````features````, signed with a well-known key, and containing/forwarding the implementation of all the features.\r\n - A NuGet package must be identifiable as a ````framework````\r\n   - Framework NuGet packages are not considered framework agnostic (they… are… applying to themselves, somehow)\r\n   - Framework NuGet packages follow the same rules as NuGet packages that **provide** ````features````\r\n\r\n# Remarks\r\n\r\n## How should ````features```` be sliced from .NET Standard ?\r\n\r\nThe goal of this proposal is not (yet) to propose how ````features```` should be sliced, but to propose how to allow them to be sliced.\r\nHowever, it must be noted, that there are many ways to slice an API with the feature proposed here.\r\nWhile most types will not require any special treatment, some types may be better sliced into multiple separate features, rather than exported as a single feature.\r\n\r\nWe could consider, for example, that the ````Stream```` class could be exported in a ````Feature.IO.Stream.Sync```` and ````Feature.IO.Stream.Async````, with possibly even a common feature ````Feature.IO.Stream.Core````.\r\n\r\nI'm sure that would generate a lot of discussions anyway… 🙂\r\n\r\n## Possible uses of ````features````\r\n\r\nApart from the obvious modularization of the standard, ````features```` could also be used in the following scenarios:\r\n\r\n - For framework dependencies of a .NET language such as C#: The ````feature```` for the language would be versioned in parallel with the language version, and, for each version, declare every type and member needed to fully support that version of the language.\r\n - For defining an optional standardized .NET UI API. (Whose implementation might be tied to the runtime)\r\n - Defining a new ````feature```` over a third party API, for allowing developers to more easily swap the implementation (because ````features```` apply to any .NET type, and not just only interfaces)\r\n\r\n ## Finding how ````features```` are provided\r\n\r\n While ````features```` provided by the runtime can be easy to discover (the user only would only need to import the corresponding package, and the tools might even do it automatically), it might be much harder to find that a package for supporting a feature exists on a given runtime.\r\n\r\n Given that the responsibility for ensuring that à ````feature```` is **provided** is delegated to the final user (user of the library(ies) depending on ````features````), there might be a need for some sort of mechanism helping to discover feature implementations.\r\n\r\n It would be great if NuGet coult auto import default feature-providing packages, based on some kind of repository… So that everything goes smoothly on the end-user side.\r\n\r\n# (Supposed) pros and cons of this proposal\r\n\r\n## Pros\r\n\r\n - More fine grained control over dependencies (looser coupling, maybe recovering some of the possibilities that were lost by removing Assembly Neutral Interfaces)\r\n - Ability to standardize small parts of the API surface rather than a whole framework (e.g. new Span APIs could be standardized faster on their own)\r\n - Ability to make some newer APIs compatible with old .NET versions again (That is an important scenario in some migration paths)\r\n - Ability to standardize things such as UI APIs (e.g. Windows Forms) without redefining \".NET Standard\"\r\n - This proposal does not require modifying existing runtimes\r\n\r\n## Cons\r\n\r\n - This proposal adds yet another layer of complexity to the already complicated world of framework compatibility\r\n - Consuming libraries implemented over ````features```` requires upgrading the toolchain (that is not a problem for everyone, but it can be for some)\r\n - This proposal may requires non-trivial additions to NuGet (let's hope not)\r\n - Slicing the .NET Standard API in a potentially large number of fine-grained features must be done very carefully, and may take quite a bit of time\r\n\r\n# Conclusion\r\n\r\nThank you very much for reading this to the end !\r\n\r\nI'm waiting for your feedback. 😉"},{"Id":"7813817261","Type":"PullRequestEvent","CreatedAt":"2018-06-12T17:02:16","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/773","RelatedDescription":"Opened pull request \"Add diagnostic logging to trimming\" (#773) at dotnet/standard","RelatedBody":"Enable diagnostic logging to help understand the state of the task if a failure occurs.\r\n\r\nAlso guard against unpopulated dependencies."},{"Id":"7813802040","Type":"PullRequestEvent","CreatedAt":"2018-06-12T16:59:30","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/766","RelatedDescription":"Merged pull request \"Fix typo in FileNode 'Polulate'\" (#766) at dotnet/standard","RelatedBody":"/cc @nil4"},{"Id":"7803009293","Type":"IssuesEvent","CreatedAt":"2018-06-10T18:49:51","Actor":"gehnster","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/772","RelatedDescription":"Opened issue \"New HttpStatusCodes\" (#772) at dotnet/standard","RelatedBody":"Would it be possible to get these added to the next release of .NET Standard, from .NET Core.\r\n\r\nhttps://github.com/dotnet/corefx/issues/4382"},{"Id":"7802771531","Type":"IssuesEvent","CreatedAt":"2018-06-10T16:13:31","Actor":"Lexcess","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/771","RelatedDescription":"Opened issue \"[Proposal] Add GC.GetAllocatedBytesForCurrentThread in .Net Standard vNext\" (#771) at dotnet/standard","RelatedBody":"Given the recent focus on reducing allocations in .Net (e.g. the introduction of `Span<>`). I think it would be useful to have a simple tool for tracking allocations on the current thread. I would categorise this similarly to the `Stopwatch `class; yes I could use an external profiler, but having an in process solution is so much more flexible. I want to use something like this for monitoring, unit tests and even sanity-checking refactorings.  \r\n\r\nThe good news is that `GetAllocatedBytesForCurrentThread` was added to .Net Core CLR a while back now (see dotnet/corefx#10157 and https://github.com/dotnet/corefx/pull/12489 ), and it offers a robust model to follow.\r\n\r\nThe bad news is that the other runtime GC's don't currently have similar implementations and given GC differences the code probably can't be ported straight over. \r\n\r\nI understand that there is a higher cost implied by adding API's to the Standard that don't currently have obvious implementations for each runtime, but I do think this is an area where there will be growing interest in such an API. For example on Mono where allocations are critical to the performance of games and mobile apps.\r\n\r\nFurthermore there are already some people in the wild attempting cross runtime solutions, but it is a lot of hoops even when .Net Core is in play. See for example what Benchmark.Net is having to do right now: [Benchmark.Net/GCStats.cs](https://github.com/dotnet/BenchmarkDotNet/blob/master/src/BenchmarkDotNet/Engines/GcStats.cs)). Adding `GetAllocatedBytesForCurrentThread` to the standard would ease this immediate issue and give the opportunity for the other runtimes to add valuable diagnostic information in the future (with `PlatformNotSupportedException`s perhaps being the cost in the interim)."},{"Id":"7802434780","Type":"IssuesEvent","CreatedAt":"2018-06-10T12:33:45","Actor":"panost","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/770","RelatedDescription":"Opened issue \"[Question] Nullable Ref Types\" (#770) at dotnet/standard","RelatedBody":"I don't ask if are they plans for it, but if it is possible (for technological POV) to support Nullable Ref Types (C# 8.0) annotations even if none of the supported frameworks has them?\r\n\r\nFor example String.Replace to be defined in .NET Standard as \r\n\r\n> public string String.Replace(string oldValue,string? newValue);\r\n\r\neven if none of the supported frameworks has this annotation ?\r\n"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7816398953","Type":"PullRequestEvent","CreatedAt":"2018-06-13T04:25:41","Actor":"mmitche","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30347","RelatedDescription":"Merged pull request \"Update CoreClr, CoreFx, CoreSetup to servicing-26606-02, servicing, stable, respectively (release/2.1)\" (#30347) at dotnet/corefx","RelatedBody":""},{"Id":"7816306181","Type":"PullRequestEvent","CreatedAt":"2018-06-13T03:46:28","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/28989","RelatedDescription":"Merged pull request \"Clean dead code System.Private.Xml*\" (#28989) at dotnet/corefx","RelatedBody":""},{"Id":"7816226263","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:14:36","Actor":"Petermarcu","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30349","RelatedDescription":"Opened issue \"Setting Authorization header on an HttpClient instance does not work in .NET Core 2.1\" (#30349) at dotnet/corefx","RelatedBody":"@pereiraarun commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1684)\n\nTesting on .NET Core 2.1 (by setting Target Framework 2.1), the following code results in a 403 Forbidden since the header is not set correctly.\r\nHeader is set using the following method:\r\n\r\n    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Token\", \"9ac..b87b20\");\r\n    var result = client.GetStringAsync(\"/api/ipam/prefixes/\").Result;\r\n\r\nMoving back to .NET Core 2.0 (by setting Target Framework 2.0) fixes the issue. The same happens when using RestSharp. Seems there is some bug with HttpClient and setting authorization headers. \r\n\r\nTesting through: Vs Professional 2017 (15.7.3) on Windows 10 with the latest updates. \n\n---\n\n@brockallen commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1684#issuecomment-396406603)\n\nAre you sure the scheme is correct? Normally it should be \"Bearer\" (not \"Token\") if you're doing an OAuth2 style client.\n\n---\n\n@pereiraarun commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1684#issuecomment-396757677)\n\nThe code works as posted in .Net Core 2.0. The code is used for https://netbox.readthedocs.io/en/latest/api/authentication/\r\n\r\n`  $ curl -H \"Authorization: Token d2f763479f703d80de0ec15254237bc651f9cdc0\" -H \"Accept: application/json; indent=4\" http://localhost/api/dcim/sites/`\r\n` {`\r\n`     \"count\": 10,`\r\n`     \"next\": null,`\r\n`     \"previous\": null,`\r\n`     \"results\": [...]`\r\n  `}`\n\n"},{"Id":"7816225418","Type":"IssuesEvent","CreatedAt":"2018-06-13T03:14:15","Actor":"Petermarcu","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30348","RelatedDescription":"Opened issue \"asp.net core 2.1 System.Net.Sockets.SocketException\" (#30348) at dotnet/corefx","RelatedBody":"@HP-dufeng commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1685)\n\n#System.Net.Sockets.SocketException\r\n\r\nI use visual studio 2017 create a asp.net core 2.1 site use empty template, then start with debug, Occasionally the following errors:\r\n```\r\nUnhandled Exception: System.AggregateException: One or more errors occurred. (An existing connection was forcibly closed by the remote host.) ---> System.Net.Sockets.SocketE\r\nxception: An existing connection was forcibly closed by the remote host.\r\n   at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, String callerName)\r\n   at System.Net.Sockets.Socket.Shutdown(SocketShutdown how)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.Shutdown()\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.Abort()\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.TransportConnection.Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.Abort()\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1OutputProducer.Abort(Exception error)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.Abort(Exception error)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnection.Abort(Exception ex)\r\n   at System.IO.Pipelines.PipeCompletionCallbacks.Execute()\r\n   --- End of inner exception stack trace ---\r\n   at System.IO.Pipelines.PipeCompletionCallbacks.Execute()\r\n   at System.IO.Pipelines.Pipe.<>c.<.cctor>b__79_2(Object state)\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n```\r\n\n\n"},{"Id":"7816194225","Type":"PullRequestEvent","CreatedAt":"2018-06-13T03:01:51","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/29928","RelatedDescription":"Closed pull request \"Testing flow of crash dumps to dumpling.\" (#29928) at dotnet/corefx","RelatedBody":""}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7816127272","Type":"PullRequestEvent","CreatedAt":"2018-06-13T02:36:50","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5934","RelatedDescription":"Merged pull request \"Use SemaphoreModifyState and EventModifyState instead of MutexModifyState\" (#5934) at dotnet/corert","RelatedBody":"This was introduced in Corert in https://github.com/dotnet/corert/pull/5921\r\n"},{"Id":"7815843738","Type":"PullRequestEvent","CreatedAt":"2018-06-13T00:48:02","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5934","RelatedDescription":"Opened pull request \"Use SemaphoreModifyState and EventModifyState instead of MutexModifyState\" (#5934) at dotnet/corert","RelatedBody":"This was introduced in Corert in https://github.com/dotnet/corert/pull/5921\r\n"},{"Id":"7812681802","Type":"PullRequestEvent","CreatedAt":"2018-06-12T14:01:51","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5933","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#5933) at dotnet/corert","RelatedBody":""},{"Id":"7812383144","Type":"PullRequestEvent","CreatedAt":"2018-06-12T13:15:11","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5933","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#5933) at dotnet/corert","RelatedBody":""},{"Id":"7812380827","Type":"PullRequestEvent","CreatedAt":"2018-06-12T13:14:47","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5932","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#5932) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7812376312","Type":"PullRequestEvent","CreatedAt":"2018-06-12T13:14:01","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5932","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#5932) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7809979216","Type":"PullRequestEvent","CreatedAt":"2018-06-12T04:00:19","Actor":"maryamariyan","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5931","RelatedDescription":"Opened pull request \"[JustForView] Helps move x86 HW intrinsics files to shared in corert\" (#5931) at dotnet/corert","RelatedBody":"- gitignore needs to be updated because the new files (to be moved from coreclr src to shared) are located in a folder named x86.\r\n\r\n- the second commit shows how the ifdefs could be simplified after the APIs are added.\r\n\r\nRelated to coreclr PR: https://github.com/dotnet/coreclr/pull/18427\r\n\r\ncc: @jkotas @MichalStrehovsky "},{"Id":"7809498141","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:58:28","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5930","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5930) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7809487366","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:54:17","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5928","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#5928) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7816065681","Type":"IssuesEvent","CreatedAt":"2018-06-13T02:14:18","Actor":"ponarunkumar","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2326","RelatedDescription":"Opened issue \"Unable to install dotnet-sdk-2.1 in Ubuntu 16.04 \" (#2326) at dotnet/sdk","RelatedBody":"Followed the steps provided as per https://www.microsoft.com/net/learn/get-started/linux/ubuntu16-04\r\nHowever, the package seems to be updated.\r\n\r\nReference steps to recreate the issue:\r\n:~$ sudo wget -q https://packages.microsoft.com/config/ubuntu/16.04/packages-microsoft-prod.deb\r\n~$ sudo dpkg -i packages-microsoft-prod.deb\r\n(Reading database ... 323159 files and directories currently installed.)\r\nPreparing to unpack packages-microsoft-prod.deb ...\r\nUnpacking packages-microsoft-prod (1.0-3) over (1.0-3) ...\r\nSetting up packages-microsoft-prod (1.0-3) ...\r\n~$ sudo apt-get install apt-transport-https\r\nReading package lists... Done\r\nBuilding dependency tree       \r\nReading state information... Done\r\napt-transport-https is already the newest version (1.2.26).\r\nThe following packages were automatically installed and are no longer required:\r\n  linux-headers-4.13.0-41 linux-headers-4.13.0-41-generic linux-image-4.13.0-41-generic linux-image-extra-4.13.0-41-generic\r\nUse 'sudo apt autoremove' to remove them.\r\n0 upgraded, 0 newly installed, 0 to remove and 8 not upgraded.\r\n~$ sudo apt-get update\r\nHit:1 http://us.archive.ubuntu.com/ubuntu xenial InRelease\r\nHit:2 http://us.archive.ubuntu.com/ubuntu xenial-updates InRelease                            \r\nHit:3 http://us.archive.ubuntu.com/ubuntu xenial-backports InRelease                          \r\nHit:4 http://security.ubuntu.com/ubuntu xenial-security InRelease       \r\nHit:5 http://ppa.launchpad.net/alexlarsson/flatpak/ubuntu xenial InRelease\r\nIgn:6 https://storage.googleapis.com/download.dartlang.org/linux/debian stable InRelease\r\nHit:7 https://deb.nodesource.com/node_10.x xenial InRelease\r\nHit:8 https://storage.googleapis.com/download.dartlang.org/linux/debian stable Release\r\nHit:9 https://dl.yarnpkg.com/debian stable InRelease\r\nHit:10 https://packages.microsoft.com/ubuntu/16.04/prod xenial InRelease\r\nReading package lists... Done \r\n:~$ sudo apt-get install dotnet-sdk-2.1\r\nReading package lists... Done\r\nBuilding dependency tree       \r\nReading state information... Done\r\nE: Unable to locate package dotnet-sdk-2.1\r\nE: Couldn't find any package by glob 'dotnet-sdk-2.1'\r\nE: Couldn't find any package by regex 'dotnet-sdk-2.1'\r\n$ \r\n\r\nsudo apt-get install dotnet-sdk-2.1\r\nReading package lists... Done\r\nBuilding dependency tree       \r\nReading state information... Done\r\nE: Unable to locate package dotnet-sdk-2.1\r\nE: Couldn't find any package by glob 'dotnet-sdk-2.1'\r\nE: Couldn't find any package by regex 'dotnet-sdk-2.1'\r\n"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1005426264029753345","CreatedAt":"2018-06-09T12:27:55+00:00","UserScreenname":"dotnet","Text":"Tune in today at 10a ET / 7a PT / 14:00 UTC / 8p IST and learn about global tools along with Jeff. https://t.co/hqxNjfqPMq","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":5,"RawContent":null},{"Id":"1005082168442449920","CreatedAt":"2018-06-08T13:40:37+00:00","UserScreenname":"dotnet","Text":"Tune in with Jeff as he works through the tutorials to learn F#.  Ask questions, and learn along with him https://t.co/rntL0szWYX","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":34,"FavoriteCount":16,"RawContent":null},{"Id":"1004145068381331456","CreatedAt":"2018-06-05T23:36:55+00:00","UserScreenname":"dotnet","Text":"Cool retro game built with #dotnet #monogame. Clone the repo, play the game, and you could win some serious money!… https://t.co/iHu2MQ1bME","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":70,"FavoriteCount":19,"RawContent":null}]}},"RunOn":"2018-06-13T05:30:33.4103041Z","RunDurationInMilliseconds":7177}