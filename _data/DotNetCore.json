{"Data":{"Blog":{"FeedItems":[{"Title":".NET Framework 4.7.2 Developer Pack Early Access build 3056 is available!","PublishedOn":"2018-03-08T23:22:13+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are happy to share an Early Access build with the .NET Framework 4.7.2 Developer Pack. The .NET Framework 4.7.2 Developer Pack lets developers build applications that target the .NET...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/08/net-framework-4-7-2-developer-pack-early-access-build-3056-is-available/","RawContent":null},{"Title":"F# language and tools update for Visual Studio 2017 version 15.6","PublishedOn":"2018-03-06T18:28:06+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"With the release of Visual Studio 2017 version 15.6, we’re excited to share updates to the F# language and core library, F# tooling in Visual Studio, and infrastructure updates that concern OSS...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/06/f-language-and-tools-update-for-visual-studio-2017-version-15-6/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1 Preview 1","PublishedOn":"2018-02-27T18:11:29+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"Today we are releasing the first preview of EF Core 2.1, alongside .NET Core 2.1 Preview 1 and ASP.NET Core 2.1 Preview 1. The new bits are available in NuGet as part of the individual packages, and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/announcing-entity-framework-core-2-1-preview-1/","RawContent":null},{"Title":"Announcing .NET Core 2.1 Preview 1","PublishedOn":"2018-02-27T18:08:23+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are announcing .NET Core 2.1 Preview 1. It is the first public release of .NET Core 2.1. We have great improvements that we want to share and that we would love to get your feedback on,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/announcing-net-core-2-1-preview-1/","RawContent":null},{"Title":"Calling All Desktop Developers: How do you interact with data?","PublishedOn":"2018-02-27T17:00:36+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Connecting to databases and services is an important part of desktop application development for many of our customers. Visual Studio provides a variety of tools and technologies that can help you...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/calling-all-desktop-developers-how-do-you-interact-with-data/","RawContent":null},{"Title":"Azure Blob Storage as a Network Drive","PublishedOn":"2018-02-26T16:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Many applications make use of a network drive to backup and store files. When I was in university I found myself constantly coding for fun, and one example took the form of a network share for my...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/26/azure-blob-storage-as-a-network-drive/","RawContent":null},{"Title":".NET Framework February 2018 Security and Quality Rollup","PublishedOn":"2018-02-14T04:27:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the February 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework January 2018 Security and Quality Rollup for the latest security updates....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/13/net-framework-february-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Machine Learning in .NET – Help us build the right experience!","PublishedOn":"2018-02-13T17:17:58+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"In the past few years, Machine Learning (ML) and Artificial Intelligence (AI) have paved the road for building smarter applications through advancements in speech recognition, computer vision,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/13/machine-learning-in-net-help-us-build-the-right-experience/","RawContent":null},{"Title":"Announcing .NET Framework 4.7.2 Early Access build 3052!","PublishedOn":"2018-02-05T21:55:13+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.7.2 Early Access build 3052 for your feedback. .NET Framework 4.7.2 is the next version of the .NET Framework. It is currently feature-complete and in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/05/announcing-net-framework-4-7-2-early-access-build-3052/","RawContent":null},{"Title":"Entity Framework Core 2.1 Roadmap","PublishedOn":"2018-02-02T18:39:25+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"As mentioned in the announcement of the .NET Core 2.1 roadmap earlier today, at this point we know the overall shape of our next release and we have decided on a general schedule for it. As we...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/02/entity-framework-core-2-1-roadmap/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7192252734","Type":"PullRequestEvent","CreatedAt":"2018-02-03T01:30:47","Actor":"karann-msft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Opened pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7187459205","Type":"PullRequestEvent","CreatedAt":"2018-02-02T05:26:03","Actor":"mairaw","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/97","RelatedDescription":"Opened pull request \"update CLA PDF link\" (#97) at dotnet/home","RelatedBody":""},{"Id":"7102763357","Type":"PullRequestEvent","CreatedAt":"2018-01-16T00:17:04","Actor":"galatrash-at-dnn","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Opened pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7097053889","Type":"PullRequestEvent","CreatedAt":"2018-01-14T15:15:00","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Opened pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7065382954","Type":"PullRequestEvent","CreatedAt":"2018-01-06T19:21:47","Actor":"ctaggart","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Opened pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7044237283","Type":"PullRequestEvent","CreatedAt":"2017-12-31T20:25:44","Actor":"onovotny","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Opened pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7387413694","Type":"IssuesEvent","CreatedAt":"2018-03-15T21:18:32","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/63","RelatedDescription":"Reopened issue \"Transport Layer Security (TLS) best practices with the .NET Framework article published\" (#63) at dotnet/announcements","RelatedBody":"# Transport Layer Security (TLS) best practices with the .NET Framework article published\r\n\r\nA new article was published that discusses the Transport Layer Security (TLS) best practices at https://docs.microsoft.com/dotnet/framework/network-programming/tls.\r\n\r\nTo ensure .NET Framework applications remain secure, the TLS version should **not** be hardcoded. .NET Framework applications should use the TLS version the operating system (OS) supports.\r\n\r\nThe (TLS) best practices article targets developers who are:\r\n* Directly using the System.Net APIs (for example, `System.Net.Http.HttpClient` and `System.Net.Security.SslStream`).\r\n* Directly using WCF clients and services using the `System.ServiceModel` namespace.\r\n* Using [Azure Cloud Services](https://azure.microsoft.com/services/cloud-services/) Web and Worker roles to host and run your application. See the [Azure Cloud Services](https://docs.microsoft.com/dotnet/framework/network-programming/tls#azure-cloud-services) section.\r\n\r\nThe article explains how to enable the strongest security available for the version of the .NET Framework that your app targets and runs on.\r\n\r\nThe section [Audit your code and make code changes](https://docs.microsoft.com/dotnet/framework/network-programming/tls#audit-your-code-and-make-code-changes) covers auditing and updating your code.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\ndotnet/docs#4675"},{"Id":"7387391842","Type":"IssuesEvent","CreatedAt":"2018-03-15T21:13:45","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/63","RelatedDescription":"Closed issue \"Transport Layer Security (TLS) best practices with the .NET Framework article published\" (#63) at dotnet/announcements","RelatedBody":"# Transport Layer Security (TLS) best practices with the .NET Framework article published\r\n\r\nA new article was published that discussed the Transport Layer Security (TLS) best practices at https://docs.microsoft.com/dotnet/framework/network-programming/tls.\r\n\r\nTo ensure .NET Framework applications remain secure, the TLS version should **not** be hardcoded. .NET Framework applications should use the TLS version the operating system (OS) supports.\r\n\r\nThe (TLS) best practices article targets developers who are:\r\n* Directly using the System.Net APIs (for example, `System.Net.Http.HttpClient` and `System.Net.Security.SslStream`).\r\n* Directly using WCF clients and services using the `System.ServiceModel` namespace.\r\n* Using [Azure Cloud Services](https://azure.microsoft.com/services/cloud-services/) Web and Worker roles to host and run your application. See the [Azure Cloud Services](https://docs.microsoft.com/dotnet/framework/network-programming/tls#azure-cloud-services) section.\r\n\r\nThe article explains how to enable the strongest security available for the version of the .NET Framework that your app targets and runs on.\r\n\r\nThe section [Audit your code and make code changes](https://docs.microsoft.com/dotnet/framework/network-programming/tls#audit-your-code-and-make-code-changes) covers auditing and updating your code.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\ndotnet/docs#4675"},{"Id":"7373349220","Type":"IssuesEvent","CreatedAt":"2018-03-13T17:01:53","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/62","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-0875: Hash Collison can cause Denial of Service\" (#62) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-0875: Hash Collison can cause Denial of Service\r\n## Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 2.0 (including other minor and patch releases).\r\nThis advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public versions of .NET Core where a malicious file or web request could cause a denial of service (DoS) attack.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.10, 1.1.7 or 2.0.6. Developers are advised to update their .NET Core SDK to versions 1.1.8 or 2.1.101.\r\n\r\n## Discussion\r\n\r\nUse *TBD* for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\nNone\r\n\r\n### Affected Software\r\n\r\nAny application running against .NET Core 1.0.9 or lower versions, 1.1.6 or lower minor versions or 2.0.5 or lower minor versions is affected. \r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\nAny application running against .NET Core 1.0.9 or lower versions, 1.1.6 or lower minor versions or 2.0.5 or lower minor versions is affected. \r\n\r\nA complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location |\r\n|------------------|----------|\r\n| Windows\t| `C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\` |\r\n| macOS\t| `/usr/local/share/dotnet/shared/Microsoft.NETCore.App/` |\r\n| Supported Linux platforms\t| `/usr/share/dotnet/shared/Microsoft.NETCore.App/` |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.10, 1.1.7 and 2.0.6, then any applications targeting the respective major/minor versions, 1.0 or 1.1 or 2.0 of .NET Core are vulnerable.\r\n\r\nAdditionally, if you've deployed self-contained applications targeting any of the impacted versions, these applications are also vulnerable and must be recompiled and redeployed.\r\n\r\n#### How do I fix my affected application?\r\n\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. \r\nInstallers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). \r\n.NET Core 1.1.8 SDK installs both versions 1.0.10 and 1.1.7 of the .NET Core runtime.\r\n\r\nIf you've built a self-contained application, you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the `application.runtime.config` file for that application. Set the framework version to the desired version and the `rollForward` property to false. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the `application.runtime.config` file is an optional file, you may need to create one for each application and add it alongside the executable.\r\n\r\n### Acknowledgments\r\n[Ben Adams](https://twitter.com/ben_a_adams) of [Illyriad Games](https://www.illyriad.co.uk/)\r\n\r\n### External Links\r\n[CVE-2018-0875](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0875)\r\n\r\n### Revisions\r\n\r\nV1.0 (Mar 13, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n_Last Updated 2018-03-13_\r\n"},{"Id":"7301596554","Type":"IssuesEvent","CreatedAt":"2018-02-27T06:10:33","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/61","RelatedDescription":"Opened issue \"New offline books released for Visual Studio 2017\" (#61) at dotnet/announcements","RelatedBody":"# New offline books released for Visual Studio 2017\r\n\r\nEarlier this month, we released an update to Offline Books for the Visual Studio 2017 Help Viewer.\r\n\r\nThis release includes new .NET books, including .NET Core Guide, .NET Guide, .NET Framework Guide and the .NET API Reference. It also includes the latest content for Visual Studio 2017 version 15.5, the latest updates to Visual Basic, C# (7.1 and 7.2), F#, ASP.NET Core, NuGet, SQL Server, and the Universal Windows Platform.\r\n\r\nThe .NET Guide, .NET Framework Guide and .NET API Reference books together are a replacement for the .NET Framework 4.6 and 4.5 book, which can be removed. Just be aware that the new .NET API Reference book currently displays the API syntax block for C# only, but examples are shown in other languages, just like the experience you currently have on docs.microsoft.com.If you need to see the API syntax for Visual Basic, C++/CLI or F#, then you should keep the old book until the new reference book is updated again in a few weeks. Once you remove the .NET Framework 4.6 and 4.5 book, you cannot reinstall it.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\n- https://github.com/dotnet/docs/issues/4502\r\n\r\n## Add new content\r\n\r\nYou will see these new books when you have Help Viewer installed and choose **Help** > **Add and Remove Content** from the Visual Studio 2017 main menu. If you don't see this menu item, then [open the Visual Studio Installer](https://docs.microsoft.com/visualstudio/install/modify-visual-studio), click the **More** dropdown and choose **Modify**. When the component list appears, choose **Individual Components** at the top, then check **Help Viewer**.\r\n\r\n![help_viewer_component](https://user-images.githubusercontent.com/12971179/36713111-c9d49a7c-1b40-11e8-918a-e7e3619669a2.png)\r\n\r\n## Help Viewer Installation\r\n\r\nTo start the installation, select the **Modify** button in the lower right corner of the Installer window.\r\n\r\nTo update individual books whose status is \"Updates available\", remove the book and then click **Add** to get the new version. To update all your books at once, select the link in the lower right corner of the **Add and Remove Content** window:\r\n\r\n![offline-books](https://user-images.githubusercontent.com/12971179/36713028-75b944f6-1b40-11e8-91c4-4830355f815e.png)"},{"Id":"7300537622","Type":"IssuesEvent","CreatedAt":"2018-02-27T00:12:10","Actor":"eerhardt","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/60","RelatedDescription":"Opened issue \"System.Runtime.Intrinsics in .NET Core 2.1\" (#60) at dotnet/announcements","RelatedBody":"# System.Runtime.Intrinsics in .NET Core 2.1\r\n\r\n.NET Core 2.1 has been adding platform intrinsic APIs to support directly calling processor specific instructions, such as Intel’s x86 SIMD instructions.  See the [initial platform intrinsics design](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md) for more information.\r\n\r\nWe have decided that it makes the most sense for this intrinsics feature to ship in a “preview” status in the .NET Core 2.1 RTM timeframe.  This means that the runtime support we are implementing will be included, but the assembly exposing the intrinsics will only be available to projects via explicit reference to a “preview-only” package.  These APIs won’t be included in the official .NET Core 2.1 packages.\r\n\r\nGiven our limited time and resources, recent changes in the approach we take to expose the intrinsics, and API changes prompted by design feedback from the community, we don’t believe there is enough time to settle these APIs for 2.1. We plan to follow the pattern of other recent features like Span<T> and Memory<T> that first shipped in preview before formally joining the supported API surface.  Not only would we expect the next version of .NET Core to support more intrinsics than could be supported in 2.1, but we expect to have real usage examples in CoreFX and higher level components as well.  These real world examples, as well as feedback from customers who opt in to the preview, should give us the confidence we need to officially support the APIs going forward.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\nhttps://github.com/dotnet/corefx/issues/27486\r\n\r\n## Details\r\n\r\nIn the coming days, we plan on removing System.Runtime.Intrinsics.dll from the Microsoft.NETCore.App package.  This means any libraries/applications that are using these APIs will no longer compile by default, and will not run on new builds of .NET Core 2.1.\r\n\r\nAt the same time, we will start producing a new System.Runtime.Intrinsics.Experimental NuGet package.  In order to continue using these APIs on .NET Core 2.1, a project will need to add a reference to this new package.\r\n\r\nAs its name implies, this package is experimental and should only be used for preview purposes.  It isn’t expected to be used in production scenarios.  Future version of .NET Core (after 2.1) will be allowed to break this package. This enables us respond to future feedback that requires the APIs to be modified.\r\n\r\nIn the future, when we are confident we have the intrinsic APIs right, we will stop producing the System.Runtime.Intrinsics.Experimental package. The platform intrinsics APIs will then be added back to Microsoft.NETCore.App and will be officially supported."},{"Id":"7273056222","Type":"IssuesEvent","CreatedAt":"2018-02-21T02:28:03","Actor":"KathleenDollard","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/57","RelatedDescription":"Opened issue \"Manually Uninstall .NET Core SDK 2.2.0-Preview Nightly Builds\" (#57) at dotnet/announcements","RelatedBody":"# Manually Uninstall .NET Core SDK 2.2.0-Preview Nightly Builds\r\n\r\n[A change in the version number strategy for .NET Core SDK](https://github.com/dotnet/designs/pull/29) resulted in some nightly builds having a higher version number. This higher version number will block the installation of the correct .NET Core SDK.\r\n\r\nIf you have installed nightly builds of the .NET Core SDK that start with version number that begin with `2.2.0-preview1`, you must manually uninstall these preview builds before later versions of the SDK with version numbers like 2.1.xxx will be available. This may have occurred by installing nightly builds of the .NET Core SDK or nightly builds of Visual Studio 15.5 Preview. \r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n[dotnet/cli #8652](https://github.com/dotnet/cli/issues/8652)\r\n\r\n## Details\r\n\r\n[We changed the version number strategy for .NET Core SDK](https://github.com/dotnet/designs/pull/29) as development was ongoing. Because of this, version numbers on the old scheme appeared in nightly builds. Unfortunately, these numbers are higher than the version numbers in the new scheme. All of the newer SDKs for .NET Core 2.1 will be ignored due to this higher version number; this includes newer nightly builds, public previews and eventual releases.\r\n\r\nThese older version numbers are similar to the following, with the last several different values in the last six digits:\r\n\r\n```\r\n2.2.0-preview1-008000\r\n```\r\n\r\nSince the newer versions are in the form:\r\n\r\n```\r\n2.1.300-preview1-008000\r\n```\r\n\r\n## Call to Action\r\n\r\nIf you have installed nightly builds. Please uninstall any .NET SDK versions that start with 2.2.0-preview1."},{"Id":"7253280422","Type":"IssuesEvent","CreatedAt":"2018-02-16T04:14:06","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/56","RelatedDescription":"Closed issue \"Can you help with this issue?\" (#56) at dotnet/announcements","RelatedBody":"https://stackoverflow.com/questions/48819198/weird-behavior-of-httpclienthandler-sslprotocol-property-in-net-framework-4-7-1\r\n"},{"Id":"7253090788","Type":"IssuesEvent","CreatedAt":"2018-02-16T02:41:24","Actor":"rudeGit","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/56","RelatedDescription":"Opened issue \"Can you help with this issue?\" (#56) at dotnet/announcements","RelatedBody":"https://stackoverflow.com/questions/48819198/weird-behavior-of-httpclienthandler-sslprotocol-property-in-net-framework-4-7-1\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7404483983","Type":"PullRequestEvent","CreatedAt":"2018-03-20T05:05:50","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17061","RelatedDescription":"Opened pull request \"Move EncodingTable and CodePageDataItem to System.Text namespace\" (#17061) at dotnet/coreclr","RelatedBody":"This is the more logical namespace for it and it matches the namespace that these live under in CoreRT."},{"Id":"7404366755","Type":"PullRequestEvent","CreatedAt":"2018-03-20T04:16:24","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17059","RelatedDescription":"Merged pull request \"Fix copy&paste bug\" (#17059) at dotnet/coreclr","RelatedBody":""},{"Id":"7404231001","Type":"PullRequestEvent","CreatedAt":"2018-03-20T03:24:03","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17053","RelatedDescription":"Merged pull request \"Fix unloading of images mapped by PAL\" (#17053) at dotnet/coreclr","RelatedBody":"The m_FileView member of MappedImageLayout is a CLRMapViewHolder,\r\nwhich runs CLRUnmapViewOfFile on release. This is fine on\r\nWindows, where the MappedImageLayout constructor calls\r\nCLRMapViewOfFile. However, with FEATURE_PAL, the constructor calls\r\nPAL_LOADLoadPEFile, which simulates LoadLibrary and records multiple\r\nmapping entries. Each entry increases the refcount of the underlying\r\nfile handle PAL object. PAL_LOADUnloadPEFile should be called in this\r\ncase (instead of CLRUnmapViewOfFile), to decrease the refcount for\r\neach mapping entry.\r\n\r\nFixes https://github.com/dotnet/coreclr/issues/15189.\r\n\r\n@jkotas, @janvorli PTAL"},{"Id":"7404230991","Type":"IssuesEvent","CreatedAt":"2018-03-20T03:24:02","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/15189","RelatedDescription":"Closed issue \"AssemblyName.GetAssemblyName throws exceptions on Linux and macOS\" (#15189) at dotnet/coreclr","RelatedBody":"Given the following program:\r\n```csharp\r\nclass Program\r\n{\r\n    static Task Main()\r\n    {\r\n        var assembliesString = (string)AppContext.GetData(\"TRUSTED_PLATFORM_ASSEMBLIES\");\r\n        var assemblies = assembliesString.Split(Path.PathSeparator);\r\n\r\n        var tasks = new List<Task>();\r\n\r\n        for (int i = 0; i < 100; i++)\r\n        {\r\n            tasks.Add(Task.Run(() => GetAssemblyNames(assemblies)));\r\n        }\r\n\r\n        return Task.WhenAll(tasks);\r\n    }\r\n\r\n    static void GetAssemblyNames(string[] assemblies)\r\n    {\r\n        foreach (var assembly in assemblies)\r\n        {\r\n            var assemblyName = AssemblyName.GetAssemblyName(assembly);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe behavior varies depending on what OS it is run on. It works perfectly on Windows. On Linux and macOS, the calls to GetAssemblyName eventually start failing. I've seen a variety of exceptions.\r\n\r\non macOS I've see the following exceptions:\r\n```\r\nSystem.IO.FileLoadException: Could not load file or assembly '/usr/local/share/dotnet/shared/Microsoft.NETCore.App/2.0.3/System.Security.Cryptography.Encoding.dll'. A device attached to the system is not functioning.\r\n (Exception from HRESULT: 0x8007001F)\r\n```\r\n```\r\nSystem.IO.FileLoadException: Could not load file or assembly '/usr/local/share/dotnet/shared/Microsoft.NETCore.App/2.0.3/System.Diagnostics.FileVersionInfo.dll'. The system cannot open the file.\r\n (Exception from HRESULT: 0x80070004)\r\n```\r\n\r\non Linux I've seen:\r\n```\r\nSystem.Runtime.InteropServices.COMException (0x8007000C) : The access code is invalid.\r\n(Exception from HRESULT: 0x8007000C)\r\n```\r\n```\r\nSystem.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown.\r\n```\r\n\r\nThe stack traces all show the exceptions coming from `System.Reflection.AssemblyName.nGetFileInformation(String s)`. The assemblies that end up throwing vary from run to run, so the ones listed above are just examples.\r\n\r\n\r\nI've run my tests using the 2.0.3 SDK and runtime, on the following OSes:\r\n- Windows 10 1709 16299.64\r\n- macOS 10.13\r\n- Ubuntu 16.04\r\n"},{"Id":"7404230025","Type":"IssuesEvent","CreatedAt":"2018-03-20T03:23:40","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/13230","RelatedDescription":"Closed issue \"GetAssemblyName throws BadImageFormatException on some crossgen'd dlls\" (#13230) at dotnet/coreclr","RelatedBody":"I see this failure mode in the following cases:\r\n\r\n- Windows, on a linux-x64 or osx-64 crossgen'd dll\r\n- Linux, on an osx-64 crossgen'd dll.\r\n- macOS, on a linux-x64 crossgen'd dll.\r\n\r\nSpecifically, I've been hitting the failure on the System.Private.CoreLib.dll included in nuget packages like `runtime.linux-x64.microsoft.netcore.app`, under the path `2.0.0-preview2-25407-01/runtimes/linux-x64/native/System.Private.CoreLib.dll`\r\n\r\nI **am** able to get the assembly name of a win-x64 crossgen'd dll from linux or macOS.\r\n\r\n\r\nSome investigation shows the following:\r\n- On windows, with a crossgen’d unix dll: [LoadLibrary call returns NULL](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimage.cpp#L972), then [CreateFileMapping returns NULL](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L390), and an [exception is thrown](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L403).\r\n- On unix, with a crossgen’d windows dll: [PAL LoadLibrary call (using mmap) fails](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L481), so [MappedImageLayout returns](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L488), we [create a FlatImageLayout](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L76), and GetAssemblyName succeeds.\r\n- On unix, with a crossgen’d unix dll for a different unix OS: [PAL LoadLibrary call (using mmap) succeeds](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L481), but we see that the assembly has a [non-matching OS in the Machine header](https://github.com/dotnet/coreclr/blob/dbdb5387c28795d6f9fe8b9b0be1ce0048e01561/src/vm/peimagelayout.cpp#L503), so an exception is thrown.\r\n\r\nBy [removing some of these checks](https://github.com/dotnet/coreclr/pull/13214/files#diff-37106c39a89096d71f6fc38eaf66961b) I was able to make GetAssemblyName work for all of the above platform/target combinations, but of course those checks were there for a reason. :)\r\n\r\nIt seems like fixing this will involve changes similar to the following, for the special case of reflection-only load contexts (thanks @jkotas!):\r\n- Either enabling the FlatImageLayout as a fallback or preventing an exception from being thrown on windows\r\n- Suppressing the non-matching OS check on unix\r\n\r\n/cc @richlander @russellhadley @swaroop-sridhar @erozenfeld \r\n"},{"Id":"7404230031","Type":"PullRequestEvent","CreatedAt":"2018-03-20T03:23:40","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17052","RelatedDescription":"Merged pull request \"Use flat layout for GetAssemblyName\" (#17052) at dotnet/coreclr","RelatedBody":"This change will result in the use of flat layouts for the temporary\r\nlayouts created by GetAssemblyName. This allows crossgen'd PE images\r\ncreated for a different OS to be loaded in the code path that\r\nretrieves the assembly name.\r\n\r\nFixes https://github.com/dotnet/coreclr/issues/13230.\r\n\r\n@jkotas PTAL"},{"Id":"7404228190","Type":"IssuesEvent","CreatedAt":"2018-03-20T03:23:00","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17060","RelatedDescription":"Opened issue \"Globalization API optimization opportunities\" (#17060) at dotnet/coreclr","RelatedBody":"From https://github.com/dotnet/coreclr/pull/17029#discussion_r175551618\r\n\r\n- Speculatively allocate array for LCMapStringEx / GetSortKey during case-insensitive hashing\r\n- Do not use SafeHandle for sort handle on Unix (we are not using SafeHandle for this on Windows either)\r\n- Use arguments that do not require marshaling in globalization API signature (pointers instead of strings, etc.)"},{"Id":"7404201850","Type":"PullRequestEvent","CreatedAt":"2018-03-20T03:13:28","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17059","RelatedDescription":"Opened pull request \"Fix copy&paste bug\" (#17059) at dotnet/coreclr","RelatedBody":""}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7404524737","Type":"PullRequestEvent","CreatedAt":"2018-03-20T05:22:46","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8833","RelatedDescription":"Merged pull request \"Change --source to --source-feed and make it additional\" (#8833) at dotnet/cli","RelatedBody":"Fix https://github.com/dotnet/cli/issues/8561\r\n\r\nOther than change source to source-feed and make it additional instead of exclusive. I changed source to be multiple. Because restore support multiple source https://github.com/Microsoft/dotnet/issues/361\r\n\r\nAs for mock. The offline feed and source feed is considered the same, so remove the category of “source”. \r\n\r\nI renamed source to “AdditionalFeed” because that is more accurate on implementation level.\r\n\r\nNote:\r\nNuGet feed don’t have order. Whichever responses the fastest, is the first.\r\nNo change on restore.\r\n\r\nscripts/cli-test-env.sh change is due to mac 10.13 is finally added to RID graph. And it is “considered” one of the CLI supported RID\r\n\r\n"},{"Id":"7404431136","Type":"PullRequestEvent","CreatedAt":"2018-03-20T04:43:25","Actor":"peterhuene","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8782","RelatedDescription":"Merged pull request \"Merge rel/1.1.0-MSRC to rel/1.1.0\" (#8782) at dotnet/cli","RelatedBody":""},{"Id":"7403948870","Type":"IssuesEvent","CreatedAt":"2018-03-20T01:44:47","Actor":"RussKeldorph","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/8834","RelatedDescription":"Closed issue \"Used in the DOCKER dotnet restore error Segmentation fault (core dumped)\" (#8834) at dotnet/cli","RelatedBody":"_From @Loongle on September 6, 2017 14:3_\n\nI built Jenkins in docker container, then entered the container to install the dotnet core 2.0 SDK, and when I used the dotnew new console - o hwapp in container, there was an error: \r\n`Running 'dotnet restore' on hwapp/hwapp.csproj...\r\nSegmentation fault (core dumped)\r\n`\n\n_Copied from original issue: dotnet/coreclr#13809_"},{"Id":"7403595212","Type":"IssuesEvent","CreatedAt":"2018-03-19T23:40:11","Actor":"nategraf","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8849","RelatedDescription":"Opened issue \"`dotnet publish` leaves a dangling process even with \"/p:UseSharedCompilation=false\"\" (#8849) at dotnet/cli","RelatedBody":"On the newest dotnet client (2.1.300-preview3-008384), when I publish certain templates, it leaves a dangling process. I am using `/p:UseSharedCompilation=false` to prevent the shared compiler from starting and it works for most templates. The template I have been able to confirm this issue with is \"mvc\"\r\n\r\nBased on the [\"size on disk\" Jenkins build](https://ci2.dot.net/job/dotnet_coreclr/job/perf/job/master/job/sizeondisk_x64/), this issue was introduced between March 6th and March 15th\r\n\r\n## Steps to reproduce\r\n1. `dotnet new mvc`\r\n2. `dotnet restore`\r\n3. `dotnet publish /p:UseSharedCompilation=false`\r\n4. `ps dotnet`\r\n\r\n## Expected  behavior\r\n`ps dotnet` should not identify any dotnet processes running on the system\r\n\r\n## Actual behavior\r\n`ps dotnet` identifies a single dotnet process running\r\n\r\n## Environment data\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300-preview3-008384\r\n Commit:    4343118151\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Temp\\sod257e8f47-5ab3\\.dotnet\\sdk\\2.1.300-preview3-008384\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0-preview3-26319-04\r\n  Commit:  939333dbc8\r\n\r\n.NET Core SDKs installed:\r\n  2.1.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.4-preview-007239 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.4 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100-preview-007354 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100-preview-007363 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100-preview-007391 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300-preview3-008384 [C:\\Temp\\sod257e8f47-5ab3\\.dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0-preview2-30338 [C:\\Temp\\sod257e8f47-5ab3\\.dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0-preview2-30338 [C:\\Temp\\sod257e8f47-5ab3\\.dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0-preview2-26313-01 [C:\\Temp\\sod257e8f47-5ab3\\.dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0-preview3-26319-04 [C:\\Temp\\sod257e8f47-5ab3\\.dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n```"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7403652291","Type":"PullRequestEvent","CreatedAt":"2018-03-19T23:59:35","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/685","RelatedDescription":"Opened pull request \"Add options to control package trimming level, dgml, and hide trimming items\" (#685) at dotnet/standard","RelatedBody":"Fixes #680\r\n\r\n/cc @jnm2"},{"Id":"7396992039","Type":"IssuesEvent","CreatedAt":"2018-03-18T17:52:34","Actor":"Petermarcu","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/684","RelatedDescription":"Opened issue \"System.AppContext.GetData is in netstandard1.6 but not net462\" (#684) at dotnet/standard","RelatedBody":"@nothrow commented on [Fri Feb 23 2018](https://github.com/dotnet/core/issues/1281)\n\n# Issue Title\r\n\r\nSome .NET Standard calls are not implemented as expected in .NET Framework\r\n\r\n# General\r\n\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.appcontext.getdata?view=netstandard-1.6#System_AppContext_GetData_System_String_\r\n\r\nHere, it says that AppContext.GetData is supported in NetStandard 1.6, 2.0, but .NET Framework 4.7.\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/net-standard\r\n\r\nthis one says, that .NET 461 is fully supporting .NET Standard 2.0.\r\n\r\nI have application, that is compiled as .NET Standard library, and then is expected to be called from some kind of service host, that is either net462, or netcoreapp (based on platform it is running on). However, some of the libraries (Microsoft.Extensions.DependencyModel) for netstandard uses this call.\r\n\n\n---\n\n@svick commented on [Fri Feb 23 2018](https://github.com/dotnet/core/issues/1281#issuecomment-368089059)\n\nThis is expected. .Net Framework 4.6.1 behaves as if it supported .Net Standard 2.0 and it does support the vast majority of it, but not everything. Specifically, it does not support APIs that were added in .Net Standard 1.5 and 1.6.\r\n\r\nFor more details, see [.NET Framework 4.6.1 supporting .NET Standard 2.0](https://github.com/dotnet/standard/tree/master/docs/netstandard-20#net-framework-461-supporting-net-standard-20).\r\n\r\nAs for your specific case, Microsoft.Extensions.DependencyModel 2.0.4 has versions for .Net Framework 4.5.1, .Net Standard 1.3 and .Net Standard 1.6. How exactly are you distributing your application/library? Maybe there's a way to use the .Net Framework 4.5.1 version of Microsoft.Extensions.DependencyModel from your .Net Framework 4.6.2 host?\n\n---\n\n@nothrow commented on [Thu Mar 01 2018](https://github.com/dotnet/core/issues/1281#issuecomment-369511734)\n\nThanks for the link, I missed this specific document. \r\n\r\n> Considering the number of APIs that .NET Framework 4.6.1 will not support is low and that these are all brand-new APIs with low adoption we believe this is a much better trade-off.\r\n\r\nThis is kind of unfortunate, since the brand new API is used by ASP.NET Core, so eventually anyone wanting to combine netstandard + full framework with web will probably hit the wall here.\r\n\r\nI had troubles with 4.5.1 version, so I ended up with shipping my own forked version of DependencyModel. \r\n\r\nJust a suggestion, there is bunch of #if DOTNETCORE s  in `Microsoft.Extensions.DependencyModel`. Wouldn't it make sense to have libraries with #ifs in `runtime/`, so the correct one will be resolved, based on framework at run-time, not at compile-time?\r\n\r\n\n\n---\n\n@svick commented on [Thu Mar 01 2018](https://github.com/dotnet/core/issues/1281#issuecomment-369566176)\n\n> eventually anyone wanting to combine netstandard + full framework with web will probably hit the wall here\r\n\r\nI don't think so, that's what the .Net Framework 4.5.1 version is for. I think you're in a special situation, where you're distributing a single DLL to multiple frameworks, so that doesn't help. But most people will be fine.\r\n\r\n> Wouldn't it make sense to have libraries with #ifs in `runtime/`, so the correct one will be resolved, based on framework at run-time, not at compile-time?\r\n\r\nI don't know, I'm not sure that would actually work. You might consider creating a new issue about that in the repo where that code lives: [dotnet/core-setup](https://github.com/dotnet/core-setup).\n\n---\n\n@Petermarcu commented on [Wed Mar 14 2018](https://github.com/dotnet/core/issues/1281#issuecomment-373257629)\n\n@terrajobst , sounds like this one is just unfortunately hitting the small set of API's that fell through the cracks. Anything actionable here? Should we move this to the standard repo or close?\n\n"},{"Id":"7395784656","Type":"IssuesEvent","CreatedAt":"2018-03-18T02:51:21","Actor":"Petermarcu","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/683","RelatedDescription":"Opened issue \"netstandard2.0 library, dependent on Microsoft.Win32.Registry, doesn't work from net471 when loaded via MEF\" (#683) at dotnet/standard","RelatedBody":"@jherby2k commented on [Wed Feb 28 2018](https://github.com/dotnet/core/issues/1311)\n\n# Issue Title\r\n\r\nI'm building a .net standard 2.0 library that uses MEF to load extensions. The MEF parts are also .net standard 2.0.\r\n\r\nEverything works fine when called from netcore2.0 test project. But if i have the test project also target net471, calls to Microsoft.Win32.Registry from the MEF part fail (Registry.LocalMachine returns null). I assume this is because Microsoft.Win32.Registry has a net461-specific library that isn't present.\r\n\r\nI see this problem doesn't exist if, instead of using MEF, i just directly depend on the part. I imagine MEF prevents the framework-specific dependencies from flowing through correctly. Any suggestions?\r\n\r\n# General\r\n\r\nYou can repro this by cloning https://github.com/jherby2k/AudioWorks.git then changing the AudioWorks.Api.Tests projects to also target net471. Tests using the AudioWorks.Extensions.Apple extension will fail because it can't read the registry.\n\n"},{"Id":"7395546948","Type":"IssuesEvent","CreatedAt":"2018-03-17T23:21:04","Actor":"RussKeldorph","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/682","RelatedDescription":"Opened issue \".Net Standard 2.1?\" (#682) at dotnet/standard","RelatedBody":"_From @jherby2k on March 7, 2018 19:35_\n\nI can't find any information about a .net standard 2.1.\r\n\r\nI really want to use the new Span-ified methods like Stream.Read in my class libraries, but it looks like that stuff isn't in System.Memory but rather the .net core 2.1 SDK. Any other way to get these APIs, or do I have to wait for .net standard 2.1. And is there any ETA on that?\n\n_Copied from original issue: dotnet/coreclr#16806_"},{"Id":"7393599747","Type":"PullRequestEvent","CreatedAt":"2018-03-16T23:57:53","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/681","RelatedDescription":"Opened pull request \"Update BuildTools to preview3-02616-02 (master)\" (#681) at dotnet/standard","RelatedBody":""}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7404543565","Type":"IssuesEvent","CreatedAt":"2018-03-20T05:30:06","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/28236","RelatedDescription":"Closed issue \"Rename string-like Span.Equals method to SequenceEqual\" (#28236) at dotnet/corefx","RelatedBody":"We have the following string-like extension method for `ReadOnlySpan<char>`:\r\n```C#\r\npublic static bool Equals(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType)\r\n```\r\n\r\nHowever, due to its name, we are unable to leverage the implicit cast from string to `ReadOnlySpan<char>`. The following code throws a compiler error since it fails to match the correct overload.\r\n```C#\r\nstring test = \"Hello World!\";\r\nReadOnlySpan<char> span = new char[100];\r\nbool result = span.Equals(test, StringComparison.Ordinal);\r\n// Current workarounds - specify the type explicitly or call AsSpan:\r\n// bool result = span.Equals((ReadOnlySpan<char>)test, StringComparison.Ordinal);\r\n// bool result = span.Equals(test.AsSpan(), StringComparison.Ordinal);\r\n// bool result = MemoryExtensions.Equals(span, test, StringComparison.Ordinal);\r\n```\r\n\r\nError\tCS0176\tMember 'object.Equals(object, object)' cannot be accessed with an instance reference; qualify it with a type name instead\r\n\r\nShould we rename the method to SequenceEqual instead?\r\n\r\nWe already have a SequenceEqual method (which only takes a single argument), which means, we would end up with a non-generic overload, specific to `ReadOnlySpan<char>`.\r\n\r\n```C#\r\npublic static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : System.IEquatable<T> {}\r\npublic static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : System.IEquatable<T> {}\r\n// ADD:\r\npublic static bool SequenceEqual(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType) {}\r\n```\r\n\r\nThe alternative of adding an Equals overload that takes `string` as the argument will not work in resolving the overload matching issue.\r\n\r\nOther alternatives for names:\r\n- EqualsTo\r\n\r\ncc @KrzysztofCwalina, @terrajobst, @VSadov "},{"Id":"7404468748","Type":"PullRequestEvent","CreatedAt":"2018-03-20T04:59:36","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28225","RelatedDescription":null,"RelatedBody":"Fixes: https://github.com/dotnet/corefx/issues/28209\r\n\r\ncc: @danmosemsft @vancem @jkotas @stephentoub "},{"Id":"7404443400","Type":"PullRequestEvent","CreatedAt":"2018-03-20T04:48:45","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/28225","RelatedDescription":"Closed pull request \"Break hangs on HashSet when a loop is formed on entries due to a concurrent operation\" (#28225) at dotnet/corefx","RelatedBody":"Fixes: https://github.com/dotnet/corefx/issues/28209\r\n\r\ncc: @danmosemsft @vancem @jkotas @stephentoub "},{"Id":"7404284143","Type":"IssuesEvent","CreatedAt":"2018-03-20T03:44:02","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/28238","RelatedDescription":"Opened issue \"Consolidate the string and span tests for the string-like APIs\" (#28238) at dotnet/corefx","RelatedBody":"See https://github.com/dotnet/corefx/pull/27319#discussion_r170049466 for additional details and context.\r\n\r\nThis way, all the tests will be in one place making it easier to maintain, rather than duplicated between assemblies. Consider moving them to Common as well and reference from System.Memory.csproj so that running System.Memory tests will run all the span related tests.\r\n\r\ncc @tarekgh "},{"Id":"7404204955","Type":"PullRequestEvent","CreatedAt":"2018-03-20T03:14:38","Actor":"GrabYourPitchforks","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28237","RelatedDescription":"Opened pull request \"Don't run LargeArray test on 32 bit platforms.\" (#28237) at dotnet/corefx","RelatedBody":"Fixes https://github.com/dotnet/corefx/issues/28205."},{"Id":"7404200921","Type":"IssuesEvent","CreatedAt":"2018-03-20T03:13:09","Actor":"yaakov-h","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/28188","RelatedDescription":"Closed issue \"ConcurrentDictionary<,>.IsEmpty is barely faster than checking Count\" (#28188) at dotnet/corefx","RelatedBody":"I would assume that a specialist method named `IsEmpty` is significantly faster than simply obtaining the `Count` of a `ConcurrentDictionary<,>`, yet it appears to be just a touch slower.\r\n\r\nx-ref https://github.com/WiseTechGlobal/WTG.Analyzers/pull/23#issuecomment-374116037\r\n\r\nSimilar to the benchmark in the linked above, here's a benchmark comparing an empty dictionary to one containing 1,200 items.\r\n\r\nI would expect `Empty_IsEmpty` to take roughly the same amount of time as `Contents_IsEmpty`, but it appears to scale up similarly to testing against `Count`.\r\n\r\n```\r\n// * Summary *\r\n\r\nBenchmarkDotNet=v0.10.13, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.309)\r\nIntel Core i5-7600K CPU 3.80GHz (Kaby Lake), 1 CPU, 4 logical cores and 4 physical cores\r\nFrequency=3703123 Hz, Resolution=270.0423 ns, Timer=TSC\r\n.NET Core SDK=2.1.100-preview-007326\r\n  [Host]     : .NET Core 2.0.5 (CoreCLR 4.6.26020.03, CoreFX 4.6.26018.01), 64bit RyuJIT\r\n  DefaultJob : .NET Core 2.0.5 (CoreCLR 4.6.26020.03, CoreFX 4.6.26018.01), 64bit RyuJIT\r\n\r\n\r\n           Method |        Mean |     Error |    StdDev |  Gen 0 | Allocated |\r\n----------------- |------------:|----------:|----------:|-------:|----------:|\r\n    Empty_IsEmpty |    67.29 ns | 0.0808 ns | 0.0716 ns |      - |       0 B |\r\n      Empty_Count |    67.49 ns | 0.0255 ns | 0.0199 ns |      - |       0 B |\r\n    Empty_LinqAny |   180.82 ns | 0.1109 ns | 0.0926 ns | 0.0203 |      64 B |\r\n Contents_IsEmpty | 3,907.88 ns | 1.8701 ns | 1.7493 ns |      - |       0 B |\r\n   Contents_Count | 4,129.74 ns | 1.5337 ns | 1.3596 ns |      - |       0 B |\r\n Contents_LinqAny |    42.68 ns | 0.0471 ns | 0.0417 ns | 0.0203 |      64 B |\r\n\r\n```\r\n\r\nIs `IsEmpty` actually doing anything special or could the implementation just about be replaced with:\r\n\r\n```csharp\r\npublic bool IsEmpty => Count == 0;\r\n```\r\n\r\n?\r\n\r\nI don't actually see a huge difference in the two implementations."},{"Id":"7404134429","Type":"IssuesEvent","CreatedAt":"2018-03-20T02:49:55","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/28236","RelatedDescription":"Opened issue \"Rename string-like Span.Equals method to SequenceEqual\" (#28236) at dotnet/corefx","RelatedBody":"We have the following string-like extension method for `ReadOnlySpan<char>`:\r\n```C#\r\npublic static bool Equals(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)\r\n```\r\n\r\nHowever, due to its name, we are unable to leverage the implicit cast from string to `ReadOnlySpan<char>`. The following code throws a compiler error since it fails to match the correct overload.\r\n```C#\r\nstring test = \"Hello World!\";\r\nReadOnlySpan<char> span = new char[100];\r\nbool result = span.Equals(test, StringComparison.Ordinal);\r\n// Current workarounds - specify the type explicitly or call AsSpan:\r\n// bool result = span.Equals((ReadOnlySpan<char>)test, StringComparison.Ordinal);\r\n// bool result = span.Equals(test.AsSpan(), StringComparison.Ordinal);\r\n```\r\n\r\nError\tCS0176\tMember 'object.Equals(object, object)' cannot be accessed with an instance reference; qualify it with a type name instead\r\n\r\nShould we rename the method to SequenceEqual instead?\r\n\r\nWe already have a SequenceEqual method (which only takes a single argument), which means, we would end up with a non-generic overload, specific to `ReadOnlySpan<char>`.\r\n\r\n```C#\r\npublic static bool SequenceEqual<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second) where T : System.IEquatable<T> {}\r\npublic static bool SequenceEqual<T>(this Span<T> first, ReadOnlySpan<T> second) where T : System.IEquatable<T> {}\r\n// ADD:\r\npublic static bool SequenceEqual(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType) {}\r\n```\r\n\r\ncc @KrzysztofCwalina, @terrajobst, @VSadov "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7404486920","Type":"IssuesEvent","CreatedAt":"2018-03-20T05:07:02","Actor":"KirillOsenkov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/25612","RelatedDescription":"Opened issue \"Decompiler should add a file header on top like Metadata As Source\" (#25612) at dotnet/roslyn","RelatedBody":"Decompiled files should have a comment header on top like Metadata As Source, containing the full path to the assembly being decompiled.\r\n\r\nThis feature of Metadata As Source is incredibly useful and without it I really don't know how to determine which assembly the symbol is defined in."},{"Id":"7404482738","Type":"IssuesEvent","CreatedAt":"2018-03-20T05:05:19","Actor":"KirillOsenkov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/25611","RelatedDescription":"Opened issue \"QuickInfo should display the assembly and namespace where the symbol is defined\" (#25611) at dotnet/roslyn","RelatedBody":"To make QuickInfo more useful, consider adding these two items to the display:\r\n 1. assembly or project where the symbol is defined\r\n 2. namespace\r\n\r\nOf course this is probably not needed for locals, parameters and direct members of the current class.\r\nFor partial class maybe mention the file name if the symbol is in another part of a partial class.\r\n\r\nOtherwise to find the assembly I used to F12 or Alt+F12 to go to Metadata as Source, which very helpfully displays the assembly, but now with decompilation we lost that."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7402479763","Type":"PullRequestEvent","CreatedAt":"2018-03-19T19:28:09","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5578","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#5578) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7402406696","Type":"PullRequestEvent","CreatedAt":"2018-03-19T19:13:20","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5578","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#5578) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7402071044","Type":"PullRequestEvent","CreatedAt":"2018-03-19T18:09:37","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5577","RelatedDescription":"Merged pull request \"Merge master to nmirror\" (#5577) at dotnet/corert","RelatedBody":""},{"Id":"7402070080","Type":"PullRequestEvent","CreatedAt":"2018-03-19T18:09:25","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5577","RelatedDescription":"Opened pull request \"Merge master to nmirror\" (#5577) at dotnet/corert","RelatedBody":""},{"Id":"7402065604","Type":"PullRequestEvent","CreatedAt":"2018-03-19T18:08:35","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5576","RelatedDescription":"Merged pull request \"Fix ProjectN build break and work around MCG bug\" (#5576) at dotnet/corert","RelatedBody":"Unblocks integration to TFS."},{"Id":"7401734790","Type":"PullRequestEvent","CreatedAt":"2018-03-19T17:10:19","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5576","RelatedDescription":"Opened pull request \"Fix ProjectN build break and work around MCG bug\" (#5576) at dotnet/corert","RelatedBody":"Unblocks integration to TFS."},{"Id":"7401572912","Type":"IssuesEvent","CreatedAt":"2018-03-19T16:43:34","Actor":"kbaladurin","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5575","RelatedDescription":"Opened issue \"Static members debug information\" (#5575) at dotnet/corert","RelatedBody":"How can I get value of the class's static member in VS?\r\nSample:\r\n```cs\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nclass Program\r\n{\r\n    public static int s_int = 10;\r\n\tpublic static int[] s_arr = new int[10];\r\n\tpublic int a = 42;\r\n\r\n    static int Main()\r\n    {\r\n        var a = new Program();\r\n\tProgram.s_int = 20;\r\n        return 0;\r\n    }\r\n}\r\n```\r\nResult (Immediate Window):\r\n```\r\na\r\n{a=42 }\r\n    Object: {m_pEEType=0x00007ff60c59c1c0 {BasicThreading.exe!const BasicThreading_Program::`vftable'} }\r\n    __vfptr: <Unable to read memory>\r\n    a: 42\r\na.__NONGCSTATICS\r\nclass \"BasicThreading_Program\" has no member \"__NONGCSTATICS\"\r\na.__GCSTATICS\r\nclass \"BasicThreading_Program\" has no member \"__GCSTATICS\"\r\n```\r\n\r\nThank you!"},{"Id":"7401181889","Type":"PullRequestEvent","CreatedAt":"2018-03-19T15:42:26","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5571","RelatedDescription":"Merged pull request \"Objwriter: fix warnings\" (#5571) at dotnet/corert","RelatedBody":"- Delete unused variable in SubprogramInfo::DumpEHClauses\r\n- Fix narrowing conversions in DwarfAbbrev::Dump\r\n\r\nIt fixes https://github.com/dotnet/corert/issues/5567"},{"Id":"7400659292","Type":"PullRequestEvent","CreatedAt":"2018-03-19T14:24:25","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5552","RelatedDescription":"Merged pull request \"Fix automatic rebuild of the objwriter project\" (#5552) at dotnet/corert","RelatedBody":""}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7403188040","Type":"PullRequestEvent","CreatedAt":"2018-03-19T21:51:27","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/pull/2053","RelatedDescription":"Closed pull request \"Merge release/2.1.2xx to release/2.1.3xx\" (#2053) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.2xx into release/2.1.3xx.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.2xx-to-release/2.1.3xx\ngit reset --hard upstream/release/2.1.3xx\ngit merge upstream/release/2.1.2xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.2xx-to-release/2.1.3xx --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7402628474","Type":"IssuesEvent","CreatedAt":"2018-03-19T19:58:37","Actor":"natemcmaster","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2065","RelatedDescription":"Opened issue \"Add codes to MSBuild warnings and errors\" (#2065) at dotnet/sdk","RelatedBody":"Follow-up to this: https://github.com/dotnet/sdk/pull/2064#discussion_r175557190\r\n\r\nMost MSBuild warnings and errors issued by this SDK do not have error codes. We should add codes to all of them."},{"Id":"7402250811","Type":"PullRequestEvent","CreatedAt":"2018-03-19T18:43:16","Actor":"natemcmaster","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/2064","RelatedDescription":"Opened pull request \"Issue a warning on restore about obsolete DotNetCliToolReference\" (#2064) at dotnet/sdk","RelatedBody":"Resolves #2014 \r\n\r\nI will make a corresponding change to dotnet/cli to generate Microsoft.NETCoreSdk.BundledCliTools.props with a list of obsolete package IDs to match https://github.com/dotnet/cli/blob/master/build/BundledDotnetTools.props.\r\n\r\nVS:\r\n\r\n![image](https://user-images.githubusercontent.com/2696087/37615207-eeb0e088-2b69-11e8-9a11-86c8e3a67ff6.png)\r\n\r\nCommand line:\r\n\r\n![image](https://user-images.githubusercontent.com/2696087/37615256-100ade78-2b6a-11e8-9c78-a9420f76c85d.png)\r\n\r\nFYI @muratg @DamianEdwards @prafullbhosale @divega @bricelam @Eilon "},{"Id":"7401626016","Type":"PullRequestEvent","CreatedAt":"2018-03-19T16:52:12","Actor":"livarcocc","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/2063","RelatedDescription":"Opened pull request \"Updating SDK branding to 2.1.300-preview3\" (#2063) at dotnet/sdk","RelatedBody":""}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"975544139893825536","CreatedAt":"2018-03-19T01:27:02+00:00","UserScreenname":"dotnet","Text":"We agree with this sentiment very much! We often retweet blog posts that came to our attention. While it doesn't im… https://t.co/GtFpUrShX8","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":26,"FavoriteCount":5,"RawContent":null},{"Id":"974694823067246592","CreatedAt":"2018-03-16T17:12:09+00:00","UserScreenname":"dotnet","Text":"Check out the latest On .NET show with @jeremylikness &amp; @jplane talking .NET Core and containers. #dotnetcore https://t.co/NfFbKIsLTw","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":33,"FavoriteCount":18,"RawContent":null},{"Id":"974414421245095936","CreatedAt":"2018-03-15T22:37:56+00:00","UserScreenname":"dotnet","Text":"Transport Layer Security (TLS) best practices with the .NET Framework article published https://t.co/SbAZXvK8n7 #security","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":192,"FavoriteCount":98,"RawContent":null},{"Id":"974274431127302145","CreatedAt":"2018-03-15T13:21:40+00:00","UserScreenname":"dotnet","Text":"Tune in to @csharpfritz and @shanselman talking through an #ASP.NET upgrade at 10am ET / 7am PT / 14:00 UTC! https://t.co/WyBUY4oGYv","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":6,"FavoriteCount":6,"RawContent":null},{"Id":"974176533270036480","CreatedAt":"2018-03-15T06:52:39+00:00","UserScreenname":"dotnet","Text":"Exciting news! https://t.co/wgCtuUTXcr","Source":"<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>","RetweetCount":71,"FavoriteCount":33,"RawContent":null}]}},"RunOn":"2018-03-20T05:30:21.1490236Z","RunDurationInMilliseconds":7761}