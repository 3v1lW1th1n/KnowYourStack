{"Data":{"Blog":{"FeedItems":[{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":69,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803)","PublishedOn":"2018-05-24T01:49:57+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/23/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-april-2018-update-version-1803/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update)","PublishedOn":"2018-05-21T22:44:05+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/21/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-1709-fall-creators-update/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10","PublishedOn":"2018-05-17T17:20:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1703 (Creators Update) and Windows 10 1607 (Anniversary Update). Quality and Reliability This release contains the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/17/net-framework-may-2018-preview-of-quality-rollup-for-windows-10/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup","PublishedOn":"2018-05-15T18:10:24+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup. Quality and Reliability This release contains the following quality and reliability improvements. CLR Resolves an issue in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/15/net-framework-may-2018-preview-of-quality-rollup/","RawContent":null},{"Title":".NET Core May 2018 Update","PublishedOn":"2018-05-08T22:31:30+00:00","CommentsCount":15,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core May 2018 Update. This update includes .NET Core 2.1.200 SDK and ASP.NET Core 2.0.8. Security Microsoft is releasing this security advisory to provide information...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-core-may-2018-update/","RawContent":null},{"Title":".NET Framework May 2018 Security and Quality Rollup","PublishedOn":"2018-05-08T21:18:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Security and Quality Rollup. Security CVE-2018-1039 – Windows Security Feature Bypass Vulnerability A security feature bypass vulnerability exists in Windows which...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-framework-may-2018-security-and-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""},{"Id":"7697516495","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:04:23","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/101","RelatedDescription":"Merged pull request \"Create mlnet.md\" (#101) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7809961019","Type":"PullRequestEvent","CreatedAt":"2018-06-12T03:52:57","Actor":"maryamariyan","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18427","RelatedDescription":"Opened pull request \" Move x86 HW intrinsics files to shared\" (#18427) at dotnet/coreclr","RelatedBody":""},{"Id":"7809818983","Type":"PullRequestEvent","CreatedAt":"2018-06-12T02:58:36","Actor":"tannergooding","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18349","RelatedDescription":"Merged pull request \"Adding containment support to more x86 HWIntrinsics\" (#18349) at dotnet/coreclr","RelatedBody":"FYI. @CarolEidt, @fiigii, @4creators \r\n\r\nThis should resolve https://github.com/dotnet/coreclr/issues/16497\r\n\r\nThe remaining work is to:\r\n* Add additional handling for \"Special Commutative\" intrinsics (such as `Compare*OrderedScalar`)\r\n* Update the MemoryLoad/MemoryStore intrinsics to be GT_Indir, where possible\r\n* Allow some helper intrinsics to be containable themselves (such as `StaticCast`, when it is a non RMW source operand)"},{"Id":"7809818971","Type":"IssuesEvent","CreatedAt":"2018-06-12T02:58:36","Actor":"tannergooding","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/16497","RelatedDescription":"Closed issue \"Ensure all relevant containment paths are handled for the HWIntrinsics\" (#16497) at dotnet/coreclr","RelatedBody":"Currently we are only handling the containment cases for SimpleSIMD/SIMDScalar binary nodes and for the immediate operand in ternary nodes.\r\n\r\nHowever, there are several additional node types for which containment may be relevant.\r\n\r\nWe should update the `ContainCheckHWIntrinsic` method to appropriately use `unreached` to ensure we are handling all node types as expected (they should either be explicitly handled and check if the node can be contained or skipped via the `NoContainment` flag)."},{"Id":"7809545902","Type":"PullRequestEvent","CreatedAt":"2018-06-12T01:16:55","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18426","RelatedDescription":"Opened pull request \"[WIP][test pr] find cases when the cold part does not adjust the hot part.\" (#18426) at dotnet/coreclr","RelatedBody":""},{"Id":"7809505953","Type":"PullRequestEvent","CreatedAt":"2018-06-12T01:01:16","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18424","RelatedDescription":"Merged pull request \"Fix Decimal.NearNegativeZero/NearPositiveZero\" (#18424) at dotnet/coreclr","RelatedBody":"Contributes to #12605, tests are in https://github.com/dotnet/corefx/pull/30291."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7803009293","Type":"IssuesEvent","CreatedAt":"2018-06-10T18:49:51","Actor":"gehnster","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/772","RelatedDescription":"Opened issue \"New HttpStatusCodes\" (#772) at dotnet/standard","RelatedBody":"Would it be possible to get these added to the next release of .NET Standard, from .NET Core.\r\n\r\nhttps://github.com/dotnet/corefx/issues/4382"},{"Id":"7802771531","Type":"IssuesEvent","CreatedAt":"2018-06-10T16:13:31","Actor":"Lexcess","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/771","RelatedDescription":"Opened issue \"[Proposal] Add GC.GetAllocatedBytesForCurrentThread in .Net Standard vNext\" (#771) at dotnet/standard","RelatedBody":"Given the recent focus on reducing allocations in .Net (e.g. the introduction of `Span<>`). I think it would be useful to have a simple tool for tracking allocations on the current thread. I would categorise this similarly to the `Stopwatch `class; yes I could use an external profiler, but having an in process solution is so much more flexible. I want to use something like this for monitoring, unit tests and even sanity-checking refactorings.  \r\n\r\nThe good news is that `GetAllocatedBytesForCurrentThread` was added to .Net Core CLR a while back now (see dotnet/corefx#10157 and https://github.com/dotnet/corefx/pull/12489 ), and it offers a robust model to follow.\r\n\r\nThe bad news is that the other runtime GC's don't currently have similar implementations and given GC differences the code probably can't be ported straight over. \r\n\r\nI understand that there is a higher cost implied by adding API's to the Standard that don't currently have obvious implementations for each runtime, but I do think this is an area where there will be growing interest in such an API. For example on Mono where allocations are critical to the performance of games and mobile apps.\r\n\r\nFurthermore there are already some people in the wild attempting cross runtime solutions, but it is a lot of hoops even when .Net Core is in play. See for example what Benchmark.Net is having to do right now: [Benchmark.Net/GCStats.cs](https://github.com/dotnet/BenchmarkDotNet/blob/master/src/BenchmarkDotNet/Engines/GcStats.cs)). Adding `GetAllocatedBytesForCurrentThread` to the standard would ease this immediate issue and give the opportunity for the other runtimes to add valuable diagnostic information in the future (with `PlatformNotSupportedException`s perhaps being the cost in the interim)."},{"Id":"7802434780","Type":"IssuesEvent","CreatedAt":"2018-06-10T12:33:45","Actor":"panost","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/770","RelatedDescription":"Opened issue \"[Question] Nullable Ref Types\" (#770) at dotnet/standard","RelatedBody":"I don't ask if are they plans for it, but if it is possible (for technological POV) to support Nullable Ref Types (C# 8.0) annotations even if none of the supported frameworks has them?\r\n\r\nFor example String.Replace to be defined in .NET Standard as \r\n\r\n> public string String.Replace(string oldValue,string? newValue);\r\n\r\neven if none of the supported frameworks has this annotation ?\r\n"},{"Id":"7799259998","Type":"PullRequestEvent","CreatedAt":"2018-06-08T21:18:26","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/769","RelatedDescription":"Opened pull request \"Update BuildTools to preview1-02908-01 (master)\" (#769) at dotnet/standard","RelatedBody":""},{"Id":"7797761610","Type":"PullRequestEvent","CreatedAt":"2018-06-08T15:45:42","Actor":"mairaw","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/768","RelatedDescription":"Opened pull request \"Update version\" (#768) at dotnet/standard","RelatedBody":""}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7810055745","Type":"PullRequestEvent","CreatedAt":"2018-06-12T04:33:19","Actor":"wfurt","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30312","RelatedDescription":"Opened pull request \"fix dereferencing uninitialized byte array in case recv() fails\" (#30312) at dotnet/corefx","RelatedBody":"fixes #29376 [arm32/Ubuntu] corefx test failures: System.Net.NetworkInformation.Functional.Tests, System.Net.Sockets.Tests\r\n\r\nrelated to #27411 Re-enable initlocals clearing in System.Net.Sockets on Unix\r\n\r\nWe disabled initialization of local variables for sockets. We pass buffer allocated via stackalloc() to get ancillary data. When recv() call fails (like with EAGAIN) the buffer is uninitialized and it is not safe to parse it and use data or pointers from it. This does not seems ARM specific bug. X86 may be just more lucky getting stack full of zeros. My initial POC was to initialize control buffer (24b) to zeros.so \r\nThat fixes the crash as well (by fining first message has 0 length) but I think this fix is better. \r\nIt would be nice IMHO if we do not need to allocate ipPacketInformation but that is beyond this fix. \r\n\r\nI also briefly scan for other use of stackalloc() in sockets and the other place looks reasonable. \r\n\r\nI re-run all (outerloop) test on ARM system and I see no crash. Four tests timed out - but the ARM system  is MUCH slower so this may not be sign of real problem. \r\n\r\n"},{"Id":"7810031755","Type":"IssuesEvent","CreatedAt":"2018-06-12T04:22:39","Actor":"murray-grant-fe","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30311","RelatedDescription":"Opened issue \"HttpRequestException when creating empty key in AWS S3\" (#30311) at dotnet/corefx","RelatedBody":"Hello,\r\n\r\nI'm getting a `System.Net.Http.HttpRequestException` after an AWS S3 PUT operation. I'm trying to create an S3 \"folder\" (ie: an empty object) usign the AWS SDK for S3. The folder itself is successfully created. The error happens on every request. Environment is ASP.NET Core 2.1, Windows 10 (dev computer).\r\n\r\nI'm currently working around this by catching the exception and re-querying the S3 key to confirm creation. But something looks very out of place. And surely AWS is so heaveily used that this bug is would be rampent! (Which makes me wonder if this is something special or unusual). The stack dump is pointing at `HttpConnection.SendAsyncCore()`, so I don't think this is Amazon's fault.\r\n\r\nI've checked in [HttpConnection.SendAsyncCore()](https://github.com/dotnet/corefx/blob/02b11fae98fd2d6662e1c490cae8462b0ce1ecdf/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/HttpConnection.cs) but that method is.... complex. And the places where `ThrowInvalidHttpResponse()` is called don't obviously correspond to anythign wrong with the HTTP response.\r\n\r\nFrom the HTTP response, the only error I can see is it's *200 OK* rather than *204 Empty*. Other corefx issues raised with this exception have missing headers or extra whitespace or missing colons, but the headers all look OK to me.\r\n\r\nIt would also be nice for the exception to \"tag\" which site it is thrown from, given there are ~15 possible places in HttpConnection.cs. Even if its an error number or short code, anything to narrow down the exact throw!\r\n\r\nRegards\r\nMurray\r\n\r\n**HTTP Request**\r\n\r\n```\r\nPUT https://circuitlink-bt.s3.ap-southeast-2.amazonaws.com/_Unprocessed/BTR12357/FIRMWARE/ HTTP/1.1\r\nExpect: 100-continue\r\nUser-Agent: aws-sdk-dotnet-coreclr/3.3.18.3 aws-sdk-dotnet-core/3.3.24.0 .NET_Core/4.6.26515.07 OS/Microsoft_Windows_10.0.16299 ClientAsync\r\nHost: circuitlink-bt.s3.ap-southeast-2.amazonaws.com\r\nX-Amz-Date: 20180612T023113Z\r\nX-Amz-Content-SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\r\nAuthorization: AWS4-HMAC-SHA256 Credential=[redacted]/20180612/ap-southeast-2/s3/aws4_request, SignedHeaders=content-length;content-type;host;user-agent;x-amz-content-sha256;x-amz-date, Signature=[redacted]\r\nContent-Length: 0\r\nContent-Type: text/plain\r\n```\r\n\r\n**HTTP Response**\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nx-amz-id-2: VECzyxSK/10lyVcQQickFaiZxvDpNRQiUKhUXN2IHQJD6OpJ+pJWGXvimA0YjeZlcKFwGJisoEU=\r\nx-amz-request-id: 7CB4D3B7B2438CA0\r\nDate: Tue, 12 Jun 2018 02:31:15 GMT\r\nETag: \"d41d8cd98f00b204e9800998ecf8427e\"\r\nContent-Length: 0\r\nServer: AmazonS3\r\n```\r\n\r\n**Client Code**\r\n\r\n```\r\npublic async Task CreateDirectory(string relativePath)\r\n{\r\n\t// relativePath = \"FIRMWARE\"\r\n    var putRequest = new PutObjectRequest();\r\n    putRequest.BucketName = _Config.BucketName;\t\t// = \"circuitlink-bt\"\r\n    putRequest.Key = (String.IsNullOrEmpty(_Config.BasePath) ? \"\" : _Config.BasePath + \"/\")\t\t// BasePath = \"_Unprocessed\"\r\n                + relativePath + \"/\";       // Need trailing slash to create a folder.\r\n    putRequest.ContentBody = \"\";\r\n    Logger.Debug(\"Creating directory '{0}' in S3 bucket '{1}'.\", putRequest.Key, putRequest.BucketName);\r\n\t// Logs: Creating directory '_Unprocessed/BTR12357/FIRMWARE/' in S3 bucket 'circuitlink-bt'.\r\n    PutObjectResponse response;\r\n    try\r\n    {\r\n        response = await _S3Client.PutObjectAsync(putRequest);\r\n\t\t// Next line is never hit.\r\n        Logger.Debug(\"Created directory '{0}' in S3 bucket '{1}' successfully.\", putRequest.Key, putRequest.BucketName);\r\n    }\r\n    catch (System.Net.Http.HttpRequestException ex)\r\n    {\r\n        Logger.Error(ex, \"Exception while creating S3 directory '{0}' in S3 bucket '{1}'.\", putRequest.Key, putRequest.BucketName);\r\n\t\t// Logs: Exception while creating S3 directory '_Unprocessed/BTR12357/FIRMWARE/' in S3 bucket 'circuitlink-bt'.\r\n\t\t// Stack dump below.\r\n        throw;\r\n    }\r\n}\r\n```\r\n\r\n**Exception and Stack Dump**\r\n\r\n```\r\n13:57:36.6|DEBUG| | 4: | CL.BTCloud.Services.AWS.DeviceServerStorage.DeviceServerStorageOnS3 | http://localhost/api/register/BTC| HttpRequestException while creating S3 directory '_Unprocessed/BTR12357/FIRMWARE/' in S3 bucket 'circuitlink-bt'. System.Net.Http.HttpRequestException: The server returned an invalid or unrecognized response.\r\n   at System.Net.Http.HttpConnection.ThrowInvalidHttpResponse()\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncUnbuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)\r\n   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\\JenkinsWorkspaces\\v3-trebuchet-release\\AWSDotNetPublic\\sdk\\src\\Core\\Amazon.Runtime\\Pipeline\\HttpHandler\\_mobile\\HttpRequestMessageFactory.cs:line 428\r\n   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\\JenkinsWorkspaces\\v3-trebuchet-release\\AWSDotNetPublic\\sdk\\src\\Core\\Amazon.Runtime\\Pipeline\\HttpHandler\\HttpHandler.cs:line 175\r\n   at Amazon.Runtime.Internal.RedirectHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.S3.Internal.AmazonS3ResponseHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\\JenkinsWorkspaces\\v3-trebuchet-release\\AWSDotNetPublic\\sdk\\src\\Core\\Amazon.Runtime\\Pipeline\\Handlers\\CredentialsRetriever.cs:line 98\r\n   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\\JenkinsWorkspaces\\v3-trebuchet-release\\AWSDotNetPublic\\sdk\\src\\Core\\Amazon.Runtime\\Pipeline\\RetryHandler\\RetryHandler.cs:line 137\r\n   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.S3.Internal.AmazonS3ExceptionHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)\r\n   at CL.BTCloud.Services.AWS.DeviceServerStorage.DeviceServerStorageOnS3.CreateDirectory(String relativePath) in C:\\Projects\\CircuitLink\\Intelligo\\Braketesta\\Shared\\BTCloud.Services.AWS\\DeviceServerStorage\\DeviceServerStorageOnS3.cs:line 47\r\n```"},{"Id":"7809968774","Type":"IssuesEvent","CreatedAt":"2018-06-12T03:56:03","Actor":"wfurt","Repository":"dotnet/","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30169","RelatedDescription":"Closed issue \"CheckRawSocketPermissions() always fails for IPv6 on Unix and we fall back to executing ping6 utility as new process.\" (#30169) at dotnet/","RelatedBody":"Consider simple \"ping\" program:\r\n\r\n```c#\r\nusing System.Net.NetworkInformation;\r\n\r\nnamespace Test\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {            \r\n            using (Ping pinger = new Ping())\r\n            {\r\n                string dst = \"2607:f8b0:400a:800::200e\";\r\n                PingReply reply = pinger.SendPingAsync(dst, 5000, new byte[] { 0xff }, new PingOptions(3, false)).Result;\r\n                Console.WriteLine($\"status: {reply.Status} address: {reply.Address}\");\r\n                Console.ReadLine();\r\n            }\r\n       }\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ strace -f -t -e network ~/latest/dotnet run\r\n[pid  7527] 08:49:30 socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6) = -1 EPERM (Operation not permitted)\r\n```\r\n\r\nThis is expected. We try to open RAW socket and if that fails we will do ping by starting new process and using system binary. \r\n\r\nNow, try same command with sufficient priviledge\r\n\r\n```\r\n$ sudo strace -f -t -e network ~/latest/dotnet run\r\n[pid  7822] 08:56:05 socket(PF_INET6, SOCK_RAW|SOCK_CLOEXEC, IPPROTO_ICMP) = 28\r\n[pid  7822] 08:56:05 setsockopt(28, SOL_IPV6, IPV6_V6ONLY, [1], 4) = -1 EINVAL (Invalid argument)\r\n```"},{"Id":"7809968774","Type":"IssuesEvent","CreatedAt":"2018-06-12T03:56:03","Actor":"wfurt","Repository":"dotnet/","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30169","RelatedDescription":"Closed issue \"CheckRawSocketPermissions() always fails for IPv6 on Unix and we fall back to executing ping6 utility as new process.\" (#30169) at dotnet/","RelatedBody":"Consider simple \"ping\" program:\r\n\r\n```c#\r\nusing System.Net.NetworkInformation;\r\n\r\nnamespace Test\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {            \r\n            using (Ping pinger = new Ping())\r\n            {\r\n                string dst = \"2607:f8b0:400a:800::200e\";\r\n                PingReply reply = pinger.SendPingAsync(dst, 5000, new byte[] { 0xff }, new PingOptions(3, false)).Result;\r\n                Console.WriteLine($\"status: {reply.Status} address: {reply.Address}\");\r\n                Console.ReadLine();\r\n            }\r\n       }\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ strace -f -t -e network ~/latest/dotnet run\r\n[pid  7527] 08:49:30 socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6) = -1 EPERM (Operation not permitted)\r\n```\r\n\r\nThis is expected. We try to open RAW socket and if that fails we will do ping by starting new process and using system binary. \r\n\r\nNow, try same command with sufficient priviledge\r\n\r\n```\r\n$ sudo strace -f -t -e network ~/latest/dotnet run\r\n[pid  7822] 08:56:05 socket(PF_INET6, SOCK_RAW|SOCK_CLOEXEC, IPPROTO_ICMP) = 28\r\n[pid  7822] 08:56:05 setsockopt(28, SOL_IPV6, IPV6_V6ONLY, [1], 4) = -1 EINVAL (Invalid argument)\r\n```"},{"Id":"7809874468","Type":"PullRequestEvent","CreatedAt":"2018-06-12T03:19:10","Actor":"caesar1995","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30310","RelatedDescription":"Opened pull request \"Improve code coverage for NegoState class\" (#30310) at dotnet/corefx","RelatedBody":"Contributes to #17099\r\n\r\nBefore the PR:\r\n\r\nSystem.Net.Security | 6025 | 2721 | 8746 | 32749 | 68.8% |  55.2%\r\n-- | -- | -- | -- | -- | --  | --\r\nSystem.Net.Security.NegoState | 267 | 229 | 496 | 843 | **_53.8%_** | **_46.5%_**\r\n\r\n\r\nAfter PR:\r\n\r\nSystem.Net.Security | 6311 | 2432 | 8743 | 32744 | 72.1% | 58.1%\r\n-- | -- | -- | -- | -- | --  | --\r\nSystem.Net.Security.NegoState | 392 | 101 | 493 | 838 | _**79.5%**_ | _**71.7%**_\r\n\r\nSummary:\r\n- TODO"},{"Id":"7809736027","Type":"PullRequestEvent","CreatedAt":"2018-06-12T02:28:55","Actor":"davidsh","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30309","RelatedDescription":"Opened pull request \"Add HTTP/2.0 test server\" (#30309) at dotnet/corefx","RelatedBody":"To prepare for the work of adding HTTP/2.0 support to SocketsHttpHandler, I deployed a new Azure\r\nserver. As with all HTTP/2.0 endpoints, only HTTPS (TLS) is supported.\r\n\r\nThis server is based on Azure Web Apps instead of Azure Cloud Services (classic). This makes it\r\neasier to scale out and maintain as well as give us a staging environment to validate upgrades to\r\nthe test server without affecting the production PR/CI runs.\r\n\r\nAlthough the default for HttpClient/HttpRequestMessage.Version is 2.0, only the older platform handler\r\nstacks (WinHttpHandler, CurlHandler, UAP) will send as HTTP/2.0. SocketsHttpHandler is currently just\r\nignoring the version value and using HTTP/1.1 as the request version. When SocketsHttpHandler is\r\nmodified to support HTTP/2.0, then all default requests by HttpClient will attempt HTTP/2.0.\r\nOur existing Azure test server (and loopback server) will still downgrade to HTTP/1.1. But this\r\nnew test server will use HTTP/2.0."},{"Id":"7809598260","Type":"IssuesEvent","CreatedAt":"2018-06-12T01:37:00","Actor":"anurse","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30276","RelatedDescription":"Closed issue \"System.Threading.Tasks.Extensions version in UWP 16300 does not match netstandard2.0 API\" (#30276) at dotnet/corefx","RelatedBody":"The System.Threading.Tasks.Extensions package has a `lib/uap10.0.16300/_._` file, meaning the reference is marked as in-box. However, the in-box version seems to be System.Threading.Tasks.Extension 4.1.2.0 whereas the `ref/netstandard2.0/System.Threading.Tasks.Extensions.dll` is 4.2.0.0.\r\n\r\nAs a result, when referencing a library built against `netstandard2.0` from a UWP application targeting \"Windows 10, version 1803\" as the **minimum** version a FileLoadException is thrown:\r\n\r\n```\r\nSystem.IO.FileLoadException: 'Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. The located assembly's manifest definition does not match the assembly reference. \r\n```\r\n\r\nThis can be reproduced in https://github.com/anurse/UWPValueTask . The UWPValueTask project has `TargetPlatformMinVersion` set to `10.0.17134.0` and throws the FileLoadException on launch (I had to enable first-chance exceptions to see the specific exception, otherwise I just hit the `Windows.UI.Xaml.Application.UnhandledException` event handler)\r\n\r\nChanging the MinVersion to \"Fall Creators Update\" resolves the issue, because the application uses the `lib/netstandard2.0/System.Threading.Tasks.Extensions.dll` which **is** version 4.2.0.0."}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7809979216","Type":"PullRequestEvent","CreatedAt":"2018-06-12T04:00:19","Actor":"maryamariyan","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5931","RelatedDescription":"Opened pull request \"[JustForView] Helps move x86 HW intrinsics files to shared in corert\" (#5931) at dotnet/corert","RelatedBody":"- gitignore needs to be updated because the new files (to be moved from coreclr src to shared) are located in a folder named x86.\r\n\r\n- the second commit shows how the ifdefs could be simplified after the APIs are added.\r\n\r\nRelated to coreclr PR: https://github.com/dotnet/coreclr/pull/18427\r\n\r\ncc: @jkotas @MichalStrehovsky "},{"Id":"7809498141","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:58:28","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5930","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5930) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7809487366","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:54:17","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5928","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#5928) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7809463033","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:44:50","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5929","RelatedDescription":"Merged pull request \"Fix CoreRT build\" (#5929) at dotnet/corert","RelatedBody":"Locks tasks at supported versions rather than floating.\r\n\r\nRemove disabled or deprecated tasks.\r\n\r\nValidated with https://devdiv.visualstudio.com/DefaultCollection/DevDiv/Default/_build/results?buildId=1765657"},{"Id":"7809409201","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:24:05","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5930","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5930) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7809380632","Type":"PullRequestEvent","CreatedAt":"2018-06-12T00:13:29","Actor":"chcosta","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5929","RelatedDescription":"Opened pull request \"Fix CoreRT build\" (#5929) at dotnet/corert","RelatedBody":"Locks tasks at supported versions rather than floating.\r\n\r\nRemove disabled or deprecated tasks.\r\n\r\nValidated with https://devdiv.visualstudio.com/DefaultCollection/DevDiv/Default/_build/results?buildId=1765657"},{"Id":"7808807132","Type":"PullRequestEvent","CreatedAt":"2018-06-11T21:26:10","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5928","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#5928) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7808284676","Type":"PullRequestEvent","CreatedAt":"2018-06-11T19:40:08","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5926","RelatedDescription":"Merged pull request \"Optimize Decimal.Remainder\" (#5926) at dotnet/corert","RelatedBody":"In addition to better performance this contributes to making decimal a readonly struct.\r\nI'll add new tests to CoreFX also.\r\nContributes to https://github.com/dotnet/coreclr/issues/18249.\r\n### x64\r\n|  Method |      Mean |     Error |    StdDev | Scaled |\r\n|-------- |----------:|----------:|----------:|-------:|\r\n|  Native | 169.42 ns | 0.3258 ns | 0.1162 ns |   1.00 |\r\n| CoreRT2 |  78.66 ns | 0.0869 ns | 0.0310 ns |   0.46 |\r\n### x86\r\n|  Method |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 128.0 ns | 0.1594 ns | 0.0568 ns |   1.00 |\r\n| CoreRT2 | 120.4 ns | 0.2057 ns | 0.0734 ns |   0.94 |\r\n\r\n@jkotas I have a WIP [readonly decimal branch](https://github.com/pentp/corert/commit/ee175a15451c95eddb5941b720219b0b13d47ba5), it doesn't compile yet because of `VarDecMod` and `NumberBufferToDecimal`, but can you check if I'm on the right track?"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7810012808","Type":"IssuesEvent","CreatedAt":"2018-06-12T04:14:43","Actor":"davkean","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2322","RelatedDescription":"Opened issue \"[Feedback] We should not be breaking design-time builds when the assets file is missing framework data\" (#2322) at dotnet/sdk","RelatedBody":"https://developercommunity.visualstudio.com/content/problem/232872/adding-existing-multitargeted-sdk-csproj-causes-er.html\r\nhttps://developercommunity.visualstudio.com/content/problem/234605/projects-with-multiple-targetframeworks-restore-on.html\r\n\r\nWhen a project contains multiple TFMs, there is a race where we can perform a design-time build for one of the TFMs that errors because the assets file is missing data for one of the other TFMs. This prevents us from sending data to NuGet that would resolve the issue.\r\n\r\n> @davkean says:\r\n> This isn’t a regression, and I can see what is happening. Probably more common due to performance improvements or changes in NuGet restore logic (did you reduce the timeout?)\r\n> In summary, due to timing the design-time build is failing, causing us to fail to nominate NuGet:\r\n> \r\n> Given a project with net45;net452;netstandard20\r\n\r\n\r\n> net45 design-time build starts\r\n> net46 design-time build starts\r\n> net45 design-time build finishes (tell NuGet about TFM + Packages)\r\n> net46 design-time build finishes (tell NuGet about TFM + Packages)\r\n> NuGet restores (assets file only contains net45/net46 and not netstandard20)\r\n> netstandard20 design-time builds starts\r\n> netstandard20 design-time build fails with:\r\n \r\n>\r\n> error : Assets file 'C:\\Users\\davkean\\Downloads\\obj\\project.assets.json' doesn't have a target for '.NETStandard,Version=v2.0'. Ensure that restore has run and that you have included 'netstandard2.0' in the TargetFrameworks for your project.\r\n>\r\n> That prevents us from telling NuGet about netstandard20.\r\n>\r\n> It’s a bit of a flaw that this error blocks the build from completing. We should rethink that – we should also consider not nominating for restore unless the first build of all TFMs have completed to prevent NuGet from double restoring.> \r\n\r\nand \r\n\r\n> @davkean says:\r\n> We came to the conclusion that we're going to remove the error that checks to see if the assets file contains the TFM for design-time builds; it will still continue to occur for solution/command-line builds.\r\n> \r\n\r\n"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1005426264029753345","CreatedAt":"2018-06-09T12:27:55+00:00","UserScreenname":"dotnet","Text":"Tune in today at 10a ET / 7a PT / 14:00 UTC / 8p IST and learn about global tools along with Jeff. https://t.co/hqxNjfqPMq","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":5,"RawContent":null},{"Id":"1005082168442449920","CreatedAt":"2018-06-08T13:40:37+00:00","UserScreenname":"dotnet","Text":"Tune in with Jeff as he works through the tutorials to learn F#.  Ask questions, and learn along with him https://t.co/rntL0szWYX","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":33,"FavoriteCount":15,"RawContent":null},{"Id":"1004145068381331456","CreatedAt":"2018-06-05T23:36:55+00:00","UserScreenname":"dotnet","Text":"Cool retro game built with #dotnet #monogame. Clone the repo, play the game, and you could win some serious money!… https://t.co/iHu2MQ1bME","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":70,"FavoriteCount":19,"RawContent":null}]}},"RunOn":"2018-06-12T05:30:32.7787466Z","RunDurationInMilliseconds":7553}