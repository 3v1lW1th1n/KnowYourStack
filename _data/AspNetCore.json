{
	"Data": {
		"Home-Issues": {
			"Issues": [{
				"Id": "342826066",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:56:48",
				"Actor": "DanFTRX",
				"Number": "3342",
				"RawContent": null,
				"Title": "Add Enabled flag to Microsoft.AspNetCore.Diagnostics.ExceptionHandlerFeature",
				"State": "closed",
				"Body": "It would be nice to be able to enable/disable the exception handler pages on the fly in [Microsoft.AspNetCore.Diagnostics.ExceptionHandlerFeature](https://github.com/aspnet/Diagnostics/blob/master/src/Microsoft.AspNetCore.Diagnostics/ExceptionHandler/ExceptionHandlerFeature.cs) similar to how:  [Microsoft.AspNetCore.Diagnostics.StatusCodePagesFeature](https://github.com/aspnet/Diagnostics/blob/master/src/Microsoft.AspNetCore.Diagnostics/StatusCodePage/StatusCodePagesFeature.cs#L11) allows. \r\n",
				"Url": "https://github.com/aspnet/Home/issues/3342",
				"RelatedDescription": "Closed issue \"Add Enabled flag to Microsoft.AspNetCore.Diagnostics.ExceptionHandlerFeature\" (#3342)"
			},
			{
				"Id": "343732570",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:52:04",
				"Actor": "ryanbrandenburg",
				"Number": "3354",
				"RawContent": null,
				"Title": "Flaky tests: EnsureCreateIdentityTokenSigningCertificate_CreatesACertificate_WhenThereAreNoHttpsCertificates et al",
				"State": "open",
				"Body": "This test [fails](http://aspnetci/viewLog.html?buildId=512272&buildTypeId=Releases_22xPublic_HighSierraOsxUniverse) occasionally with the following error:\r\n```\r\nAssert.Equal() Failure\r\nExpected: Succeeded\r\nActual:   ErrorSavingTheCertificateIntoTheCurrentUserPersonalStore\r\n   at Microsoft.AspNetCore.Certificates.Generation.Tests.CertificateManagerTests.EnsureCreateIdentityTokenSigningCertificate_CreatesACertificate_WhenThereAreNoHttpsCertificates() in /_/test/Microsoft.Extensions.Internal.Test/CertificateManagerTests.cs:line 220\r\n```\r\nPossibly this is an agent state issue since we only have one High-Sierra agent and no code appears to have changed before the failures started.",
				"Url": "https://github.com/aspnet/Home/issues/3354",
				"RelatedDescription": "Open issue \"Flaky tests: EnsureCreateIdentityTokenSigningCertificate_CreatesACertificate_WhenThereAreNoHttpsCertificates et al\" (#3354)"
			},
			{
				"Id": "343729098",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:41:22",
				"Actor": "pranavkm",
				"Number": "3353",
				"RawContent": null,
				"Title": "[CORS] Normalize internationalized domain names when adding to CORS",
				"State": "open",
				"Body": "Follow up to https://github.com/aspnet/CORS/pull/170. `CorsPolicyBuilder` should normalize IDNs to use punycode. This would match the format browsers send for IDN urls.",
				"Url": "https://github.com/aspnet/Home/issues/3353",
				"RelatedDescription": "Open issue \"[CORS] Normalize internationalized domain names when adding to CORS\" (#3353)"
			},
			{
				"Id": "343530599",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:18:48",
				"Actor": "jkotas",
				"Number": "3351",
				"RawContent": null,
				"Title": "memory leak during the use of reloadOnChange: true with ConfigurationBuilder",
				"State": "closed",
				"Body": "_From @abelpalaty on July 23, 2018 7:39_\r\n\r\n  Hi,\r\nWe have dotnet core driver which connects to our product (CICS TG).\r\nIn the driver we create a connection and closes it after each transaction.\r\nWhile creating the connection we have the following code.\r\n\r\n```c#\r\n     var  builder = new ConfigurationBuilder()\r\n           .SetBasePath(Directory.GetCurrentDirectory())\r\n           .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true);\r\n```\r\n\r\nWith the setting reloadOnChange: true we see the memory leak with time eventhough the connection is closed after each request.\r\n\r\nWe tried with the following code\r\n\r\n```c#\r\n     var  builder = new ConfigurationBuilder()\r\n           .SetBasePath(Directory.GetCurrentDirectory())\r\n           .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: false);\r\n```\r\n\r\nwith the setting reloadOnChange: false we see the memory usage is constant with time.\r\n\r\nThe sample we ran runs same application in a loop of like 2500 times where each time new object is created and closed.\r\nOur customer reported this issue and its recreating every time. Its high priority .\r\nIs there any fix available already or is it a known issue?\r\nIs there a way we can make sure memory usage is constant (maybe additional  code to release FileSystemWatcher after the connection is closed.)\r\n\r\nWe created a memory profiling report and we see that the function which allocated the most memory is System.IO.FileSystemWatcher.AllocateBuffer().\r\nI am attaching the screenshots of the observation we did during our testing.\r\n![70910eb8a8b6afd3](https://user-images.githubusercontent.com/41566819/43063074-769bc604-8e78-11e8-8e85-89b2e4abe863.jpg)\r\n![748aa0170f472bc9](https://user-images.githubusercontent.com/41566819/43063075-76d0beb8-8e78-11e8-9892-9bff9e5c5ba8.jpg)\r\n![7e81d48d0df38b32](https://user-images.githubusercontent.com/41566819/43063076-770d7a56-8e78-11e8-8e69-16700d9bddba.jpg)\r\n\r\n\r\n\r\n_Copied from original issue: dotnet/coreclr#19080_",
				"Url": "https://github.com/aspnet/Home/issues/3351",
				"RelatedDescription": "Closed issue \"memory leak during the use of reloadOnChange: true with ConfigurationBuilder\" (#3351)"
			},
			{
				"Id": "343478075",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:16:09",
				"Actor": "MhAllan",
				"Number": "3349",
				"RawContent": null,
				"Title": "How to get used InputFormatter and OutputFormatter in ActionFilter?",
				"State": "closed",
				"Body": "Hi,\r\n\r\nSo I have added Message Pack formatter beside Json. now in an action filter I want to get that formatter to deserialize some request header. how can I get access to the current formatter?",
				"Url": "https://github.com/aspnet/Home/issues/3349",
				"RelatedDescription": "Closed issue \"How to get used InputFormatter and OutputFormatter in ActionFilter?\" (#3349)"
			},
			{
				"Id": "343511416",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:15:57",
				"Actor": "Abarbz",
				"Number": "3350",
				"RawContent": null,
				"Title": "Strange behavior while getting method parameter from body in ApiController",
				"State": "closed",
				"Body": "Hello,\r\nWhile testing one of the methods in my Asp.Net Core Web API, I witnessed a strange behavior.\r\nThe method, sitting in an `[ApiController]`, has the following signature:\r\n```\r\n[HttpPost(\"myPath\")]\r\n[ProducesResponseType(200)]\r\npublic IActionResult MyMethod(MyObject obj)\r\n```\r\n\r\nAnd the `MyObject` looks like this:\r\n```\r\npublic struct MyObject\r\n{\r\n\t    public readonly bool MyBoolean;\r\n\t    public MyObject(bool myBoolean)\r\n\t    {\r\n\t\t    MyBoolean= myBoolean;\r\n\t    }\r\n}\r\n```\r\n\r\nI was manually testing some behaviors using Postman, and when posting the following objects, I was surprised by the results:\r\n* `{ afdqgdqgdsgqdgdg: false }` : yields a proper MyObject instance, with its MyBoolean field set to `false`\r\n* `{ afdqgdqgdsgqdgdg: false, myBoolean: true }` yields a proper MyObject instance, with its MyBoolean field set to `true`\r\n* `{ afdqgdqgdsgqdgdg: false, jfghdfhfdhf: true }` yields a proper MyObject instance, with its MyBoolean field set to `false`\r\n* `{ afdqgdqgdsgqdgdg: 3 }`: yields a proper MyObject instance, with its MyBoolean field set to `false`\r\n\r\nIn those 5 cases, I was actually expecting an error due to model mismatch (except maybe in the second case, where at least one of the properties was matching).\r\nWhat is happening here? Is this behavior expected?\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3350",
				"RelatedDescription": "Closed issue \"Strange behavior while getting method parameter from body in ApiController\" (#3350)"
			},
			{
				"Id": "343662123",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T16:15:18",
				"Actor": "jmhmaine",
				"Number": "3352",
				"RawContent": null,
				"Title": "Contribute Link 404",
				"State": "closed",
				"Body": "The \"How to contribute\" link on [Wiki](https://github.com/aspnet/Home/wiki) points to a DEV location that no longer exists. It should point to: https://github.com/aspnet/Home/blob/master/CONTRIBUTING.md\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3352",
				"RelatedDescription": "Closed issue \"Contribute Link 404\" (#3352)"
			},
			{
				"Id": "342908821",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T15:33:15",
				"Actor": "Tratcher",
				"Number": "3344",
				"RawContent": null,
				"Title": "High CPU usage after await (with sample repo)",
				"State": "closed",
				"Body": "_From @daddyman on July 19, 2018 21:47_\n\nSince moving to .NET Core 2.1 we have been seeing our aspnet core web api spike to 99% CPU usage on Linux. This does not happen when running on Windows.\r\n\r\nWhat we observe in our application is if we make 4 or 5 API calls in quick succession then the CPU goes to 99% and stays there for a few minutes.\r\n\r\nI was able to strip down our app and reproduce the issue in a simple app. The repo is here: https://github.com/daddyman/dotnetcorecpu\r\n\r\nI am running .NET Core 2.1.2 using SDK 2.1.302 on Ubuntu 16.04.\r\n\r\nIt seems to have something to do with \"await\". In the reproduction case I have one controller that handles a POST. \r\n* Performing an `await Task.CompletedTask;` does not cause a problem.\r\n* Performing an `away DummyWait();` where DummyWait is `return Task.Delay(1);` causes high CPU after hitting the server with many requests in a short time. The requests complete quickly but then the CPU goes to 99% and stays there.\r\n\r\nIn our real app I did the same change of using the `await Task.CompletedTask;` and 'await Task.DummyWait();` and saw the same difference with the CPU usage.\r\n\r\n\n\n_Copied from original issue: dotnet/corefx#31208_",
				"Url": "https://github.com/aspnet/Home/issues/3344",
				"RelatedDescription": "Closed issue \"High CPU usage after await (with sample repo)\" (#3344)"
			},
			{
				"Id": "342608332",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T09:05:10",
				"Actor": "lserafin",
				"Number": "3340",
				"RawContent": null,
				"Title": "AutomaticDecompression not working with HttpClientFactory",
				"State": "closed",
				"Body": "I'm trying to set up **automatic gzip decompression** with the new **HttpClientFactory**.\r\nSomehow this is not working for me.\r\nCan you please let me know if I am doing something wrong ? \r\n\r\n```  C#\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing Serilog;\r\nusing System;\r\nusing System.Net;\r\nusing System.Net.Http;\r\nusing System.Net.Http.Headers;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace GzipTest\r\n{\r\n    class Program\r\n    {\r\n        // C# 7.1\r\n        static async Task Main()\r\n        {\r\n            await Go();\r\n        }\r\n\r\n        static async Task Go()\r\n        {\r\n            Log.Logger = new LoggerConfiguration()\r\n                .MinimumLevel.Debug()\r\n                .WriteTo.Console()\r\n                .CreateLogger();\r\n\r\n            var services = new ServiceCollection()\r\n                .AddLogging(builder =>\r\n                {\r\n                    // Add Serilog\r\n                    builder.AddSerilog();\r\n                });\r\n\r\n            // Register a HTTP Client\r\n            services.AddHttpClient<GzipTestClient>().ConfigureHttpMessageHandlerBuilder(config => new HttpClientHandler\r\n            {\r\n                AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip\r\n            });\r\n\r\n            var serviceProvider = services.BuildServiceProvider();\r\n\r\n            // This is the Microsoft Logging interface\r\n            var logger = serviceProvider.GetRequiredService<ILogger<Program>>();\r\n            logger.LogInformation(\"We are using Serilog!\");\r\n\r\n            // Get a HTTP Client and make a request\r\n            var google = serviceProvider.GetRequiredService<GzipTestClient>();\r\n            await google.Get();\r\n        }\r\n    }\r\n\r\n    class GzipTestClient\r\n    {\r\n        HttpClient HttpClient { get; }\r\n        public GzipTestClient(HttpClient client)\r\n        {\r\n            HttpClient = client;\r\n            HttpClient.BaseAddress = new Uri(\"http://httpbin.org\");\r\n            HttpClient.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"gzip\"));\r\n            HttpClient.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"deflate\"));\r\n        }\r\n        public async Task<HttpResponseMessage> Get()\r\n        {\r\n            var request = new HttpRequestMessage(HttpMethod.Get, \"/gzip\");\r\n            var response = await HttpClient.SendAsync(request);\r\n            //var response = await HttpClient.GetAsync(\"/gzip\"); Also not working\r\n            var payload = response.Content.ReadAsStringAsync().Result;\r\n            Console.WriteLine(\"Decompressed Content:\\n{0}\", payload);\r\n            response.EnsureSuccessStatusCode();\r\n            return response;\r\n        }\r\n    }\r\n}\r\n```\r\n**Output**\r\n\r\n`[16:57:48 INF] We are using Serilog!\r\n[16:57:48 INF] Start processing HTTP request GET http://httpbin.org/gzip\r\n[16:57:48 INF] Sending HTTP request GET http://httpbin.org/gzip\r\n[16:57:48 INF] Received HTTP response after 440.1212ms - OK\r\n[16:57:48 INF] End processing HTTP request after 476.972ms - OK\r\nDecompressed Content:\r\n\u001f ?\u0003N[\u0002?\u001d?A\r\n?0\u0010E??Bf\u001d\u0003?\u0016?H??\u00025\u0019??:\u0013?qc??M]????/\u0010??3\u0006?|?@?)`??/p?\u001e?\u001e\u0006?\u0012?#???\u0003??I\u0011\f?\u0019??p+?,u?w??bR?Ob+%?j?????8<?$?\"m+w??l??\u001e/\u000e??\u000f??6N?\r\nPress any key to continue . . .`\r\n\r\n### Environment / dotnet Info\r\n\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.302\r\n Commit:    9048955601\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17134\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.302\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.2\r\n  Commit:  811c3ce6c0\r\n\r\n.NET Core SDKs installed:\r\n  1.1.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.104 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.201 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300-rc1-008673 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0-rc1-final [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0-rc1-final [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0-rc1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n```\r\n\r\nSame code seems to be working without the HttpClientFactory (https://github.com/dotnet/corefx/issues/31121)",
				"Url": "https://github.com/aspnet/Home/issues/3340",
				"RelatedDescription": "Closed issue \"AutomaticDecompression not working with HttpClientFactory\" (#3340)"
			},
			{
				"Id": "343380904",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-22T06:17:52",
				"Actor": "georgiosd",
				"Number": "3348",
				"RawContent": null,
				"Title": "Correctly handling exceptions in middleware",
				"State": "open",
				"Body": "Hey gents,\r\n\r\nI have a simple middleware class that will write a \"virtual file\" i.e. - if the client requests `/foo.path` it will write a response, otherwise it will pass the request down the pipeline.\r\n\r\nMy problem is that when an exception occurs somewhere along the rest of the pipeline, it is reported to App Insights like coming from my middleware because the `next(context)` call is awaited. And it has to be awaited because `context.Response` only has `Async` methods to write. \r\n\r\nCode:\r\n\r\n```\r\npublic async Task InvokeAsync(HttpContext context)\r\n        {\r\n            if (context.Request.Path == \"/foo.path\")\r\n            {\r\n                    await context.Response.WriteAsync(\"content\");\r\n                    return;\r\n            }\r\n\r\n            await next(context);\r\n        }\r\n```\r\n\r\nHow do I go about cleaning this up??",
				"Url": "https://github.com/aspnet/Home/issues/3348",
				"RelatedDescription": "Open issue \"Correctly handling exceptions in middleware\" (#3348)"
			},
			{
				"Id": "343271006",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-21T00:54:18",
				"Actor": "jacobslusser",
				"Number": "3347",
				"RawContent": null,
				"Title": "Dependency injection interceptor/wrapper/chain",
				"State": "closed",
				"Body": "Apologies if this has been asked and/or answers already...\r\n\r\nI want to be able to register a service in the traditional way:\r\n```cs\r\nservices.AddSingleton<IRepository, Repository>();\r\n```\r\nbut when I call for the service I want to get a wrapped/intercepted version that does caching. i.e. the caching service would implement the same service and wrap the original service:\r\n\r\n```cs\r\npublic class CachingRepository : IRepository\r\n{\r\n    private readonly IRepository originalRepository;\r\n    public CachingRepository(IRepository originalRepository)\r\n    {\r\n        this.originalRepository = originalRepository; // Would be instance of Repository\r\n    }\r\n}\r\n```\r\nIt might help to think of this in the way that middleware calls the next middleware in the chain...\r\n\r\nIs there a good way to do this? Maybe with a factory? I can't quite put my finger on it and the approach I'm currently using feels kludge-y.",
				"Url": "https://github.com/aspnet/Home/issues/3347",
				"RelatedDescription": "Closed issue \"Dependency injection interceptor/wrapper/chain\" (#3347)"
			},
			{
				"Id": "342887491",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T23:49:36",
				"Actor": "ArifKuttayi",
				"Number": "3343",
				"RawContent": null,
				"Title": "InvalidOperationException: Unable to resolve service for type",
				"State": "closed",
				"Body": "I'm using Core 2.1 razor pages with repository. Showing error while opening register page even I have registered Email sender in Startup.cs. Please see below error log.\r\n![error log](https://user-images.githubusercontent.com/17797408/42969720-c8cbbaa4-8baf-11e8-89a3-f0c74cfaa137.JPG)\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3343",
				"RelatedDescription": "Closed issue \"InvalidOperationException: Unable to resolve service for type\" (#3343)"
			},
			{
				"Id": "343254956",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T21:38:05",
				"Actor": "sungam3r",
				"Number": "3346",
				"RawContent": null,
				"Title": "Microsoft.Extensions.DiagnosticAdapter does not map properties from ancestor classes",
				"State": "open",
				"Body": "Microsoft.Extensions.DiagnosticAdapter package provides easy opportunity to wrap execution flow into the suitable well-configured methods like this\r\n```\r\n[DiagnosticName(\"Microsoft.EntityFrameworkCore.Database.Command.CommandExecuting\")]\r\npublic void OnCommandExecuting(DbCommand command, DbCommandMethod executeMethod, Guid commandId, Guid connectionId, DateTimeOffset startTime)\r\n{\r\n}\r\n```\r\ninitializing all known specified parameters in method signature, but it does not work with properties in ancestor classes, e.g [CommandExecutedEventData](https://github.com/aspnet/EntityFrameworkCore/blob/master/src/EFCore.Relational/Diagnostics/CommandExecutedEventData.cs) because of this line of code ([link](https://github.com/aspnet/EventNotification/blob/28b77e7fb51b30797ce34adf86748c98c040985e/src/Microsoft.Extensions.DiagnosticAdapter/Internal/ProxyMethodEmitter.cs#L60)):\r\n```\r\nvar properties = inputType.GetTypeInfo().DeclaredProperties.ToArray();\r\n```\r\nIt uses only those properties, which are declared in this particular **inputType** type. And in case of CommandExecutedEventData there are only one property - Result. All other properties from CommandEndEventData, CommandEventData and EventData will be ignored. \r\n\r\nConsider to change the line of code mentioned above to\r\n```\r\nvar properties = inputType.GetTypeInfo().GetProperties();\r\n```\r\nto allow mapping to any property in the chain of class inheritance, so we can use such methods:\r\n```\r\n[DiagnosticName(\"Microsoft.EntityFrameworkCore.Database.Command.CommandExecuted\")]\r\npublic void OnCommandExecuted(object result, bool async, TimeSpan duration, DbCommand command, Guid commandId)\r\n{\r\n}\r\n```\r\nNow all arguments except *result* have their default values - null for reference types and zeros for structs.",
				"Url": "https://github.com/aspnet/Home/issues/3346",
				"RelatedDescription": "Open issue \"Microsoft.Extensions.DiagnosticAdapter does not map properties from ancestor classes\" (#3346)"
			},
			{
				"Id": "343051996",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T10:15:05",
				"Actor": "ststeiger",
				"Number": "3345",
				"RawContent": null,
				"Title": "Impossible to check if HttpContext-body is null/empty...",
				"State": "open",
				"Body": "In ASP.NET-Core, there is no way to check if the request's body is NULL/empty...\r\n\r\nI make a fetch request \r\n```\r\n    let result = <any>await fetch(markerUrl, {\r\n        \"method\": 'POST',\r\n        // \"headers\": {'auth': '1234','content-type': 'application/json'},\r\n        // https://stackoverflow.com/questions/38156239/how-to-set-the-content-type-of-request-header-when-using-fetch-api\r\n        \"headers\": new Headers({ 'content-type': 'application/json' }),\r\n        \"body\": null \r\n    })\r\n    .then(function (response) { return response.json(); })\r\n    ;\r\n```\r\neither with setting body to NULL or by omiting body altogether. \r\n\r\nIn ASP.NET-Core, I get:\r\n\r\n\r\n```\r\ncontext.Responst.Body: is not NULL \r\ncontext.Request.Body.Length: System.NotSupportedException \r\ncontext.Request.Body.Position: System.NotSupportedException \r\ncontext.Request.Body.Seek(0, System.IO.SeekOrigin.End): System.NotSupportedException \r\nand\r\ncontext.Request.Body._body.IsEmpty: true \r\n```\r\nthere is no public empty property on Body...\r\n\r\nConsequentially, it's not possible to read the stream directly into a JSON-object, because there's no way to tell if there actually is a stream/empty-stream...\r\n\r\n```\r\n            if (string.Equals(context.Request.ContentType, \"application/json\", System.StringComparison.InvariantCultureIgnoreCase))\r\n            {\r\n                Newtonsoft.Json.Linq.JObject jsonData = null;\r\n\r\n                // Can only be read ONCE ! \r\n                using (System.IO.StreamReader reader = new System.IO.StreamReader(context.Request.Body, System.Text.Encoding.UTF8, false, 4096, true))\r\n                {\r\n                    using (Newtonsoft.Json.JsonTextReader jsonReader = new Newtonsoft.Json.JsonTextReader(reader))\r\n                    {\r\n                       // KABOOM ! \r\n                        var a = Newtonsoft.Json.Linq.JToken.Load(jsonReader);\r\n                        System.Console.WriteLine(a);\r\n                        jsonData = Newtonsoft.Json.Linq.JObject.Load(jsonReader);\r\n                    } // End Using jsonReader \r\n\r\n                } // End Using reader \r\n```\r\n\r\nI don't want to use exceptions for this, because this is slowwwww...\r\nI don't want to read it into a string, because that shouldn't be necessary either...",
				"Url": "https://github.com/aspnet/Home/issues/3345",
				"RelatedDescription": "Open issue \"Impossible to check if HttpContext-body is null/empty...\" (#3345)"
			},
			{
				"Id": "342223969",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T05:24:25",
				"Actor": "yashwanthreddyg",
				"Number": "3337",
				"RawContent": null,
				"Title": "Way to configure IIS reverse proxy without aspnetcore module",
				"State": "closed",
				"Body": "I have Kestrel running as a Windows service using dotnet core portal runtime and a DLL.\r\nCan I make IIS run as a reverse proxy for my application?\r\nI want to avoid installing the dotnethostingbundle as I already have a portable runtime.",
				"Url": "https://github.com/aspnet/Home/issues/3337",
				"RelatedDescription": "Closed issue \"Way to configure IIS reverse proxy without aspnetcore module\" (#3337)"
			},
			{
				"Id": "342697577",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T11:56:58",
				"Actor": "tmds",
				"Number": "3341",
				"RawContent": null,
				"Title": "aspnet/FileSystem Polling broken?",
				"State": "open",
				"Body": "I set DOTNET_USE_POLLING_FILE_WATCHER to see how it affects aspnet/Configuration refresh.\r\nI saw no polling of the configuration files.\r\n\r\nLooking at the implementation, it seems events are triggered by FileSystemWatcher, even when polling: https://github.com/aspnet/FileSystem/blob/faf1f007208001988d30618eca934481ea61dcda/src/FS.Physical/PhysicalFileProvider.cs#L78\r\n\r\nMy understanding is DOTNET_USE_POLLING_FILE_WATCHER is meant for filesystems like NFS where FileSystemWatcher does not work.\r\nSo, the configuration reload is probably broken on such filesystems, even when setting DOTNET_USE_POLLING_FILE_WATCHER.\r\n\r\nCC @natemcmaster @pranavkm",
				"Url": "https://github.com/aspnet/Home/issues/3341",
				"RelatedDescription": "Open issue \"aspnet/FileSystem Polling broken?\" (#3341)"
			},
			{
				"Id": "342477325",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T20:51:57",
				"Actor": "ggirard07",
				"Number": "3339",
				"RawContent": null,
				"Title": "Unable to debug ASP.Net Core 2.0 app running in ISS on .Net Framework",
				"State": "closed",
				"Body": "**Steps to reproduce**\r\n1. File > New > Project\r\n2. Select ASP.Net Core Web Application\r\n3. In popup window, select \"API\" and change target framework for \".Net Framework\" on top of the window (ASP.Net Core 2.0 should be default)\r\n4. Create the project\r\n5. Add a breakpoint in ValuesController in Get() method then start debug on ISS target\r\n\r\n**Expected Result**\r\nBreakpoint is hit then when debug is resumed response from the controller is displayed in the browser\r\n\r\n**Actual Result**\r\nBreakpoint is never hit and Visual Studio freeze\r\n\r\n**Versions**\r\n- Visual Studio 15.7.5\r\n- Default Nuget package versions from ASP.Net Core WebAPI template\r\n  - Microsoft.AspNetCore 2.0.4\r\n  - Microsoft.AspNetCore.Mvc 2.0.4\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3339",
				"RelatedDescription": "Closed issue \"Unable to debug ASP.Net Core 2.0 app running in ISS on .Net Framework\" (#3339)"
			},
			{
				"Id": "342249475",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T17:05:52",
				"Actor": "Edward-Zhou",
				"Number": "3338",
				"RawContent": null,
				"Title": "How To Bind Model Value From Body by Custom Binder",
				"State": "closed",
				"Body": "I am trying this document [Custom Model Binding in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-2.1), I could get the model value when passing by `Query String`.\r\nBut, I want to bind the model to Request Body, how could I fetch value from Request body when I sending request with `application/json`.",
				"Url": "https://github.com/aspnet/Home/issues/3338",
				"RelatedDescription": "Closed issue \"How To Bind Model Value From Body by Custom Binder\" (#3338)"
			},
			{
				"Id": "341734126",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T02:11:40",
				"Actor": "moogle001",
				"Number": "3334",
				"RawContent": null,
				"Title": "NET 2.1: Breaking Change in TestServer?",
				"State": "closed",
				"Body": "I have a website built on NET Core 2.0 with unit tests that confirm routing using the RestEase library. A unit test looks like this:\r\n\r\n\r\n\r\n        [Fact]\r\n        public async Task GetAll()\r\n        {\r\n            var webHostBuilder = CreateWebHostBuilder();\r\n            using (var server = new TestServer(webHostBuilder))\r\n            {\r\n                var client = CreateClient(server);\r\n                var objs = await client.GetAll();\r\n\r\n                Assert.NotNull(objs);\r\n                Assert.True(objs.Count > 0);\r\n            }\r\n        }\r\n\r\n        public IWebHostBuilder CreateWebHostBuilder()\r\n        {\r\n            var config = new ConfigurationBuilder()\r\n                .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true)\r\n                .Build();\r\n\r\n            var host = new WebHostBuilder()\r\n                .UseConfiguration(config)\r\n                .UseStartup<TestStartup>();\r\n\r\n            return host;\r\n        }\r\n\r\n        public ITransactionsApi CreateClient(TestServer server)\r\n        {\r\n            HttpClient client = server.CreateClient();\r\n            ITransactionsApi toReturn = RestClient.For<ITransactionsApi>(client);\r\n            return toReturn;\r\n        }\r\n \r\n\r\n\r\nEverything runs and passes under 2.0. However, upon upgrading to 2.1, all tests fail with 404. Aside from the introduction of WebApplicationFactory, I don't see anything in the notes about changes to unit testing. It should also be noted that when debugging the routes work under both versions, which is why I'm suspect of TestServer. I can provide diffs for the main project and test project if needed. I appreciate any insight anyone can provide.",
				"Url": "https://github.com/aspnet/Home/issues/3334",
				"RelatedDescription": "Closed issue \"NET 2.1: Breaking Change in TestServer?\" (#3334)"
			},
			{
				"Id": "341785089",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T06:39:59",
				"Actor": "hishamco",
				"Number": "3336",
				"RawContent": null,
				"Title": "Adding AddRequestCultureProvider as extension method",
				"State": "open",
				"Body": "For all that are familiar with localization, adding new culture provider is something confusing, because the developer expect that the newly added provider is winner provider, but it's not!!\r\n\r\nHave a look to [this](https://github.com/aspnet/Localization/blob/master/samples/LocalizationSample/Startup.cs#L34) we should use `Insert` instead of `Add`, to let our culture provider wins over the other predefined culture providers.\r\n\r\nUsing this\r\n```csharp\r\noptions.AddRequestCultureProvider(new CustomRequestCultureProvider(async context =>\r\n{\r\n\r\n}));\r\n```\r\n\r\nis slightly better than\r\n```csharp\r\noptions.RequestCultureProviders.Insert(0, new CustomRequestCultureProvider(async context =>\r\n{\r\n\r\n}));\r\n```\r\n\r\n/cc @ryanbrandenburg ",
				"Url": "https://github.com/aspnet/Home/issues/3336",
				"RelatedDescription": "Open issue \"Adding AddRequestCultureProvider as extension method\" (#3336)"
			},
			{
				"Id": "341783484",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T06:32:50",
				"Actor": "hishamco",
				"Number": "3335",
				"RawContent": null,
				"Title": "Move localization builder APIs into an extension methods",
				"State": "open",
				"Body": "After revising the localization builder APIs that we introduce in `2.1`, it would be nice to move those into an extensions methods, because they rely on the existing members",
				"Url": "https://github.com/aspnet/Home/issues/3335",
				"RelatedDescription": "Open issue \"Move localization builder APIs into an extension methods\" (#3335)"
			},
			{
				"Id": "341383119",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T01:44:58",
				"Actor": "scottsauber",
				"Number": "3333",
				"RawContent": null,
				"Title": "2.1.302 SDK, but AspNetCore.App only downloads 2.1.1 instead of 2.1.2",
				"State": "closed",
				"Body": "Hello, not really sure where to put this so I'm starting here.\r\n\r\nOn two different machines, I'm unable to get the AspNetCore.App package with no explicit version number to download 2.1.1 instead of 2.1.2.\r\n\r\nThis is on a dotnet new and is happening on two different machines.  On one of them, I even uninstalled all older SDK's other than 2.1.302.\r\n\r\nAm I doing something wrong?\r\n\r\nScreenshots:\r\n![image](https://user-images.githubusercontent.com/10823939/42742518-ddcfc896-8880-11e8-99f0-73488fe5218e.png)\r\n![image](https://user-images.githubusercontent.com/10823939/42742524-e1562afa-8880-11e8-9751-c4f1eda0d112.png)\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3333",
				"RelatedDescription": "Closed issue \"2.1.302 SDK, but AspNetCore.App only downloads 2.1.1 instead of 2.1.2\" (#3333)"
			},
			{
				"Id": "341289408",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T15:36:17",
				"Actor": "thammadi",
				"Number": "3330",
				"RawContent": null,
				"Title": "Controllers declared in class library, returning 404 with AWS Lambda C#2.1",
				"State": "closed",
				"Body": "I created an AWS Serverless solution with a Web API and Class Library projects (2.1.0). Class Library is referenced by the Web API project.\r\n\r\nController in Web API:\r\n```\r\n[Route(\"api/[controller]\")]\r\npublic class ValuesController : Controller\r\n{\r\n        [HttpGet]\r\n        public IEnumerable<string> Get()\r\n        {\r\n            return new string[] { \"value1\", \"value2\" };\r\n        }\r\n}\r\n```\r\nReferences: Microsoft.AspNetCore.App (2.1.0) and Microsoft.NETCore.App (2.1.0)\r\nCompatability version set in Startup.cs:\r\n```\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n}\r\n```\r\n\r\nController in Class Library: \r\n```\r\n[Route(\"api/[controller]\")]\r\npublic class ClassesController : Controller\r\n{\r\n        [HttpGet]\r\n        public IEnumerable<string> Get()\r\n        {\r\n            return new string[] { \"class1\", \"class2\" };\r\n        }\r\n}\r\n```\r\nReferences: Microsoft.AspNetCore.App (2.1.0) and Microsoft.NETCore.App (2.1.0)\r\nSDK reference in Class Library project file is updated from Microsoft.NET.Sdk to Microsoft.NET.Sdk.Web\r\n\r\nDeployed the above to AWS lambda (dotnet lambda package -c \"Release\")\r\n\r\nWhen tested, '/api/values' works as expected but '/api/classes' returns 404\r\nThis used to work with 2.0 version.\r\n\r\nDid I miss anything?",
				"Url": "https://github.com/aspnet/Home/issues/3330",
				"RelatedDescription": "Closed issue \"Controllers declared in class library, returning 404 with AWS Lambda C#2.1\" (#3330)"
			},
			{
				"Id": "341312593",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-15T11:07:48",
				"Actor": "ygoe",
				"Number": "3332",
				"RawContent": null,
				"Title": "Internal redirect for UseStatusCodePages",
				"State": "open",
				"Body": "The [documentation](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-2.1) explains how to use `app.UseStatusCodePages();` to show some content when a controller action returns `NotFound()` or something. This only shows very basic plain text. I could also redirect the user to another URL that has more content like /Error/404. But that would redirect the user away from the originating URL that caused the error. Redirecting the user away from the actual error page to a static page that always shows an error message is a bad thing. The user will not be able to verify the URL and probably find the problem. Also, reloading the page will not bring back the expected content when the error has been resolved meanwhile. Reloading the /Error/404 page will always show the error even if it doesn't exist anymore.\r\n\r\nSo what I need is an internal redirect to a more rich page that fits my site design, but doesn't change the visible URL.\r\n\r\nHow can I do that?",
				"Url": "https://github.com/aspnet/Home/issues/3332",
				"RelatedDescription": "Open issue \"Internal redirect for UseStatusCodePages\" (#3332)"
			},
			{
				"Id": "341295314",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-15T06:09:58",
				"Actor": "huazhenhz",
				"Number": "3331",
				"RawContent": null,
				"Title": "Session OnStart and Session OnEnd",
				"State": "open",
				"Body": "To reopen the issue #3025 \r\nhttps://github.com/aspnet/Home/issues/3025\r\n\r\nI hope Session can have \"Session_Start\" and \"Session_End\" event mechanism.\r\n\r\nIf the mechanism is the same as Spring Session in Java Web, that's preferred.\r\n\r\nSpring Session has the similiar events such as \"SessionCreatedEvent\" and \"SessionDestroyedEvent\" (\"SessionDestroyedEvent\" includes \"SessionDeletedEvent\" and \"SessionExpiredEvent\".).\r\n\r\nThe relevant web sites about Spring Session below:\r\n\r\nSessionCreatedEvent:\r\nhttps://docs.spring.io/spring-session/docs/1.3.0.RELEASE/reference/html5/#api-redisoperationssessionrepository-sessioncreatedevent\r\n\r\nSessionDestroyedEvent:\r\nhttps://docs.spring.io/spring-session/docs/1.3.0.RELEASE/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent\r\n\r\nI think the mechanism is important to .NET developers, and it can make ASP.NET Core more perfect.\r\n\r\nSo, \"Session_Start\" and \"Session_End\" events should be provided continuously in ASP.NET Core.\r\n\r\nThanks!\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3331",
				"RelatedDescription": "Open issue \"Session OnStart and Session OnEnd\" (#3331)"
			},
			{
				"Id": "340940743",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T16:00:14",
				"Actor": "stap123",
				"Number": "3326",
				"RawContent": null,
				"Title": "Refactoring/Renaming Inside Razor Views",
				"State": "closed",
				"Body": "Is there a way to to have refactoring (specifically renaming things) work inside razor view files within VS2017? I thought I'd heard Damien mention that it was possible in a community stand up video a while ago but can't work out how to do it.\r\n\r\nIf it's not possible is it planned at all?\r\n",
				"Url": "https://github.com/aspnet/Home/issues/3326",
				"RelatedDescription": "Closed issue \"Refactoring/Renaming Inside Razor Views\" (#3326)"
			},
			{
				"Id": "341072710",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T15:57:05",
				"Actor": "Eilon",
				"Number": "3329",
				"RawContent": null,
				"Title": "Suggest:The IOC resolves the relationship and displays the available implementation in the error message",
				"State": "open",
				"Body": "_From @hjkl950217 on May 8, 2018 8:28_\n\n.net environment：\r\nsdk:   .net core 2.1.104\r\nVS: 2017 Community\r\nsystem: windows 10 1709 pro N\r\n\r\nHopefully when ‘IOC’ parses an error, give some more detailed error information\r\n\r\nfor examples：\r\n\r\nIHttpContextAccessor interface，it injected when VS in debug mode。but release project，project does not contain the IHttpContextAccessor 。 this error message should show:\r\n\r\n“This interface is no corresponding implementation”\r\n\r\nbut However, sometimes this interface will be forcibly injected，This interface corresponding to the two to achieve。 this error message should show:\r\n\r\nThere are multiple implementations of this interface:\r\n{xxxx.xxxx.xxxx.IHttpContextAccessor }\r\n{bbbb.bbbb.bbbb.IHttpContextAccessor }\r\n\r\nThis can be more convenient positioning problem！\r\n\r\n##  about me project\r\n\r\nI am writing the company's basic class library，Use IHttpContextAccessor in the basic class library.\r\nBut,Other web api project Report this interface to resolve errors。\r\n\r\nPossible situations:\r\n1.Internal references to projects lead to。\r\n2.Used by other libraries referenced by the base class library。\r\n3.Library version issues\r\n4.other issues.\r\n\r\n\r\nI know that the official blog has described this issue，but it did not help me solve the problem.\r\nOccasionally, this problem will still occur, but it can hardly be solved.\r\n\r\n\r\n\r\n\n\n_Copied from original issue: dotnet/core#1514_",
				"Url": "https://github.com/aspnet/Home/issues/3329",
				"RelatedDescription": "Open issue \"Suggest:The IOC resolves the relationship and displays the available implementation in the error message\" (#3329)"
			},
			{
				"Id": "341070392",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T15:50:04",
				"Actor": "Eilon",
				"Number": "3328",
				"RawContent": null,
				"Title": "Not allowing to post huge data in AJAX call in ASP .net core 2",
				"State": "open",
				"Body": "_From @SattarMomin on May 16, 2018 9:52_\n\n# Issue Title\r\n\r\nNot allowing to post huge data in AJAX call in ASP .net core 2\r\n\r\n# General\r\n\r\nI have created 1 page in ASP .net core 2 MVC. Now I am posting data of form by AJAX call and calling Controller Action. But when data is huge on page it is giving error \"Failed to load resource: the server responded with a status of 500 (Internal Server Error)\", same is working fine when data is less.\r\n\r\nI am sure issue is due to exceeding data size limit. \r\n\r\nI have tried '[DisableRequestSizeLimit]' at action level and .UseKestrel(options => { options.Limits.MaxRequestBodySize = null; }) at global level, but giving same error.\r\n\r\nKindly suggest\r\n\n\n_Copied from original issue: dotnet/core#1566_",
				"Url": "https://github.com/aspnet/Home/issues/3328",
				"RelatedDescription": "Open issue \"Not allowing to post huge data in AJAX call in ASP .net core 2\" (#3328)"
			},
			{
				"Id": "340956108",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T09:55:00",
				"Actor": "Edward-Zhou",
				"Number": "3327",
				"RawContent": null,
				"Title": "CORS did not add valid Origins to Response if Method is not Allowed",
				"State": "open",
				"Body": "I have configured CORS like below:\r\n```\r\nservices.AddCors(x =>\r\n            {\r\n                x.AddPolicy(CORS.AllowPostMethod,\r\n                    policyBuilder =>\r\n                    {\r\n                        policyBuilder\r\n                            .WithOrigins(\"https://localhost:44326\")\r\n                            .WithMethods(HttpMethods.Post)\r\n                            .AllowAnyHeader();\r\n                    });\r\n            });\r\n```\r\nAnd use it like this:   \r\n```\r\n[HttpPut(\"{id}\")]\r\n        [EnableCors(CORS.AllowPostMethod)] \r\n        public void Put(int id)\r\n        {\r\n        }\r\n```\r\nIf I send request like this:\r\n```\r\n$.ajax({\r\n    url: \"https://localhost:44329/api/User/12\",\r\n    type: \"PUT\",\r\n});\r\n```\r\nIt will throw error below instead of \"Method PUT is not allowed by Access-Control-Allow-Methods in preflight response\".\r\n\r\n> Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'https://localhost:44326' is therefore not allowed access.\r\n\r\nAfter checking the source code [EvaluatePreflightRequest](https://github.com/aspnet/CORS/blob/8e4d3aacb3153f2a1338e228f0ea096e242d746a/src/Microsoft.AspNetCore.Cors/Infrastructure/CorsService.cs#L111). It did not add the valid `Origin` to `CorsResult `.\r\n\r\nShould the `EvaluatePreflightRequest` like below?\r\n\r\n```\r\n                 public virtual void EvaluatePreflightRequest(HttpContext context, CorsPolicy policy, ref CorsResult result)\r\n        {\r\n            var origin = context.Request.Headers[CorsConstants.Origin];\r\n            if (!IsOriginAllowed(policy, origin))\r\n            {\r\n                return;\r\n            }\r\n            result.AllowedOrigin = origin;\r\n\r\n            var accessControlRequestMethod = context.Request.Headers[CorsConstants.AccessControlRequestMethod];\r\n            if (StringValues.IsNullOrEmpty(accessControlRequestMethod))\r\n            {\r\n                return;\r\n            }\r\n\r\n            var requestHeaders =\r\n                context.Request.Headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders);\r\n\r\n            if (!policy.AllowAnyMethod)\r\n            {\r\n                var found = false;\r\n                for (var i = 0; i < policy.Methods.Count; i++)\r\n                {\r\n                    var method = policy.Methods[i];\r\n                    result.AllowedMethods.Add(method);\r\n                    if (string.Equals(method, accessControlRequestMethod, StringComparison.OrdinalIgnoreCase))\r\n                    {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found)\r\n                {\r\n                    _logger?.PolicyFailure();\r\n                    _logger?.AccessControlMethodNotAllowed(accessControlRequestMethod);\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            if (!policy.AllowAnyHeader &&\r\n                requestHeaders != null)\r\n            {\r\n                foreach (var requestHeader in requestHeaders)\r\n                {\r\n                    if (!CorsConstants.SimpleRequestHeaders.Contains(requestHeader, StringComparer.OrdinalIgnoreCase) &&\r\n                                                  !policy.Headers.Contains(requestHeader, StringComparer.OrdinalIgnoreCase))\r\n                    {\r\n                        _logger?.PolicyFailure();\r\n                        _logger?.RequestHeaderNotAllowed(requestHeader);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            AddOriginToResult(origin, policy, result);\r\n            result.SupportsCredentials = policy.SupportsCredentials;\r\n            result.PreflightMaxAge = policy.PreflightMaxAge;\r\n            result.AllowedMethods.Add(accessControlRequestMethod);\r\n            AddHeaderValues(result.AllowedHeaders, requestHeaders);\r\n            _logger?.PolicySuccess();\r\n        }\r\n```",
				"Url": "https://github.com/aspnet/Home/issues/3327",
				"RelatedDescription": "Open issue \"CORS did not add valid Origins to Response if Method is not Allowed\" (#3327)"
			},
			{
				"Id": "340821013",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T22:32:12",
				"Actor": "avechuche",
				"Number": "3325",
				"RawContent": null,
				"Title": "Cannot capture 405 error with CORS - CORE API",
				"State": "open",
				"Body": "Hi, I am trying to get a 405 method not allowed error but it is impossible and I do not know why. I have the following configuration.\r\n\r\n```\r\n//Startup.cs\r\nservicesCollection.AddCors(x =>\r\n{\r\n    x.AddPolicy(CORS.AllowPutMethod,\r\n        policyBuilder =>\r\n        {\r\n            policyBuilder.WithOrigins(\"http://localhost:4200\")\r\n                .WithMethods(HttpMethods.Put).AllowAnyHeader();\r\n        });\r\n    x.AddPolicy(CORS.AllowPostMethod,\r\n        policyBuilder =>\r\n        {\r\n            policyBuilder.WithOrigins(\"http://localhost:4200\")\r\n                .WithMethods(HttpMethods.Post).AllowAnyHeader();\r\n        });\r\n});\r\n\r\npublic static class CORS\r\n{\r\n    public const string AllowPutMethod = nameof(AllowPutMethod);\r\n\r\n    public const string AllowPostMethod = nameof(AllowPostMethod);\r\n}\r\n\r\n[ApiController]\r\n[Route(\"api/[controller]\")]\r\npublic class UserController : ControllerBase\r\n{\r\n    // PUT: api/User/5\r\n    [HttpPut(\"{id}\")]\r\n    [EnableCors(CORS.AllowPostMethod)]\r\n    public void Put(int id, UserDTO currentUser)\r\n    {\r\n    }\r\n\r\n}\r\n```\r\nMy intention is that this method only accepts a PUT request, to which I add [EnableCors (CORS.AllowPostMethod)] to force an error, but this does not generate any errors, it works perfectly, but if I comment that part // [EnableCors (CORS .AllowPostMethod)] method does not work and returns error 500. Its a ASP CORE bug or or i am the bug?",
				"Url": "https://github.com/aspnet/Home/issues/3325",
				"RelatedDescription": "Open issue \"Cannot capture 405 error with CORS - CORE API\" (#3325)"
			}],
			"ResultType": "GitHubIssue"
		},
		"SignalR-Issues": {
			"Issues": [{
				"Id": "343700051",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T16:13:11",
				"Actor": "natemcmaster",
				"Number": "2670",
				"RawContent": null,
				"Title": "Compilation fails on macOS High Sierra: \"TypeError: The argument 'path' must be a string or Uint8Array without null bytes.\"",
				"State": "open",
				"Body": "The latest builds of the release/2.2 branch fail on our macOS High Sierra agents.\r\n\r\n```\r\n[04:27:22]  SignalR               |   /Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/signalr-protocol-msgpack/dist/cjs/browser-index.js → ./dist/browser/signalr-protocol-msgpack.js...\r\n[04:27:22]  SignalR               |   [!] TypeError [ERR_INVALID_ARG_VALUE]: The argument 'path' must be a string or Uint8Array without null bytes. Received '/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/signalr-protocol-msgpack/\\u0000commonjs-e...\r\n[04:27:22]  SignalR               |   TypeError [ERR_INVALID_ARG_VALUE]: The argument 'path' must be a string or Uint8Array without null bytes. Received '/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/signalr-protocol-msgpack/\\u0000commonjs-e...\r\n[04:27:22]  SignalR               |       at Object.stat (fs.js:794:3)\r\n[04:27:22]  SignalR               |       at isFile (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:22:12)\r\n[04:27:22]  SignalR               |       at loadpkg (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:118:9)\r\n[04:27:22]  SignalR               |       at load (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:85:18)\r\n[04:27:22]  SignalR               |       at loadAsFile (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:77:9)\r\n[04:27:22]  SignalR               |       at processDirs (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:186:9)\r\n[04:27:22]  SignalR               |       at loadNodeModules (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:201:9)\r\n[04:27:22]  SignalR               |       at resolve (/Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/resolve/lib/async.js:43:12)\r\n[04:27:22]  SignalR               |       at /Users/aspnetci/Documents/buildAgent/work/33bdfc1cae7b2a38/modules/SignalR/clients/ts/node_modules/rollup-plugin-node-resolve/dist/rollup-plugin-node-resolve.cjs.js:76:5\r\n[04:27:22]  SignalR               |       at new Promise (<anonymous>)\r\n```\r\nhttp://aspnetci/viewLog.html?tab=buildLog&logTab=tree&filter=debug&expand=all&buildId=512264&_focus=8074",
				"Url": "https://github.com/aspnet/SignalR/issues/2670",
				"RelatedDescription": "Open issue \"Compilation fails on macOS High Sierra: \"TypeError: The argument 'path' must be a string or Uint8Array without null bytes.\"\" (#2670)"
			},
			{
				"Id": "343565375",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T09:56:40",
				"Actor": "beradrian",
				"Number": "2669",
				"RawContent": null,
				"Title": "SignalR connection negotiation fails",
				"State": "open",
				"Body": "* Versions of Server-Side NuGet Packages: 2.3.0\r\n* Versions of Client-Side NPM Packages: 1.0.2\r\n* Are you using the C# client or the JavaScript client: TypeScript\r\n* The Server you are using (Kestrel/HttpSysServer/IIS/IIS Express/Azure Web App/etc.): Azure Web App\r\n* The Operating System on the Server (Windows/Linux/macOS): Windows\r\n* The Operating System on the Client (Windows/Linux/macOS): Windows\r\n* The Browser on the client, if using the JavaScript client (IE/Chrome/Edge/Firefox/etc.): Chrome\r\n\r\nI'm trying to use SignalR in an Angular application. I'm using the Typescript client `@aspnet/signalr`.\r\n\r\nWhat I get in the console is \r\n\r\n> Information: Normalizing '/api/signalr?connectionData=%5B%7B%22name%22%3A%22myhub%22%7D%5D' to 'http://server:port/api/signalr?connectionData=%5B%7B%22name%22%3A%22myhub%22%7D%5D'.\r\n>\r\n> Debug: Starting HubConnection. \r\n> \r\n> Debug: Starting connection with transfer format 'Text'. \r\n> \r\n> Debug: Sending negotiation request:\r\n> http://server:port/api/signalr/negotiate?connectionData=%5B%7B%22name%22%3A%22kanbanhub%22%7D%5D\r\n>\r\n> Error: Failed to start the connection: TypeError: Cannot read property 'length' of undefined\r\n\r\nThe error seems to come from the line `if (!(_i < transports_1.length)) return [3 /*break*/, 9];` in `HttpConnection`. It could be related to the fact that the negotiation response does not contain the `availableTransports` array.\r\n\r\n    {\r\n        \"Url\":\"/api/signalr\",\r\n        \"ConnectionToken\":\"XXX\",\r\n        \"ConnectionId\":\"XXX\",\r\n        \"KeepAliveTimeout\":20.0,\r\n        \"DisconnectTimeout\":30.0,\r\n        \"ConnectionTimeout\":110.0,\r\n        \"TryWebSockets\":false,\r\n        \"ProtocolVersion\":\"1.2\",\r\n        \"TransportConnectTimeout\":5.0,\r\n        \"LongPollDelay\":0.0\r\n    }\r\n\r\nAny idea why?\r\n\r\nI also asked this on SO: https://stackoverflow.com/questions/51449450\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2669",
				"RelatedDescription": "Open issue \"SignalR connection negotiation fails\" (#2669)"
			},
			{
				"Id": "342579236",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-22T18:24:05",
				"Actor": "davidfowl",
				"Number": "2659",
				"RawContent": null,
				"Title": "Turn on cookies by default for .NET Client",
				"State": "closed",
				"Body": "SignalR requires sticky sessions when using layer 7 load balancers. This is usually specified using cookies. Today we don't set a cookie container by default in the .NET Client which means it fails with a 404. We should turn it on by default.",
				"Url": "https://github.com/aspnet/SignalR/issues/2659",
				"RelatedDescription": "Closed issue \"Turn on cookies by default for .NET Client\" (#2659)"
			},
			{
				"Id": "343382758",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-22T06:57:09",
				"Actor": "ericbrunner",
				"Number": "2668",
				"RawContent": null,
				"Title": "SignalR Connection Stability - Connection Error and Connection Timeout",
				"State": "open",
				"Body": "* Versions of Server-Side NuGet Packages:  `Microsoft.Azure.SignalR V. 1.0.0-preview1-10015`\r\n* Versions of Client-Side NuGet/NPM Packages: `Microsoft.AspNetCore.SignalR.Client V. 1.0.2` / `signalr.js V. 1.0.2`\r\n* Are you using the C# client or the JavaScript client: `Both`\r\n* The Server you are using (Kestrel/HttpSysServer/IIS/IIS Express/Azure Web App/etc.): `WebApp and ApiApp (with SignalR Hub) are hosted in Azure App Service (guess both run on KESTREL, didn't changed anything in portal). The ApiApp uses the [Azure SignalR service](https://azure.microsoft.com/en-us/services/signalr-service/).`\r\n* The Operating System on the Server (Windows/Linux/macOS): `Azure App Service on WIndows`\r\n* The Operating System on the Client (Windows/Linux/macOS): `Windows/Linux`\r\n* The Browser on the client, if using the JavaScript client (IE/Chrome/Edge/Firefox/etc.): `Chrome/Edge/Firefox/Opera`\r\n\r\n\r\nI did everything mentioned in the Diagnostics Guide except the Fiddler tracing.\r\nDownload my logs from 2 separate TESTRUNS here => [SignalR-TestRuns.zip](https://github.com/aspnet/SignalR/files/2216757/SignalR-TestRuns.zip)\r\n\r\nI write down what I did and maybe it is easier to follow in context of the logs.\r\n\r\n1. I navigated to my the [SignalR test URL](https://truckerapp360-dev.azurewebsites.net/signalrtest) of  my WebApp \r\n2. From that URL the SignalR Hub at [https://truckerwebapp-api-dev.azurewebsites.net/chat](https://truckerwebapp-api-dev.azurewebsites.net/chat) is contacted (CORS in truckerwebapp-api.dev enabled). \r\n3. All javascript code from the [SignalR test URL](https://truckerapp360-dev.azurewebsites.net/signalrtest) can be found with right-click view source.\r\n4. I made 2 separate TESTRUNS\r\n   **TESTRUN1:**\r\n   Only on WIndows 10 Pro PC inside my company LAN\r\n   **TESTRUN2:**\r\n   On the WIndow 10 Pro PC inside my company LAN and from my private Ubuntu Linux PC at home.\r\n   The logs are separated and I hope you can easily locate them. If not feel free to contact me \r\n   immediately.\r\n\r\n**TESTRUN Descriptions:**\r\n\r\nTest Case: Test SignalR Connection Stability\r\n\r\n---- **TESTRUN 1** -------------------------------------------------------------------------\r\n\r\nDuration: 12 hours\r\nTests Hosting Environment: Window 10 Professional 64 bit\r\nWhere: On-Premises Window LAN behind Firefall\r\n \r\n\r\nWeb App (Test CORS) - OUTGOING REQUESTS\r\nURL: [https://truckerapp360-dev.azurewebsites.net/signalrtest](https://truckerapp360-dev.azurewebsites.net/signalrtest)\r\nHost: Azure \r\nType: App Service (Web App)\r\n\r\n-\t(Client Side)\r\n\tnpm @aspnet/signalr \r\n\t\t- `signalr.js V. 1.0.2`\r\n\t\r\nApi App (with SignalR Hub) - INCOMING REQUESTS\r\nSignalR Endpoint: [https://truckerwebapp-api-dev.azurewebsites.net/chat](https://truckerwebapp-api-dev.azurewebsites.net/chat) \r\nHost: Azure \r\nType: App Service (Api App)\r\n\r\n(Server Side)\r\nNuget\r\n\t- `Microsoft.Azure.SignalR V. 1.0.0-preview1-10015`\r\n\r\nApi App utilized Azure SignalR Service (currently for Tests on Free Plan max. 100 concurrent connections)!\r\n\r\nCode snippet:\r\n`services.AddSignalR(hubOptions => hubOptions.EnableDetailedErrors = true).AddAzureSignalR();`\r\n\t\r\n\r\n\r\nTests on : \r\n\r\n- .NET FW 4.6.1 (Console App) - OUTGOING REQUESTS (connect, wireup, start, receive)\r\n\r\n(Client Side) \r\nNuget\r\n\t- `Microsoft.AspNetCore.SignalR.Client V. 1.0.2`\r\n\r\n- .NET Core 2.1 (Console App) - OUTGOING REQUESTS (connect, wireup, start, receive)\r\n\r\n(Client Side)\r\nNuget\r\n\t- `Microsoft.AspNetCore.SignalR.Client V. 1.0.2`\r\n\r\n\r\n- Browser\r\n\t- `Chrome  Version 67.0.3396.99 (Official Build) (64-bit)`\r\n\t- `Opera Version 54.0.2952.60` \r\n\t\r\n\t\r\nStill running after 12 hours:\r\n\t- `.NET Core 2.1 (Console App)`\r\n\t- `Opera Version 54.0.2952.60`\r\n\t\r\n\tBrowser that lost Connection\r\n\t- `Chrome  Version 67.0.3396.99 (Official Build) (64-bit)`\r\n\r\n\t\r\n\tApp that lost connection\r\n\t`.NET FW 4.6.1 (Console App)`\r\n\t\r\n\r\n---------------- **TESTRUN 2** -------------------------------------------------------\r\n\r\nBROWSER:\r\nChrome (WIndows + Ubuntu)\r\nOpera (WIndows + Ubuntu)\r\nEdge\r\n\r\nTests Hosting Environment: Window 10 Professional 64 bit / Ubuntu Linux\r\nWhere: On-Premises Window LAN behind Firefall / Linux from external PC\r\n\r\nTests on : \r\n\r\n- .NET FW 4.6.1 (Console App) - OUTGOING REQUESTS (connect, wireup, start, receive)\r\n\r\n(Client Side) \r\nNuget\r\n\t- `Microsoft.AspNetCore.SignalR.Client V. 1.0.2`\r\n\r\n- .NET Core 2.1 (Console App) - OUTGOING REQUESTS (connect, wireup, start, receive)\r\n\r\n(Client Side)\r\nNuget\r\n\t- `Microsoft.AspNetCore.SignalR.Client V. 1.0.2`\r\n\r\n\r\n- Browser\r\n\t- `Chrome  Version 67.0.3396.99 (Official Build) (64-bit)`\r\n\t- `Opera Version 54.0.2952.60 `\r\n\t- `Microsoft Edge Version 41.16299.371.0 (Microsoft EdgeHTML 16.16299)`\r\n\r\n\r\n\r\nDuration: \t21 hours\r\nStarted\t: \t21.07.2018 11:20 am\r\nEnded\t:\t22.07.2018 08:20 am\r\n\r\n\r\n**Sample Code:**\r\n\r\nApiApp containing the SignalR Hub and TruckerAppChangeTracker Service that sends every 10 seconds data to all clients \r\n[TruckerWebApp.RestApi.zip](https://github.com/aspnet/SignalR/files/2216789/TruckerWebApp.RestApi.zip)\r\n[TruckerWebApp.RestApi.Samples.Net.Console.zip](https://github.com/aspnet/SignalR/files/2216790/TruckerWebApp.RestApi.Samples.Net.Console.zip)\r\n[TruckerWebApp.RestApi.Samples.NetCore.Console.zip](https://github.com/aspnet/SignalR/files/2216791/TruckerWebApp.RestApi.Samples.NetCore.Console.zip)\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2668",
				"RelatedDescription": "Open issue \"SignalR Connection Stability - Connection Error and Connection Timeout\" (#2668)"
			},
			{
				"Id": "343300545",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-21T05:50:45",
				"Actor": "ericbrunner",
				"Number": "2667",
				"RawContent": null,
				"Title": "Wiki - Diagnostics Guide Missing Console Nuget hint for .NET Client logging",
				"State": "open",
				"Body": "Hi\r\n\r\nJust followed that [Diagnostics Guide](https://github.com/aspnet/SignalR/wiki/Diagnostics-Guide) and got stuck when applying the [.NET Client logging](https://github.com/aspnet/SignalR/wiki/Diagnostics-Guide#net-client-logging) .\r\n\r\nThe extension method `AddConsole()` wasn't found. After gooling I found that @anurse mentioned that nuget extension package [here](https://github.com/aspnet/SignalR/issues/2466#issuecomment-396425386)\r\n\r\n`PM> install Microsoft.Extensions.Logging.Console\r\n`\r\n\r\nPlease add the hint to the Diagnostics Guide. Thanks!\r\nEric\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2667",
				"RelatedDescription": "Open issue \"Wiki - Diagnostics Guide Missing Console Nuget hint for .NET Client logging\" (#2667)"
			},
			{
				"Id": "343294128",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-21T04:45:45",
				"Actor": "anurse",
				"Number": "2666",
				"RawContent": null,
				"Title": "Test for cookies from negotiate being preserved by WebSocket request",
				"State": "closed",
				"Body": "Testing a hunch right now.",
				"Url": "https://github.com/aspnet/SignalR/pull/2666",
				"RelatedDescription": "Closed or merged PR \"Test for cookies from negotiate being preserved by WebSocket request\" (#2666)"
			},
			{
				"Id": "343279533",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-21T01:08:16",
				"Actor": "mikaelm12",
				"Number": "2665",
				"RawContent": null,
				"Title": "Refactor MockTransport in Java HubConnectionTests",
				"State": "closed",
				"Body": "There's some trickery in the MockTransport in the Java client's HubConnectionTests file. It should use `recieveMessage` and `getSentMessages` for 'sending' messages and for validating them. This change will touch every test in the file but it clears up the internals of the MockTransport and makes more complicated scenarios easier to test. \r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2665",
				"RelatedDescription": "Closed issue \"Refactor MockTransport in Java HubConnectionTests\" (#2665)"
			},
			{
				"Id": "342992770",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T16:46:37",
				"Actor": "yun738243875",
				"Number": "2663",
				"RawContent": null,
				"Title": "JS Client Support IE8？",
				"State": "closed",
				"Body": "same as title",
				"Url": "https://github.com/aspnet/SignalR/issues/2663",
				"RelatedDescription": "Closed issue \"JS Client Support IE8？\" (#2663)"
			},
			{
				"Id": "343079898",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T11:54:48",
				"Actor": "LucaGanio",
				"Number": "2664",
				"RawContent": null,
				"Title": "MessagePackHubProtocol and unions",
				"State": "open",
				"Body": "\r\nThe current version of the method  MessagePackHubProtocol.WriteArgument only takes two arguments:\r\nprivate void WriteArgument(object argument, Stream stream)\r\n\r\nThis is fine for regular serializations, but it is failing when an Interface marked with the Messagepack.UnionAttribute is used as an argument. This happens because the current implementation infer the type to pass to the serializer from a call to GetType(), while for the case of the union the interface type should be used.\r\n\r\nA possible solution would be to turn the WriteArgument method into a 3 arguments method, providing the real type of the argument along with its value\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2664",
				"RelatedDescription": "Open issue \"MessagePackHubProtocol and unions\" (#2664)"
			},
			{
				"Id": "342909569",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T22:21:41",
				"Actor": "dotnet-maestro-bot",
				"Number": "2662",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "open",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @BrennanConroy\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/SignalR merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/SignalR/pull/2662",
				"RelatedDescription": "Open PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2662)"
			},
			{
				"Id": "342116597",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T21:50:15",
				"Actor": "BrennanConroy",
				"Number": "2654",
				"RawContent": null,
				"Title": "Abort connection on protocol error",
				"State": "closed",
				"Body": "https://github.com/aspnet/SignalR/issues/2257",
				"Url": "https://github.com/aspnet/SignalR/pull/2654",
				"RelatedDescription": "Closed or merged PR \"Abort connection on protocol error\" (#2654)"
			},
			{
				"Id": "342888137",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T21:01:56",
				"Actor": "anurse",
				"Number": "2661",
				"RawContent": null,
				"Title": "SignalR Functional Tests very slow on some TC agents when VS Test Diagnostics enabled",
				"State": "open",
				"Body": "SignalR Tests were running very slowly on one of the build agents (aspnetci-a-100), and it looked to be due to the fact that VS Test diagnostics were on. It looks like the logging may have been slowing the tests down enough on that agent (and only that agent) so that it took >60 mins to run the whole build, causing TeamCity to shut it down.\r\n\r\nWe're not yet sure exactly why this is happening, so for now I have simply blocked the SignalR project build from running on that agent, to work around the issue (other agents are not having this problem). This bug is to keep track of the issue and allow us to track further investigation (now that the immediate issue is mitigated).\r\n\r\ncc @ryanbrandenburg \r\n\r\nI was seeing long-running test notifications like the following:\r\n\r\n```\r\n[16:34:38]  [xUnit.net 00:39:52.25] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:02:30\r\n[16:35:08]  [xUnit.net 00:40:23.19] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:03:01\r\n[16:36:22]  [xUnit.net 00:41:35.97] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:00:57\r\n[16:36:53]  [xUnit.net 00:42:07.74] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:01:29\r\n[16:37:24]  [xUnit.net 00:42:38.97] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:02:00\r\n[16:37:55]  [xUnit.net 00:43:09.98] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:02:31\r\n[16:38:26]  [xUnit.net 00:43:40.93] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:03:02\r\n[16:38:58]  [xUnit.net 00:44:11.92] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:03:33\r\n[16:39:29]  [xUnit.net 00:44:43.18] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:04:04\r\n[16:40:00]  [xUnit.net 00:45:14.31] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:04:35\r\n[16:40:31]  [xUnit.net 00:45:45.17] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"json\", transportType: LongPolling, path: \"/default\")', Elapsed: 00:05:06\r\n[16:41:50]  [xUnit.net 00:47:04.49] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:00:58\r\n[16:42:20]  [xUnit.net 00:47:35.05] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:01:29\r\n[16:42:52]  [xUnit.net 00:48:05.79] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:01:59\r\n[16:43:23]  [xUnit.net 00:48:37.06] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:02:31\r\n[16:43:54]  [xUnit.net 00:49:08.38] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/hubT\")', Elapsed: 00:03:02\r\n[16:45:01]  [xUnit.net 00:50:15.12] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/dynamic\")', Elapsed: 00:00:59\r\n[16:45:32]  [xUnit.net 00:50:46.68] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/dynamic\")', Elapsed: 00:01:31\r\n[16:46:04]  [xUnit.net 00:51:17.86] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/dynamic\")', Elapsed: 00:02:02\r\n[16:46:35]  [xUnit.net 00:51:49.51] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/dynamic\")', Elapsed: 00:02:33\r\n[16:47:06]  [xUnit.net 00:52:20.66] Microsoft.AspNetCore.SignalR.Client.FunctionalTests: [Long Running Test] 'Microsoft.AspNetCore.SignalR.Client.FunctionalTests.HubConnectionTests.CanStopAndStartConnection(protocolName: \"messagepack\", transportType: WebSockets, path: \"/dynamic\")', Elapsed: 00:03:05\r\n```\r\n\r\nHowever, the logs for the tests themselves showed very short running times (0.025281s in the example below):\r\n\r\n```\r\n[0.001s] [TestLifetime] [Information] Starting test \"CanStopAndStartConnection_json_WebSockets_dynamic\" at \"2018-07-18T22:55:29\"\r\n[0.001s] [ServerLogScope] [Information] Server log scope started.\r\n[0.001s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] Waiting on Connection Lock in StartAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:288).\r\n[0.001s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] Starting HubConnection.\r\n[0.001s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] Starting HttpConnection.\r\n[0.001s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] Establishing connection with server at 'http://127.0.0.1:49655/dynamic'.\r\n[0.001s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.LoggingHttpMessageHandler] [Verbose] Sending HTTP request POST 'http://127.0.0.1:49655/dynamic/negotiate'.\r\n[0.002s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URP\" started.\r\n[0.003s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request starting HTTP/1.1 POST http://127.0.0.1:49655/dynamic/negotiate  0\r\n[0.003s] [SERVER Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler] [Debug] AuthenticationScheme: Bearer was not authenticated.\r\n[0.003s] [SERVER Microsoft.AspNetCore.Routing.RouteBase] [Debug] Request successfully matched the route with name '(null)' and template '/dynamic/negotiate'.\r\n[0.003s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionManager] [Debug] New connection eElBhrFObvfkcSX0p5LLsA created.\r\n[0.003s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionDispatcher] [Debug] eElBhrFObvfkcSX0p5LLsA - Sending negotiation response.\r\n[0.003s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URP\" completed keep alive response.\r\n[0.004s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] Established connection 'eElBhrFObvfkcSX0p5LLsA' with the server.\r\n[0.004s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request finished in 1.1844ms 200 application/json\r\n[0.004s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Starting transport 'WebSockets' with Url: http://127.0.0.1:49655/dynamic?id=eElBhrFObvfkcSX0p5LLsA.\r\n[0.004s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Information] eElBhrFObvfkcSX0p5LLsA - Starting transport. Transfer mode: Text. Url: 'ws://127.0.0.1:49655/dynamic?id=eElBhrFObvfkcSX0p5LLsA'.\r\n[0.004s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URQ\" started.\r\n[0.005s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request starting HTTP/1.1 GET http://127.0.0.1:49655/dynamic?id=eElBhrFObvfkcSX0p5LLsA  \r\n[0.005s] [SERVER Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler] [Debug] AuthenticationScheme: Bearer was not authenticated.\r\n[0.005s] [SERVER Microsoft.AspNetCore.Routing.RouteBase] [Debug] Request successfully matched the route with name '(null)' and template '/dynamic'.\r\n[0.005s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionDispatcher] [Debug] eElBhrFObvfkcSX0p5LLsA - Establishing new connection.\r\n[0.005s] [SERVER Microsoft.AspNetCore.SignalR.HubConnectionHandler] [Debug] eElBhrFObvfkcSX0p5LLsA - OnConnectedAsync started.\r\n[0.005s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.Transports.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Socket opened using Sub-Protocol: '(null)'.\r\n[0.007s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Transport 'WebSockets' started.\r\n[0.007s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Information] eElBhrFObvfkcSX0p5LLsA - HttpConnection Started.\r\n[0.007s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Information] eElBhrFObvfkcSX0p5LLsA - Using HubProtocol 'json v1'.\r\n[0.007s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Sending Hub Handshake.\r\n[0.007s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Received message from application. Payload size: 32.\r\n[0.007s] [SERVER Microsoft.AspNetCore.SignalR.Internal.DefaultHubProtocolResolver] [Debug] eElBhrFObvfkcSX0p5LLsA - Found protocol implementation for requested protocol: json.\r\n[0.008s] [SERVER Microsoft.AspNetCore.SignalR.HubConnectionContext] [Information] eElBhrFObvfkcSX0p5LLsA - Completed connection handshake. Using HubProtocol 'json'.\r\n[0.008s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Message received. Type: Text, size: 19, EndOfMessage: True.\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Handshake with server complete.\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Receive loop starting.\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Sending PingMessage message.\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Sending PingMessage message completed.\r\n[0.008s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Received message from application. Payload size: 11.\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Information] eElBhrFObvfkcSX0p5LLsA - HubConnection started.\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Releasing Connection Lock in StartAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:331).\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Waiting on Connection Lock in InvokeCoreAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:442).\r\n[0.008s] [Microsoft.AspNetCore.SignalR.Client.Internal.InvocationRequest.NonStreaming] [Verbose] eElBhrFObvfkcSX0p5LLsA - Invocation 1 created.\r\n[0.009s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Preparing blocking invocation '1' of 'Echo', with return type 'System.String' and 1 argument(s).\r\n[0.009s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Registering Invocation ID '1' for tracking.\r\n[0.009s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Issuing Invocation '1': System.String Echo(System.String).\r\n[0.009s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Sending InvocationMessage message '1'.\r\n[0.009s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Sending InvocationMessage message '1' completed.\r\n[0.009s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Received message from application. Payload size: 70.\r\n[0.009s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Releasing Connection Lock in InvokeCoreAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:455).\r\n[0.009s] [SERVER Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher] [Debug] eElBhrFObvfkcSX0p5LLsA - Received hub invocation: InvocationMessage { InvocationId: \"1\", Target: \"Echo\", Arguments: [ SignalR ] }.\r\n[0.009s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Message received. Type: Text, size: 49, EndOfMessage: True.\r\n[0.010s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Processing 49 byte message from server.\r\n[0.010s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Resetting keep-alive timer, received a message from the server.\r\n[0.010s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Received Completion for Invocation 1.\r\n[0.010s] [Microsoft.AspNetCore.SignalR.Client.Internal.InvocationRequest.NonStreaming] [Verbose] eElBhrFObvfkcSX0p5LLsA - Invocation 1 marked as completed.\r\n[0.010s] [Microsoft.AspNetCore.SignalR.Client.Internal.InvocationRequest.NonStreaming] [Verbose] eElBhrFObvfkcSX0p5LLsA - Invocation 1 disposed.\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Waiting on Connection Lock in StopAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:347).\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Releasing Connection Lock in StopAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:374).\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Stopping HubConnection.\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Terminating receive loop.\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Waiting for the receive loop to terminate.\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Waiting on Connection Lock in ReceiveLoop (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:840).\r\n[0.011s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Releasing Connection Lock in ReceiveLoop (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:849).\r\n[0.012s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Disposing HttpConnection.\r\n[0.012s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Information] eElBhrFObvfkcSX0p5LLsA - Transport is stopping.\r\n[0.012s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Send loop stopped.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.Transports.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Waiting for the application to finish sending data.\r\n[0.012s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Transport stopped.\r\n[0.012s] [SERVER Microsoft.AspNetCore.SignalR.HubConnectionHandler] [Debug] eElBhrFObvfkcSX0p5LLsA - OnConnectedAsync ending.\r\n[0.012s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Information] eElBhrFObvfkcSX0p5LLsA - HttpConnection Disposed.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URQ\" reset.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.Transports.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Socket closed.\r\n[0.012s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - Canceling all outstanding invocations.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URP\" received FIN.\r\n[0.012s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] eElBhrFObvfkcSX0p5LLsA - Shutting down connection.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URQ\" disconnecting.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionManager] [Debug] eElBhrFObvfkcSX0p5LLsA - Removing connection eElBhrFObvfkcSX0p5LLsA from the list of connections.\r\n[0.012s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] eElBhrFObvfkcSX0p5LLsA - HubConnection stopped.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URQ\" reset.\r\n[0.012s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URP\" disconnecting.\r\n[0.012s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] Waiting on Connection Lock in StartAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:288).\r\n[0.013s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URQ\" sending FIN.\r\n[0.013s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request finished in 7.4594ms 101 \r\n[0.013s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URP\" sending FIN.\r\n[0.013s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] Starting HubConnection.\r\n[0.013s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URQ\" stopped.\r\n[0.013s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] Starting HttpConnection.\r\n[0.013s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] Establishing connection with server at 'http://127.0.0.1:49655/dynamic'.\r\n[0.013s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] eElBhrFObvfkcSX0p5LLsA - Receive loop stopped.\r\n[0.013s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URP\" stopped.\r\n[0.013s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.LoggingHttpMessageHandler] [Verbose] Sending HTTP request POST 'http://127.0.0.1:49655/dynamic/negotiate'.\r\n[0.014s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URR\" started.\r\n[0.014s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request starting HTTP/1.1 POST http://127.0.0.1:49655/dynamic/negotiate  0\r\n[0.014s] [SERVER Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler] [Debug] AuthenticationScheme: Bearer was not authenticated.\r\n[0.014s] [SERVER Microsoft.AspNetCore.Routing.RouteBase] [Debug] Request successfully matched the route with name '(null)' and template '/dynamic/negotiate'.\r\n[0.014s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionManager] [Debug] New connection 3wLQUDyohkcmLBP0ohjpaw created.\r\n[0.015s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionDispatcher] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Sending negotiation response.\r\n[0.015s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URR\" completed keep alive response.\r\n[0.015s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] Established connection '3wLQUDyohkcmLBP0ohjpaw' with the server.\r\n[0.015s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request finished in 1.0609ms 200 application/json\r\n[0.015s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Starting transport 'WebSockets' with Url: http://127.0.0.1:49655/dynamic?id=3wLQUDyohkcmLBP0ohjpaw.\r\n[0.015s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Information] 3wLQUDyohkcmLBP0ohjpaw - Starting transport. Transfer mode: Text. Url: 'ws://127.0.0.1:49655/dynamic?id=3wLQUDyohkcmLBP0ohjpaw'.\r\n[0.016s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URS\" started.\r\n[0.016s] [SERVER Microsoft.AspNetCore.Hosting.Internal.WebHost] [Information] Request starting HTTP/1.1 GET http://127.0.0.1:49655/dynamic?id=3wLQUDyohkcmLBP0ohjpaw  \r\n[0.016s] [SERVER Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler] [Debug] AuthenticationScheme: Bearer was not authenticated.\r\n[0.016s] [SERVER Microsoft.AspNetCore.Routing.RouteBase] [Debug] Request successfully matched the route with name '(null)' and template '/dynamic'.\r\n[0.017s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.HttpConnectionDispatcher] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Establishing new connection.\r\n[0.017s] [SERVER Microsoft.AspNetCore.SignalR.HubConnectionHandler] [Debug] 3wLQUDyohkcmLBP0ohjpaw - OnConnectedAsync started.\r\n[0.017s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.Transports.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Socket opened using Sub-Protocol: '(null)'.\r\n[0.017s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Transport 'WebSockets' started.\r\n[0.017s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Information] 3wLQUDyohkcmLBP0ohjpaw - HttpConnection Started.\r\n[0.017s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Information] 3wLQUDyohkcmLBP0ohjpaw - Using HubProtocol 'json v1'.\r\n[0.017s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Sending Hub Handshake.\r\n[0.018s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Received message from application. Payload size: 32.\r\n[0.018s] [SERVER Microsoft.AspNetCore.SignalR.Internal.DefaultHubProtocolResolver] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Found protocol implementation for requested protocol: json.\r\n[0.018s] [SERVER Microsoft.AspNetCore.SignalR.HubConnectionContext] [Information] 3wLQUDyohkcmLBP0ohjpaw - Completed connection handshake. Using HubProtocol 'json'.\r\n[0.018s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Message received. Type: Text, size: 19, EndOfMessage: True.\r\n[0.018s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Handshake with server complete.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Receive loop starting.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Sending PingMessage message.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Sending PingMessage message completed.\r\n[0.019s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Received message from application. Payload size: 11.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Information] 3wLQUDyohkcmLBP0ohjpaw - HubConnection started.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Releasing Connection Lock in StartAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:331).\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Waiting on Connection Lock in InvokeCoreAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:442).\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.Internal.InvocationRequest.NonStreaming] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Invocation 1 created.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Preparing blocking invocation '1' of 'Echo', with return type 'System.String' and 1 argument(s).\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Registering Invocation ID '1' for tracking.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Issuing Invocation '1': System.String Echo(System.String).\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Sending InvocationMessage message '1'.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Sending InvocationMessage message '1' completed.\r\n[0.019s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Received message from application. Payload size: 70.\r\n[0.019s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Releasing Connection Lock in InvokeCoreAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:455).\r\n[0.020s] [SERVER Microsoft.AspNetCore.SignalR.Internal.DefaultHubDispatcher] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Received hub invocation: InvocationMessage { InvocationId: \"1\", Target: \"Echo\", Arguments: [ SignalR ] }.\r\n[0.020s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Message received. Type: Text, size: 49, EndOfMessage: True.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Processing 49 byte message from server.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Resetting keep-alive timer, received a message from the server.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Received Completion for Invocation 1.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.Internal.InvocationRequest.NonStreaming] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Invocation 1 marked as completed.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.Internal.InvocationRequest.NonStreaming] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Invocation 1 disposed.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Waiting on Connection Lock in StopAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:347).\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Releasing Connection Lock in StopAsyncCore (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:374).\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Stopping HubConnection.\r\n[0.020s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Terminating receive loop.\r\n[0.021s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Waiting for the receive loop to terminate.\r\n[0.021s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Waiting on Connection Lock in ReceiveLoop (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:840).\r\n[0.021s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Releasing Connection Lock in ReceiveLoop (/_/src/Microsoft.AspNetCore.SignalR.Client.Core/HubConnection.cs:849).\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Disposing HttpConnection.\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Information] 3wLQUDyohkcmLBP0ohjpaw - Transport is stopping.\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Send loop stopped.\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Message received. Type: Text, size: 11, EndOfMessage: True.\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Receive loop stopped.\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Transport stopped.\r\n[0.021s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.Transports.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Waiting for the application to finish sending data.\r\n[0.021s] [Microsoft.AspNetCore.Http.Connections.Client.HttpConnection] [Information] 3wLQUDyohkcmLBP0ohjpaw - HttpConnection Disposed.\r\n[0.021s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URS\" reset.\r\n[0.021s] [SERVER Microsoft.AspNetCore.Http.Connections.Internal.Transports.WebSocketsTransport] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Socket closed.\r\n[0.026s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - Canceling all outstanding invocations.\r\n[0.026s] [SERVER Microsoft.AspNetCore.Server.Kestrel] [Debug] Connection id \"0HLFD05SJ7URS\" disconnecting.\r\n[0.026s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Verbose] 3wLQUDyohkcmLBP0ohjpaw - Shutting down connection.\r\n[0.026s] [SERVER Microsoft.AspNetCore.SignalR.HubConnectionHandler] [Debug] 3wLQUDyohkcmLBP0ohjpaw - OnConnectedAsync ending.\r\n[0.026s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URR\" received FIN.\r\n[0.026s] [Microsoft.AspNetCore.SignalR.Client.HubConnection] [Debug] 3wLQUDyohkcmLBP0ohjpaw - HubConnection stopped.\r\n[0.026s] [ServerLogScope] [Information] Server log scope stopped.\r\n[0.026s] [SERVER Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets] [Debug] Connection id \"0HLFD05SJ7URS\" reset.\r\n[0.026s] [TestLifetime] [Information] Finished test \"CanStopAndStartConnection_json_WebSockets_dynamic\" in 0.025281s\r\n```",
				"Url": "https://github.com/aspnet/SignalR/issues/2661",
				"RelatedDescription": "Open issue \"SignalR Functional Tests very slow on some TC agents when VS Test Diagnostics enabled\" (#2661)"
			},
			{
				"Id": "342846703",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T18:48:20",
				"Actor": "mikaelm12",
				"Number": "2660",
				"RawContent": null,
				"Title": "Adding Overloads up to T8.",
				"State": "open",
				"Body": "Issue: https://github.com/aspnet/SignalR/issues/2626",
				"Url": "https://github.com/aspnet/SignalR/pull/2660",
				"RelatedDescription": "Open PR \"Adding Overloads up to T8.\" (#2660)"
			},
			{
				"Id": "342007525",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T17:17:01",
				"Actor": "windischb",
				"Number": "2649",
				"RawContent": null,
				"Title": "Send OAuth Token inside WebSocket message and validate on server",
				"State": "closed",
				"Body": "Hi!\r\n\r\nI'm looking for a way to get better control of the OAuth token.\r\nIf i understand the current implementation correct, the token will only be sent once -> before the http connection is upgraded to websockets, or?\r\nWe use Reference Tokens for Authentication, which means that the API can check if the token on every request, if it is still valid and not expired.\r\n\r\nFor now i'm always create a JSON Object with the token and all necessary Properties\r\n```js\r\n\r\nlet msg = {\r\n  \"Id\": \"59b42621-1b62-4d9f-bc40-aad031408d81\",\r\n  \"AuthData\": \"ba2f4c04e731d4c3033dd1fef0530bc0bd0e6cbe808321495dc7c4669c7b1d9e\",\r\n  \"Method\": \"GetItemsByCategory\",\r\n  \"Arguments\": [\"Books\"]\r\n}\r\n\r\nthis.hubConnection.invoke(\"InvokeServerMethod\", msg)\r\n```\r\n\r\nOn the ServerSide there is only one Method in my Hub:\r\n```csharp\r\npublic async Task<SignalRResponse> InvokeServerMethod(SignalRMessage message) {\r\n    try {\r\n        return await SignalRServerMethodManager.InvokeServerMessageAsync(this, message);\r\n    } catch (Exception ex) {\r\n        return new SignalRResponse(message.Id) {\r\n            Error = ex\r\n        };\r\n    }         \r\n}\r\n```\r\n\r\nEvery `SignalRMessage` is processed by this Method.\r\n1. Check if the Token is still valid -> cached, or if cache expired(5min), validated on IdentityServer\r\n2. Search the Method with matching Arguments using Reflection -> `GetItemsByCategory(string category)` \r\n3. Invoke the Method\r\n4. return a `SignalRResponse` with the result or error\r\n\r\nSo far it works well, but i try to find a better way.\r\nI use this way in a few Projects, and i always have to do the heavy lifting with Reflection and so on...\r\n\r\nIt would be great if there where a `Middleware` or something similar which can be used for validating the token before the Method in the SignalRHub is invoked!\r\nThat would save me to do all that terrible stuff...\r\n\r\nBr\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2649",
				"RelatedDescription": "Closed issue \"Send OAuth Token inside WebSocket message and validate on server\" (#2649)"
			},
			{
				"Id": "342443642",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-18T22:47:53",
				"Actor": "mikaelm12",
				"Number": "2657",
				"RawContent": null,
				"Title": "Adding MinorVersion field to HandshakeResponse in TS client",
				"State": "closed",
				"Body": "Just adding the field to the interface for 3.0. Both this client and the C# client don't actually utilize it yet.",
				"Url": "https://github.com/aspnet/SignalR/pull/2657",
				"RelatedDescription": "Closed or merged PR \"Adding MinorVersion field to HandshakeResponse in TS client\" (#2657)"
			},
			{
				"Id": "342460110",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T19:26:20",
				"Actor": "mikaelm12",
				"Number": "2658",
				"RawContent": null,
				"Title": "HubDescriptor Type",
				"State": "open",
				"Body": "Consider changing the HubInvocationBinder and HubDispatcher to use a common HubDescriptor layer to remove the coupling between the binder and the dispatcher",
				"Url": "https://github.com/aspnet/SignalR/issues/2658",
				"RelatedDescription": "Open issue \"HubDescriptor Type\" (#2658)"
			},
			{
				"Id": "342436109",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-18T18:10:52",
				"Actor": "mikaelm12",
				"Number": "2656",
				"RawContent": null,
				"Title": "Parse HandshakeResponse",
				"State": "open",
				"Body": "Issue: https://github.com/aspnet/SignalR/issues/2621\r\nProperly parsing the handshake response.",
				"Url": "https://github.com/aspnet/SignalR/pull/2656",
				"RelatedDescription": "Open PR \"Parse HandshakeResponse\" (#2656)"
			},
			{
				"Id": "342136798",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T03:51:06",
				"Actor": "TheBuzzSaw",
				"Number": "2655",
				"RawContent": null,
				"Title": "What happened to the video about SignalR?",
				"State": "closed",
				"Body": "This is referenced on the README page: https://www.youtube.com/watch?v=u0_vkWYYXRc\r\n\r\nDid Microsoft withdraw all these videos? :(",
				"Url": "https://github.com/aspnet/SignalR/issues/2655",
				"RelatedDescription": "Closed issue \"What happened to the video about SignalR?\" (#2655)"
			},
			{
				"Id": "342107095",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T22:09:06",
				"Actor": "mikaelm12",
				"Number": "2653",
				"RawContent": null,
				"Title": "Handshake Response needs Minor Version property in TS Client",
				"State": "open",
				"Body": "For 3.0 the handshake response will contain a minor version property. This needs to be added to the `HandshakeResponse` type in the TS client.\r\nhttps://github.com/aspnet/SignalR/blob/bd0d29711164a39a1715ddc360134aca3df93946/clients/ts/signalr/src/HandshakeProtocol.ts#L11-L13\r\n\r\nReference to the C# client's `HandshakeResponse`\r\nhttps://github.com/aspnet/SignalR/blob/bd0d29711164a39a1715ddc360134aca3df93946/src/Microsoft.AspNetCore.SignalR.Common/Protocol/HandshakeResponseMessage.cs#L21-L24",
				"Url": "https://github.com/aspnet/SignalR/issues/2653",
				"RelatedDescription": "Open issue \"Handshake Response needs Minor Version property in TS Client\" (#2653)"
			},
			{
				"Id": "342062895",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-17T20:20:02",
				"Actor": "dotnet-maestro-bot",
				"Number": "2652",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @mikaelm12\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/SignalR merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/SignalR/pull/2652",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2652)"
			},
			{
				"Id": "342053033",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-17T20:20:00",
				"Actor": "mikaelm12",
				"Number": "2651",
				"RawContent": null,
				"Title": "Adding the Subscription type to remove specific handlers (#2646)",
				"State": "closed",
				"Body": "",
				"Url": "https://github.com/aspnet/SignalR/pull/2651",
				"RelatedDescription": "Closed or merged PR \"Adding the Subscription type to remove specific handlers (#2646)\" (#2651)"
			},
			{
				"Id": "341725901",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T19:27:42",
				"Actor": "mikaelm12",
				"Number": "2645",
				"RawContent": null,
				"Title": "Add Subscription type for removing Single handlers from HubConnection.",
				"State": "closed",
				"Body": "The `Subscription` is the return value of calls to `on` in `HubConnection`. With references to a subscription a user can remove a specific handler from a `HubConnection `instead of removing all handlers associated with an invocation target",
				"Url": "https://github.com/aspnet/SignalR/issues/2645",
				"RelatedDescription": "Closed issue \"Add Subscription type for removing Single handlers from HubConnection.\" (#2645)"
			},
			{
				"Id": "341726038",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-17T19:27:16",
				"Actor": "mikaelm12",
				"Number": "2646",
				"RawContent": null,
				"Title": "Adding the Subscription type to remove specific handlers",
				"State": "closed",
				"Body": "Issue: https://github.com/aspnet/SignalR/issues/2645",
				"Url": "https://github.com/aspnet/SignalR/pull/2646",
				"RelatedDescription": "Closed or merged PR \"Adding the Subscription type to remove specific handlers\" (#2646)"
			},
			{
				"Id": "342040793",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T18:50:41",
				"Actor": "eduardoyupanqui",
				"Number": "2650",
				"RawContent": null,
				"Title": "Microsoft.AspNetCore.SignalR.1.0.2 for ASP.NET Core 2.0 projects",
				"State": "open",
				"Body": "Can i use this nuget for ASP.NET Core 2.0 projects?. We plan to migrate to ASP.NET Core 2.1 next month.\r\n\r\nThanks.\r\nEduardo",
				"Url": "https://github.com/aspnet/SignalR/issues/2650",
				"RelatedDescription": "Open issue \"Microsoft.AspNetCore.SignalR.1.0.2 for ASP.NET Core 2.0 projects\" (#2650)"
			},
			{
				"Id": "341773135",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T16:51:26",
				"Actor": "Tristyn",
				"Number": "2648",
				"RawContent": null,
				"Title": "System.InvalidOperationException on C# UWP client",
				"State": "closed",
				"Body": "In a blank UWP app:\r\n\r\n```\r\nnamespace App1\r\n{\r\n    public sealed partial class MainPage : Page\r\n    {\r\n        public MainPage()\r\n        {\r\n            this.InitializeComponent();\r\n            \r\n            Init();\r\n        }\r\n\r\n        private async void Init()\r\n        {\r\n            await Task.Delay(4000);\r\n            // Wait for server to listen\r\n\r\n            var hub = new HubConnectionBuilder()\r\n                .WithUrl(\"http://localhost:5000/api/v1/myhub\")\r\n                .Build();\r\n\r\n            await hub.StartAsync();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI get the exception `System.InvalidOperationException: 'Unable to connect to the server with any of the available transports.'`\r\n\r\nI reproduced it at [https://github.com/Tristyn/SignalrUwpRepro](https://github.com/Tristyn/SignalrUwpRepro), by starting multiple projects in VS it will work on the console app, however throws on UWP.\r\n\r\nI used Kestrel with https disabled for simplicity.\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2648",
				"RelatedDescription": "Closed issue \"System.InvalidOperationException on C# UWP client\" (#2648)"
			},
			{
				"Id": "341738310",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T02:36:36",
				"Actor": "ly745455",
				"Number": "2647",
				"RawContent": null,
				"Title": "how ios object-c connection to signalr, is have demo?",
				"State": "closed",
				"Body": "### Please consider the following before filing an issue\r\n\r\n* If you are using NuGet Packages that start with `Microsoft.AspNet.SignalR`, use the issue tracker at https://github.com/SignalR/SignalR to report the issue. This \r\nrepository is for packages that start with `Microsoft.AspNetCore.SignalR` (and NPM packages that start with `@aspnet/signalr`)\r\n\r\n### Please include as much of the following as you can in your bug report\r\n\r\n* Versions of Server-Side NuGet Packages:\r\n* Versions of Client-Side NuGet/NPM Packages:\r\n* Are you using the C# client or the JavaScript client:\r\n* The Server you are using (Kestrel/HttpSysServer/IIS/IIS Express/Azure Web App/etc.): \r\n* The Operating System on the Server (Windows/Linux/macOS):\r\n* The Operating System on the Client (Windows/Linux/macOS):\r\n* The Browser on the client, if using the JavaScript client (IE/Chrome/Edge/Firefox/etc.):\r\n* Please use the Diagnostics Guide at https://github.com/aspnet/SignalR/wiki/Diagnostics-Guide to collect server-side and client-side logs and network traces if possible. Please **do not** put the traces and logs in the Issue text as they are quite large. The Diagnostics Guide describes how to attach them to the issue.\r\n\r\nWhen in doubt, feel free to file the issue, we're happy to help answer questions. We also suggest using the `asp.net-core-signalr` tag on StackOverflow to ask questions.\r\n",
				"Url": "https://github.com/aspnet/SignalR/issues/2647",
				"RelatedDescription": "Closed issue \"how ios object-c connection to signalr, is have demo?\" (#2647)"
			},
			{
				"Id": "341711207",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T23:33:07",
				"Actor": "mikaelm12",
				"Number": "2644",
				"RawContent": null,
				"Title": "Remove handlers from HubConnection (#2628)",
				"State": "closed",
				"Body": "Merging back from 2.2\r\n",
				"Url": "https://github.com/aspnet/SignalR/pull/2644",
				"RelatedDescription": "Closed or merged PR \"Remove handlers from HubConnection (#2628)\" (#2644)"
			},
			{
				"Id": "341691284",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T21:53:07",
				"Actor": "dotnet-maestro-bot",
				"Number": "2643",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @mikaelm12\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/SignalR merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/SignalR/pull/2643",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2643)"
			},
			{
				"Id": "341683356",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T21:53:06",
				"Actor": "mikaelm12",
				"Number": "2642",
				"RawContent": null,
				"Title": "Adding HubConnection State Enum (#2627)",
				"State": "closed",
				"Body": "Merging back to master",
				"Url": "https://github.com/aspnet/SignalR/pull/2642",
				"RelatedDescription": "Closed or merged PR \"Adding HubConnection State Enum (#2627)\" (#2642)"
			},
			{
				"Id": "341676319",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T20:56:46",
				"Actor": "BrennanConroy",
				"Number": "2641",
				"RawContent": null,
				"Title": "Backport WebPack change from 2.2",
				"State": "open",
				"Body": "Backport https://github.com/aspnet/SignalR/pull/2496 from 2.2 to make 2.1 builds pass.",
				"Url": "https://github.com/aspnet/SignalR/pull/2641",
				"RelatedDescription": "Open PR \"Backport WebPack change from 2.2\" (#2641)"
			}],
			"ResultType": "GitHubIssue"
		},
		"Identity-Issues": {
			"Issues": [{
				"Id": "343719379",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:11:04",
				"Actor": "Rick-Anderson",
				"Number": "1888",
				"RawContent": null,
				"Title": "No way to resend confirmation email",
				"State": "open",
				"Body": "From #1662\r\n\r\n**No way to resend confirmation email**\r\n\r\nIf you somehow didn't receive (or accidentally deleted, etc.) your confirmation email, then your account is dead forever, because there's no way to resend it. It's worse still if v1 of your site didn't implement confirmation emails, but v2 does, because then all existing users lose their accounts.\r\n\r\nThis is the `#1` ask from the docs feedback.\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1888",
				"RelatedDescription": "Open issue \"No way to resend confirmation email\" (#1888)"
			},
			{
				"Id": "343572939",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T10:19:35",
				"Actor": "binhghi5",
				"Number": "1887",
				"RawContent": null,
				"Title": "Why you remove ApplicationUser?",
				"State": "open",
				"Body": "In 2.0 we use to have an ApplicationUser class. I can add some custom fields and create relationship with another classes. Why you remove ApplicationUser class. Any reason?",
				"Url": "https://github.com/aspnet/Identity/issues/1887",
				"RelatedDescription": "Open issue \"Why you remove ApplicationUser?\" (#1887)"
			},
			{
				"Id": "341647823",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T17:50:38",
				"Actor": "postb99",
				"Number": "1879",
				"RawContent": null,
				"Title": "Why isn't there a FindByNormalizedName method?",
				"State": "closed",
				"Body": "Hello,\r\n\r\nI'm reading UserManager and RoleManager API documentation. I've understood the usefulness of normalized name/email, to have consistent comparison, maybe also a uniqueness value check.\r\n\r\nWhy aren't there FindByNormalizedNameAsync (UserManager and RoleManager) and FindByNormalizedEmail (UserManager) methods?\r\n\r\nThanks for information.",
				"Url": "https://github.com/aspnet/Identity/issues/1879",
				"RelatedDescription": "Closed issue \"Why isn't there a FindByNormalizedName method?\" (#1879)"
			},
			{
				"Id": "342687415",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T17:47:44",
				"Actor": "Ponant",
				"Number": "1884",
				"RawContent": null,
				"Title": "Difference between AddDefaultIdentity and AddIdentity??",
				"State": "closed",
				"Body": "In scaffolding Identity I get this in ASP.NET Core 2.1:\r\n\r\n```\r\n  services.AddDefaultIdentity<ApplicationUser>()\r\n                    .AddEntityFrameworkStores<ApplicationDbContext>();\r\n\r\n```\r\n\r\nWhereas the previous templates produced this\r\n\r\n ```\r\n  services.AddIdentity<ApplicationUser, IdentityRole>()\r\n        .AddEntityFrameworkStores<ApplicationDbContext>()\r\n        .AddDefaultTokenProviders();\r\n```\r\nWhich was clearer.\r\nIs is possible to understand the difference please? What does the former has that the latter does not? Can I just replace the former by the latter?\r\nThanks\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1884",
				"RelatedDescription": "Closed issue \"Difference between AddDefaultIdentity and AddIdentity??\" (#1884)"
			},
			{
				"Id": "342268347",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T13:09:21",
				"Actor": "Dolphinsimon",
				"Number": "1882",
				"RawContent": null,
				"Title": "Register users keep login failed in the default scaffolded identity razor pages.",
				"State": "closed",
				"Body": "In the default scaffolded Identity razor page-Login, users can login with email and password.\r\n```\r\n                <div class=\"form-group\">\r\n                    <label asp-for=\"Input.Email\"></label>\r\n                    <input asp-for=\"Input.Email\" class=\"form-control\" />\r\n                    <span asp-validation-for=\"Input.Email\" class=\"text-danger\"></span>\r\n                </div>\r\n                <div class=\"form-group\">\r\n                    <label asp-for=\"Input.Password\"></label>\r\n                    <input asp-for=\"Input.Password\" class=\"form-control\" />\r\n                    <span asp-validation-for=\"Input.Password\" class=\"text-danger\"></span>\r\n                </div>\r\n```\r\n\r\nHowever, the OnPostAsync() checks email and password with PasswordSignInAsync() witch sign in users\r\nby username and password.\r\n\r\n\r\n```\r\npublic async Task<IActionResult> OnPostAsync(string returnUrl = null)\r\n        {\r\n            returnUrl = returnUrl ?? Url.Content(\"~/\");\r\n\r\n            if (ModelState.IsValid)\r\n            {\r\n                // This doesn't count login failures towards account lockout\r\n                // To enable password failures to trigger account lockout, set lockoutOnFailure: true\r\n                var result = await _signInManager.PasswordSignInAsync(Input.Email, Input.Password, Input.RememberMe, lockoutOnFailure: true);\r\n                if (result.Succeeded)\r\n                {\r\n                    _logger.LogInformation(\"User logged in.\");\r\n                    return LocalRedirect(returnUrl);\r\n                }\r\n                if (result.RequiresTwoFactor)\r\n                {\r\n                    return RedirectToPage(\"./LoginWith2fa\", new { ReturnUrl = returnUrl, RememberMe = Input.RememberMe });\r\n                }\r\n                if (result.IsLockedOut)\r\n                {\r\n                    _logger.LogWarning(\"User account locked out.\");\r\n                    return RedirectToPage(\"./Lockout\");\r\n                }\r\n                else\r\n                {\r\n                    ModelState.AddModelError(string.Empty, \"Invalid login attempt.\");\r\n                    return Page();\r\n                }\r\n            }\r\n\r\n            // If we got this far, something failed, redisplay form\r\n            return Page();\r\n        }\r\n```\r\n\r\n\r\nIt seems that you won't login to your system forever.\r\nSo, witch situation was by designed? Login with username or email?\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1882",
				"RelatedDescription": "Closed issue \"Register users keep login failed in the default scaffolded identity razor pages.\" (#1882)"
			},
			{
				"Id": "342706152",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T18:04:02",
				"Actor": "huxiaozhong",
				"Number": "1885",
				"RawContent": null,
				"Title": "How can i use AspNetCore.Identity  in .net4.7 mvc5",
				"State": "closed",
				"Body": "i want use AspNetCore.Identity in  .net4.7 mvc5 ,can you  help me  or  give me some example;\r\n\r\ni want to know  how to resoleve  SignInManager<User> in Controller",
				"Url": "https://github.com/aspnet/Identity/issues/1885",
				"RelatedDescription": "Closed issue \"How can i use AspNetCore.Identity  in .net4.7 mvc5\" (#1885)"
			},
			{
				"Id": "342777573",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T18:02:50",
				"Actor": "Ponant",
				"Number": "1886",
				"RawContent": null,
				"Title": "Scaffold Identity omits custom ApplicationUser",
				"State": "closed",
				"Body": "**Works**\r\n1) New project 2.1 MVC with no auth\r\n2) Scaffold identity and choose the plus button for the user class\r\n\r\n![scaffoldidentity21](https://user-images.githubusercontent.com/19961806/42952012-cef98632-8b77-11e8-9c61-219423f81672.PNG)\r\n\r\nThe resulting code is expected because it refers to `ApplicationUser`\r\n\r\n`    public class ApplicationDbContext : IdentityDbContext<ApplicationUser>\r\n`\r\n`                services.AddDefaultIdentity<ApplicationUser>()\r\n`\r\n\r\n**Does not work**\r\n1) New project 2.1 MVC with no auth\r\n2) Create a class ApplicationUser that derives from IdentityUser\r\n`    public class ApplicationUser : IdentityUser\r\n`\r\n3) Scaffold identity and choose the **dropdown** button for the user class\r\n\r\n![scaffoldidentity21bug](https://user-images.githubusercontent.com/19961806/42952344-8aa84c10-8b78-11e8-96d4-c37ede8b262c.PNG)\r\n\r\n\r\nThe resulting code is unexpected because it refers to `IdentityUser`. `ApplicationUser `is totally ignored\r\n\r\n`    public class ApplicationDbContext : IdentityDbContext<IdentityUser>\r\n`\r\n`                services.AddDefaultIdentity<IdentityUser>()\r\n`\r\n\r\nBug?",
				"Url": "https://github.com/aspnet/Identity/issues/1886",
				"RelatedDescription": "Closed issue \"Scaffold Identity omits custom ApplicationUser\" (#1886)"
			},
			{
				"Id": "342559767",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T02:48:12",
				"Actor": "christiansk",
				"Number": "1883",
				"RawContent": null,
				"Title": "Make Context virtual in UserStore",
				"State": "open",
				"Body": "Could the [Context property](https://github.com/aspnet/Identity/blob/9ecbefcf21d12d90ac187e1eefe02ed0219edc23/src/EF/UserStore.cs#L126) be marked as virtual in UserStore? I would like to implement my own getter so I can better manage the lifecycle of the DbContext (to enforce better control over the transaction boundaries).\r\nI have implemented an unit of work using the [DbContextScope library](https://github.com/apawsey/DbContextScope) and it's working great throughout my app, so I would like to use it for Identity as well.",
				"Url": "https://github.com/aspnet/Identity/issues/1883",
				"RelatedDescription": "Open issue \"Make Context virtual in UserStore\" (#1883)"
			},
			{
				"Id": "342187541",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T06:00:53",
				"Actor": "maxwang",
				"Number": "1881",
				"RawContent": null,
				"Title": "How can I inject custom code to account controller in Identity core 2.1",
				"State": "open",
				"Body": "Dear Sir/Madam,\r\n\r\nI tried to update my project from .net core 2.0 to core 2.1 and could not find the place to inject my code to account controller. Do I have to change back to .net Identity core 2.0 code? Or could you give me some suggestions?\r\n\r\nThanks.\r\n\r\nRegards,\r\nMax\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1881",
				"RelatedDescription": "Open issue \"How can I inject custom code to account controller in Identity core 2.1\" (#1881)"
			},
			{
				"Id": "341810304",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T08:09:50",
				"Actor": "tiljanssen",
				"Number": "1880",
				"RawContent": null,
				"Title": "AddIdentity should check if IUserSecurityStampStore is implemented before registering a check on securityStamp",
				"State": "open",
				"Body": "If the UserStore does not implement IUserSecurityStampStore, most functionality regarding security stamps will be skipped, but AddIdentity() does register a validation on the securityStamp every 30 minutes.\r\n\r\nThis results in the confusing behaviour that the user is logged out after 30 minutes, even though the cookies did not expire.\r\n\r\nAddIdentity should check whether the UserSecurityStampStore is supported before registering the check, and either throw, or skip the check.\r\n\r\nSee also #1425 ",
				"Url": "https://github.com/aspnet/Identity/issues/1880",
				"RelatedDescription": "Open issue \"AddIdentity should check if IUserSecurityStampStore is implemented before registering a check on securityStamp\" (#1880)"
			},
			{
				"Id": "341347083",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-15T19:58:33",
				"Actor": "dazinator",
				"Number": "1878",
				"RawContent": null,
				"Title": "Custom IdentityUserLogin<int> and EF user store",
				"State": "closed",
				"Body": "I'm using the EF stores.\r\n\r\nThe only change I'd like to make is to add a column to the `AspNetUserLogins` table so that I can also store the refresh token associated with the external login. I think adding a column to an EF model should be fairly straightforward, and it was, but then getting identity to work with it is turning out to be a bit painful :-)\r\n\r\nI derived my own entity from `IdentityUserLogin<int>` and added the additional property:\r\n\r\n```\r\n   public class DennisUserLogin : IdentityUserLogin<int>\r\n   {\r\n        public string RefreshToken { get; set; }\r\n   }\r\n```\r\n\r\nAnd therefore had to derive my own `IdentityDbContext`, passing in that replacement type:\r\n\r\n```\r\n\r\n public class DennisContext : IdentityDbContext<DennisUser, IdentityRole<int>, int, IdentityUserClaim<int>, IdentityUserRole<int>, DennisUserLogin, IdentityRoleClaim<int>, IdentityUserToken<int>>\r\n    {\r\n        public DennisContext(DbContextOptions<DennisContext> options)\r\n            : base(options)\r\n        {\r\n        }\r\n\r\n        protected override void OnModelCreating(ModelBuilder builder)\r\n        {\r\n            base.OnModelCreating(builder);         \r\n            \r\n        }\r\n    }\r\n```\r\n\r\nI was able to then add a new ef migration, and apply that, and I can see the additional column in the database - great.\r\n\r\nNext I needed to be able to set this new property. So I had to find the locations where a new `IdentityUserLogin` entity is created, so that I could also set my additional property before its saved.\r\n\r\nUnfortunately the `UserStore` seems to create this entity, and the there is nowhere in the existing API where I could pass an additional value to it (i.e referesh token). Therefore overriding any existing method on UserStore or UserManager wouldn't cater for my scenario. So I had to add some additional method to UserManager and UserStore that also took a \"refresh token\":\r\n\r\n```\r\n\r\n  public class DennisUserStore : UserStore<DennisUser, IdentityRole<int>, DennisContext, int>, IDennisUserStore\r\n    {\r\n\r\n        private readonly DennisContext _context;\r\n\r\n        public DennisUserStore(DennisContext context, IdentityErrorDescriber describer = null) : base(context, describer)\r\n        {\r\n            _context = context;\r\n        }\r\n        \r\n        \r\n        /// <summary>\r\n        /// Adds the <paramref name=\"login\"/> given to the specified <paramref name=\"user\"/>.\r\n        /// </summary>\r\n        /// <param name=\"user\">The user to add the login to.</param>\r\n        /// <param name=\"login\">The login to add to the user.</param>\r\n        /// <param name=\"cancellationToken\">The <see cref=\"CancellationToken\"/> used to propagate notifications that the operation should be canceled.</param>\r\n        /// <returns>The <see cref=\"Task\"/> that represents the asynchronous operation.</returns>\r\n        public Task AddLoginAsync(DennisUser user, UserLoginInfo login, string refreshToken,\r\n            CancellationToken cancellationToken = default(CancellationToken))\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n            ThrowIfDisposed();\r\n            if (user == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(user));\r\n            }\r\n            if (login == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(login));\r\n            }\r\n            var userLogins = _context.UserLogins;\r\n            var newLogin = CreateDennisUserLogin(user, login);\r\n            newLogin.RefreshToken = refreshToken;\r\n            userLogins.Add(newLogin);\r\n            return Task.FromResult(false);\r\n        }\r\n\r\n        private DennisUserLogin CreateDennisUserLogin(DennisUser user, UserLoginInfo login)\r\n        {\r\n            var dennisUserLogin = new DennisUserLogin();\r\n            dennisUserLogin.LoginProvider = login.LoginProvider;\r\n            dennisUserLogin.ProviderDisplayName = login.ProviderDisplayName;\r\n            dennisUserLogin.ProviderKey = login.ProviderKey;\r\n            dennisUserLogin.UserId = user.Id;\r\n            return dennisUserLogin;\r\n        }\r\n\r\n    }\r\n\r\n```\r\n\r\nand `UserManager`:\r\n\r\n```\r\n\r\n\r\n   public class DennisUserManager : UserManager<DennisUser>\r\n    {\r\n        public DennisUserManager(IUserStore<DennisUser> store, IOptions<IdentityOptions> optionsAccessor, IPasswordHasher<DennisUser> passwordHasher, IEnumerable<IUserValidator<DennisUser>> userValidators, IEnumerable<IPasswordValidator<DennisUser>> passwordValidators, ILookupNormalizer keyNormalizer, IdentityErrorDescriber errors, IServiceProvider services, ILogger<UserManager<DennisUser>> logger) : base(store, optionsAccessor, passwordHasher, userValidators, passwordValidators, keyNormalizer, errors, services, logger)\r\n        {\r\n\r\n        }\r\n\r\n        // IUserLoginStore methods\r\n        private IDennisUserStore GetStore()\r\n        {\r\n\r\n            var cast = Store as IDennisUserStore;\r\n            if (cast == null)\r\n            {\r\n                throw new NotSupportedException(\"Store Not IUserLoginStore\");\r\n            }\r\n            return cast;\r\n        }     \r\n\r\n        public async Task<IdentityResult> AddLoginAsync(DennisUser user, UserLoginInfo login, string refreshToken)\r\n        {\r\n            ThrowIfDisposed();\r\n            var loginStore = GetStore();\r\n            if (login == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(login));\r\n            }\r\n            if (user == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(user));\r\n            }\r\n\r\n            var existingUser = await FindByLoginAsync(login.LoginProvider, login.ProviderKey);\r\n            if (existingUser != null)\r\n            {\r\n                Logger.LogWarning(4, \"AddLogin for user {userId} failed because it was already associated with another user.\", await GetUserIdAsync(user));\r\n                return IdentityResult.Failed(ErrorDescriber.LoginAlreadyAssociated());\r\n            }\r\n            await loginStore.AddLoginAsync(user, login, refreshToken, CancellationToken);\r\n            return await UpdateUserAsync(user);\r\n        }\r\n    }\r\n\r\n```\r\n\r\nSo far this is a lot of work in order to be able to add one property to this entity but I thought I was close.\r\n\r\nI changed the razor UI code to call the new method on my UserManager instead which takes the refresh token,\r\n\r\nNow when I run the app, when attempting an external login, I get the following error:\r\n\r\n> InvalidOperationException: Cannot create a DbSet for 'IdentityUserLogin<int>' because this type is not included in the model for the context.\r\nMicrosoft.EntityFrameworkCore.Internal.InternalDbSet<TEntity>.get_EntityType()\r\nMicrosoft.EntityFrameworkCore.Internal.InternalDbSet<TEntity>.get_EntityQueryable()\r\nMicrosoft.EntityFrameworkCore.Internal.InternalDbSet<TEntity>.System.Linq.IQueryable.get_Provider()\r\nMicrosoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync<TSource, TResult>(MethodInfo operatorMethodInfo, IQueryable<TSource> source, Expression expression, CancellationToken cancellationToken)\r\nMicrosoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync<TSource, TResult>(MethodInfo operatorMethodInfo, IQueryable<TSource> source, LambdaExpression expression, CancellationToken cancellationToken)\r\nMicrosoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.SingleOrDefaultAsync<TSource>(IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, CancellationToken cancellationToken)\r\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)\r\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)\r\nMicrosoft.AspNetCore.Identity.SignInManager<TUser>.ExternalLoginSignInAsync(string loginProvider, string providerKey, bool isPersistent, bool bypassTwoFactor)\r\nDennis.Areas.Identity.Pages.Account.ExternalLoginModel.OnGetCallbackAsync(string returnUrl, string remoteError) in ExternalLogin.cshtml.cs\r\n-\r\n            {\r\n                ErrorMessage = \"Error loading external login information.\";\r\n                return RedirectToPage(\"./Login\", new { ReturnUrl = returnUrl });\r\n            }\r\n            // Sign in the user with this external login provider if the user already has a login.\r\n            var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false, bypassTwoFactor : true);\r\n            if (result.Succeeded)\r\n            {\r\n                var tokens = info.AuthenticationTokens.ToArray();\r\n                // save the users \r\n                _logger.LogInformation(\"{Name} logged in with {LoginProvider} provider.\", info.Principal.Identity.Name, info.LoginProvider);\r\n                return LocalRedirect(returnUrl);\r\nMicrosoft.AspNetCore.Mvc.RazorPages.Internal.ExecutorFactory+GenericTaskHandlerMethod.Convert<T>(object taskAsObject)\r\n\r\n\r\nIt seems something about the store is still specifically looking for `IdentityUserLogin<int>` which isn't part of my model anymore - because I am using my own derived type `DennisUserLogin`. However it doesn't appear I can inform the user store of that.. What am I missing?",
				"Url": "https://github.com/aspnet/Identity/issues/1878",
				"RelatedDescription": "Closed issue \"Custom IdentityUserLogin<int> and EF user store\" (#1878)"
			},
			{
				"Id": "341346866",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-15T19:47:26",
				"Actor": "dotnet-maestro-bot",
				"Number": "1877",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "open",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @aspnetci\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/Identity merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/Identity/pull/1877",
				"RelatedDescription": "Open PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#1877)"
			},
			{
				"Id": "341165815",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T21:32:17",
				"Actor": "NinoFloris",
				"Number": "1876",
				"RawContent": null,
				"Title": "Can PasswordValidator errors pretty please be merged with UserValidator errors on user create?",
				"State": "open",
				"Body": "Talking about https://github.com/aspnet/Identity/blame/master/src/Core/UserManager.cs#L597\r\nCould instead of returning on `!succeeded` store them, run CreateAsync and merge them with those errors.\r\nThis is blocking a nice api where you get all errors of a registration in one go.",
				"Url": "https://github.com/aspnet/Identity/issues/1876",
				"RelatedDescription": "Open issue \"Can PasswordValidator errors pretty please be merged with UserValidator errors on user create?\" (#1876)"
			},
			{
				"Id": "340801603",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T02:40:43",
				"Actor": "natemcmaster",
				"Number": "1875",
				"RawContent": null,
				"Title": "[2.1]: pin baseline package versions to 2.1.2",
				"State": "closed",
				"Body": "Part of https://github.com/aspnet/Home/issues/3316\n\nThis pins package versions to the 2.1.2 baseline. Universe will not override variables in the 'Pinned' section. This helps ensure that this repo does not upgrade its dependency versions for all future patches of 2.1.",
				"Url": "https://github.com/aspnet/Identity/pull/1875",
				"RelatedDescription": "Closed or merged PR \"[2.1]: pin baseline package versions to 2.1.2\" (#1875)"
			},
			{
				"Id": "337865699",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T18:41:50",
				"Actor": "egmfrs",
				"Number": "1860",
				"RawContent": null,
				"Title": "Determine if Confirmation Email link failed because Token expired",
				"State": "closed",
				"Body": "Is there a way to do this? Like an error code that will return when the email confirmation token has expired?\r\nFor example if the error code was \"TokenExpired\" I could use the following to return the user to a specific view which gives them advice on a process to follow if their token has expired:\r\n\r\n```\r\n        var result = await _userManager.ConfirmEmailAsync(user, code);\r\n        if (result.Succeeded) return View(\"ConfirmEmail\");\r\n\r\n        return View(result.Errors.Any(c => c.Code == \"TokenExpired\") ? \"TokenExpired\" : \"Error\");\r\n```",
				"Url": "https://github.com/aspnet/Identity/issues/1860",
				"RelatedDescription": "Closed issue \"Determine if Confirmation Email link failed because Token expired\" (#1860)"
			},
			{
				"Id": "339455942",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T18:37:56",
				"Actor": "flatproject",
				"Number": "1867",
				"RawContent": null,
				"Title": "Two factor authentication by Email",
				"State": "closed",
				"Body": "Is it possible to configure 2FA via email in a .net core 2.0 or 2.1 application? \r\n\r\nI can't find any information anywhere about it apart from SMS or QR code examples which are not usable in a PCI compliant environment.\r\n\r\nAre there any email 2FA examples anywhere?\r\n\r\nThank you",
				"Url": "https://github.com/aspnet/Identity/issues/1867",
				"RelatedDescription": "Closed issue \"Two factor authentication by Email\" (#1867)"
			},
			{
				"Id": "340309923",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T18:37:20",
				"Actor": "Freakazoid182",
				"Number": "1871",
				"RawContent": null,
				"Title": "Wrong password logging with Warning level",
				"State": "closed",
				"Body": "In my opinion this should be an Information level warning. What is the reason behind a Warning level here?\r\n\r\nhttps://github.com/aspnet/Identity/blob/c7276ce2f76312ddd7fccad6e399da96b9f6fae1/src/Core/UserManager.cs#L711",
				"Url": "https://github.com/aspnet/Identity/issues/1871",
				"RelatedDescription": "Closed issue \"Wrong password logging with Warning level\" (#1871)"
			},
			{
				"Id": "340410768",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-11T21:23:15",
				"Actor": "bigpodgurc",
				"Number": "1874",
				"RawContent": null,
				"Title": "using same ASP.net core identity for multiple web applicaitons",
				"State": "open",
				"Body": "Hello\r\n\r\nI want to have 3 different web applications but want to use same identity back end application so i have SSO. im using Individual user accounts\r\n\r\nthanks",
				"Url": "https://github.com/aspnet/Identity/issues/1874",
				"RelatedDescription": "Open issue \"using same ASP.net core identity for multiple web applicaitons\" (#1874)"
			},
			{
				"Id": "340388845",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-11T20:27:19",
				"Actor": "dotnet-maestro-bot",
				"Number": "1873",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @HaoK\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit fetch --force https://github.com/dotnet-maestro-bot/Identity merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/Identity/pull/1873",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#1873)"
			},
			{
				"Id": "340335156",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-11T17:23:47",
				"Actor": "blowdart",
				"Number": "1872",
				"RawContent": null,
				"Title": "[bug].net core 2.1,Identity will throw exception while implement IdentityUser. But .net core 2.0 is Ok.",
				"State": "open",
				"Body": "_From @Caizhenyu on July 7, 2018 11:58_\n\nI am using asp net core Identity Framework on core 2.1, and I implement my  `ApplicationUser : IdentityUser` .Then there will throw Exception like the screenshot .\r\nBut I found that, the same code is Ok on core 2.0, or I just user IdentityUser not my own ApplicationUser is also ok while `services.AddIdentity<TUser, TRole>`.\r\n\r\nIs it's a core 2.1 bug?\r\n![tim 20180707194836](https://user-images.githubusercontent.com/19528235/42410678-1fcd9ff0-8220-11e8-9bf7-27d4c34b266a.png)\r\n\r\n\n\n_Copied from original issue: aspnet/Security#1804_",
				"Url": "https://github.com/aspnet/Identity/issues/1872",
				"RelatedDescription": "Open issue \"[bug].net core 2.1,Identity will throw exception while implement IdentityUser. But .net core 2.0 is Ok.\" (#1872)"
			},
			{
				"Id": "339303539",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-10T19:56:50",
				"Actor": "tstivers1990",
				"Number": "1866",
				"RawContent": null,
				"Title": "ActivePage declarations missing on scaffolded Identity UI",
				"State": "closed",
				"Body": "Some of the ActivePage declarations are missing on the default scaffolded Identity UI. This causes some pages not to show an active item in the relevant nav section.\r\n\r\nSome pages also use an ActivePage declaration that doesn't have a corresponding item in the navigation section, resulting in those pages not showing an active navigation item.\r\n\r\nI've created a pull request that adds the missing ActivePage declarations, and changes the ones that don't have a corresponding nav element to use an ActivePage declaration with the most relevant nav element. For example, the DeletePersonalData page was using `ViewData[\"ActivePage\"] = ManageNavPages.DeletePersonalData;` There is no nav element for Delete Personal Data. I've changed it to use `ViewData[\"ActivePage\"] = ManageNavPages.PersonalData;` instead, as there is a nav element for Personal Data, and that is the most relevant nav element for the page.\r\n\r\nAny methods and variables within `ManageNavPages` that are no longer used after this changed were removed. For example, the `ManageNavPages.DeletePersonalData` variable is no longer used after the change, and neither is the `ManageNavPages.DeletePeronalDataNavClass` method. Therefore, both of them are removed.\r\n\r\nI've also made the `PageNavClass` method private, as it is never accessed outside of its class and, based on the class' design, should only be referenced by public methods in the class, and not directly outside of the class.\r\n\r\nPR: #1838 ",
				"Url": "https://github.com/aspnet/Identity/issues/1866",
				"RelatedDescription": "Closed issue \"ActivePage declarations missing on scaffolded Identity UI\" (#1866)"
			},
			{
				"Id": "339929777",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-10T17:02:34",
				"Actor": "blowdart",
				"Number": "1870",
				"RawContent": null,
				"Title": "Microsoft Security Advisory CVE-2018-8171: ASP.NET Core Security Feature Bypass Vulnerability",
				"State": "open",
				"Body": "# Microsoft Security Advisory CVE-2018-8171: ASP.NET Core Security Feature Bypass Vulnerability\r\n\r\n## <a name=\"executive-summary\"></a>Executive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in ASP.NET Core. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nMicrosoft is aware of a security feature bypass in ASP.NET Core when the number of incorrect login attempts is not validated. An attacker who successfully exploited this vulnerability could try an infinite number of authentication attempts.\r\n\r\nThe update addresses the vulnerability by correcting how ASP.NET Core validates the number of incorrect login attempts.\r\n\r\n## Announcement\r\n\r\nThe original announcement can be found at https://github.com/aspnet/Announcements/issues/310\r\n\r\n### <a name=\"mitigation-factors\"></a>Mitigation factors\r\n\r\n* If your application does not use ASP.NET Core's implementation of multi-factor authentication you are not affected.\r\n\r\n## <a name=\"affected-software\"></a>Affected software\r\n\r\nAny ASP.NET Core based application that uses Microsoft.AspNetCore.Identity with a vulnerable version listed below.\r\n\r\nPackage name | Vulnerable versions | Secure versions\r\n------------ | ---------------- | -------------------------\r\nMicrosoft.AspNetCore.Identity | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5 <br /> 1.1.0, 1.1.1, 1.1.2, 1.1.3, 1.1.4, 1.1.5 <br /> 2.0.0, 2.0.1, 2.0.2, 2.0.3 <br /> 2.1.0, 2.1.1 | 1.0.6 <br /> 1.1.6 <br /> 2.0.4 <br /> 2.1.2\r\n\r\n## <a name=\"advisory-faq\"></a>Advisory FAQ\r\n\r\n### <a name=\"how-affected\"></a>How do I know if I am affected?\r\n\r\n.NET Core has two types of dependencies: direct and transitive. Direct dependencies are dependencies where you specifically add a package to your project, transitive dependencies occur when you add a package to your project that in turn relies on another package.\r\n\r\nFor example, the `Microsoft.AspNetCore.Mvc` package depends on the `Microsoft.AspNetCore.Mvc.Core` package. When you add a dependency on `Microsoft.AspNetCore.Mvc` in your project, you're taking a transitive dependency on `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\nAny application that has a direct or transitive dependency on the [affected package](#affected-software) can be exposed to the vulnerability if it does not meet any of the [mitigation factors](#mitigation-factors).\r\n\r\n### <a name=\"how-fix\"></a>How do I fix the issue?\r\n\r\n### ASP.NET Core 2.1\r\n\r\nTo update ASP.NET Core 2.1 you should [download](https://www.microsoft.com/net/download) and install the .NET Core SDK 2.1.302 on your development machines and build servers, and the .NET Core Runtime 2.1.2 on your deployment servers. Your application will roll forward to these versions on an application restart.\r\n\r\n### ASP.NET Core 2.0\r\n\r\nIf you're targeting ASP.NET Core 2.0 and using the `Microsoft.AspNetCore.All` metapackage update its version number to 2.0.9 to update the `Microsoft.AspNetCore.Identity` package, recompile, and redeploy. On your deployment servers, you should [download](https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.0.9-download.md) and install the .NET Core 2.0.9 using the Windows Server Hosting Bundle for Windows and the `dotnet-hosting-2.0.9` package for Linux servers.\r\n\r\n### ASP.NET Core 1.0, 1.1 or 2.0 not targeting the metapackage.\r\n\r\n.NET Core projects have two types of dependencies: direct and transitive. You must update your projects using the following instructions to address both types of dependency.\r\n\r\n### <a name=\"project-format\"></a>.NET Core Project formats\r\n\r\n.NET Core has two different project file formats, depending on what software created the project.\r\n\r\n1. `project.json` is the format used in .NET Core 1.0 and Microsoft Visual Studio 2015.\r\n2. `csproj` is the format used in .NET Core 1.1, .NET Core 2.0 and Microsoft Visual Studio 2017.\r\n\r\n#### Direct dependencies\r\n\r\nDirect dependencies are discoverable by examining your `csproj` file or your `project.json` file. They can be fixed by [editing the project file](#direct-dependencies) or using NuGet to update the dependency.\r\n\r\n#### Transitive dependencies\r\n\r\nTransitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.\r\n\r\nTransitive dependencies are reviewable in three ways, depending on your [project format](#project-format):\r\n\r\n* In the Visual Studio Solution Explorer window, which supports searching.\r\n* By examining the `project.assets.json` file contained in the obj directory of your project for `csproj` based projects *OR*.\r\n* By examining the `project.lock.json` file contained in the root directory of your project for `project.json` based projects.\r\n\r\nThe `project.assets.json` and `project.lock.json` files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.\r\n\r\n#### <a name=\"direct-dependencies-vs2017\"></a>Fixing direct dependencies in a csproj based project / Visual Studio 2017\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nThe preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.\r\nThe package version number is in the `Version` attribute. The previous example shows a single direct dependency on `Microsoft.AspNetCore.Identity` version 2.0.0.\r\n\r\nTo update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).\r\nIn this example, update `Microsoft.AspNetCore.Identity` to the appropriate [fixed package number](#affected-software) for your major version. Save the *csproj* file. The example *csproj* now looks as follows:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.4\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nIf you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.\r\n\r\nNow recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.\r\n\r\n#### <a name=\"direct-dependencies-vs2015\"></a> Fixing Direct Dependencies in project.json based project / Visual Studio 2015\r\n\r\nOpen your `project.json` file in your editor. Look for the dependencies section. Below is an example dependencies section:\r\n\r\n``` json\r\n    \"dependencies\": {\r\n      \"Microsoft.NETCore.App\": {\r\n        \"version\": \"1.0.1\",\r\n        \"type\": \"platform\"\r\n      },\r\n     \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n     \"Microsoft.AspNetCore.Identity\" : \"1.0.5\"\r\n    }\r\n```\r\n\r\nThis example has three direct dependencies: `Microsoft.NETCore.App`, `Microsoft.AspNetCore.Mvc.Core` and `Microsoft.AspNetCore.Identity`.\r\n\r\n`Microsoft.NetCore.App` is the platform the application targets, you should ignore this. The other packages expose their version to the right of the package name. In our example, our non-platform packages are version 1.0.1.\r\n\r\nReview your direct dependencies for any instance of the packages and versions listed above. In the example above, there is a direct dependency on a vulnerable package, `Microsoft.AspNetCore.Identity` version 1.0.5.\r\n\r\nTo update to the fixed package, change the version number to be the appropriate package for your release. In the example, this would be updating `Microsoft.AspNetCore.Identity` to 1.0.6.\r\n\r\nAfter updating the vulnerable package versions, save your `project.json` file.\r\n\r\nThe dependencies section in our example `project.json` would now look as follows:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n    \"Microsoft.AspNetCore.Identity \": \"1.0.6\"\r\n  }\r\n```\r\n\r\nIf you are using Visual Studio and save your updated `project.json` file, Visual Studio will restore the new package version. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependency.\r\n\r\nAfter you have addressed all of your direct dependencies, you must also review your transitive dependencies.\r\n\r\nAfter you've addressed all of your direct dependencies, you must review your transitive dependencies.\r\n\r\n#### Discovering and fixing transitive dependencies\r\n\r\nThere are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can review [the `project.assets.json` file](#project-assets-json) or the [the `project.lock.json` file](#project-lock-json).\r\n\r\n##### <a name=\"vs-solution-explorer\"></a>Using Visual Studio Solution Explorer\r\n\r\nTo use Solution Explorer, open the project in Visual Studio, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.\r\n\r\nFor example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:\r\n\r\n![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)\r\n\r\nThe search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.\r\n\r\nUnder the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.\r\nIn screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.\r\nThe `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\n##### <a name=\"project-assets-json\"></a> Manually reviewing project.assets.json (csproj/VS2017)\r\n\r\nOpen the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.\r\nVisual Studio and Visual Studio Code provide JSON friendly editing.\r\n\r\nSearch the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:\r\n\r\n* Examine the line on which they are found, the version number is after the `/`.\r\n* Compare to the [vulnerable versions table](#affected-software).\r\n\r\nFor example, a search result that shows `Microsoft.AspNetCore.Identity/2.0.0` is a reference to version 2.0.0 of `Microsoft.AspNetCore.Identity`.\r\nIf your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to any vulnerable packages, this means either\r\n\r\n* None of your direct dependencies depend on any vulnerable packages, or\r\n* You have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.\r\nLook for `PackageReference` nodes, for example:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nYou must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.\r\nYou do this by adding a new line to the dependencies section, referencing the fixed version.\r\nFor example, if your search showed a transitive reference to a vulnerable `Microsoft.AspNetCore.Identity` version, you'd add a reference to the [fixed package number](#affected-software).\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.4\" />\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nAfter you've added the direct dependency reference, save your *csproj* file.\r\n\r\nIf you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.\r\n\r\n##### <a name=\"project-lock-json\"></a> Manually reviewing project.lock.json (project.json/VS2015)\r\n\r\nOpen the `project.lock.json` file in your editor. We suggest you use an editor that understands json and allows you to collapse and expand nodes to review this file; both Visual Studio and Visual Studio Code provide this functionality.\r\n\r\nIf you are using Visual Studio the `project.lock.json` file is “under” the `project.json` file. Click the right pointing triangle, ▷, to the left of the `project.json` file to expand the solution tree to expose the `project.lock.json` file. The following image shows a project with the `project.json` file expanded to show the `project.lock.json` file.\r\n\r\n![project lock json](https://cloud.githubusercontent.com/assets/796298/25858179/f6e01200-348f-11e7-8a77-7176d8dd3f03.png)\r\n\r\nSearch the `project.lock.json` file for the vulnerable packages, using the format `packagename/`, using each of the package names from the table above. If you find any vulnerable assembly name in your search examine the line on which they are found, the version number is after the `/` and compare to the vulnerable versions table above. For example a search result that shows `Microsoft.AspNetCore.Identity/1.0.1` is a reference to v1.0.1 of `Microsoft.AspNetCore.Identity`.   If your `project.lock.json` file includes references to any of the package versions shown above then you will need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to a vulnerable version of  `Microsoft.AspNetCore.Identity` this means none of your direct dependencies depend on any vulnerable packages or you have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to any of the vulnerable packages you must add a direct dependency to the updated package to your `project.json` file to override the transitive dependency. Open your `project.json` and find the dependencies section. For example:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nFor each of the vulnerable packages your search returned you must add a direct dependency to the updated version by adding it to the `project.json` file. You do this by adding a new line to the dependencies section, referring the fixed version. For example, if your search showed a transitive reference to the vulnerable `Microsoft.AspNetCore.Identity` version 1.0.0 you would add a reference to the appropriate fixed version, 1.0.6. Edit the `project.json` file as follows:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Identity\": \"1.0.6\",\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nAfter you have added direct dependencies to the fixed packages, save your `project.json` file.\r\n\r\nIf you are using Visual Studio save your updated `project.json` file and Visual Studio will restore the new package versions. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependencies.\r\n\r\n#### Rebuilding your application\r\n\r\nFinally you must rebuild your application, test, and redeploy.\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \"as is\" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### Acknowledgments\r\n\r\n[Martin Knafve](https://www.linkedin.com/in/martin-knafve-99187a2/)\r\n\r\n### External Links\r\n\r\n[CVE-2018-8171](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2018-8171)\r\n\r\n### Revisions\r\n\r\nV1.0 (July 10, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2018-07-10_",
				"Url": "https://github.com/aspnet/Identity/issues/1870",
				"RelatedDescription": "Open issue \"Microsoft Security Advisory CVE-2018-8171: ASP.NET Core Security Feature Bypass Vulnerability\" (#1870)"
			},
			{
				"Id": "339822774",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-10T12:35:55",
				"Actor": "tincann",
				"Number": "1869",
				"RawContent": null,
				"Title": "Fix misleading exception message when adding a TokenProvider",
				"State": "open",
				"Body": "",
				"Url": "https://github.com/aspnet/Identity/pull/1869",
				"RelatedDescription": "Open PR \"Fix misleading exception message when adding a TokenProvider\" (#1869)"
			},
			{
				"Id": "339512611",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-09T16:03:47",
				"Actor": "benm-eras",
				"Number": "1868",
				"RawContent": null,
				"Title": "Why are the `DbSet`s in `IdentityUserContext` non-virtual?",
				"State": "open",
				"Body": "In ASP.NET Core 2.x the `DbSet`s defined in the abstract classes `IdentityDbContext` and `IdentityUserContext` are all non-virtual making it much harder to effectively mock my database context that is built on them. It looks like they were virtual in ASP.NET Core 1.x, although the library was arranged differently then, so I am not 100% sure on that. \r\n\r\nIs there a reason that they cannot just be made virtual to facilitate unit testing? I really don't like having to resort to something drastic like Fakes when I could just use Moq etc.\r\n\r\nIf there is a reason they can't be made virtual I would really appreciate it if any one has any ideas on how  I can proceed with mocking my db context that implements `IdentityDbContext`! ",
				"Url": "https://github.com/aspnet/Identity/issues/1868",
				"RelatedDescription": "Open issue \"Why are the `DbSet`s in `IdentityUserContext` non-virtual?\" (#1868)"
			},
			{
				"Id": "339263894",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-08T22:31:57",
				"Actor": "dm-CaT",
				"Number": "1865",
				"RawContent": null,
				"Title": "UserManager -> SetPasswordHashAsync is called before CreateAsync(user)",
				"State": "open",
				"Body": "Is there any reason why when the new user is created with password the password hash is set before user is saved?\r\nI'm trying to implement my own IUserStore/IUserPasswordStore (to use custom DAL). But I got an error because my store cannot set password hash (update record in DB) to non created user.\r\nHere is the code from UserManager which causes an error.\r\n```\r\n        public virtual async Task<IdentityResult> CreateAsync(TUser user, string password)\r\n        {\r\n            ThrowIfDisposed();\r\n            var passwordStore = GetPasswordStore();\r\n            if (user == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(user));\r\n            }\r\n            if (password == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(password));\r\n            }\r\n            // Here is the SetPasswordHashAsync occurs\r\n            var result = await UpdatePasswordHash(passwordStore, user, password);\r\n            if (!result.Succeeded)\r\n            {\r\n                return result;\r\n            }\r\n            // Only here I save user in DB\r\n            return await CreateAsync(user);\r\n        }\r\n```\r\n [Link on method](https://github.com/aspnet/Identity/blob/c60b4d8784550ea868af0c2d08cc14217ae2e940/src/Core/UserManager.cs#L585)\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1865",
				"RelatedDescription": "Open issue \"UserManager -> SetPasswordHashAsync is called before CreateAsync(user)\" (#1865)"
			},
			{
				"Id": "339141041",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-07T12:44:30",
				"Actor": "CeelMarten",
				"Number": "1864",
				"RawContent": null,
				"Title": "Can't configure Identity",
				"State": "closed",
				"Body": "I have a class **ApplicationUser**  witch inherited from **IdentityUser<long>**\r\n```\r\n    public class ApplicationUser : IdentityUser<long>\r\n    {\r\n    }\r\n```\r\nand I want to use it in **ApplicationDbContext** \r\n```\r\n    public class ApplicationDbContext : IdentityDbContext<ApplicationUser>\r\n    {\r\n        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)\r\n            : base(options)\r\n        {\r\n        }\r\n\r\n        protected override void OnModelCreating(ModelBuilder builder)\r\n        {\r\n            base.OnModelCreating(builder);\r\n        }\r\n    }\r\n```\r\n\r\nVisual Studio says that I can't use **ApplicationUser** because there is no implicit reference conversion from **ApplicationUser** to **IdentityUser**. I found this in github where \r\n\r\n```\r\n      services.AddIdentity<ApplicationUser, IdentityRole>()\r\n                .AddEntityFrameworkStores<ApplicationDbContext, long>()\r\n                .AddDefaultTokenProviders();\r\n```\r\nthe solution is to change code from  \r\n`.AddEntityFrameworkStores<ApplicationDbContext>()` to `.AddEntityFrameworkStores<ApplicationDbContext, long>()`\r\nbut there is not overload for this method\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1864",
				"RelatedDescription": "Closed issue \"Can't configure Identity\" (#1864)"
			},
			{
				"Id": "339134116",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-07T10:03:39",
				"Actor": "ckams",
				"Number": "1863",
				"RawContent": null,
				"Title": "Feature Request—Consider providing ACL in ASP.NET Core Identity",
				"State": "open",
				"Body": "To get some context about the request, see the issue https://github.com/aspnet/Identity/issues/1859\r\n\r\n## Consider providing ACL in Identity\r\nWell as in the title: consider providing ACL in ASP.NET Core though Identity.\r\n\r\n### Some arguments\r\n- ACL is not something too much complex for enterprise level app… \r\n- What Identity provides today, **about group management**, is out to date (again see the issue [1859](https://github.com/aspnet/Identity/issues/1859))…\r\n- Other frameworks oriented **enterprise level app/webapp**, provide, out of the box, ACL support. (See, Zend frameworks, Joomla, etc…)\r\n    - **With all due respect, In comparison, Identity looks like a back to the Past…(there is simply no ACL support at all)**\r\n- Nothing prevents to suggest some improvements, **[or do not mention community involvement](https://www.asp.net/open-source)**…\r\n- You should \"write\" [for customers, **not for simplicity sake**, nor without listening customers](https://github.com/aspnet/Identity/issues/1859#issuecomment-403067317)… And I used to think that ASP.NET Core was for writing enterprise level app, not to write simple blog CMS, **with simplistic group support**…\r\n- it will not cost so much for you, to add ACL support.\r\n\r\n### Design\r\nIt will be simple to integrate some ACL support to Identity, without breaking anything (simply by adding few line of codes, again, take a look at [1859](https://github.com/aspnet/Identity/issues/1859)).\r\n\r\nFor the sake of demonstration:\r\n- Add an Acl table like `IdentityAcl`\r\n- Add a many-to-many relationship table between `IdentityRoles` and `IdentityAcl`;\r\n- Add to `ClaimsIdentity` and `ClaimsPrincipal` … the adequat properties (to avoid having recourse to `Scope` and `IdentityDbContext` for `AuthorizationHandler`)…\r\n- Good doc…\r\n\r\n### Some thoughts\r\nWe do not ask you to write for us our apps, but to provide us with a good, up to date, and real world use framework (**like other frameworks in the market**).",
				"Url": "https://github.com/aspnet/Identity/issues/1863",
				"RelatedDescription": "Open issue \"Feature Request—Consider providing ACL in ASP.NET Core Identity\" (#1863)"
			},
			{
				"Id": "339040922",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-06T21:39:35",
				"Actor": "wilsonrivera",
				"Number": "1862",
				"RawContent": null,
				"Title": "Fixed documentation typo",
				"State": "closed",
				"Body": "Corrected a typo on the XML documentation of the UserId property that made it read \"... sets the of the ...\"",
				"Url": "https://github.com/aspnet/Identity/pull/1862",
				"RelatedDescription": "Closed or merged PR \"Fixed documentation typo\" (#1862)"
			},
			{
				"Id": "337863779",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-06T15:04:21",
				"Actor": "ckams",
				"Number": "1859",
				"RawContent": null,
				"Title": "RoleClaims: Usages Designs and Questions",
				"State": "closed",
				"Body": "**Maybe I am missing something**, but I find RoleClaims \"badly considered\", even neglected.\r\n\r\nWhereas Role Claims/Group Claims are **essential for intranet Apps (Windows authentication), and \"general\" group membership**—without them, it will lead to some repetitive code, **or to write custom Identity**— I find that they are not \"user friendly\".\r\n\r\nSo I have some questions, and will share some thoughts.\r\n\r\n## Usages of RoleClaims\r\nWhat is the purpose of RoleClaims in Identity?\r\n- How to use them **accordingly to you**?\r\n    - This subject is not documented.\r\n    - I find no sample on github;\r\n- Do you consider to remove them in the future?\r\n    - It seems—badly considered—and that it could be…\r\n    - if yes, how you will replace them? (How??? Knowing that, most of us cannot rely on something \"ephemeral\")\r\n\r\n## Design and limitations\r\nIf we want to use RoleClaims as it should (in a many-to-many relationship) like AspNetUserRoles table, we find that some pieces are missing…\r\n- No documentation…\r\n- No many-to-many relationship table between Roles and Claims, ready to use;\r\n- Weird property `public virtual TKey RoleId { get; set; }` in `IdentityRoleClaim`;\r\n- Not ready to use in `AuthorizationHandler` as\r\n    - Nothing ready to use in `ClaimsIdentity` and `ClaimsPrincipal` classes, to get RoleClaims;\r\n    - If we use DI in `AuthorizationHandler`, we have to register the `AuthorizationHandler` as `scope` to get access to RoleManager/UserManager, etc…\r\n\r\n## Consequences\r\n- We have to do some choice: singleton vs RoleClaims access;\r\n- Write many-to-many relationship table between Roles and RoleClaims;\r\n- Keeping useless property `public virtual TKey RoleId { get; set; }` in `IdentityRoleClaim`;\r\n\r\n**But If we want to get something nice and simple, particularly with `AuthorizationHandler`:**\r\n- With or without the current RoleClaims Api, we have to dive into Identity Customization, **because nothing is ready to use as it should be…**\r\n\r\n## Conclusion\r\nCan you reconsider the importance of RoleClaims in Identity, and provide us \"a better design\"?",
				"Url": "https://github.com/aspnet/Identity/issues/1859",
				"RelatedDescription": "Closed issue \"RoleClaims: Usages Designs and Questions\" (#1859)"
			},
			{
				"Id": "338215212",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-05T15:45:58",
				"Actor": "zhulien-ivanov",
				"Number": "1861",
				"RawContent": null,
				"Title": "ConfirmEmailAsync in UserManager is not doing a check if the email is already confirmed",
				"State": "closed",
				"Body": "Hey. Shouldn't the **`ConfirmEmailAsync`** method in **`UserManager`** do a check if the email is already confirmed? Is it an adequate behaviour to successfully confirm an already confirmed email? It basically don't change the outcome in any way(and the operation can be considered as successful), because the email confirmation state stays the same, but shouldn't it be considered an exceptional behaviour and be accompanied with an error?",
				"Url": "https://github.com/aspnet/Identity/issues/1861",
				"RelatedDescription": "Closed issue \"ConfirmEmailAsync in UserManager is not doing a check if the email is already confirmed\" (#1861)"
			}],
			"ResultType": "GitHubIssue"
		},
		"Kestrel-Issues": {
			"Issues": [{
				"Id": "343743677",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T18:26:03",
				"Actor": "joshfree",
				"Number": "2744",
				"RawContent": null,
				"Title": "System.IO.IOException in Kestrel (.net core 2.1.300) on Windows",
				"State": "open",
				"Body": "Original issue from https://github.com/dotnet/core/issues/1798 \r\n\r\n\r\n**_@tamasVajda commented 5 days ago_**\r\nWe use .net core app with hosted Kestrel web server. During Some requests Kestrel throw the following exception at the end of the corresponding request:\r\n\r\n> info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]\r\n>       Request finished in 1.0512ms 200\r\n> info: Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets[14]\r\n>       Connection id \"0HLFB5I99V5O0\" communication error.\r\n> System.IO.IOException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond ---> System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketAwaitable.GetResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.ProcessReceives()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.DoReceive()\r\n>    --- End of inner exception stack trace ---\r\n> info: Microsoft.AspNetCore.Server.Kestrel[20]\r\n>       Connection id \"0HLFB5I99V5O0\" request processing ended abnormally.\r\n> System.IO.IOException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond ---> System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketAwaitable.GetResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.ProcessReceives()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.DoReceive()\r\n>    --- End of inner exception stack trace ---\r\n>    at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n>    at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n>    at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication`1 application)\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequestsAsync[TContext](IHttpApplication`1 application)\r\n>    at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n>    at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n>    at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.ProcessSends()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.DoSend() \r\n\r\nThe server tries to provide a file to the client like the following example:\r\n\r\n>  public async Task ProcessRequest(HttpContext context)\r\n>         {\r\n>  // some file operations\r\n>    string sourcePath = context.Request.Query[\"File2Download\"].ToString();\r\n>                if (!File.Exists(fileToSend))\r\n>                 {\r\n>                     context.Response.StatusCode = StatusCodes.Status404NotFound;\r\n>                     return;\r\n>                 }\r\n>                 await context.Response.SendFileAsync(fileToSend);\r\n> }\r\n\r\nOn client site we use System.Net.Http.HttpClient without redefining Default request header, and PostAsync to sending the get request to the server.\r\n\r\nIf the connection would broken it would throw kestrel connection lost exception instead of this. \r\n\r\nThis issue occurred just on Windows 10, on Cent OS 7, and on Debian 9 the same scenario doesn't cause this problem.\r\n\r\n Have you any idea what can cause this \r\n\r\n> System.IO.IOException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond ---> System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond   exception?\r\n\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2744",
				"RelatedDescription": "Open issue \"System.IO.IOException in Kestrel (.net core 2.1.300) on Windows\" (#2744)"
			},
			{
				"Id": "343269349",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T22:54:39",
				"Actor": "Tratcher",
				"Number": "2743",
				"RawContent": null,
				"Title": "Enable Http/2 by default",
				"State": "open",
				"Body": " #2720 Making the default protocols Http1 and Http2. We want this for the previews to gather feedback. If it doesn't work out we can disable it again for RTM.\r\n\r\nWith these defaults:\r\nFor TLS it will rely on ALPN to select Http2 or else fall back to Http1.\r\nFor non-TLS it will pick Http1 (I removed one error check to enable this).\r\n\r\nOnce we get stephen's flow control [PR](#2740) in then we should be ready for this.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2743",
				"RelatedDescription": "Open PR \"Enable Http/2 by default\" (#2743)"
			},
			{
				"Id": "342901827",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T20:07:23",
				"Actor": "dotnet-maestro-bot",
				"Number": "2738",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @halter73\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2738",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2738)"
			},
			{
				"Id": "343205219",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T18:27:28",
				"Actor": "Tratcher",
				"Number": "2742",
				"RawContent": null,
				"Title": "Consider using response headers & data padding",
				"State": "open",
				"Body": "https://tools.ietf.org/html/rfc7540#section-6.1\r\n\"   DATA frames MAY also contain padding.  Padding can be added to DATA\r\n   frames to obscure the size of messages.  Padding is a security\r\n   feature; see Section 10.7.\"\r\n\r\n\"The HEADERS frame can include padding. \"\r\n\r\nhttps://tools.ietf.org/html/rfc7540#section-10.7\r\n\"   Padding can be used to obscure the exact size of frame content and is\r\n   provided to mitigate specific attacks within HTTP, for example,\r\n   attacks where compressed content includes both attacker-controlled\r\n   plaintext and secret data (e.g., [BREACH]).\"\r\n\r\n@blowdart \r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2742",
				"RelatedDescription": "Open issue \"Consider using response headers & data padding\" (#2742)"
			},
			{
				"Id": "342124180",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T15:58:34",
				"Actor": "Tratcher",
				"Number": "2731",
				"RawContent": null,
				"Title": "Validate Http/2 pseudo headers",
				"State": "closed",
				"Body": " #2205 #2263 #2659 https://github.com/aspnet/KestrelHttpServer/issues/2154#issuecomment-395504675\r\n\r\nThese fields were not being properly validated or decoded (path). When they're invalid send a RST frame. The remaining exception is Host validation since the shared code there would need to be re-written, it currently sends a 400 which is passible.\r\n\r\nI split the Http2Connection tests into Http2Stream tests for behavior specific to the Http2Stream class.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2731",
				"RelatedDescription": "Closed or merged PR \"Validate Http/2 pseudo headers\" (#2731)"
			},
			{
				"Id": "343071376",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T11:23:13",
				"Actor": "leomathas",
				"Number": "2741",
				"RawContent": null,
				"Title": "ar",
				"State": "closed",
				"Body": "",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2741",
				"RelatedDescription": "Closed issue \"ar\" (#2741)"
			},
			{
				"Id": "342954893",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T02:52:40",
				"Actor": "halter73",
				"Number": "2740",
				"RawContent": null,
				"Title": "Implement HTTP/2 input flow control",
				"State": "open",
				"Body": "#2710",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2740",
				"RelatedDescription": "Open PR \"Implement HTTP/2 input flow control\" (#2740)"
			},
			{
				"Id": "342914601",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T22:44:13",
				"Actor": "ryanbrandenburg",
				"Number": "2739",
				"RawContent": null,
				"Title": "Broken tests: RegisterAddresses_HostName_Success et al",
				"State": "open",
				"Body": "This test [fails](http://aspnetci/viewLog.html?buildId=509500&buildTypeId=XPlat_HighSierraOsxUniverse) every time with on of the following errors:\r\n```\r\nSystem.Net.Sockets.SocketException : Device not configured\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetSocket(Uri requestUri)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStream(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(String requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_Success(String addressInput, String[] testUrls, Int32 testPort) in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 190\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_HostName_Success() in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 39\r\n--- End of stack trace from previous location where exception was thrown ---\r\n------- Stdout: -------\r\n| [0.001s] TestLifetime Information: Starting test RegisterAddresses_HostName_Success at 2018-07-19T04:58:28\r\n| [0.010s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting starting\r\n| [0.018s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting started\r\n| [0.018s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Loaded hosting startup assembly Sockets.FunctionalTests\r\n| [0.054s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting shutdown\r\n| [0.059s] TestLifetime Information: Finished test RegisterAddresses_HostName_Success in 0.057792s\r\n```\r\n[or](http://aspnetci/viewLog.html?buildId=509842&tab=buildResultsDiv&buildTypeId=XPlat_HighSierraOsxUniverse#testNameId-64104852415917104)\r\n```\r\n======= Failed test run #1 ==========\r\nSystem.Net.Sockets.SocketException : Connection refused\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetSocket(Uri requestUri)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStream(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(String requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_Success(String addressInput, String[] testUrls, Int32 testPort) in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 190\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_HostName_Success() in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 39\r\n--- End of stack trace from previous location where exception was thrown ---\r\n------- Stdout: -------\r\n| [0.001s] TestLifetime Information: Starting test RegisterAddresses_HostName_Success at 2018-07-19T19:19:11\r\n| [0.011s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting starting\r\n| [0.016s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting started\r\n| [0.017s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Loaded hosting startup assembly Sockets.FunctionalTests\r\n| [0.022s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting shutdown\r\n| [0.026s] TestLifetime Information: Finished test RegisterAddresses_HostName_Success in 0.024921s\r\n======= Failed test run #2 ==========\r\nSystem.Net.Sockets.SocketException : Connection refused\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetSocket(Uri requestUri)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStream(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(String requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_Success(String addressInput, String[] testUrls, Int32 testPort) in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 190\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_HostName_Success() in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 39\r\n--- End of stack trace from previous location where exception was thrown ---\r\n------- Stdout: -------\r\n| [0.001s] TestLifetime Information: Starting test RegisterAddresses_HostName_Success at 2018-07-19T19:23:23\r\n| [0.005s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting starting\r\n| [0.007s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting started\r\n| [0.007s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Loaded hosting startup assembly Libuv.FunctionalTests\r\n| [0.010s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting shutdown\r\n| [0.014s] TestLifetime Information: Finished test RegisterAddresses_HostName_Success in 0.012739s\r\n```\r\n\r\nCC @Eilon for triaging.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2739",
				"RelatedDescription": "Open issue \"Broken tests: RegisterAddresses_HostName_Success et al\" (#2739)"
			},
			{
				"Id": "342469952",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T21:37:04",
				"Actor": "halter73",
				"Number": "2732",
				"RawContent": null,
				"Title": "Responses are sometimes written after the unexpected end of request content",
				"State": "closed",
				"Body": "There's a race that sometimes occurs when a connection is half closed mid request body where Kestrel will still write a response. This is even after the application code reading the request body observes the BadHttpRequestException. Even weirder yet, if the app swallows the BadHttpRequestException, a 200 status response will be written.\r\n\r\nSee [this](http://aspnetci/viewLog.html?buildId=507772&buildTypeId=Lite_KestrelStressTest).",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2732",
				"RelatedDescription": "Closed issue \"Responses are sometimes written after the unexpected end of request content\" (#2732)"
			},
			{
				"Id": "342897418",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T21:34:01",
				"Actor": "halter73",
				"Number": "2737",
				"RawContent": null,
				"Title": "Stop using InvalidOperationExceptions to signal invalid ASCII during parsing",
				"State": "open",
				"Body": "GetAsciiStringNonNullCharacters() currently throws an InvalidOperationException fo invalid or chacters, and the parsing logic catches these InvalidOperationExceptions at [various](https://github.com/aspnet/KestrelHttpServer/blob/6551eae321cd6306b485906ea47e8d41e932d65b/src/Kestrel.Core/Internal/Http/Http1Connection.cs#L469) [layers](https://github.com/aspnet/KestrelHttpServer/blob/6551eae321cd6306b485906ea47e8d41e932d65b/src/Kestrel.Core/Internal/Http/Http1Connection.cs#L261) to handle the bad request appropriately.\r\n\r\nIdeally we could switch to calling a TryGetAsciiStringNonNullCharacters method, but if propagating failure down the stack proves too difficult, we should at least move to a custom exception type so we don't end up obscuring real product bugs by inadvertently swallowing InvalidOperationExceptions thrown by other methods.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2737",
				"RelatedDescription": "Open issue \"Stop using InvalidOperationExceptions to signal invalid ASCII during parsing\" (#2737)"
			},
			{
				"Id": "342521214",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T21:18:58",
				"Actor": "halter73",
				"Number": "2734",
				"RawContent": null,
				"Title": "Stop writing responses after the unexpected end of request content",
				"State": "closed",
				"Body": "#2732 ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2734",
				"RelatedDescription": "Closed or merged PR \"Stop writing responses after the unexpected end of request content\" (#2734)"
			},
			{
				"Id": "341099998",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T20:25:38",
				"Actor": "Tratcher",
				"Number": "2722",
				"RawContent": null,
				"Title": "Kestrel test hangs (Control flow?)",
				"State": "closed",
				"Body": "I've seen several kestrel test CI hangs in the last week. E.g.:\r\nhttp://aspnetci/viewLog.html?buildId=504305&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\nhttp://aspnetci/viewLog.html?buildId=503757&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\nhttp://aspnetci/viewLog.html?buildId=503644&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\nhttp://aspnetci/viewLog.html?buildId=503531&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\n\r\nHere are some stacks that look like a new flow control deadlock. @halter73 \r\nGOAWAY_Received_RelievesConnectionBackpressure\r\n```\r\nThread id=4204\r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.Dispose() \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException abortReason) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException abortReason) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Stream.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException abortReason) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection+<ProcessRequestsAsync>d__41<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Runtime.CompilerServices.ValueTaskAwaiter+<>c.<.cctor>b__9_0(System.Object state) \r\nat System.IO.Pipelines.InlineScheduler.Schedule(System.Action<System.Object> action, System.Object state) \r\nat System.IO.Pipelines.Pipe.TrySchedule(System.IO.Pipelines.PipeScheduler scheduler, System.IO.Pipelines.CompletionData& completionData) \r\nat System.IO.Pipelines.Pipe.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Pipelines.Pipe+DefaultPipeWriter.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<FlushAsync>d__166.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<FlushAsync>d__166>(Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<FlushAsync>d__166& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests.FlushAsync(System.IO.Pipelines.PipeWriter writableBuffer) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests.SendAsync(System.ReadOnlySpan<System.Byte> span) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests.SendGoAwayAsync() \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<GOAWAY_Received_RelievesConnectionBackpressure>d__130.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action action, System.Boolean allowInlining, System.Threading.Tasks.Task& currentTask) \r\nat System.Threading.Tasks.Task.FinishContinuations() \r\nat System.Threading.Tasks.Task.FinishStageThree() \r\nat System.Threading.Tasks.Task<System.__Canon>.TrySetResult(System.__Canon result) \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame>.SetResult(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame result) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<ExpectAsync>d__199.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action action, System.Boolean allowInlining, System.Threading.Tasks.Task& currentTask) \r\nat System.Threading.Tasks.Task.FinishContinuations() \r\nat System.Threading.Tasks.Task.FinishStageThree() \r\nat System.Threading.Tasks.Task<System.__Canon>.TrySetResult(System.__Canon result) \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame>.SetResult(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame result) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<ReceiveFrameAsync>d__197.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Runtime.CompilerServices.ValueTaskAwaiter+<>c.<.cctor>b__9_0(System.Object state) \r\nat System.IO.Pipelines.InlineScheduler.Schedule(System.Action<System.Object> action, System.Object state) \r\nat System.IO.Pipelines.Pipe.TrySchedule(System.IO.Pipelines.PipeScheduler scheduler, System.IO.Pipelines.CompletionData& completionData) \r\nat System.IO.Pipelines.Pipe.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Pipelines.Pipe+DefaultPipeWriter.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StreamSafePipeFlusher.FlushAsync(System.Int64 count, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer outputProducer, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter.FlushAsync(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer outputProducer, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseStream.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Stream.FlushAsync() \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d>(Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0.<GOAWAY_Received_RelievesConnectionBackpressure>b__0(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7>(Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7& stateMachine) \r\nat Microsoft.AspNetCore.Testing.DummyApplication.ProcessRequestAsync(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequestsAsync<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection+<>c__58<Microsoft.AspNetCore.Http.HttpContext>.<StartStream>b__58_0(System.Object state) \r\nat System.Threading.QueueUserWorkItemCallback.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() \r\nat System.Threading.ThreadPoolWorkQueue.Dispatch() \r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() \r\nU-->M\r\n```\r\n```\r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter.WriteDataAsync(System.Int32 streamId, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2StreamOutputFlowControl flowControl, System.Buffers.ReadOnlySequence<System.Byte> data, System.Boolean endStream) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer+<ProcessDataWrites>d__19.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Runtime.CompilerServices.ValueTaskAwaiter+<>c.<.cctor>b__9_0(System.Object state) \r\nat System.IO.Pipelines.InlineScheduler.Schedule(System.Action<System.Object> action, System.Object state) \r\nat System.IO.Pipelines.Pipe.TrySchedule(System.IO.Pipelines.PipeScheduler scheduler, System.IO.Pipelines.CompletionData& completionData) \r\nat System.IO.Pipelines.Pipe.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Pipelines.Pipe+DefaultPipeWriter.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StreamSafePipeFlusher.FlushAsync(System.Int64 count, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer outputProducer, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.WriteDataAsync(System.ReadOnlySpan<System.Byte> data, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.WriteAsync(System.ReadOnlyMemory<System.Byte> data, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseStream.WriteAsync(System.Byte[] buffer, System.Int32 offset, System.Int32 count, System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Stream.WriteAsync(System.Byte[] buffer, System.Int32 offset, System.Int32 count) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d>(Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0.<GOAWAY_Received_RelievesConnectionBackpressure>b__0(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7>(Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7& stateMachine) \r\nat Microsoft.AspNetCore.Testing.DummyApplication.ProcessRequestAsync(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequestsAsync<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection+<>c__58<Microsoft.AspNetCore.Http.HttpContext>.<StartStream>b__58_0(System.Object state) \r\nat System.Threading.QueueUserWorkItemCallback.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() \r\nat System.Threading.ThreadPoolWorkQueue.Dispatch() \r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() \r\nU-->M\r\n```",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2722",
				"RelatedDescription": "Closed issue \"Kestrel test hangs (Control flow?)\" (#2722)"
			},
			{
				"Id": "342857282",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T20:25:02",
				"Actor": "dotnet-maestro-bot",
				"Number": "2736",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @davidfowl\n* @halter73\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2736",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2736)"
			},
			{
				"Id": "342594220",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T18:49:46",
				"Actor": "davidfowl",
				"Number": "2735",
				"RawContent": null,
				"Title": "Complete the transport pipes after connection middleware runs",
				"State": "closed",
				"Body": "- It's a safe guard for code that doesn't complete the pipes (makes sure we don't leak memory).\r\n- It simplifies writing ConnectionHandlers",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2735",
				"RelatedDescription": "Closed or merged PR \"Complete the transport pipes after connection middleware runs\" (#2735)"
			},
			{
				"Id": "341287512",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T17:56:41",
				"Actor": "VenkateshSrini",
				"Number": "2725",
				"RawContent": null,
				"Title": "Unable to use HTTPS certificate with Kestrel indocker",
				"State": "closed",
				"Body": "Hi,\r\nI have been trying to dockerize a Simple ASP.NET core API app running Kestrel with Https enabled. I have followed all the instructions available but nothing seems to work. A detailed issue is created here\r\n[Docker with HTTPS ASP.NET Core 2.1](https://github.com/dotnet/dotnet-docker/issues/630#issuecomment-404865564). The link also provides the code and various methods that we are trying to get it working. \r\n\r\nPlease help us in this regard\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2725",
				"RelatedDescription": "Closed issue \"Unable to use HTTPS certificate with Kestrel indocker\" (#2725)"
			},
			{
				"Id": "342518336",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T22:47:46",
				"Actor": "Tratcher",
				"Number": "2733",
				"RawContent": null,
				"Title": "Verify request and response Content-Length",
				"State": "open",
				"Body": "https://tools.ietf.org/html/rfc7540#section-8.1.2.6\r\n\r\nIn http2 requests and responses use the chunk style data frames to transfer the body and indicate when it's complete. However the Content-Length header is still supported and MUST be cross-checked against the number of bytes received or sent. A mismatch is a stream level protocol error.\r\n\r\nWe can also use the Content-Length tracking to know when to set the End_Stream flag rather than waiting until the app pipeline exits. Compare with https://github.com/aspnet/KestrelHttpServer/issues/2678\r\n(Q: How would that optimization interact with trailers? Related: https://github.com/aspnet/KestrelHttpServer/issues/2630) ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2733",
				"RelatedDescription": "Open issue \"Verify request and response Content-Length\" (#2733)"
			},
			{
				"Id": "341923938",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T13:39:37",
				"Actor": "baal2000",
				"Number": "2730",
				"RawContent": null,
				"Title": "Deeply recursive ConnectionAbortedException handling after HttpRequestStream.ValidateState ",
				"State": "open",
				"Body": "We are getting the following 850 calls deep recursive ConnectionAbortedException stack logged that does not cause any noticeable issues at the moment but still doesn't look right. \r\n\r\nKestrel and .Net Core version: 2.1.1\r\n\r\n```\r\nMicrosoft.AspNetCore.Connections.ConnectionAbortedException: The connection was aborted\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.ValidateState(CancellationToken cancellationToken)\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.ReadAsync(...)\r\n at System.IO.StreamReader.ReadBufferAsync()\r\n at System.IO.StreamReader.ReadToEndAsyncInternal()  \r\n```",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2730",
				"RelatedDescription": "Open issue \"Deeply recursive ConnectionAbortedException handling after HttpRequestStream.ValidateState \" (#2730)"
			},
			{
				"Id": "341648195",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T22:13:35",
				"Actor": "gerardtoconnor",
				"Number": "2729",
				"RawContent": null,
				"Title": "Connection Hanging after prior request not closed out",
				"State": "closed",
				"Body": "I've tried my best to figure out the issue without opening an issue but nothing seems to work.\r\n\r\nI have been experimenting with a new web framework format for FSharp & TechEmpower benchmark tests and everything seemed fine but I noticed that when I try re-request a path the request stays stuck pending. It appears the prior request that delivered is not correctly closing out. I am returning a Task from a `AsyncTaskMethodBuilder` in my Invoke middleware and I am setting it's result at the very end of the final body write. I am able to run a HttpContext.Abort() after the SetResult and that removes the issue but some requests then come back as abort errors. Is there some way to force close out / Dispose of the connection/HttpContext as it seems there's a hanging reference or something that is preventing it being cleaned up/closed out\r\n\r\n[Middleware Invoke](https://github.com/gerardtoconnor/FrameworkBenchmarks/tree/master/frameworks/FSharp/Zebra/src/App/Program.fs)\r\n\r\n[Hybrid State Machine](https://github.com/gerardtoconnor/FrameworkBenchmarks/tree/master/frameworks/FSharp/Zebra/src/App/State.fs)\r\n\r\n```fsharp\r\n[<Struct>]\r\ntype FinishStateAwaiter(methodBuilder:AsyncTaskMethodBuilder,ctx:HttpContext) =\r\n    interface IAsyncStateMachine with\r\n        member __.MoveNext() =         \r\n            methodBuilder.SetResult()  // Sets result of Task returned at invoke which should close out connection\r\n            \r\n            ctx.Abort()  // << Forced to abort connection as stays open even after Task SetResult above\r\n        member __.SetStateMachine sm = methodBuilder.SetStateMachine sm \r\n```\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2729",
				"RelatedDescription": "Closed issue \"Connection Hanging after prior request not closed out\" (#2729)"
			},
			{
				"Id": "341347093",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T18:41:06",
				"Actor": "dotnet-maestro-bot",
				"Number": "2726",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @aspnetci\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2726",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2726)"
			},
			{
				"Id": "341198133",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T17:55:21",
				"Actor": "halter73",
				"Number": "2724",
				"RawContent": null,
				"Title": "Fix deadlock in GOAWAY_Received_RelievesConnectionBackpressure",
				"State": "closed",
				"Body": "#2722\r\n\r\n@Tratcher ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2724",
				"RelatedDescription": "Closed or merged PR \"Fix deadlock in GOAWAY_Received_RelievesConnectionBackpressure\" (#2724)"
			},
			{
				"Id": "341587113",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T17:16:21",
				"Actor": "olamide1234",
				"Number": "2728",
				"RawContent": null,
				"Title": "Booking ",
				"State": "closed",
				"Body": "I want to know more ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2728",
				"RelatedDescription": "Closed issue \"Booking \" (#2728)"
			},
			{
				"Id": "341573742",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T15:45:15",
				"Actor": "Naragato",
				"Number": "2727",
				"RawContent": null,
				"Title": "Dev HTTPS Certificate not loading when assembly name differs from project name.",
				"State": "open",
				"Body": "If your project name differs from the assembly name the dev ssl certificate isn't loaded.  A certificate is created with the project name, but the library uses the assembly name.\r\n\r\nThe result is the following exception:\r\n\r\n```System.InvalidOperationException: 'Unable to configure HTTPS endpoint. No server certificate was \r\nspecified, and the default developer certificate could not be found.\r\nTo generate a developer certificate run 'dotnet dev-certs https'. To trust the certificate (Windows and macOS only) run 'dotnet dev-certs https --trust'.\r\nFor more information on configuring HTTPS see https://go.microsoft.com/fwlink/?linkid=848054.'\r\n```\r\n\r\nRenaming said certificate to the assembly works, until the certificate is recreated.  As a temporary work around I'm using a symbolic link.\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2727",
				"RelatedDescription": "Open issue \"Dev HTTPS Certificate not loading when assembly name differs from project name.\" (#2727)"
			},
			{
				"Id": "340756936",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T23:48:14",
				"Actor": "dotnet-maestro-bot",
				"Number": "2719",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @halter73\n* @natemcmaster\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2719",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2719)"
			},
			{
				"Id": "341116186",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T18:25:45",
				"Actor": "Eilon",
				"Number": "2723",
				"RawContent": null,
				"Title": "Need a better error message when kestrel cannot get the requested port",
				"State": "open",
				"Body": "_From @richlander on May 4, 2018 0:14_\n\n#This is what I see when Kestrel cannot get the port I asked for. This is on .NET Core 2.1 RC1 (with a 2.0 app).\r\n\r\n```console\r\npi@raspberrypi:~/dotnet-docker/samples/aspnetapp/aspnetapp $ export ASPNETCORE_URLS=http://+:80\r\npi@raspberrypi:~/dotnet-docker/samples/aspnetapp/aspnetapp $ dotnet run\r\ncrit: Microsoft.AspNetCore.Server.Kestrel[0]\r\n      Unable to start Kestrel.\r\nMicrosoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.UvException: Error -13 EACCES permission denied\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.LibuvFunctions.ThrowError(Int32 statusCode)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.LibuvFunctions.ThrowIfErrored(Int32 statusCode)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.LibuvFunctions.tcp_bind(UvTcpHandle handle, SockAddr\r\n```\n\n_Copied from original issue: aspnet/Home#3114_",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2723",
				"RelatedDescription": "Open issue \"Need a better error message when kestrel cannot get the requested port\" (#2723)"
			},
			{
				"Id": "340801614",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T03:34:13",
				"Actor": "natemcmaster",
				"Number": "2721",
				"RawContent": null,
				"Title": "[2.1]: pin baseline package versions to 2.1.2",
				"State": "closed",
				"Body": "Part of https://github.com/aspnet/Home/issues/3316\n\nThis pins package versions to the 2.1.2 baseline. Universe will not override variables in the 'Pinned' section. This helps ensure that this repo does not upgrade its dependency versions for all future patches of 2.1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2721",
				"RelatedDescription": "Closed or merged PR \"[2.1]: pin baseline package versions to 2.1.2\" (#2721)"
			},
			{
				"Id": "340494645",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T00:21:40",
				"Actor": "natemcmaster",
				"Number": "2717",
				"RawContent": null,
				"Title": "[2.1] Remove usage of the Microsoft.Extensions.Buffers.Sources package",
				"State": "closed",
				"Body": "This moves source code that used to be in aspnet/Common. It was only used here, so this simplifies the process of working with these internal-only APIs.\r\n\r\ncref https://github.com/aspnet/Common/pull/386",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2717",
				"RelatedDescription": "Closed or merged PR \"[2.1] Remove usage of the Microsoft.Extensions.Buffers.Sources package\" (#2717)"
			},
			{
				"Id": "340788716",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T20:36:09",
				"Actor": "Tratcher",
				"Number": "2720",
				"RawContent": null,
				"Title": "Enable Http/2 by default for TLS connections",
				"State": "open",
				"Body": "This is an ask from @DamianEdwards and @shirhatti. \r\n\r\nPreferably this will be enabled for preview1 so we can get feedback. ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2720",
				"RelatedDescription": "Open issue \"Enable Http/2 by default for TLS connections\" (#2720)"
			},
			{
				"Id": "340393218",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-12T18:20:49",
				"Actor": "halter73",
				"Number": "2715",
				"RawContent": null,
				"Title": " Merge branch 'release/2.1' into release/2.2",
				"State": "closed",
				"Body": "#2709",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2715",
				"RelatedDescription": "Closed or merged PR \" Merge branch 'release/2.1' into release/2.2\" (#2715)"
			},
			{
				"Id": "340728308",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-12T17:46:28",
				"Actor": "dotnet-maestro-bot",
				"Number": "2718",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2718",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2718)"
			},
			{
				"Id": "340477675",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T03:35:33",
				"Actor": "FZ14",
				"Number": "2716",
				"RawContent": null,
				"Title": "Windows Authentication (Kerberos/NTLM) in asp.net core linux",
				"State": "open",
				"Body": "Hello.\r\nEnterprise Application Development still requires Windows Authentication (via NTLM/Kerberos).\r\nIt perhaps in asp.net core development model on kestrel server in Linux?",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2716",
				"RelatedDescription": "Open issue \"Windows Authentication (Kerberos/NTLM) in asp.net core linux\" (#2716)"
			}],
			"ResultType": "GitHubIssue"
		}
	},
	"RunOn": "2018-07-24T05:30:22.990787Z",
	"RunDurationInMilliseconds": 17242
}
