{"Data":{"Blog":{"FeedItems":[{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803)","PublishedOn":"2018-05-24T01:49:57+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/23/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-april-2018-update-version-1803/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update)","PublishedOn":"2018-05-21T22:44:05+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/21/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-1709-fall-creators-update/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10","PublishedOn":"2018-05-17T17:20:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1703 (Creators Update) and Windows 10 1607 (Anniversary Update). Quality and Reliability This release contains the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/17/net-framework-may-2018-preview-of-quality-rollup-for-windows-10/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup","PublishedOn":"2018-05-15T18:10:24+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup. Quality and Reliability This release contains the following quality and reliability improvements. CLR Resolves an issue in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/15/net-framework-may-2018-preview-of-quality-rollup/","RawContent":null},{"Title":".NET Core May 2018 Update","PublishedOn":"2018-05-08T22:31:30+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core May 2018 Update. This update includes .NET Core 2.1.200 SDK and ASP.NET Core 2.0.8. Security Microsoft is releasing this security advisory to provide information...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-core-may-2018-update/","RawContent":null},{"Title":".NET Framework May 2018 Security and Quality Rollup","PublishedOn":"2018-05-08T21:18:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Security and Quality Rollup. Security CVE-2018-1039 – Windows Security Feature Bypass Vulnerability A security feature bypass vulnerability exists in Windows which...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-framework-may-2018-security-and-quality-rollup/","RawContent":null},{"Title":"F# language and tools update for Visual Studio 2017 version 15.7","PublishedOn":"2018-05-08T18:22:06+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"We’re excited to share updates about changes to F# and F# tools which shipped with the Visual Studio 2017 version 15.7 release. Let’s dive in! Type Providers now support .NET Standard For those who...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/f-language-and-tools-update-for-visual-studio-2017-version-15-7/","RawContent":null},{"Title":"Introducing ML.NET: Cross-platform, Proven and Open Source Machine Learning Framework","PublishedOn":"2018-05-08T00:41:28+00:00","CommentsCount":24,"FacebookCount":0,"Summary":"Today at //Build 2018, we are excited to announce the preview of ML.NET, a cross-platform, open source machine learning framework. ML.NET will allow .NET developers to develop their own models and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/07/introducing-ml-net-cross-platform-proven-and-open-source-machine-learning-framework/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1 RC 1","PublishedOn":"2018-05-07T18:00:05+00:00","CommentsCount":15,"FacebookCount":0,"Summary":"Today, we are excited to announce that the first release candidate of EF Core 2.1 is available, alongside .NET Core 2.1 RC 1 and ASP.NET Core 2.1 RC 1, for broad testing, and now also for production...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/07/announcing-entity-framework-core-2-1-rc-1/","RawContent":null},{"Title":".NET Core 3 and Support for Windows Desktop Applications","PublishedOn":"2018-05-07T15:40:04+00:00","CommentsCount":289,"FacebookCount":0,"Summary":"At Microsoft Build Live today, we are sharing a first look at our plans for .NET Core 3. The highlight of .NET Core 3 is support for Windows desktop applications, specifically Windows Forms, Windows...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""},{"Id":"7697516495","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:04:23","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/101","RelatedDescription":"Merged pull request \"Create mlnet.md\" (#101) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"},{"Id":"7660843516","Type":"IssuesEvent","CreatedAt":"2018-05-11T12:12:46","Actor":"Longvimol","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/69","RelatedDescription":"Opened issue \"Dotnet / announcement \" (#69) at dotnet/announcements","RelatedBody":"This repo doesn't accept issues. Please see README.md in the root for more details.\r\n"},{"Id":"7644965785","Type":"IssuesEvent","CreatedAt":"2018-05-08T17:03:40","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/67","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-0765: .NET Core Denial Of Service Vulnerability\" (#67) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-0765: .NET Core Denial Of Service Vulnerability\r\n\r\n## <a name=\"executive-summary\"></a>Executive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in .NET Core and .NET native version 2.0. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nMicrosoft is aware of a denial of service vulnerability that exists when .NET Framework and .NET Core improperly process XML documents. An attacker who successfully exploited this vulnerability could cause a denial of service against a .NET Framework, .NET Core, or .NET native application.\r\n\r\nThe update addresses the vulnerability by correcting how .NET Framework, .NET Core, and .NET native applications handle XML document processing.\r\n\r\nIf your application is an ASP.NET Core application, developers are also advised to update to ASP.NET Core 2.0.8.\r\n\r\n## Discussion\r\n\r\nDiscussion for this issue can be found at https://github.com/dotnet/Home/ **TBD**\r\n\r\n### <a name=\"mitigation-factors\"></a>Mitigation factors\r\n\r\n* If an application does not process signed XML, it is not affected by this vulnerability.\r\n* If your application targets .NET Core 1.x or .NET native 1.x, it is not affected as the vulnerable package is not available for these platforms.\r\n\r\n## <a name=\"affected-software\"></a>Affected software\r\n\r\nAny .NET Core, .NET native, or ASP.NET Core based application that uses System.Security.Cryptography.Xml with a version of 4.4.1 or earlier.\r\n\r\nPackage name | Vulnerable versions | Secure versions\r\n------------ | ---------------- | -------------------------\r\nSystem.Security.Cryptography.Xml | ≤4.4.1 |  4.4.2 or later\r\n\r\n## <a name=\"advisory-faq\"></a>Advisory FAQ\r\n### <a name=\"how-affected\"></a>How do I know if I am affected?\r\n\r\n.NET Core has two types of dependencies: direct and transitive. Direct dependencies are dependencies where you specifically add a package to your project, transitive dependencies occur when you add a package to your project that in turn relies on another package.\r\n\r\nFor example, the `Microsoft.AspNetCore.Mvc` package depends on the `Microsoft.AspNetCore.Mvc.Core` package. When you add a dependency on `Microsoft.AspNetCore.Mvc` in your project, you're taking a transitive dependency on `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\nAny application that has a direct or transitive dependency on the [affected package](#affected-software) can be exposed to the vulnerability if it does not meet any of the [mitigation factors](#mitigation-factors).\r\n\r\n### <a name=\"how-fix\"></a>How do I fix the issue?\r\n---\r\n\r\nIf you're targeting ASP.NET Core 2.0 and using the `Microsoft.AspNetCore.All` metapackage:\r\n\r\n* Update its version number to 2.0.8 to pull in updated packages that update their transitive dependencies to the fixed version of `System.Security.Cryptography.Xml`.\r\n\r\n---\r\n\r\n.NET Core projects have two types of dependencies: direct and transitive. You must update your projects using the following instructions to address both types of dependency.\r\n\r\n#### Direct dependencies\r\n\r\nDirect dependencies are discoverable by examining your *csproj* file. They can be fixed by [editing the csproj file](#direct-dependencies) or using NuGet to update the dependency.\r\n\r\n#### Transitive dependencies\r\n\r\nTransitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.\r\n\r\nTransitive dependencies are reviewable in two ways:\r\n\r\n* In the Visual Studio Solution Explorer window, which supports searching.\r\n* By examining the *project.assets.json* file contained in the obj directory of your project.\r\n\r\nThe *project.assets.json* files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.\r\n\r\n#### <a name=\"direct-dependencies\"></a>Fixing direct dependencies\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Security.Cryptography.Xml\" Version=\"4.4.1\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nThe preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.\r\nThe package version number is in the `Version` attribute. The previous example shows a single direct dependency on `System.Security.Cryptography.Xml` version 4.4.1.\r\n\r\nTo update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).\r\nIn this example, update `System.Security.Cryptography.Xml` to a [fixed package number](#affected-software). Save the *csproj* file. The example *csproj* now looks as follows:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Security.Cryptography.Xml\" Version=\"4.4.2\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nIf you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.\r\n\r\nNow recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.\r\n\r\nAfter you've addressed all of your direct dependencies, you must review your transitive dependencies.\r\n\r\n#### Discovering and fixing transitive dependencies\r\n\r\nThere are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can [review the *project.assets.json* file](#project-assets-json).\r\n\r\n##### <a name=\"vs-solution-explorer\"></a>Using Visual Studio Solution Explorer\r\n\r\nTo use Solution Explorer, open the project in Visual Studio 2017, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.\r\n\r\nFor example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:\r\n\r\n![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)\r\n\r\nThe search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.\r\n\r\nUnder the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.\r\nIn screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.\r\nThe `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\n##### <a name=\"project-assets-json\"></a>Manually reviewing project.assets.json\r\n\r\nOpen the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.\r\nVisual Studio and Visual Studio Code provide JSON friendly editing.\r\n\r\nSearch the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:\r\n\r\n* Examine the line on which they are found, the version number is after the `/`.\r\n* Compare to the [vulnerable versions table](#affected-software).\r\n\r\nFor example, a search result that shows `System.Security.Cryptography.Xml/4.4.0` is a reference to version 4.4.0 of `System.Security.Cryptography.Xml`.\r\nIf your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.\r\n\r\n##### Fixing transitive dependencies\r\n\r\nIf you have not found any reference to any vulnerable packages, this means either\r\n\r\n* None of your direct dependencies depend on any vulnerable packages, or\r\n* You have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.\r\nLook for `PackageReference` nodes, for example:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nYou must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.\r\nYou do this by adding a new line to the dependencies section, referencing the fixed version.\r\nFor example, if your search showed a transitive reference to a vulnerable `System.Security.Cryptography.Xml` version, you'd add a reference to the [fixed package number](#affected-software).\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Security.Cryptography.Xml\" Version=\"4.4.2\" />\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nAfter you've added the direct dependency reference, save your *csproj* file.\r\n\r\nIf you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.\r\n\r\n#### Rebuilding your application\r\n\r\nFinally you must rebuild your application, test, and redeploy.\r\n\r\n---\r\n\r\nIf you're targeting .NET native for a Universal Windows Platform (UWP) application, you should update your dependencies and republish your application.\r\n\r\nIf you submit an application to the Windows Store with an outdated reference, the store will update the reference automatically, which has the potential for compatibility issues. Thus, we recommend updating your application directly and testing its functionality before resubmitting.\r\n\r\n---\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \"as is\" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### External Links\r\n\r\n[CVE-2018-0787](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2018-0765)\r\n\r\n### Revisions\r\n\r\nV1.0 (May 8, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2018-05-08_"},{"Id":"7619224203","Type":"IssuesEvent","CreatedAt":"2018-05-02T20:28:55","Actor":"MichaelSimons","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/65","RelatedDescription":"Opened issue \".NET Framework Runtime and Builder Docker repos have merged \" (#65) at dotnet/announcements","RelatedBody":"# .NET Framework Runtime and Builder Docker repos have merged\r\n\r\nThe [microsoft/dotnet-framework-build](https://hub.docker.com/r/microsoft/dotnet-framework-build/) Docker Hub repo has been merged into the [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) Docker Hub repo.  All new tags going forward will only be pushed to [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/).  The images in the [microsoft/dotnet-framework-build](https://hub.docker.com/r/microsoft/dotnet-framework-build/) Docker Hub repo will be retained and serviced accordingly as to not affect existing usage.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #125](https://github.com/Microsoft/dotnet-framework-docker/issues/125)\r\n\r\n## Details\r\n\r\nThe [microsoft/dotnet-framework-build](https://hub.docker.com/r/microsoft/dotnet-framework-build/) Docker Hub repo has been merged into the [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) Docker Hub repo.\r\n\r\n* https://github.com/Microsoft/dotnet-framework-docker/pull/123\r\n* https://github.com/Microsoft/dotnet-framework-docker/issues/78\r\n\r\nIn order to differentiate the runtime and build images, `runtime` and `sdk` distinguishing identifiers have been added to the tags.  For example, `4.7.2-runtime` and `4.7.2-sdk`.\r\n\r\nAll new tags going forward will only be pushed to [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/).   For example, the build images for 4.7.2 which was released today, only exist in [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) repo.\r\n\r\nThe existing tags in [microsoft/dotnet-framework-build](https://hub.docker.com/r/microsoft/dotnet-framework-build/) will remain and be serviced accordingly.  For example, the stable tags such as `4.7.1-windowsservercore-1709` will continue to be patched on a monthly basis.\r\n\r\nWe recommend that as you create and maintain your code, you move to use the new `runtime` and `sdk` images from the [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) repo.\r\n"},{"Id":"7545995438","Type":"IssuesEvent","CreatedAt":"2018-04-18T00:20:14","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/64","RelatedDescription":"Opened issue \"April 2018 .NET Updates\" (#64) at dotnet/announcements","RelatedBody":"# April 2018 .NET Updates\r\n\r\nThe following .NET updates were released this month. This issue will be updated if there are any additional updates during the month.\r\n\r\n## .NET Framework\r\n\r\n* No new releases. See: [.NET Framework February 2018 Security and Quality Rollup](https://blogs.msdn.microsoft.com/dotnet/2018/02/13/net-framework-february-2018-security-and-quality-rollup/).\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) and related Docker images were updated for [KB4093112](https://support.microsoft.com/help/4093112) and associated updates.\r\n\r\n## .NET Core\r\n\r\n* [.NET Core April 2018 Update](https://blogs.msdn.microsoft.com/dotnet/2018/04/17/net-core-april-2018-update/)\r\n   * [2.0.7 Release Notes](https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.7.md)\r\n   * [1.1.8 Release Notes](https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.8.md)\r\n   * [1.0.11 Release Notes](https://github.com/dotnet/core/blob/master/release-notes/1.0/1.0.11.md)\r\n* [.NET Core 2.1 Preview 2](https://blogs.msdn.microsoft.com/dotnet/2018/04/11/announcing-net-core-2-1-preview-2/)\r\n* [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) and related Docker images were updated for [KB4093112](https://support.microsoft.com/help/4093112) and associated updates.\r\n* Latest .NET Core security release: [.NET Core March 2018 Update](https://github.com/dotnet/core/issues/1341)\r\n\r\n## .NET for UWP\r\n\r\n* No new releases. See: [.NET for UWP January 2018 Update](https://blogs.msdn.microsoft.com/dotnet/2018/01/09/net-for-uwp-january-2018-update/).\r\n\r\n## Previous Updates\r\n\r\n* [February 2018 Security and Quality Updates](https://github.com/dotnet/announcements/issues/59)"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7736667088","Type":"IssuesEvent","CreatedAt":"2018-05-28T04:00:28","Actor":"AmeetShinde","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18149","RelatedDescription":"Opened issue \"Multiple restart of runtime host within the same process\" (#18149) at dotnet/coreclr","RelatedBody":"We have requirement to restart the runtime host within the same process. We are using following sequence of calls with ICLRRuntimeHost4 interface as listed in https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting\r\n\r\n1. Load coreclr library and get m_runtimehost (of type ICLRRuntimeHost4) by calling GetCLRRuntimeHost\r\n2. m_runtimehost->Start()\r\n3. m_runtimehost->CreateAppDomainwithManager() => using SINGLE_APP_DOMAIN\r\n4. m_runtimehost->CreateDelegate()\r\n5. Call delegates\r\n6. m_runtimehost->UnloadAppDomain2()\r\n7. m_runtimehost->Stop()\r\n8. Unload the coreclr library\r\n\r\nWhen we try to repeat the above sequence without restarting the process, we get access denied exceptionat step 2 with following call stack\r\n         coreclr.dll!SystemDomain::LoadBaseSystemClasses() Line 2715\tC++\r\n \tcoreclr.dll!SystemDomain::Init() Line 2460\tC++\r\n \tcoreclr.dll!EEStartupHelper(tagCOINITEE) Line 1058\tC++\r\n \tcoreclr.dll!EEStartup(tagCOINITEE) Line 1237\tC++\r\n \tcoreclr.dll!EnsureEEStarted(tagCOINITEE) Line 375\tC++\r\n \tcoreclr.dll!CorHost2::Start() Line 189\tC++\r\n\r\nIs this known issue? Is there any workaround to make this work?"},{"Id":"7736420928","Type":"IssuesEvent","CreatedAt":"2018-05-28T02:05:13","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18146","RelatedDescription":"Closed issue \"IContainable(Of T) Interface.\" (#18146) at dotnet/coreclr","RelatedBody":"# `IContainable(Of T)`\r\nThis is a simple interface that decouple the concept of containablity from collections / sequences and read / write access.\r\n```vbnet\r\nInterface IContainable(Of T)\r\n  Function Contains( value As T ) As Boolean\r\nEnd Interface\r\n```"},{"Id":"7735894744","Type":"IssuesEvent","CreatedAt":"2018-05-27T20:05:17","Actor":"borgdylan","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18148","RelatedDescription":"Opened issue \"Question: How do I diagnose an IPE?\" (#18148) at dotnet/coreclr","RelatedBody":"I am running code on .NET Core that is ported over from mono. The same compielr was use din both instances. Mono runs the IL fine but .NET Core is complaining about invalid IL in a particular method. Is there a debug flag that will make .NET Core spit out the exact instruction that it finds invalid? As th4 author of said compiler, I could fix the bug pointed out by the CLR if I had the instruction pointed out."},{"Id":"7735793636","Type":"IssuesEvent","CreatedAt":"2018-05-27T18:59:24","Actor":"AArnott","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18147","RelatedDescription":"Opened issue \"CoreCLR 1.0 won't load System.Collections.Immutable 1.2.2\" (#18147) at dotnet/coreclr","RelatedBody":"The simplest possible .NET Core 1.0 console application throws a `FileLoadException` with very little detail, when I try to load the netstandard1.0 build of System.Collections.Immutable.dll:\r\n\r\n> Could not load file or assembly 'System.Collections.Immutable, Version=1.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'\r\n\r\nIf I update to .NET Core 2.0, it works, but it loads the assembly from a different path than the one I give it. And besides, in the original project, updating to .NET Core 2.0 creates other assembly load problems, so I'd prefer to learn why this doesn't work on .NET Core 1.0 and fix that issue.\r\n\r\nSimplest repro project is linked below, but the C# code is simply this:\r\n\r\n```cs        AssemblyLoadContext.Default.LoadFromAssemblyPath(@\"C:\\Users\\andarno\\.nuget\\packages\\system.collections.immutable\\1.4.0\\lib\\netstandard1.0\\System.Collections.Immutable.dll\");\r\n```\r\n\r\n[ConsoleApp20.zip](https://github.com/dotnet/coreclr/files/2042920/ConsoleApp20.zip)\r\n"},{"Id":"7735747252","Type":"IssuesEvent","CreatedAt":"2018-05-27T18:31:34","Actor":"AdamSpeight2008","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18146","RelatedDescription":"Opened issue \"IContainable(Of T) Interface.\" (#18146) at dotnet/coreclr","RelatedBody":"# `IContainable(Of T)`\r\nThis is a simple interface that decouple the concept of containablity from collections / sequences and read / write access.\r\n```vbnet\r\nInterface IContainable(Of T)\r\n  Function Contains( value As T ) As Boolean\r\nEnd Interface\r\n```"},{"Id":"7735565742","Type":"IssuesEvent","CreatedAt":"2018-05-27T16:27:50","Actor":"voinokin","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18145","RelatedDescription":"Opened issue \"Some integer scalar and vectored conversion methods are not exposed in HW intrinsics API\" (#18145) at dotnet/coreclr","RelatedBody":"1. Currently, the intrinsics are exposed for signed int -> signed int and for unsigned int -> signed int upconversion when both src and dest are 128-bit vector. But no such API method is directly exposed for **unsigned int -> unsigned int**, so one has to either use `UnpackLow()` (which is different operation), or wrap existing signed upconversion with `StaticCast<signed, unsigned>()` which may provide overhead (see #18069) .\r\nThe suggestion is to add following convenience methods:\r\n- Sse41.ConvertToVector128UInt16(Vector128(byte)) for `[V]PMOVZXBW xmm, xmm` (same insn as for existing ConvertToVector128Int16())\r\n- Sse41.ConvertToVector128UInt32(Vector128(byte/ushort)) for `[V]PMOVZXBD/WD xmm, xmm` (same insn as for existing ConvertToVector128Int32())\r\n- Sse41.ConvertToVector128UInt64(Vector128(byte/ushort/uint)) for `[V]PMOVZXBQ/WQ/DQ xmm, xmm` (same insn as for existing ConvertToVector128Int64())\r\n----------------------------------------\r\n2. Similarly, no direct means are exposed in API for **unsigned int -> signed int** upconversion when src is in 128-bit vector, and the dest is in 256-bit vector.\r\nThe methods being suggested are:\r\n- Avx2.ConvertToVector256Int16(Vector128(byte)) for `VPMOVZXBW ymm, xmm` (same insn as for existing ConvertToVector256UInt16())\r\n- Avx2.ConvertToVector256Int32(Vector128(byte/ushort)) for `VPMOVZXBD/WD ymm, xmm` (same insn as for existing ConvertToVector256UInt32())\r\n- Avx2.ConvertToVector256Int64(Vector128(byte/ushort/uint)) for `VPMOVZXBQ/WQ/DQ ymm, xmm` (same insn as for existing ConvertToVector256UInt64())\r\n----------------------------------------\r\n3. I was not able to find not-too-verbose method to convert 32/64-bit scalar value to 256-bit vector in YMM reg. It is possible to set 128-bit vector with `Sse2.ConvertScalarToVector128UInt32/64()` which produces (`MOV r32/r64, imm` + `MOVD/MOVQ XMM, r32/r64`), but then `MOVDQA XMMd, XMMs` is automatically issued when one attempts to use helper method `Avx.ExtendToVector256()` to get 256-bit vector. To my understanding the helper method was intended to be used as type conversion and produce no-op in such cases, since `MOVD/MOVQ X/YMM, r32/r64` zeroes upper portion of dest reg. Below is an example of the issue I'm trying to explain:\r\n\r\n```\r\nvar v = Avx.ExtendToVector256(Sse2.ConvertScalarToVector128UInt64(0x12345678UL));\r\n00007FF989272625  mov         ecx,12345678h  \r\n00007FF98927262A  vmovq       xmm0,rcx  \r\n00007FF98927262F  vmovdqa     xmm6,xmm0  <======= this is not required\r\n```\r\n\r\nOTOH, the following conversion in reverse direction produces code that looks fine/optimal:\r\n\r\n```\r\nvar v1 = Sse2.ConvertToUInt64(Avx.GetLowerHalf(Avx.SetZeroVector256<ulong>()));\r\n00007FF989282618  vpxor       ymm0,ymm0,ymm0  \r\n00007FF98928261D  vmovq       rsi,xmm0\r\n```"},{"Id":"7735384655","Type":"PullRequestEvent","CreatedAt":"2018-05-27T14:34:52","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18141","RelatedDescription":"Merged pull request \"Typo\" (#18141) at dotnet/coreclr","RelatedBody":""},{"Id":"7735296691","Type":"IssuesEvent","CreatedAt":"2018-05-27T13:38:42","Actor":"voinokin","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18144","RelatedDescription":"Opened issue \"Sub-optimal performance when saving/restoring upper part of YMM regs before/after invoking nested methods\" (#18144) at dotnet/coreclr","RelatedBody":"Normally, VEXTRACTx128 is emitted by JIT to save upper part of YMM reg before invoking nested method(s), which is followed by VINSERTx128 to restore value back.\r\n\r\nThere are 3 issues observed:\r\n\r\n1. Although there exists encoding of `VEXTRACTx128` that allows saving the upper half of YMM directly to [m128] when for some reason ;-)  JIT decides to spill that to stack location, two insns are now emitted: `VEXTRACTx128 XMMx, YMMy, 1` + `VMOVUPD xmmword ptr [rsp+ZZZ],XMMx`. The similar issue appears when restoring values back - `VMOVUPD XMMx, xmmword ptr [rsp+ZZZ]` + `VINSERTx128 YMMy, YMMy, XMMx, 1` although there exist form `VINSERTx128 YMMy, YMMy, [m128], 1`\r\n\r\n2. Overall, multiple unneeded `VINSERTx128` + `VEXRACTx128` (in this order) are issued inbetween the calls to nested methods even though it is obvious that the values initially saved are neither modified, nor required during the invocations of methods. For the repro code below, no restore/save roundtrip is required to my understanding inbetween calls to `DoThis()` and `DoThat()`. The good indication of performance hit is in the 2nd part of example when `object[]` is implicitly created and filled in which involves lots of (what I think is) boxing conversions to be later passed to `Console.WriteLine()`. It is even worse if string interpolation would be used. [My speculation is - this thing may worsen further when it will come to restoring/saving larger vectors like the ones AVX-512 will provide when it will come into play.]\r\n\r\n3. `VINSERTF128/VEXTRACTF128` insns are issued for integer domain vectors although `VINSERTI128/VEXTRACTI128` insns are available on AVX2 (JIT ran on Haswell). It's possible that even though both pairs of insns execute equally fast on current CPUs, this may change in the future. [I cannot consistently confirm whether performance hit exists or not on current CPUs since I only have noisy Haswell VM at my disposal.]\r\n\r\nBelow is the source code for repro:\r\n\r\n```\r\n        [MethodImpl(MethodImplOptions.NoInlining)]\r\n        static void DoThis() { }\r\n\r\n        [MethodImpl(MethodImplOptions.NoInlining)]\r\n        static void DoThat() { }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var xA = Avx.SetZeroVector256<byte>();\r\n            var xB = Avx.SetZeroVector256<byte>();\r\n            var xC = Avx.SetZeroVector256<byte>();\r\n            var xD = Avx.SetZeroVector256<byte>();\r\n            var xE = Avx.SetZeroVector256<byte>();\r\n            var xF = Avx.SetZeroVector256<byte>();\r\n            var xG = Avx.SetZeroVector256<byte>();\r\n            var xH = Avx.SetZeroVector256<byte>();\r\n\r\n            DoThis();\r\n            DoThat();\r\n\r\n            Console.WriteLine($\"{xA} {xB} {xC} {xD} {xE} {xF} {xG} {xH}\");\r\n        }\r\n```\r\nThe asm code I've got on Haswell (i7-4790K with AVX2):\r\n\r\n```\r\n--- ...\\Program.cs --------------------------------------\r\n            var xA = Avx.SetZeroVector256<byte>();\r\n00007FF989261BA0  push        rsi  \r\n00007FF989261BA1  sub         rsp,190h  \r\n00007FF989261BA8  vzeroupper  \r\n00007FF989261BAB  vmovaps     xmmword ptr [rsp+180h],xmm6  \r\n00007FF989261BB5  vmovaps     xmmword ptr [rsp+170h],xmm7  \r\n00007FF989261BBF  vmovaps     xmmword ptr [rsp+160h],xmm8  \r\n00007FF989261BC9  vmovaps     xmmword ptr [rsp+150h],xmm9  \r\n00007FF989261BD3  vmovaps     xmmword ptr [rsp+140h],xmm10  \r\n00007FF989261BDD  vmovaps     xmmword ptr [rsp+130h],xmm11  \r\n00007FF989261BE7  vmovaps     xmmword ptr [rsp+120h],xmm12  \r\n00007FF989261BF1  vmovaps     xmmword ptr [rsp+110h],xmm13  \r\n00007FF989261BFB  vmovaps     xmmword ptr [rsp+100h],xmm14  \r\n00007FF989261C05  vmovaps     xmmword ptr [rsp+0F0h],xmm15  \r\n00007FF989261C0F  vpxor       ymm6,ymm6,ymm6  \r\n            var xB = Avx.SetZeroVector256<byte>();\r\n00007FF989261C14  vpxor       ymm7,ymm7,ymm7  \r\n            var xC = Avx.SetZeroVector256<byte>();\r\n00007FF989261C19  vpxor       ymm8,ymm8,ymm8  \r\n            var xD = Avx.SetZeroVector256<byte>();\r\n00007FF989261C1E  vpxor       ymm9,ymm9,ymm9  \r\n            var xE = Avx.SetZeroVector256<byte>();\r\n00007FF989261C23  vpxor       ymm10,ymm10,ymm10  \r\n            var xF = Avx.SetZeroVector256<byte>();\r\n00007FF989261C28  vpxor       ymm11,ymm11,ymm11  \r\n00007FF989261C2D  vmovupd     ymmword ptr [rsp+60h],ymm11  \r\n            var xG = Avx.SetZeroVector256<byte>();\r\n00007FF989261C34  vpxor       ymm12,ymm12,ymm12  \r\n            var xG = Avx.SetZeroVector256<byte>();\r\n00007FF989261C39  vmovupd     ymmword ptr [rsp+40h],ymm12  \r\n            var xH = Avx.SetZeroVector256<byte>();\r\n00007FF989261C40  vpxor       ymm13,ymm13,ymm13  \r\n00007FF989261C45  vmovupd     ymmword ptr [rsp+20h],ymm13  \r\n\r\n            DoThis();\r\n00007FF989261C4C  vextractf128 xmm14,ymm6,1  \r\n00007FF989261C52  vextractf128 xmm15,ymm7,1  \r\n00007FF989261C58  vextractf128 xmm4,ymm8,1  \r\n00007FF989261C5E  vmovupd     xmmword ptr [rsp+0E0h],xmm4  \r\n00007FF989261C68  vextractf128 xmm4,ymm9,1  \r\n00007FF989261C6E  vmovupd     xmmword ptr [rsp+0D0h],xmm4  \r\n00007FF989261C78  vextractf128 xmm4,ymm10,1  \r\n00007FF989261C7E  vmovupd     xmmword ptr [rsp+0C0h],xmm4  \r\n00007FF989261C88  call        00007FF989261108  \r\n00007FF989261C8D  vmovupd     xmm4,xmmword ptr [rsp+0C0h]  \r\n00007FF989261C97  vinsertf128 ymm10,ymm10,xmm4,1  \r\n00007FF989261C9D  vmovupd     xmm4,xmmword ptr [rsp+0D0h]  \r\n00007FF989261CA7  vinsertf128 ymm9,ymm9,xmm4,1  \r\n00007FF989261CAD  vmovupd     xmm4,xmmword ptr [rsp+0E0h]  \r\n00007FF989261CB7  vinsertf128 ymm8,ymm8,xmm4,1  \r\n00007FF989261CBD  vinsertf128 ymm7,ymm7,xmm15,1  \r\n00007FF989261CC3  vinsertf128 ymm6,ymm6,xmm14,1  \r\n            DoThat();\r\n00007FF989261CC9  vextractf128 xmm11,ymm6,1  \r\n00007FF989261CCF  vextractf128 xmm12,ymm7,1  \r\n00007FF989261CD5  vextractf128 xmm13,ymm8,1  \r\n00007FF989261CDB  vextractf128 xmm14,ymm9,1  \r\n00007FF989261CE1  vextractf128 xmm15,ymm10,1  \r\n00007FF989261CE7  call        00007FF989261110  \r\n00007FF989261CEC  vinsertf128 ymm10,ymm10,xmm15,1  \r\n00007FF989261CF2  vinsertf128 ymm9,ymm9,xmm14,1  \r\n00007FF989261CF8  vinsertf128 ymm8,ymm8,xmm13,1  \r\n            DoThat();\r\n00007FF989261CFE  vinsertf128 ymm7,ymm7,xmm12,1  \r\n00007FF989261D04  vinsertf128 ymm6,ymm6,xmm11,1  \r\n\r\n            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6} {7}\", xA, xB, xC, xD, xE, xF, xG, xH);\r\n00007FF989261D0A  mov         rcx,7FF9E67932B0h  \r\n00007FF989261D14  mov         edx,8  \r\n00007FF989261D19  vextractf128 xmm11,ymm6,1  \r\n00007FF989261D1F  vextractf128 xmm12,ymm7,1  \r\n00007FF989261D25  vextractf128 xmm13,ymm8,1  \r\n00007FF989261D2B  vextractf128 xmm14,ymm9,1  \r\n00007FF989261D31  vextractf128 xmm15,ymm10,1  \r\n00007FF989261D37  call        00007FF9E8D41AD0  \r\n00007FF989261D3C  vinsertf128 ymm10,ymm10,xmm15,1  \r\n00007FF989261D42  vinsertf128 ymm9,ymm9,xmm14,1  \r\n00007FF989261D48  vinsertf128 ymm8,ymm8,xmm13,1  \r\n00007FF989261D4E  vinsertf128 ymm7,ymm7,xmm12,1  \r\n00007FF989261D54  vinsertf128 ymm6,ymm6,xmm11,1  \r\n00007FF989261D5A  mov         rsi,rax  \r\n00007FF989261D5D  mov         rcx,7FF989256770h  \r\n00007FF989261D67  vextractf128 xmm11,ymm6,1  \r\n00007FF989261D6D  vextractf128 xmm12,ymm7,1  \r\n00007FF989261D73  vextractf128 xmm13,ymm8,1  \r\n00007FF989261D79  vextractf128 xmm14,ymm9,1  \r\n00007FF989261D7F  vextractf128 xmm15,ymm10,1  \r\n00007FF989261D85  call        00007FF9E8D41940  \r\n00007FF989261D8A  vinsertf128 ymm10,ymm10,xmm15,1  \r\n00007FF989261D90  vinsertf128 ymm9,ymm9,xmm14,1  \r\n00007FF989261D96  vinsertf128 ymm8,ymm8,xmm13,1  \r\n00007FF989261D9C  vinsertf128 ymm7,ymm7,xmm12,1  \r\n00007FF989261DA2  vinsertf128 ymm6,ymm6,xmm11,1  \r\n00007FF989261DA8  mov         r8,rax  \r\n00007FF989261DAB  vmovupd     ymmword ptr [r8+8],ymm6  \r\n00007FF989261DB1  mov         rcx,rsi  \r\n00007FF989261DB4  xor         edx,edx  \r\n00007FF989261DB6  vextractf128 xmm6,ymm7,1  \r\n00007FF989261DBC  vextractf128 xmm11,ymm8,1  \r\n00007FF989261DC2  vextractf128 xmm12,ymm9,1  \r\n00007FF989261DC8  vextractf128 xmm13,ymm10,1  \r\n00007FF989261DCE  call        00007FF9E8D405C0  \r\n00007FF989261DD3  vinsertf128 ymm10,ymm10,xmm13,1  \r\n00007FF989261DD9  vinsertf128 ymm9,ymm9,xmm12,1  \r\n00007FF989261DDF  vinsertf128 ymm8,ymm8,xmm11,1  \r\n00007FF989261DE5  vinsertf128 ymm7,ymm7,xmm6,1  \r\n00007FF989261DEB  mov         rcx,7FF989256770h  \r\n00007FF989261DF5  vextractf128 xmm6,ymm7,1  \r\n00007FF989261DFB  vextractf128 xmm11,ymm8,1  \r\n00007FF989261E01  vextractf128 xmm12,ymm9,1  \r\n00007FF989261E07  vextractf128 xmm13,ymm10,1  \r\n00007FF989261E0D  call        00007FF9E8D41940  \r\n00007FF989261E12  vinsertf128 ymm10,ymm10,xmm13,1  \r\n00007FF989261E18  vinsertf128 ymm9,ymm9,xmm12,1  \r\n00007FF989261E1E  vinsertf128 ymm8,ymm8,xmm11,1  \r\n00007FF989261E24  vinsertf128 ymm7,ymm7,xmm6,1  \r\n00007FF989261E2A  mov         r8,rax  \r\n00007FF989261E2D  vmovupd     ymmword ptr [r8+8],ymm7  \r\n00007FF989261E33  mov         rcx,rsi  \r\n00007FF989261E36  mov         edx,1  \r\n00007FF989261E3B  vextractf128 xmm6,ymm8,1  \r\n00007FF989261E41  vextractf128 xmm7,ymm9,1  \r\n00007FF989261E47  vextractf128 xmm11,ymm10,1  \r\n00007FF989261E4D  call        00007FF9E8D405C0  \r\n00007FF989261E52  vinsertf128 ymm10,ymm10,xmm11,1  \r\n00007FF989261E58  vinsertf128 ymm9,ymm9,xmm7,1  \r\n00007FF989261E5E  vinsertf128 ymm8,ymm8,xmm6,1  \r\n00007FF989261E64  mov         rcx,7FF989256770h  \r\n00007FF989261E6E  vextractf128 xmm6,ymm8,1  \r\n00007FF989261E74  vextractf128 xmm7,ymm9,1  \r\n00007FF989261E7A  vextractf128 xmm11,ymm10,1  \r\n00007FF989261E80  call        00007FF9E8D41940  \r\n00007FF989261E85  vinsertf128 ymm10,ymm10,xmm11,1  \r\n00007FF989261E8B  vinsertf128 ymm9,ymm9,xmm7,1  \r\n00007FF989261E91  vinsertf128 ymm8,ymm8,xmm6,1  \r\n00007FF989261E97  mov         r8,rax  \r\n00007FF989261E9A  vmovupd     ymmword ptr [r8+8],ymm8  \r\n00007FF989261EA0  mov         rcx,rsi  \r\n00007FF989261EA3  mov         edx,2  \r\n00007FF989261EA8  vextractf128 xmm6,ymm9,1  \r\n00007FF989261EAE  vextractf128 xmm7,ymm10,1  \r\n00007FF989261EB4  call        00007FF9E8D405C0  \r\n00007FF989261EB9  vinsertf128 ymm10,ymm10,xmm7,1  \r\n00007FF989261EBF  vinsertf128 ymm9,ymm9,xmm6,1  \r\n00007FF989261EC5  mov         rcx,7FF989256770h  \r\n00007FF989261ECF  vextractf128 xmm6,ymm9,1  \r\n00007FF989261ED5  vextractf128 xmm7,ymm10,1  \r\n00007FF989261EDB  call        00007FF9E8D41940  \r\n00007FF989261EE0  vinsertf128 ymm10,ymm10,xmm7,1  \r\n00007FF989261EE6  vinsertf128 ymm9,ymm9,xmm6,1  \r\n00007FF989261EEC  mov         r8,rax  \r\n00007FF989261EEF  vmovupd     ymmword ptr [r8+8],ymm9  \r\n00007FF989261EF5  mov         rcx,rsi  \r\n00007FF989261EF8  mov         edx,3  \r\n00007FF989261EFD  vextractf128 xmm6,ymm10,1  \r\n00007FF989261F03  call        00007FF9E8D405C0  \r\n00007FF989261F08  vinsertf128 ymm10,ymm10,xmm6,1  \r\n00007FF989261F0E  mov         rcx,7FF989256770h  \r\n00007FF989261F18  vextractf128 xmm6,ymm10,1  \r\n00007FF989261F1E  call        00007FF9E8D41940  \r\n00007FF989261F23  vinsertf128 ymm10,ymm10,xmm6,1  \r\n00007FF989261F29  mov         r8,rax  \r\n00007FF989261F2C  vmovupd     ymmword ptr [r8+8],ymm10  \r\n00007FF989261F32  mov         rcx,rsi  \r\n00007FF989261F35  mov         edx,4  \r\n00007FF989261F3A  call        00007FF9E8D405C0  \r\n00007FF989261F3F  mov         rcx,7FF989256770h  \r\n00007FF989261F49  call        00007FF9E8D41940  \r\n00007FF989261F4E  mov         r8,rax  \r\n00007FF989261F51  vmovupd     ymm11,ymmword ptr [rsp+60h]  \r\n00007FF989261F58  vmovupd     ymmword ptr [r8+8],ymm11  \r\n00007FF989261F5E  mov         rcx,rsi  \r\n00007FF989261F61  mov         edx,5  \r\n00007FF989261F66  call        00007FF9E8D405C0  \r\n00007FF989261F6B  mov         rcx,7FF989256770h  \r\n00007FF989261F75  call        00007FF9E8D41940  \r\n00007FF989261F7A  mov         r8,rax  \r\n00007FF989261F7D  vmovupd     ymm12,ymmword ptr [rsp+40h]  \r\n00007FF989261F84  vmovupd     ymmword ptr [r8+8],ymm12  \r\n00007FF989261F8A  mov         rcx,rsi  \r\n00007FF989261F8D  mov         edx,6  \r\n00007FF989261F92  call        00007FF9E8D405C0  \r\n00007FF989261F97  mov         rcx,7FF989256770h  \r\n00007FF989261FA1  call        00007FF9E8D41940  \r\n00007FF989261FA6  mov         r8,rax  \r\n00007FF989261FA9  vmovupd     ymm13,ymmword ptr [rsp+20h]  \r\n00007FF989261FB0  vmovupd     ymmword ptr [r8+8],ymm13  \r\n00007FF989261FB6  mov         rcx,rsi  \r\n00007FF989261FB9  mov         edx,7  \r\n00007FF989261FBE  call        00007FF9E8D405C0  \r\n00007FF989261FC3  mov         rcx,20B9B723068h  \r\n00007FF989261FCD  mov         rcx,qword ptr [rcx]  \r\n00007FF989261FD0  mov         rdx,rsi  \r\n00007FF989261FD3  call        00007FF9892613F0  \r\n00007FF989261FD8  nop  \r\n00007FF989261FD9  vmovaps     xmm6,xmmword ptr [rsp+180h]  \r\n00007FF989261FE3  vmovaps     xmm7,xmmword ptr [rsp+170h]  \r\n00007FF989261FED  vmovaps     xmm8,xmmword ptr [rsp+160h]  \r\n00007FF989261FF7  vmovaps     xmm9,xmmword ptr [rsp+150h]  \r\n00007FF989262001  vmovaps     xmm10,xmmword ptr [rsp+140h]  \r\n00007FF98926200B  vmovaps     xmm11,xmmword ptr [rsp+130h]  \r\n00007FF989262015  vmovaps     xmm12,xmmword ptr [rsp+120h]  \r\n00007FF98926201F  vmovaps     xmm13,xmmword ptr [rsp+110h]  \r\n00007FF989262029  vmovaps     xmm14,xmmword ptr [rsp+100h]  \r\n00007FF989262033  vmovaps     xmm15,xmmword ptr [rsp+0F0h]  \r\n00007FF98926203D  vzeroupper  \r\n00007FF989262040  add         rsp,190h  \r\n00007FF989262047  pop         rsi  \r\n00007FF989262048  ret \r\n```"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7736415324","Type":"IssuesEvent","CreatedAt":"2018-05-28T02:03:11","Actor":"briangmay85","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/757","RelatedDescription":"Closed issue \"s\" (#757) at dotnet/standard","RelatedBody":""},{"Id":"7736414563","Type":"IssuesEvent","CreatedAt":"2018-05-28T02:02:53","Actor":"briangmay85","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/757","RelatedDescription":"Opened issue \"s\" (#757) at dotnet/standard","RelatedBody":""},{"Id":"7734621172","Type":"IssuesEvent","CreatedAt":"2018-05-27T04:16:47","Actor":"weitzhandler","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/756","RelatedDescription":"Opened issue \".NET UI Standard\" (#756) at dotnet/standard","RelatedBody":"Hi,\r\n\r\nThe .NET Standard was a great solution to overcome the various shapes of .NET and all its flavors.\r\n\r\nMaybe it's time to implement a .NET UI standard?\r\nIt will be a library of contracts for controls, layouts, user-input event hooks, navigation, styling, responsive adaptations, animations, shapes, and basically all tools a decent UI library is supposed to offer.\r\nMaybe even an opinionated default theme.\r\n\r\nThis will allow .NET UI Standard providers (be it WPF, UWP, Xamarin.Forms, Avalonia, and even web technologies, like ASP.NET Core), to implement renderers for the same UI in any platform while giving the developer the option to reuse the same UI structure.\r\nWe may consider using XAML as the language to describe those UIs but the core shouldn't be XAML but rather a CLR-based set of interfaces.\r\n\r\nRelated:\r\n- [Xamarin.Forms Drawing Spec](https://github.com/xamarin/Xamarin.Forms/issues/2452)\r\n- [Is XAML Standard dead?](https://github.com/Microsoft/xaml-standard/issues/230)\r\n- [YouTube: The Future of .NET on the Desktop](https://www.youtube.com/watch?v=tkiPcCHGngY)"},{"Id":"7731385459","Type":"PullRequestEvent","CreatedAt":"2018-05-25T18:04:43","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/754","RelatedDescription":"Merged pull request \"Update BuildTools to preview1-02824-02 (master)\" (#754) at dotnet/standard","RelatedBody":""},{"Id":"7729089441","Type":"IssuesEvent","CreatedAt":"2018-05-25T10:17:49","Actor":"VitalickS","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/755","RelatedDescription":"Opened issue \"Assembly incapsulation mechanizm not implemented\" (#755) at dotnet/standard","RelatedBody":"Hi. It was surprise for me, that I cannot use standard incapsulation in new dotnet core. I want separate 3 standard architecture layers for DAL, BLL, WebClient, but when I referenced it, I can see and call DAL methods in WebClient. Google has no answer, but it seems like you don't care about it. Can you help me with my problem?\r\n\r\nIn short words I attach simple image \r\n![3 layers](https://user-images.githubusercontent.com/10177561/40539622-f6b851d8-601d-11e8-9660-84dadd7aff3c.png)\r\n"},{"Id":"7725722906","Type":"PullRequestEvent","CreatedAt":"2018-05-24T18:51:44","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/754","RelatedDescription":"Opened pull request \"Update BuildTools to preview1-02824-02 (master)\" (#754) at dotnet/standard","RelatedBody":""},{"Id":"7725600325","Type":"PullRequestEvent","CreatedAt":"2018-05-24T18:29:40","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/753","RelatedDescription":"Merged pull request \"Update BuildTools to preview1-02824-01 (master)\" (#753) at dotnet/standard","RelatedBody":""},{"Id":"7724780186","Type":"PullRequestEvent","CreatedAt":"2018-05-24T15:57:25","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/753","RelatedDescription":"Opened pull request \"Update BuildTools to preview1-02824-01 (master)\" (#753) at dotnet/standard","RelatedBody":""},{"Id":"7720571229","Type":"PullRequestEvent","CreatedAt":"2018-05-23T23:54:41","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/748","RelatedDescription":"Merged pull request \"Update BuildTools to preview1-02823-01 (master)\" (#748) at dotnet/standard","RelatedBody":""},{"Id":"7713238279","Type":"IssuesEvent","CreatedAt":"2018-05-22T20:23:23","Actor":"wtgodbe","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/737","RelatedDescription":"Closed issue \"Misc build failures in 'official/standard/master/' - '20180517.01'\" (#737) at dotnet/standard","RelatedBody":"@dotnet-mc-bot commented on [Thu May 17 2018](https://github.com/dotnet/core-eng/issues/3507)\n\nThere were a set of failures during this build. Here is a summary of these:\r\n* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&buildId=1696522\r\n  - **Agent:** DDVSOWINAGE021\r\n  - **Error log:** ##[error]Process completed with exit code 1....\r\n\r\n@jcagme, @markwilkie\r\n\n\n---\n\n@weshaggard commented on [Thu May 17 2018](https://github.com/dotnet/core-eng/issues/3507#issuecomment-389922476)\n\n@wtgodbe this looks like your issue. Apparently calling Tools/msbuild.cmd directly will not work because that doesn't initialize VS. You would need to make sure you go through run.cmd which does initialize VS. \n\n---\n\n@jcagme commented on [Thu May 17 2018](https://github.com/dotnet/core-eng/issues/3507#issuecomment-389925626)\n\nMoving this to standard repo\n\n"},{"Id":"7713136600","Type":"PullRequestEvent","CreatedAt":"2018-05-22T20:03:26","Actor":"wtgodbe","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/752","RelatedDescription":"Merged pull request \"Get access to build.common.targets in publish.msbuild in 2.0.0\" (#752) at dotnet/standard","RelatedBody":"Without this, builds fail in signing because they don't have access to the SignFiles target. Importing dir.targets gets us build.common.targets from buildtools, which we need to run the Signing targets. Pattern here matches what is already in the other repos."},{"Id":"7713135711","Type":"PullRequestEvent","CreatedAt":"2018-05-22T20:03:16","Actor":"wtgodbe","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/752","RelatedDescription":"Opened pull request \"Get access to build.common.targets in publish.msbuild in 2.0.0\" (#752) at dotnet/standard","RelatedBody":"Without this, builds fail in signing because they don't have access to the SignFiles target. Importing dir.targets gets us build.common.targets from buildtools, which we need to run the Signing targets. Pattern here matches what is already in the other repos."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7735729670","Type":"IssuesEvent","CreatedAt":"2018-05-27T18:19:42","Actor":"Kaktusbot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/29939","RelatedDescription":"Opened issue \"Socket SendAsync MutipleBuffers pinning.\" (#29939) at dotnet/corefx","RelatedBody":"I was looking at sockets code, and one thing looked suspicious to me.\r\nI downloaded corefx repo and and tested some simple code with debugger.\r\n```C#\r\nList<ArraySegment<byte>> list = ... // Init List of ArraySegments with some bytes\r\nSocket socket = ... // Init Socket and connect to smth\r\n\r\n// Here BufferList of SocketAsyncEventArgs(cached as TaskSend) pins arrays of ArraySegments\r\nawait socket.SendAsync(list, SocketFlags.None); \r\n\r\n// Send single buffer as many times as you want, or just wait some time\r\n// It will not unpin BufferList from previous SendAsync, because it's SAEA cached as ValueTaskSend\r\nfor (int i = 0; i < 1000000; i++)\r\n    await socket.SendAsync(new byte[] {...},  SocketFlags.None);\r\n\r\n// And here it is, only here with new multibuffer send \r\n// buffers from previous multibuffer send are unpinned with GCHandle.Free()\r\nawait socket.SendAsync(list, SocketFlags.None);\r\n```\r\nIf my program uses multibuffer send once and after that only uses singlebuffer sends then buffers from that first and single multibuffer send will be pinned as long as socket itself lives.\r\nI'm understand that such a memory leak is unimportant and such use case somewhat absurd but I heard that pinning causes memory fragmentation.\r\nSo it bothers me and I think unpinning should occur after async operation is completed, not when next async operation is called.\r\nAm I right with my assumptions?\r\nShould I worry about them(fragmentation and leaks)?"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7732702348","Type":"PullRequestEvent","CreatedAt":"2018-05-26T01:11:26","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5860","RelatedDescription":"Opened pull request \"Enable OSX and Linux CoreFX CI tests\" (#5860) at dotnet/corert","RelatedBody":"This is a staging commit for a limited set of CoreFX tests to be run on MacOS and Linux on every PR."},{"Id":"7732589701","Type":"PullRequestEvent","CreatedAt":"2018-05-25T23:58:37","Actor":"maryamariyan","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5859","RelatedDescription":"Opened pull request \"[JustForView] visualizing diff needed in corert for Stackframe to go to shared\" (#5859) at dotnet/corert","RelatedBody":"Related to PR dotnet/coreclr#18134 which moves common StackFrame logic to shared"},{"Id":"7731440244","Type":"PullRequestEvent","CreatedAt":"2018-05-25T18:16:53","Actor":"crummel","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5858","RelatedDescription":"Opened pull request \"Use new Helix queue for Windows CI builds.\" (#5858) at dotnet/corert","RelatedBody":"Skip CI please."},{"Id":"7730398290","Type":"IssuesEvent","CreatedAt":"2018-05-25T14:43:11","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/3776","RelatedDescription":"Closed issue \"ObjWriter for armel tizen\" (#3776) at dotnet/corert","RelatedBody":"We tried to build ObjWriter for armel tizen from the current version of https://github.com/dotnet/llilc. But we found that it is too old, in particular there are some sections in CoreRT that are not processed by ObjWriter from this repository. Where can we take more up-to-date version of it with the appropriate building instructions?"},{"Id":"7729586995","Type":"IssuesEvent","CreatedAt":"2018-05-25T12:11:14","Actor":"am11","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5857","RelatedDescription":"Opened issue \"Alpine Linux CI job\" (#5857) at dotnet/corert","RelatedBody":"For Linux x64, there is ObjectWriter package published at: https://dotnet.myget.org/feed/dotnet-core/package/nuget/runtime.linux-x64.Microsoft.DotNet.ObjectWriter, produced by https://github.com/dotnet/corert/blob/e874d6c/pkg/Microsoft.DotNet.ObjectWriter/Microsoft.DotNet.ObjectWriter.pkgproj#L23. Same goes for Microsoft.DotNet.ILCompiler.\r\n\r\nToday, the RID for Alpine Linux expect to have `runtime.linux-musl-x64.Microsoft.DotNet.ObjectWriter`.\r\n\r\nCould there be a CI job configured for Linux with musl-libc, that will produce such a package? In CoreCLR and CoreFX, there is are dedicated CI jobs to produce native packages for Alpine Linux."}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"999498830528696320","CreatedAt":"2018-05-24T03:54:25+00:00","UserScreenname":"dotnet","Text":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803) https://t.co/U6TCTrPkfb","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":24,"FavoriteCount":9,"RawContent":null},{"Id":"998698514065510400","CreatedAt":"2018-05-21T22:54:15+00:00","UserScreenname":"dotnet","Text":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update) https://t.co/a0E1oZkvk2","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":31,"FavoriteCount":11,"RawContent":null}]}},"RunOn":"2018-05-28T05:30:22.8258905Z","RunDurationInMilliseconds":6866}