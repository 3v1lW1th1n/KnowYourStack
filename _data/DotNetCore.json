{"Data":{"Blog":{"FeedItems":[{"Title":"Building C# 8.0","PublishedOn":"2018-11-13T00:00:02+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"Building C# 8.0 The next major version of C# is C# 8.0. It&#8217;s been in the works for quite some time, even as we built and shipped the minor releases C# 7.1, 7.2 and 7.3, and I&#8217;m quite...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/","RawContent":null},{"Title":"Announcing ML.NET 0.7 (Machine Learning .NET)","PublishedOn":"2018-11-08T20:57:16+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"We&#8217;re excited to announce today the release of ML.NET 0.7 &#8211; the latest release of the cross-platform and open source machine learning framework for .NET developers (ML.NET 0.1 was released...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/11/08/announcing-ml-net-0-7-machine-learning-net/","RawContent":null},{"Title":"Understanding the Whys, Whats, and Whens of ValueTask","PublishedOn":"2018-11-07T18:00:31+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"The .NET Framework 4 saw the introduction of the System.Threading.Tasks namespace, and with it the Task class. This type and the derived Task&#60;TResult&#62; have long since become a staple of .NET...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/11/07/understanding-the-whys-whats-and-whens-of-valuetask/","RawContent":null},{"Title":"Announcing .NET Standard 2.1","PublishedOn":"2018-11-05T17:42:38+00:00","CommentsCount":98,"FacebookCount":0,"Summary":"Since we shipped .NET Standard 2.0 about a year ago, we&#8217;ve shipped two updates to .NET Core 2.1 and are about to release .NET Core 2.2. It&#8217;s time to update the standard to include some of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/11/05/announcing-net-standard-2-1/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3673","PublishedOn":"2018-10-30T19:27:39+00:00","CommentsCount":18,"FacebookCount":0,"Summary":"We are happy to share the next Early Access build for the .NET Framework 4.8. This includes an updated .NET 4.8 runtime as well as the .NET 4.8 Developer Pack (a single package that bundles the .NET...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/10/30/announcing-net-framework-4-8-early-access-build-3673/","RawContent":null},{"Title":"Bringing .NET application performance analysis to Linux","PublishedOn":"2018-10-24T21:36:02+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Both the Windows and Linux ecosystems have a swath of battle-hardened performance analysis and investigation tools. But up until recently, developers and platform engineers could use none of these...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/10/24/bringing-net-application-performance-analysis-to-linux/","RawContent":null},{"Title":".NET Core Source Code Analysis with Intel® VTune™ Amplifier","PublishedOn":"2018-10-23T21:04:49+00:00","CommentsCount":9,"FacebookCount":0,"Summary":"This post was written by Varun Venkatesan, Li Tian, Denis Pravdin, who are engineers at Intel. They are excited to share .NET Core-specific enhancements that Intel has made to VTune Amplifier...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/10/23/net-core-source-code-analysis-with-intel-vtune-amplifier/","RawContent":null},{"Title":"Call For Participation: .NET and TypeScript at FOSDEM conference","PublishedOn":"2018-10-23T20:16:43+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"The organizers of the FOSDEM 2019 conference have allocated a “Developer Room” on Saturday February 2nd 2019 for .NET and TypeScript discussions in Brussels Belgium.   FOSDEM is one of Europe’s most...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/10/23/call-for-participation-net-and-typescript-at-fosdem-conference/","RawContent":null},{"Title":".NET Framework October 2018 Preview of Quality Rollup","PublishedOn":"2018-10-18T20:44:34+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Today, we are releasing the October 2018 Preview of Quality Rollup. Quality and Reliability This release contains the following quality and reliability improvements. CLR Updated Japanese dates that...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/10/18/net-framework-october-2018-preview-of-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Core 2.2 Preview 3","PublishedOn":"2018-10-18T01:03:01+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Today, we are announcing .NET Core 2.2 Preview 3. We have made more improvements to the overall release that we would love to get your feedback on, either in the comments or at dotnet/core #2004....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/10/17/announcing-net-core-2-2-preview-3/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"8578321898","Type":"PullRequestEvent","CreatedAt":"2018-11-13T04:22:33","Actor":"jongalloway","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/foundation/pull/114","RelatedDescription":"Merged pull request \"Update identityserver.md\" (#114) at dotnet/foundation","RelatedBody":""},{"Id":"8573927252","Type":"PullRequestEvent","CreatedAt":"2018-11-12T13:30:25","Actor":"scottbrady91","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/foundation/pull/116","RelatedDescription":"Opened pull request \"Update to IdentityManager project\" (#116) at dotnet/foundation","RelatedBody":"My employer and I have recently taken over the IdentityManager project from Dom & Brock. I've updated the IdentityManager page to reflect this and the newer version of the core repo."},{"Id":"8573265026","Type":"PullRequestEvent","CreatedAt":"2018-11-12T11:25:41","Actor":"leastprivilege","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/foundation/pull/115","RelatedDescription":"Opened pull request \"Create identitymodel.md\" (#115) at dotnet/foundation","RelatedBody":""},{"Id":"8573235551","Type":"PullRequestEvent","CreatedAt":"2018-11-12T11:20:18","Actor":"leastprivilege","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/foundation/pull/114","RelatedDescription":"Opened pull request \"Update identityserver.md\" (#114) at dotnet/foundation","RelatedBody":""},{"Id":"8520090559","Type":"PullRequestEvent","CreatedAt":"2018-11-01T16:20:08","Actor":"jongalloway","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/foundation/pull/113","RelatedDescription":"Merged pull request \"Update logo for couchbase-lite in projects.json\" (#113) at dotnet/foundation","RelatedBody":"Uses a working link to the logo.\r\n\r\nResolves https://github.com/dotnet/dotnetfoundation-website/issues/65\r\n\r\nFix can be verified by copying/pasting the URL into a browser."},{"Id":"8448824845","Type":"PullRequestEvent","CreatedAt":"2018-10-19T12:44:07","Actor":"SeanKilleen","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/foundation/pull/113","RelatedDescription":"Opened pull request \"Update logo for couchbase-lite in projects.json\" (#113) at dotnet/foundation","RelatedBody":"Uses a working link to the logo.\r\n\r\nResolves https://github.com/dotnet/dotnetfoundation-website/issues/65"},{"Id":"8341294365","Type":"IssuesEvent","CreatedAt":"2018-09-29T02:45:47","Actor":"athinboy","Repository":"dotnet/foundation","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/foundation/issues/112","RelatedDescription":"Opened issue \"Suggest: key  F12  go to source code of dotnetcore  rather then metadata\" (#112) at dotnet/foundation","RelatedBody":"Apology for my poor english!\r\n\r\nI have change to Java due to the boss's decision .   I think dotnet  need a big change. In China, more and more dotnet project go to die,  but new java project continuously increase!\r\n\r\nI suggest:key  F12  go to source code of dotnetcore  rather then metadata(e.g.    ***.dll.source.zip \\****.exe.source.zip),   maybe there is already done,but i don't know. \r\n\r\nthanks!\r\n"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"8578309568","Type":"PullRequestEvent","CreatedAt":"2018-11-13T04:18:02","Actor":"Maoni0","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/20968","RelatedDescription":"Opened pull request \"n_heaps needs to be initialized before init_static_data is called\" (#20968) at dotnet/coreclr","RelatedBody":""},{"Id":"8578289216","Type":"PullRequestEvent","CreatedAt":"2018-11-13T04:11:08","Actor":"tannergooding","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/20967","RelatedDescription":"Opened pull request \"Fixing Utf8Parser.Number to not modify the value of 'c'\" (#20967) at dotnet/coreclr","RelatedBody":"CC. @GrabYourPitchforks, @stephentoub \r\n\r\nCan't modify the value of `c` in place, because it is checked for equality to decimal point on L129"},{"Id":"8578163673","Type":"PullRequestEvent","CreatedAt":"2018-11-13T03:31:18","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/20962","RelatedDescription":"Merged pull request \"Exclude failing System.Memory.Tests on Linux/arm and Linux/arm64\" (#20962) at dotnet/coreclr","RelatedBody":"**Tracking issue:** #20958"},{"Id":"8578058883","Type":"PullRequestEvent","CreatedAt":"2018-11-13T03:00:46","Actor":"cshung","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/20960","RelatedDescription":"Merged pull request \"Passing the CONTEXT in ICorDebugManagedCallback4::DataBreakpoint\" (#20960) at dotnet/coreclr","RelatedBody":""},{"Id":"8577675904","Type":"PullRequestEvent","CreatedAt":"2018-11-13T01:10:31","Actor":"erozenfeld","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/20964","RelatedDescription":"Opened pull request \"Fix for bug 20499.\" (#20964) at dotnet/coreclr","RelatedBody":"When the jit is copying a struct-typed return to the return local in a synchronous method on arm64,\r\nit ends up invoking an importer utility outside the importer, where impTreeLast is not set.\r\n\r\nThe call sequence is\r\nfgMorphBlocks --> gtNewTempAssign --> impAssignStruct --> impAssignStructPtr --> impAppendTree\r\n\r\nWhen impAssignStructPtr sees GT_COMMA src nodes, it unwraps them and inserts additional statements.\r\nThe fix is to pass an insertion point statement through this call chain to prevent impAssignStruct\r\nand impAssignStructPtr from calling impAppendTree outside of the importer."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"8578140604","Type":"IssuesEvent","CreatedAt":"2018-11-13T03:24:19","Actor":"peterhuene","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/10061","RelatedDescription":"Closed issue \"Copy local package dependencies on build.\" (#10061) at dotnet/cli","RelatedBody":"## Steps to reproduce\n\nCurrently, package dependencies are probed from the NuGet cache for the build output at runtime.  While there is a measurable performance gain for not copying the files, it inherently makes the build output not transferable from machine to machine, thus requiring users to first \"publish\" for all projects, even for projects where this is simply copying those dependencies locally.\n\nWith the intention being that the output of a build for most projects is copy-deployable (an additional publishing step to post-process the build output notwithstanding for certain project types), the NuGet dependencies should also be copied local like they would for today's \"publish\" operation.  As we start generating an executable by default for `Exe` (and soon `WinExe`) output type projects when built, I expect there to be more demand for being able to copy-deploy build outputs without an additional publishing step for projects that don't require one (say, a WPF or console application).\n\n1. `dotnet new console`\n2.  Add a package reference and use the package in the application.\n3. `dotnet build`\n\n## Expected  behavior\n\nThe build directory contains package dependencies locally.  For framework-dependent applications, this means all but the runtime package dependencies.\n\n## Actual behavior\n\nThe package dependencies are sourced from the NuGet cache.\n\n\n\n\n\n"},{"Id":"8577528154","Type":"PullRequestEvent","CreatedAt":"2018-11-13T00:25:49","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/10316","RelatedDescription":"Merged pull request \"Fixing the channel and branch name for 2.2.2xx\" (#10316) at dotnet/cli","RelatedBody":"@dsplaisted you should smile that this hurt us again."},{"Id":"8577487973","Type":"PullRequestEvent","CreatedAt":"2018-11-13T00:14:03","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/10317","RelatedDescription":"Opened pull request \"Update dependencies for dev16\" (#10317) at dotnet/cli","RelatedBody":""},{"Id":"8577370795","Type":"PullRequestEvent","CreatedAt":"2018-11-12T23:41:26","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/10316","RelatedDescription":"Opened pull request \"Fixing the channel and branch name for 2.2.2xx\" (#10316) at dotnet/cli","RelatedBody":"@dsplaisted you should smile that this hurt us again."}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"8567968192","Type":"IssuesEvent","CreatedAt":"2018-11-10T17:02:10","Actor":"bernd5","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/964","RelatedDescription":"Closed issue \"Why including everything into netstandard\" (#964) at dotnet/standard","RelatedBody":"Hello,\r\nwhy is net standard growing so much? Wouldn't it be better to provide new APIs via normal libraries?\r\nFor other platforms it becomes very hard to implement all changes in net standard.\r\n\r\nThe good thing is, that we have the coreFx repository which contains almost all standard APIs. But one problem is, that it has some strong (not documented) dependencies to the underlying runtime (e.g. RuntimeThread). Theres no indicator which says \"this type needs special runtime support\". For some types this is obvious, e.g. it's clear that Int32 can't be implemented by a value of \"Int32\". But for others not!\r\n\r\nTo implement net standard I would like to have two sets of APIs. One which needs special runtime Handling (like Delegate, Int32, String, Thread ...). And another one which has only non special APIs like Dicitionaries, Lists, Color (all types which can be implemented without any special runtime support)."},{"Id":"8567597502","Type":"PullRequestEvent","CreatedAt":"2018-11-10T13:16:22","Actor":"dotnet-maestro[bot]","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/965","RelatedDescription":"Merged pull request \"[Darc-Update] Update dependencies from build 20181109.22 of https://github.com/dotnet/arcade\" (#965) at dotnet/standard","RelatedBody":"This change updates the dependencies from https://github.com/dotnet/arcade to the following\n\n- Microsoft.AspNetCore.ApiVersioning - 1.0.0-beta.18559.22\n- symbols/Microsoft.AspNetCore.ApiVersioning.Swashbuckle.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.ApiCompat.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Arcade.Sdk.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Build.Tasks.Feed.2.2.0-beta.18559.22.symbols.nupkg - 2.2.0-beta.18559.22\n- symbols/Microsoft.DotNet.Build.Tasks.Packaging.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.CodeAnalysis.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Darc.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.DarcLib.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Deployment.Tasks.Links.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.AspNetCore.ApiVersioning.Analyzers.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.GenAPI.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Helix.Client.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Helix.JobSender.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Helix.Sdk.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Maestro.Client.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Maestro.Tasks.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SignCheck.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SignTool.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SwaggerGenerator.CmdLine.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SwaggerGenerator.MSBuild.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.GenFacades.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.XUnitExtensions.2.4.0-beta.18559.22.symbols.nupkg - 2.4.0-beta.18559.22\n- symbols/Microsoft.AspNetCore.ApiVersioning.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SwaggerGenerator.MSBuild - 1.0.0-beta.18559.22\n- Microsoft.AspNetCore.ApiVersioning.Analyzers - 1.0.0-beta.18559.22\n- Microsoft.AspNetCore.ApiVersioning.Swashbuckle - 1.0.0-beta.18559.22\n- Microsoft.DotNet.ApiCompat - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Build.Tasks.Feed - 2.2.0-beta.18559.22\n- Microsoft.DotNet.Build.Tasks.Packaging - 1.0.0-beta.18559.22\n- Microsoft.DotNet.CodeAnalysis - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Darc - 1.0.0-beta.18559.22\n- Microsoft.DotNet.DarcLib - 1.0.0-beta.18559.22\n- Microsoft.DotNet.XUnitExtensions - 2.4.0-beta.18559.22\n- Microsoft.DotNet.Deployment.Tasks.Links - 1.0.0-beta.18559.22\n- Microsoft.DotNet.GenFacades - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Helix.Client - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Helix.JobSender - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Helix.Sdk - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Maestro.Client - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Maestro.Tasks - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SignCheck - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SignTool - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SwaggerGenerator.CmdLine - 1.0.0-beta.18559.22\n- Microsoft.DotNet.GenAPI - 1.0.0-beta.18559.22"},{"Id":"8567575183","Type":"PullRequestEvent","CreatedAt":"2018-11-10T13:01:18","Actor":"dotnet-maestro[bot]","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/965","RelatedDescription":"Opened pull request \"[Darc-Update] Update dependencies from build 20181109.22 of https://github.com/dotnet/arcade\" (#965) at dotnet/standard","RelatedBody":"This change updates the dependencies from https://github.com/dotnet/arcade to the following\n\n- Microsoft.AspNetCore.ApiVersioning - 1.0.0-beta.18559.22\n- symbols/Microsoft.AspNetCore.ApiVersioning.Swashbuckle.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.ApiCompat.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Arcade.Sdk.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Build.Tasks.Feed.2.2.0-beta.18559.22.symbols.nupkg - 2.2.0-beta.18559.22\n- symbols/Microsoft.DotNet.Build.Tasks.Packaging.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.CodeAnalysis.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Darc.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.DarcLib.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Deployment.Tasks.Links.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.AspNetCore.ApiVersioning.Analyzers.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.GenAPI.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Helix.Client.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Helix.JobSender.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Helix.Sdk.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Maestro.Client.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.Maestro.Tasks.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SignCheck.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SignTool.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SwaggerGenerator.CmdLine.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.SwaggerGenerator.MSBuild.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.GenFacades.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- symbols/Microsoft.DotNet.XUnitExtensions.2.4.0-beta.18559.22.symbols.nupkg - 2.4.0-beta.18559.22\n- symbols/Microsoft.AspNetCore.ApiVersioning.1.0.0-beta.18559.22.symbols.nupkg - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SwaggerGenerator.MSBuild - 1.0.0-beta.18559.22\n- Microsoft.AspNetCore.ApiVersioning.Analyzers - 1.0.0-beta.18559.22\n- Microsoft.AspNetCore.ApiVersioning.Swashbuckle - 1.0.0-beta.18559.22\n- Microsoft.DotNet.ApiCompat - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Build.Tasks.Feed - 2.2.0-beta.18559.22\n- Microsoft.DotNet.Build.Tasks.Packaging - 1.0.0-beta.18559.22\n- Microsoft.DotNet.CodeAnalysis - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Darc - 1.0.0-beta.18559.22\n- Microsoft.DotNet.DarcLib - 1.0.0-beta.18559.22\n- Microsoft.DotNet.XUnitExtensions - 2.4.0-beta.18559.22\n- Microsoft.DotNet.Deployment.Tasks.Links - 1.0.0-beta.18559.22\n- Microsoft.DotNet.GenFacades - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Helix.Client - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Helix.JobSender - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Helix.Sdk - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Maestro.Client - 1.0.0-beta.18559.22\n- Microsoft.DotNet.Maestro.Tasks - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SignCheck - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SignTool - 1.0.0-beta.18559.22\n- Microsoft.DotNet.SwaggerGenerator.CmdLine - 1.0.0-beta.18559.22\n- Microsoft.DotNet.GenAPI - 1.0.0-beta.18559.22"},{"Id":"8567330842","Type":"IssuesEvent","CreatedAt":"2018-11-10T10:00:30","Actor":"bernd5","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/964","RelatedDescription":"Opened issue \"Why including everything into netstandard\" (#964) at dotnet/standard","RelatedBody":"Hello,\r\nwhy is net standard growing so much? Wouldn't it be better to provide new APIs via normal libraries?\r\nFor other platforms it becomes very hard to implement all changes in net standard.\r\n\r\nThe good thing is, that we have the coreFx repository which contains almost all standard APIs. But one problem is, that it has some strong (not documented) dependencies to the underlying runtime (e.g. RuntimeThread). Theres no indicator which says \"this type needs special runtime support\". For some types this is obvious, e.g. it's clear that Int32 can't be implemented by a value of \"Int32\". But for others not!\r\n\r\nTo implement net standard I would like to have two sets of APIs. One which needs special runtime Handling (like Delegate, Int32, String, Thread ...). And another one which has only non special APIs like Dicitionaries, Lists, Color (all types which can be implemented without any special runtime support)."},{"Id":"8566137211","Type":"PullRequestEvent","CreatedAt":"2018-11-09T22:29:25","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/963","RelatedDescription":"Merged pull request \"Add ISOWeek\" (#963) at dotnet/standard","RelatedBody":"This fixes #956 "},{"Id":"8566137198","Type":"IssuesEvent","CreatedAt":"2018-11-09T22:29:24","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/956","RelatedDescription":"Closed issue \"Include System.Globalization.ISOWeek\" (#956) at dotnet/standard","RelatedBody":"I'd like to propose the inclusion of the new `System.Globalization.ISOWeek` APIs, added in https://github.com/dotnet/corefx/pull/30386.\r\n\r\nI would consider these pretty fundamental APIs that would be useful on all the current .NET platforms.\r\n\r\nThe implementation doesn't have a lot of dependencies and could probably be (more or less) copied to other platforms.\r\n\r\n```patch\r\ndiff --git a/netstandard/ref/System.Globalization.cs b/netstandard/ref/System.Globalization.cs\r\nindex 995ce25..4214d5a 100644\r\n--- a/netstandard/ref/System.Globalization.cs\r\n+++ b/netstandard/ref/System.Globalization.cs\r\n@@ -446,6 +446,15 @@ namespace System.Globalization\r\n         public string GetUnicode(string ascii, int index) { throw null; }\r\n         public string GetUnicode(string ascii, int index, int count) { throw null; }\r\n     }\r\n+    public static partial class ISOWeek\r\n+    {\r\n+        public static int GetWeekOfYear(System.DateTime date) { throw null; }\r\n+        public static int GetWeeksInYear(int year) { throw null; }\r\n+        public static int GetYear(System.DateTime date) { throw null; }\r\n+        public static System.DateTime GetYearEnd(int year) { throw null; }\r\n+        public static System.DateTime GetYearStart(int year) { throw null; }\r\n+        public static System.DateTime ToDateTime(int year, int week, System.DayOfWeek dayOfWeek) { throw null; }\r\n+    }\r\n     public partial class JapaneseCalendar : System.Globalization.Calendar\r\n     {\r\n         public JapaneseCalendar() { }\r\n```"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"8578408613","Type":"PullRequestEvent","CreatedAt":"2018-11-13T04:52:37","Actor":"dreddy-work","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/33451","RelatedDescription":"Closed pull request \"System.Drawing.Desing.Primitives being removed from corefx repo and moved to winforms repo.\" (#33451) at dotnet/corefx","RelatedBody":"System.Drawing.Desing.Primitives is in corefx repo and is being referenced only by winforms. This assembly ( atleast the APIs that were ported under this assembly) belongs to winforms repo. This PR will remove this assembly from corefx repo and a subsequent PR from winforms repo will add this assembly ( or the sources into existing assemblies) there.\r\n\r\nThis assembly contains UITypeEditors and ToolboxItems. UITypeeditors belong to System.Windows.Forms.dll and ToolboxItembeelong to System.Windows.Forms.Design.dll as an empty implementation ( this class is expected to be referenced by only design ( build ) time only hence, empty implementations)."},{"Id":"8578399320","Type":"PullRequestEvent","CreatedAt":"2018-11-13T04:49:38","Actor":"dreddy-work","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/33451","RelatedDescription":"Opened pull request \"System.Drawing.Desing.Primitives being removed from corefx repo and moved to winforms repo.\" (#33451) at dotnet/corefx","RelatedBody":"System.Drawing.Desing.Primitives is in corefx repo and is being referenced only by winforms. This assembly ( atleast the APIs that were ported under this assembly) belongs to winforms repo. This PR will remove this assembly from corefx repo and a subsequent PR from winforms repo will add this assembly ( or the sources into existing assemblies) there.\r\n\r\nThis assembly contains UITypeEditors and ToolboxItems. UITypeeditors belong to System.Windows.Forms.dll and ToolboxItembeelong to System.Windows.Forms.Design.dll as an empty implementation ( this class is expected to be referenced by only design ( build ) time only hence, empty implementations)."},{"Id":"8578126641","Type":"PullRequestEvent","CreatedAt":"2018-11-13T03:20:04","Actor":"tannergooding","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/33447","RelatedDescription":"Closed pull request \"Removing the Utf8Parser and Utf8Formatter from System.Memory, now that it is in S.P.Corelib\" (#33447) at dotnet/corefx","RelatedBody":"This is the CoreFX side change to https://github.com/dotnet/coreclr/pull/20934"},{"Id":"8578125837","Type":"PullRequestEvent","CreatedAt":"2018-11-13T03:19:48","Actor":"tannergooding","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/33436","RelatedDescription":"Closed pull request \"Fixing the Math/MathF Min and Max tests\" (#33436) at dotnet/corefx","RelatedBody":"This is the CoreFX side to https://github.com/dotnet/coreclr/pull/20912 and will be required for the CoreCLR package update."},{"Id":"8578034972","Type":"PullRequestEvent","CreatedAt":"2018-11-13T02:54:12","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/33450","RelatedDescription":"Opened pull request \"Update CoreClr, CoreSetup to preview-27113-01, preview-27112-04, respectively (master)\" (#33450) at dotnet/corefx","RelatedBody":""},{"Id":"8577977562","Type":"IssuesEvent","CreatedAt":"2018-11-13T02:38:23","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/32665","RelatedDescription":"Closed issue \"Proposal: Implement IAsyncDisposable on various BCL types\" (#32665) at dotnet/corefx","RelatedBody":"Related to #32640.\r\n\r\nNow that we’re adding `System.IAsyncDisposable` to the core libraries, we also want to implement the interface on a variety of types that currently do or have the potential to do asynchronous work as part of their disposal.  This is primarily focused on `System.IO` types that might flush or otherwise perform I/O as part of their clean up (e.g. flushing a buffer), though it is not limited to such types.\r\n\r\nThe following types would all implement IAsyncDisposable, and all gain a public member:\r\n```C#\r\npublic ValueTask DisposeAsync();\r\n```\r\nwith it being virtual on all of the non-sealed classes:\r\n```C#\r\npublic virtual ValueTask DisposeAsync();\r\n```\r\n\r\n- **System.IO.Stream**.  Its `DisposeAsync` will do the equivalent of Task.Run(Dispose).  Then, our various `Stream`-derived types will provide a more specialized implementation where appropriate.  For example, `MemoryStream`’s `Dispose` is a nop, so we’ll make its `DisposeAsync` a nop as well (unless the instance is actually of a type derived from `MemoryStream`, in which case we’ll delegate to the base implementation).  Conversely, `FileStream`’s `Dispose` does a flush, so its `DisposeAsync` will do an asynchronous flush.\r\n- **System.IO.BinaryWriter**.  Its implementation will check to see whether the instance is a concrete `BinaryWriter` or something derived from it.  If concrete, the `DisposeAsync` will effectively be a copy of the synchronous `Dispose`, except using async equivalents on the underlying `Stream`, e.g. where the synchronous implementation calls `Flush` or `Dispose`/`Close`, the asynchronous implementation would use `FlushAsync`/`DisposeAsync`.  If instead the type is derived from `BinaryWriter`, the implementation will simply do the equivalent of `Task.Run(Dispose)`, so as to pick up whatever `Dispose` implementation the derived class is providing, and the derived class may then choose to override `DisposeAsync` to provide a better implementation if applicable (the core libraries don’t provide any derived types).\r\n- **System.IO.TextWriter**.  Its implementations will do the equivalent of `Task.Run(Dispose)`.  Derived implementations can then do something better if appropriate.  For example, we’ll override on `StreamWriter` to asynchronously flush.\r\n- **System.Threading.Timer**.  `Timer` currently provides two `Dispose` methods, `Dispose()` and `Dispose(WaitHandle)`, the latter of which not only stops the timer, but also signals the provided `WaitHandle` when the timer guarantees that no more callbacks associated with that timer will be invoked.  A caller can then block on this `WaitHandle` to know when it’s safe to progress with any state that `Timer` may have interacted with.  As such, we’ll provide an equivalent `DisposeAsync`, where the returned `ValueTask` will complete when the timer appropriately guarantees the same thing, allowing a caller to wait asynchronously instead of synchronously.\r\n- **System.Threading.CancellationTokenRegistration**.  `CancellationTokenRegistration.Dispose` does two things: it unregisters the callback, and then it blocks until the callback has completed if the callback is currently running.  `DisposeAsync` will do the same thing, but allow for that waiting to be done asynchronously rather than synchronously.\r\n\r\n**Open issues:**\r\n\r\n_BinaryReader/TextReader_. I listed `BinaryWriter` and `TextWriter`, but not `BinaryReader` and `TextReader`.  Do we want to implement `IAsyncDisposable` on those as well, as with their writing counterparts?  It’s rare for an implementation to actually need to do asynchronous work as part of closing a reader, as they generally don't need to flush.  We could add them now for completeness, or we could wait until there's a demonstrated need.\r\n\r\n_Stream.DisposeAsync_.  There are some unfortunate issues here.  I see three main options:\r\n1. Implement IAsyncDisposable as a public virtual.\r\n2. Don't implement the interface on Stream, but implement it on derived types.\r\n3. Don't implement it on any Stream, and just have callers use `FlushAsync` + `Dispose`.\r\n\r\n(2) isn't a very good for a few reasons:\r\n- To use `using` with an object, the compiler needs to be able to see statically that it implements `IDisposable`; similarly for `IAsyncDisposable` with `await using`.  It's very common to just have a `Stream` reference that you get handed from somewhere, and so even if the derived implementation implements the interface, you wouldn't be able to use `await using` with it as a Stream.\r\n- If a `BaseStream` implements the interface explicitly, then there's no good way for a `DerivedStream : BaseStream` to invoke the base stream's implementation in order to clean up any resources the base stream owned.\r\n- Call sites need to type test for `IAsyncDisposable` to know whether they can use `DisposeAsync` and then fall back to using `Dispose` if `DisposeAsync` isn't available.\r\n\r\n(1) is what I've implemented, but it has its own problems. First, when we add `DisposeAsync` to `Stream`, it has to invoke the existing `Dispose`, as otherwise when code started using `await using` with a stream instead of `using`, it wouldn't actually clean anything up until the owner of that stream released a new version that overrode the new method.  Second, since `Dispose` could be doing anything, including I/O, we don't want to synchronously block the caller who just asked to do work asynchronously, so `DisposeAsync` really needs to queue the call to `Dispose`.  Now, it's very common for a derived `Stream`'s `Dispose(bool)` override to do some cleanup and then call `base.Dispose(disposing)` in order to do whatever further cleanup work its base has (which may be an intermediary stream rather than `Stream` itself).  However, if you do that with `DisposeAsync` and get down to the base `Stream.DisposeAsync` method, you'll end up queueing a work item to invoke `Dispose`... this shouldn't hurt anything functionally, as `Dispose` is meant to be idempotent, but it's unnecessary work.  We could say \"if you derive directly from `Stream`, don't bother calling to `base.Dispose(disposing)\", but that doesn't work, either.  Consider a type like `FileStream`.  `FileStream` has its own cleanup to do, so it needs to override `DisposeAsync`.  However, what about an existing `MySpecializedFileStream` that derives from `FileStream` and overrides `Dispose` to cleanup additional stuff and then call to `FileStream`'s implementation. That `FileStream`-derived type won't have overridden `DisposeAsync` yet, which means `FileStream`'s `DisposeAsync` actually needs to type test whether the instance is a concrete `FileStream` or something derived, and if derived, it should just use `base.DisposeAsync()` instead of its async logic.  That then makes the `base` invocation problem transitive, as when `MySpecializedFileStream` goes to override `DisposeAsync`, if it calls `base.DisposeAsync()`, it'll end up going all the way down to `Stream.DisposeAsync`, which will queue a call to `Dispose`.\r\n\r\nThis makes me wonder whether we should just do (3).  But not implementing `IAsyncDisposable` on a type like `Stream` makes me question `IAsyncDisposable`.\r\n\r\nSimilar problems apply to `TextWriter` as well.\r\n\r\n**A few notes:**\r\n- **Shouldn’t every type that implements `IDisposable` also implement `IAsyncDisposable`?**  No.  The vast majority of IDisposable types do not perform asynchronous work as part of their disposal, with most dispose routines primarily focused on releasing native resources (often via calling Dispose on SafeHandles) and other such synchronous operations.  We only want to implement IAsyncDisposable when we know that the type has the strong potential to do asynchronous I/O that would otherwise force its synchronous Dispose to block or spin waiting for those operations to complete.\r\n- **Don’t we need a DisposeAsync(bool disposing)?**  No.  The synchronous pattern has this so that both Dispose and a finalizer can share a dispose implementation, with the former passing true and the latter passing false, and then the implementation generally not disposing other managed state in the case of it being a finalizer.  With DisposeAsync, the benefit of the method is to the caller being able to await for the disposal to complete rather than being blocked implicitly; this is not relevant to a finalizer, which will not wait for any such work, synchronously or asynchronously.\r\n"},{"Id":"8577827672","Type":"PullRequestEvent","CreatedAt":"2018-11-13T01:53:22","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/33415","RelatedDescription":"Merged pull request \"Add {Deflate\\GZip\\Brotli}Stream.DisposeAsync overrides\" (#33415) at dotnet/corefx","RelatedBody":"cc: @ahsonkhan, @viktorhofer\r\nContributes to #32665"},{"Id":"8577813449","Type":"PullRequestEvent","CreatedAt":"2018-11-13T01:49:06","Actor":"bartonjs","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/33381","RelatedDescription":"Merged pull request \"Add support for TLS 1.3 to .NET Core\" (#33381) at dotnet/corefx","RelatedBody":"* TLS 1.3 connections have been tested on Ubuntu 18.10 (OpenSSL 1.1.1).\r\n* There's no public version of Windows with TLS 1.3 enabled.\r\n* There's no public version of macOS with TLS 1.3 enabled out of the box.\r\n\r\nWhen making use of SslProtocols.None (system default) TLS 1.3 is already working on Ubuntu 18.10, this change mainly makes it so that EncryptionPolicy.None is better handled, and that we can restrict-to and report TLS 1.3."}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"8578510619","Type":"PullRequestEvent","CreatedAt":"2018-11-13T05:28:14","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6562","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#6562) at dotnet/corert","RelatedBody":""},{"Id":"8578509937","Type":"PullRequestEvent","CreatedAt":"2018-11-13T05:28:00","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6563","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6563) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @tannergooding"},{"Id":"8576926716","Type":"PullRequestEvent","CreatedAt":"2018-11-12T21:58:59","Actor":"morganbr","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6553","RelatedDescription":"Merged pull request \"wasm: add method reference for delegate parameters to pinvokes\" (#6553) at dotnet/corert","RelatedBody":"This change gets the delegate wrapper for the pinvoke added to the dependencies so the function is defined in the LLVM and not just declared.  This would resolve #6525 but, I think, it is subject to the same problem as #6415.  This is the stacktrace from the test included here which is similar:\r\n\r\n```\r\nexception thrown: abort() at jsStackTrace@http://localhost:6931/HelloWasm.js:1059:13\r\nstackTrace@http://localhost:6931/HelloWasm.js:1076:12\r\nabort@http://localhost:6931/HelloWasm.js:7982:44\r\n_abort@http://localhost:6931/HelloWasm.js:5751:7\r\n__Z6AssertPKcS0_jS0_@http://localhost:6931/HelloWasm.wasm:wasm-function[19635]:0x9d23da\r\n_RhGetCommonStubAddress@http://localhost:6931/HelloWasm.wasm:wasm-function[21362]:0xad0a87\r\n_S_P_CoreLib_System_Runtime_InteropServices_PInvokeMarshal__AllocateThunk@http://localhost:6931/HelloWasm.wasm:wasm-function[2087]:0x15cc1b\r\n_S_P_CoreLib_System_Runtime_CompilerServices_ConditionalWeakTable_2_CreateValueCallback_S_P_CoreLib_System_Delegate__S_P_CoreLib_System_Runtime_InteropServices_PInvokeMarshal_PInvokeDelegateThunk___InvokeOpenStaticThunk@http://localhost:6931/HelloWasm.wasm:wasm-function[2088]:0x15cf57\r\n_S_P_CoreLib_System_Runtime_CompilerServices_ConditionalWeakTable_2_CreateValueCallback_S_P_CoreLib_System_Delegate__S_P_CoreLib_System_Runtime_InteropServices_PInvokeMarshal_PInvokeDelegateThunk___Invoke@http://localhost:6931/HelloWasm.wasm:wasm-function[3097]:0x1c76e7\r\n_S_P_CoreLib_System_Runtime_CompilerServices_ConditionalWeakTable_2_S_P_CoreLib_System_Delegate__S_P_CoreLib_System_Runtime_InteropServices_PInvokeMarshal_PInvokeDelegateThunk___GetValueLocked@http://localhost:6931/HelloWasm.wasm:wasm-function[2091]:0x15d403\r\n_S_P_CoreLib_System_Runtime_CompilerServices_ConditionalWeakTable_2_S_P_CoreLib_System_Delegate__S_P_CoreLib_System_Runtime_InteropServices_PInvokeMarshal_PInvokeDelegateThunk___GetValue@http://localhost:6931/HelloWasm.wasm:wasm-function[2089]:0x15d173\r\n_S_P_CoreLib_System_Runtime_InteropServices_PInvokeMarshal__GetFunctionPointerForDelegate@http://localhost:6931/HelloWasm.wasm:wasm-function[1351]:0x117a5e\r\n_S_P_CoreLib_Internal_Runtime_CompilerHelpers_InteropHelpers__GetFunctionPointerForDelegate@http://localhost:6931/HelloWasm.wasm:wasm-function[1349]:0x11765d\r\n_HelloWasm_Program__emscripten_set_main_loop@http://localhost:6931/HelloWasm.wasm:wasm-function[682]:0xd8c04\r\n_HelloWasm_Program__TestRegisterOfNativeCallback@http://localhost:6931/HelloWasm.wasm:wasm-function[675]:0xd887f\r\n_HelloWasm_Program__Main@http://localhost:6931/HelloWasm.wasm:wasm-function[344]:0xb2eb0\r\n_HelloWasm__Module___MainMethodWrapper@http://localhost:6931/HelloWasm.wasm:wasm-function[338]:0xaf2f2\r\n_StartupCodeMain@http://localhost:6931/HelloWasm.wasm:wasm-function[327]:0xaee49\r\n___managed__Main@http://localhost:6931/HelloWasm.wasm:wasm-function[19633]:0x9d238d\r\n_main@http://localhost:6931/HelloWasm.wasm:wasm-function[21492]:0xad74c0\r\nModule._main@http://localhost:6931/HelloWasm.js:7546:10\r\ncallMain@http://localhost:6931/HelloWasm.js:7855:15\r\ndoRun@http://localhost:6931/HelloWasm.js:7913:42\r\nrun/<@http://localhost:6931/HelloWasm.js:7924:7\r\n```\r\n\r\n@morganbr this also gets me closer to creating a PR for #5842 as it removes the undefined function so if you think its worthwhile it could be merged, without the test?"},{"Id":"8576926702","Type":"IssuesEvent","CreatedAt":"2018-11-12T21:58:59","Actor":"morganbr","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/6525","RelatedDescription":"Closed issue \"wasm: undefined function when passing a delegate as a function pointer to an extern\" (#6525) at dotnet/corert","RelatedBody":"Add the following code to Program\r\n```\r\n    private static unsafe void ThreadTest()\r\n    {\r\n        int pThread = 0;\r\n        int attr = 0;\r\n        int arg = 0;\r\n\r\n        var t = pthread_create((IntPtr)(&pThread), (IntPtr)(&attr), a => ThreadStart(), (IntPtr)(&arg));\r\n    }\r\n\r\n    private static void ThreadStart()\r\n    {\r\n    }\r\n\r\n    internal unsafe delegate void ThreadStartFunc(void * arg);\r\n\r\n    [DllImport(\"*\")]\r\n    private static unsafe extern int pthread_create(IntPtr pThread, IntPtr attr, [MarshalAs(UnmanagedType.FunctionPtr)]ThreadStartFunc thread_start, IntPtr arg);\r\n```\r\n\r\nWhen it compiles it runs through `DelegateCreationInfo.Create` at https://github.com/dotnet/corert/blob/041f51cca806a68c4de777abe4cecfb845645aa2/src/ILCompiler.Compiler/src/Compiler/DelegateCreationInfo.cs#L276 and https://github.com/dotnet/corert/blob/041f51cca806a68c4de777abe4cecfb845645aa2/src/ILCompiler.Compiler/src/Compiler/DelegateCreationInfo.cs#L280-L283.  A symbol is emitted into the LLVM:\r\n\r\n```\r\n call void @S_P_CoreLib_System_Delegate__InitializeClosedInstance(i8* %7, i8* bitcast (void (i8*, i8*)* @\"<PInvokeDelegateWrapper>HelloWasm_Program_ThreadStartFunc__<ForwardNativeFunctionWrapper>HelloWasm_Program_ThreadStartFunc\" to i8*))\r\n```\r\nAnd this symbol is declared in LLVM as function:\r\n```\r\ndeclare void @\"<PInvokeDelegateWrapper>HelloWasm_Program_ThreadStartFunc__<ForwardNativeFunctionWrapper>HelloWasm_Program_ThreadStartFunc\"(i8*, i8*)\r\n```\r\nBut should it not be defined?\r\nAt compile time, for WASM=0, a warning is output:\r\n```\r\nwarning: undefined symbol: \r\n<PInvokeDelegateWrapper>HelloWasm_Program_ThreadStartFunc__<ForwardNativeFunctionWrapper>HelloWasm_Program_ThreadStartFunc\r\n```"},{"Id":"8575964497","Type":"PullRequestEvent","CreatedAt":"2018-11-12T18:52:47","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6563","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6563) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"8575922632","Type":"PullRequestEvent","CreatedAt":"2018-11-12T18:44:32","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6560","RelatedDescription":"Merged pull request \"Use System.Linq optimized for size\" (#6560) at dotnet/corert","RelatedBody":"The UapAot version of System.Linq is optimized for size and we should use that.\r\n\r\nShrinks the ASP.NET WebApi sample by 1.2 MB."},{"Id":"8575838956","Type":"PullRequestEvent","CreatedAt":"2018-11-12T18:28:34","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6562","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#6562) at dotnet/corert","RelatedBody":""},{"Id":"8575837354","Type":"PullRequestEvent","CreatedAt":"2018-11-12T18:28:17","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6561","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6561) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8575835410","Type":"PullRequestEvent","CreatedAt":"2018-11-12T18:27:56","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6558","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/corefx,coreclr\" (#6558) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/corefx,coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @tarekgh @ericstj @stephentoub"},{"Id":"8575817457","Type":"PullRequestEvent","CreatedAt":"2018-11-12T18:24:35","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6561","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6561) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8575563076","Type":"PullRequestEvent","CreatedAt":"2018-11-12T17:37:33","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6560","RelatedDescription":"Opened pull request \"Use System.Linq optimized for size\" (#6560) at dotnet/corert","RelatedBody":"The UapAot version of System.Linq is optimized for size and we should use that.\r\n\r\nShrinks the ASP.NET WebApi sample by 1.2 MB."},{"Id":"8575084961","Type":"PullRequestEvent","CreatedAt":"2018-11-12T16:22:31","Actor":"yowl","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/6514","RelatedDescription":"Closed pull request \"WIP: wasm:Enables Interop.GetRandomBytes for wasm\" (#6514) at dotnet/corert","RelatedBody":"@morganbr @MichalStrehovsky I've made this PR to enable `GetHashcode` for strings as it uses `Marvin.DefaultSeed` and hence `Interop.GetRandomBytes`.  However, I don't know where this should go as where I've put it I think is wrong as I believe this file `src/System.Private.CoreLib/shared/Interop/Unix/System.Native/Interop.GetRandomBytes.cs` is shared with Corefx/CoreCLR.  Where should this go?  Perhaps its not even necessary as the Unix implementation in `Interop.Libraries.SystemNative` may will be enough with a different `DllImport`?  If it is required could you comment on whether we can safely assume `sizeof(int)==4` in wasm?\r\n\r\nThanks"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"8578140621","Type":"PullRequestEvent","CreatedAt":"2018-11-13T03:24:19","Actor":"peterhuene","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/2646","RelatedDescription":"Merged pull request \"Implement copy-local of package dependencies for 3.0 targeted projects. \" (#2646) at dotnet/sdk","RelatedBody":"This PR implements some of the unification of the `dotnet build` and\r\n`dotnet publish` experiences.\r\n\r\nFor 3.0 targeted projects, `dotnet build` will now copy the package\r\ndependencies locally into the output directory instead of relying on the NuGet\r\ncache.  It behaves the same as `dotnet publish`, only copying what is not\r\nprovided by the shared frameworks.\r\n\r\nAdditionally, `dotnet publish` will now copy the build outputs rather than\r\nregenerating a deps file or resolving package dependencies, provided there are\r\nno package references excluded from publishing or packages are coming from a\r\nruntime store.\r\n\r\nThe `CopyLocalLockFileAssemblies` property can be set to `false` to revert to\r\nthe previous behavior for `dotnet build`.\r\n\r\nFixes dotnet/cli#10061.\r\nFixes #933.\r\n\r\n"},{"Id":"8578140608","Type":"IssuesEvent","CreatedAt":"2018-11-13T03:24:19","Actor":"peterhuene","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/933","RelatedDescription":"Closed issue \"Filtering CopyLocalLockFileAssemblies\" (#933) at dotnet/sdk","RelatedBody":"When you use CopyLocalLockFileAssemblies with a netcoreapp project, it copies shared framework assets too.\r\n\r\nWhile you can use publish instead to copy without those assemblies, there are circumstances where its more practical and efficient to just have the single build step. In particular pack is driven by build output not publish output. Consider the case where I want to flatten dependencies in a nupkg (e.g. as currently required to package msbuild tasks).\r\n\r\nOne way to address this would be to just have a flag to apply the same filtering as publish to CopyLocalLockFileAssemblies.\r\n\r\nAlternatively, I find myself wishing that I could just slap metadata on my package references to exclude their full closure from CopyLocal. ExcludeAssets=Runtime almost works, but if I have another sibling package that pulls in overlapping assets in its closure, they get re-included.\r\n\r\nIn the msbuild task scenario, I really want to say \"copy everything that is not in the closure of Microsoft.NETCore.App, Microsoft.Build.Framework, or Microsoft.Build.Utilities.Core\"\r\n\r\nI managed to get close enough to that with this workaround:\r\n\r\n``` XML  \r\n<PropertyGroup>\r\n  <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>\r\n</PropertyGroup>\r\n\r\n<ItemGroup>\r\n  <PackageReference Include=\"Microsoft.Build.Framework\" Version=\"15.1.548\" ExcludeAssets=\"Runtime\" />\r\n  <PackageReference Include=\"Microsoft.Build.Utilities.Core\" Version=\"15.1.548\" ExcludeAssets=\"Runtime\" />\r\n</ItemGroup>\r\n\r\n<!-- Remove files from copy local that would not be published as they are provided by the platform package -->\r\n<Target Name=\"FilterCopyLocal\" DependsOnTargets=\"RunResolvePublishAssemblies\" BeforeTargets=\"ResolveLockFileCopyLocalProjectDeps\">\r\n  <ItemGroup>\r\n    <_CopyLocalButNotPublished Include=\"@(AllCopyLocalItems)\" Exclude=\"@(ResolvedAssembliesToPublish)\" />\r\n    <AllCopyLocalItems Remove=\"@(_CopyLocalButNotPublished)\" />\r\n  </ItemGroup>\r\n</Target>\r\n```\r\n"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1055215025982398465","CreatedAt":"2018-10-24T21:50:41+00:00","UserScreenname":"dotnet","Text":"Bringing .NET application performance analysis to Linux https://t.co/jivjRwPVBM","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":108,"FavoriteCount":61,"RawContent":null},{"Id":"1054879096981704704","CreatedAt":"2018-10-23T23:35:50+00:00","UserScreenname":"dotnet","Text":".NET Core Source Code Analysis with Intel® VTune™ Amplifier https://t.co/2I1YLWYbKb","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":64,"FavoriteCount":27,"RawContent":null},{"Id":"1054829662738608128","CreatedAt":"2018-10-23T20:19:24+00:00","UserScreenname":"dotnet","Text":"Call For Participation: .NET and TypeScript at FOSDEM conference https://t.co/xjDh49lbko","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":18,"FavoriteCount":12,"RawContent":null}]}},"RunOn":"2018-11-13T05:30:30.6274541Z","RunDurationInMilliseconds":8163}