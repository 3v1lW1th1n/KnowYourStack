{"Data":{"Blog":{"FeedItems":[{"Title":"Migrating your existing .NET application to the cloud? Tell us about it!","PublishedOn":"2017-12-05T18:14:46+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Hi everyone! The .NET team is conducting a survey to learn more about your approach for moving existing .NET applications to the cloud.  The survey should take less than 5 minutes to complete. Take...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/12/05/migrating-your-existing-net-application-to-the-cloud-tell-us-about-it/","RawContent":null},{"Title":"Announcing the Windows Compatibility Pack for .NET Core","PublishedOn":"2017-11-17T04:59:32+00:00","CommentsCount":73,"FacebookCount":0,"Summary":"Porting existing code to .NET Core used to be quite hard because the available API set was very small. In .NET Core 2.0, we already made this much easier, thanks to .NET Standard 2.0. Today,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/","RawContent":null},{"Title":"UPDATE – Microservices and Docker containers: Architecture, Patterns and Development guidance (Updated for .NET Core 2.0)","PublishedOn":"2017-11-16T22:00:06+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published this eBook/guide and sample application offering guidance for architecting microservices and Docker containers based applications. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-microservices-and-docker-containers-architecture-patterns-and-development-guidance-updated-for-net-core-2-0/","RawContent":null},{"Title":"UPDATE – Web Applications with ASP.NET Core Architecture and Patterns guidance (Updated for ASP.NET Core 2)","PublishedOn":"2017-11-16T21:00:05+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published an eBook/Guide and sample application offering guidance named Architecting Modern Web Applications with ASP.NET Core and Microsoft Azure. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-web-applications-with-asp-net-core-architecture-and-patterns-guidance-updated-for-asp-net-core-2/","RawContent":null},{"Title":"Introducing Tensor for multi-dimensional Machine Learning and AI data","PublishedOn":"2017-11-15T22:00:18+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"Overview Tensor is an exchange type for homogenous multi-dimensional data for 1 to N dimensions. The motivation behind introducing Tensor&#60;T&#62; is to make it easy for Machine Learning library...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/introducing-tensor-for-multi-dimensional-machine-learning-and-ai-data/","RawContent":null},{"Title":"Introducing Nullable Reference Types in C#","PublishedOn":"2017-11-15T20:00:47+00:00","CommentsCount":234,"FacebookCount":0,"Summary":"Today we released a prototype of a C# feature called &#8220;nullable reference types&#8220;, which is intended to help you find and fix most of your null-related bugs before they blow up at runtime....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/","RawContent":null},{"Title":"Announcing F# support for .NET Core and .NET Standard projects in Visual Studio","PublishedOn":"2017-11-15T19:00:49+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"We&#8217;re pleased to announce that Visual Studio 2017 15.5 Preview 4 now supports F# projects targeting .NET Core, .NET Standard, and .NET Framework through the .NET Core SDK. Some of you have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/announcing-f-support-for-net-core-and-net-standard-projects-in-visual-studio/","RawContent":null},{"Title":"Welcome to C# 7.2 and Span","PublishedOn":"2017-11-15T19:00:26+00:00","CommentsCount":29,"FacebookCount":0,"Summary":"C# 7.2 is the latest point release of C#, and adds a number of small but useful features. All the features are described in wonderful detail in the docs. Start with the overview, What&#8217;s new in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/welcome-to-c-7-2-and-span/","RawContent":null},{"Title":".NET Core November 2017 Update","PublishedOn":"2017-11-15T05:25:23+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core November Update. This includes .NET Core 1.0.8, 1.1.5 and 2.0.1 and .NET Core SDK 1.1.5 and 2.0.3. Details regarding the security issues addressed by this release...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-core-november-2017-update/","RawContent":null},{"Title":".NET Framework November 2017 Security and Quality Rollup","PublishedOn":"2017-11-15T03:54:36+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Today, we are releasing the November 2017 Security and Quality Rollup. Security This release contains no new security updates. The most recent .NET security updates were shipped with the September...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-framework-november-2017-security-and-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6946829856","Type":"PullRequestEvent","CreatedAt":"2017-12-05T18:08:42","Actor":"heiligerdankgesang","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Opened pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"6934052963","Type":"PullRequestEvent","CreatedAt":"2017-12-02T15:19:09","Actor":"rprouse","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Opened pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"6872255902","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:01:26","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Merged pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6872252909","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:00:44","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Merged pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6868854916","Type":"PullRequestEvent","CreatedAt":"2017-11-17T09:04:03","Actor":"AndreyAkinshin","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Opened pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6816687850","Type":"IssuesEvent","CreatedAt":"2017-11-06T20:30:07","Actor":"Petermarcu","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Closed issue \"File system watcher crash\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."},{"Id":"6797468573","Type":"PullRequestEvent","CreatedAt":"2017-11-01T23:04:17","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Opened pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6948315401","Type":"IssuesEvent","CreatedAt":"2017-12-05T23:41:57","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/50","RelatedDescription":"Closed issue \".Net Core ARM32 SDK availability\" (#50) at dotnet/announcements","RelatedBody":"Referencing #29.\r\n\r\nWill it be possible to : \r\n\r\na) Provide ARM32 builds for the SDK at its current state\r\nor\r\nb) Provide links on how to build the .Net Core SDK for ARM32?\r\n\r\nThe thing is I am planning to use it in a virtual environnement, through proot + qemu-arm-static. This way I would be able to build and, more importantly, run unit tests on ARM32. Another thing I am planning to do is to setup a build environnement on i686 through virtualisation as qemu doesn't seem to be able to emulate x86_64 on i686 (but arm32 does seem to work well enough).\r\n\r\nThank you in advance.\r\n\r\nSergio\r\n\r\n"},{"Id":"6944555922","Type":"IssuesEvent","CreatedAt":"2017-12-05T10:46:06","Actor":"tioduke","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/50","RelatedDescription":"Opened issue \".Net Core ARM32 SDK availability\" (#50) at dotnet/announcements","RelatedBody":"Will it be possible to : \r\n\r\na) Provide ARM32 builds for the SDK at its current state\r\nor\r\nb) Provide links on how to build the .Net Core SDK for ARM32?\r\n\r\nThe thing is I am planning to use it in a virtual environnement, through proot + qemu-arm-static. This way I would be able to build and, more importantly, run unit tests on ARM32. Another thing I am planning to do is to setup a build environnement on i686 through virtualisation as qemu doesn't seem to be able to emulate x86_64 on i686 (but arm32 does seem to work well enough).\r\n\r\nThank you in advance.\r\n\r\nSergio\r\n\r\n"},{"Id":"6886438076","Type":"IssuesEvent","CreatedAt":"2017-11-21T19:28:57","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/49","RelatedDescription":"Opened issue \".NET Core Alpine Image Ready for Testing\" (#49) at dotnet/announcements","RelatedBody":"# .NET Core Alpine Image Ready for Testing\r\n\r\nAn [Alpine](https://hub.docker.com/_/alpine/)-based Docker image is now available for .NET Core. Alpine is much smaller than Debian, which we have used for the .NET Core base image to date. There have been many requests for an Alpine image. We are pleased to make it available. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image.\r\n\r\nWe have added two new images:\r\n\r\n- `2.1-runtime-alpine`\r\n- `2.1-runtime-deps-alpine`\r\n\r\nAlpine support is part of the .NET Core 2.1 release. .NET Core 2.1 images are currently provided at the [microsoft/dotnet-nightly](https://hub.docker.com/r/microsoft/dotnet-nightly/) repo, including the new Alpine images. .NET Core 2.1 images will be promoted to the [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) repo when .NET Core 2.1 is shipped as a Preview, expected to be early 2018.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet/dotnet-docker-nightly #500](https://github.com/dotnet/dotnet-docker-nightly/issues/500)\r\n\r\n## Details\r\n\r\n* [dotnet/dotnet-docker-nightly #480](https://github.com/dotnet/dotnet-docker-nightly/pull/480)\r\n* [dotnet/announcements #20](https://github.com/dotnet/announcements/issues/20)\r\n* [dotnet/dotnet-docker-samples #94](https://github.com/dotnet/dotnet-docker-samples/pull/94)\r\n\r\nThe primary goal of Alpine is very small deployments. We have been considering various design decisions to make .NET Core Alpine base images as small as possible to align with that. In this first iteration, we enabled [.NET Core 2.0 Globalization Invariant Mode](https://github.com/dotnet/announcements/issues/20) in order to reduce the default size of the image. This change reduced the image by ~30MB. You can see the reduction in size for .NET Core images relative to Debian in the following table.\r\n\r\n|2.1 Image|Debian|Alpine|\r\n|-----    |------|------|\r\n|`-deps`   |153MB (68MB compressed) |13.8 MB (6MB compressed)|\r\n|`-runtime`|222MB (96MB compressed) |82.5 (34MB compressed)|\r\n\r\nNote: The compressed size is what you will see in a [registry](https://hub.docker.com/r/microsoft/dotnet-nightly/tags/) and is the wire-size cost.\r\n\r\nWe are also considering saving more space by native-compiling fewer assemblies. .NET Core runtime assemblies are native-compiled with the [crossgen tool](https://github.com/dotnet/coreclr/blob/master/Documentation/building/crossgen.md) in the [Ready2Run format](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md). Native-compiled code delivers superior startup performance but at the cost of 2-3x larger files. We have the opportunity to compile less, skipping compiling assemblies in part or in whole. We believe that we can save at least another 10MB through compiling less without a material drop in performance. For scenarios that value size over startup or where wire cost is significant, it may be valuable to aggressively reduce the number/% of compilation.\r\n\r\nAlpine images are only available for .NET Core 2.1. At the current time, only Runtime images are available. We intend to offer SDK images at a later date.\r\n\r\nUse cases that cannot tolerate Globalization invariant mode can reset the `DOTNET_SYSTEM_GLOBALIZATION_INVARIANT` environment variable and install the ICU package. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image with and without Globalization Invariant Mode enabled.\r\n\r\n## Call to Action\r\n\r\nPlease test your workloads with the new Alpine image. In particular, we want to know if enabling .NET Core Globalization Invariant Mode is acceptable/appreciated.\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7011110033","Type":"PullRequestEvent","CreatedAt":"2017-12-20T03:31:53","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15581","RelatedDescription":"Merged pull request \"small ref around stack levels setting methods.\" (#15581) at dotnet/coreclr","RelatedBody":"If a getter is under a define, then the setter should be under the same define.\r\n\r\nMove `ComputeStackAlignment` where `GetStkAlign` is.\r\nThe same for `SetStkSizeBytes`.\r\n\r\nAlso change `_TARGET_X86_` to `!FEATURE_FIXED_OUT_ARGS` where we do stack settings."},{"Id":"7010865368","Type":"PullRequestEvent","CreatedAt":"2017-12-20T01:53:58","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15584","RelatedDescription":"Opened pull request \"fix jit_std::unordered_map::operator[]\" (#15584) at dotnet/coreclr","RelatedBody":"Because they are template methods they were not instantiated without users. But if you try to call it you will see compilation errors. The right variant is written for `insert`.\r\n\r\nFound during local experiments."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7010844710","Type":"IssuesEvent","CreatedAt":"2017-12-20T01:45:33","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/cli/issues/8267","RelatedDescription":"Reopened issue \"Add dotnet interactive similar to Azure CLI\" (#8267) at dotnet/cli","RelatedBody":"The Azure CLI has a great `interactive` mode allowing the user to have an intellisense like experience when using the tool. This is a great learning mode and would lend a way to further introduce an additional way to discover the capabilities and options in the cli.\r\n\r\nSee: https://docs.microsoft.com/en-us/cli/azure/interactive-azure-cli?view=azure-cli-latest\r\n\r\n![image](https://user-images.githubusercontent.com/7681382/34168406-725b9954-e4b2-11e7-9b65-fc155eb48288.png)\r\n\r\n@KathleenDollard @shanselman "},{"Id":"7010732305","Type":"PullRequestEvent","CreatedAt":"2017-12-20T01:01:54","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8268","RelatedDescription":"Merged pull request \"Insert NuGet Build 4.6.0-preview2-4745 into cli\" (#8268) at dotnet/cli","RelatedBody":"Insert NuGet Build 4.6.0-preview2-4745 into cli master branch"},{"Id":"7010261571","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:26:12","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/cli/pull/8229","RelatedDescription":null,"RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/2.1.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/2.1-20171213-080039\ngit reset --hard upstream/release/2.1\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/2.1-20171213-080039 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7010261389","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:26:09","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8229","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to release/2.1\" (#8229) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/2.1.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/2.1-20171213-080039\ngit reset --hard upstream/release/2.1\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/2.1-20171213-080039 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7010246927","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:22:17","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8224","RelatedDescription":"Closed pull request \"MSBuild 15.6.22 in release/2.1\" (#8224) at dotnet/cli","RelatedBody":""},{"Id":"7010187166","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:06:49","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8214","RelatedDescription":"Merged pull request \"Updating roslyn to a version with the vbcscompiler.\" (#8214) at dotnet/cli","RelatedBody":"\r\n"},{"Id":"7009995903","Type":"IssuesEvent","CreatedAt":"2017-12-19T21:20:26","Actor":"natemcmaster","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8271","RelatedDescription":"Opened issue \"Global CLI tools creates a zombie cmd.exe process when CTRL+C is pressed to exit\" (#8271) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n1. Download this sample build of dotnet-watch:\r\n[dotnet-watch.2.1.0-preview1-t000.nupkg.zip](https://github.com/dotnet/cli/files/1573279/dotnet-watch.2.1.0-preview1-t000.nupkg.zip)\r\n1. Create a nuget.config file (required until #8226 is fixed)\r\n```xml\r\n<configuration>\r\n  <packageSources>\r\n    <clear />\r\n    <add key=\"local\" value=\"./\" />\r\n  </packageSources>\r\n</configuration>\r\n```\r\n1. Install\r\n```\r\ndotnet install tool dotnet-watch --version 2.1.0-preview1-t000 --configfile ./NuGet.config\r\n```\r\n1. Create an app and run dotnet-watch\r\n```\r\ndotnet new console -o app\r\ncd app\r\ndotnet watch run\r\n```\r\n1. Press CTRL+C\r\n\r\n## Expected  behavior\r\nThis should force-quit the global CLI tool, including any parent processes.\r\n\r\n## Actual behavior\r\nThe cmd.exe process started to launch %USERPROFILE%/.dotnet/tools/dotnet-watch.cmd is orphaned.\r\n\r\nBefore CTRL+C:\r\n![image](https://user-images.githubusercontent.com/2696087/34179261-0b5f4950-e4bf-11e7-8714-0cc26b42e868.png)\r\n\r\nAfter:\r\n![image](https://user-images.githubusercontent.com/2696087/34179309-4338423c-e4bf-11e7-9056-d598e26c1ef5.png)\r\n\r\nThe \"Terminate batch job (Y/N) question appears, but I cannot give it a response because the parent dotnet.exe process died.\r\n\r\n![image](https://user-images.githubusercontent.com/2696087/34179279-2450b26e-e4bf-11e7-99e3-05c7b030eef9.png)\r\n\r\nProcess 22736 was orphaned\r\n\r\n## Environment data\r\nShell: Happens using Command Prompt, Powershell 5, or ConEmu + cmd or powershell.\r\n\r\n\r\n`dotnet --info` output:\r\n\r\n```\r\n.NET Command Line Tools (2.2.0-preview1-007796)\r\n\r\nProduct Information:\r\n Version:            2.2.0-preview1-007796\r\n Commit SHA-1 hash:  3ac579997c\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17025\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Users\\namc\\.dotnet\\x64\\sdk\\2.2.0-preview1-007796\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.1.0-preview1-26008-01\r\n  Build    : 0327161c32d0d6175914521e47d91df3db38ebb4\r\n\r\n```\r\n\r\n\r\ncc @wli3 @anurse\r\n\r\n"},{"Id":"7009941805","Type":"IssuesEvent","CreatedAt":"2017-12-19T21:07:13","Actor":"natemcmaster","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8270","RelatedDescription":"Opened issue \"Error message when the DotNetSettings.xml manifest is malformed is misleading\" (#8270) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nCreate a dotnet cli global tool with a manifest that doesn't match the expected schema.\r\nExample:\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<DotNetTool>\r\n  <Commands>\r\n    <Command Name=\"dotnet-dev-certs\" EntryPoint=\"dotnet-dev-certs.dll\" Runner=\"dotnet\" />\r\n  </Commands>\r\n</DotNetTool>\r\n```\r\nExecute `dotnet install tool` the tool package.\r\n\r\n## Expected  behavior\r\nError message should indicate that the DotNetSettings.xml manifest could not be read because it was expecting a \"DotnetCliTool\" as the root. element\r\n\r\n## Actual behavior\r\nThe deserializer throws and error that makes it appear as if the file is invalid XML. (Spent 15 minutes trying to figure out why the CLI thought my xml was invalid, only to realize it was just a naming thing.)\r\n\r\n```\r\nSystem.InvalidOperationException: There is an error in XML document (2, 2). ---> System.InvalidOperationException: <DotnetTool xmlns=''> was not expected.\r\n   at Microsoft.Xml.Serialization.GeneratedAssembly.XmlSerializationReaderDotNetCliTool.Read4_DotNetCliTool()\r\n   --- End of inner exception stack trace ---\r\n   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader, String encodingStyle, XmlDeserializationEvents events)\r\n   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader)\r\n   at Microsoft.DotNet.ToolPackage.ToolConfigurationDeserializer.Deserialize(String pathToXml)\r\n   at Microsoft.DotNet.ToolPackage.ToolPackageObtainer.GetConfiguration(String packageId, String packageVersion, DirectoryPath individualToolVersion)\r\n   at Microsoft.DotNet.ToolPackage.ToolPackageObtainer.ObtainAndReturnExecutablePath(String packageId, String packageVersion, Nullable`1 nugetconfig, String targetframework)\r\n   at Microsoft.DotNet.Tools.Install.Tool.InstallToolCommand.ObtainPackage(String packageId, String packageVersion, Nullable`1 configFile, String framework, DirectoryPath executablePackagePath)\r\n   at Microsoft.DotNet.Tools.Install.Tool.InstallToolCommand.Execute()\r\n   at Microsoft.DotNet.Cli.DotNetTopLevelCommandBase.RunCommand(String[] args)\r\n   at Microsoft.DotNet.Tools.Install.InstallCommand.Run(String[] args)\r\n   at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, ITelemetry telemetryClient)\r\n   at Microsoft.DotNet.Cli.Program.Main(String[] args)\r\n```\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n```\r\n.NET Command Line Tools (2.2.0-preview1-007796)\r\n\r\nProduct Information:\r\n Version:            2.2.0-preview1-007796\r\n Commit SHA-1 hash:  3ac579997c\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17025\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Users\\namc\\.dotnet\\x64\\sdk\\2.2.0-preview1-007796\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.1.0-preview1-26008-01\r\n  Build    : 0327161c32d0d6175914521e47d91df3db38ebb4\r\n\r\n```\r\n\r\ncc @wli3  - this is probably a low priority, but still worth noting that the error wasn't helpful in this case.\r\n\r\n\r\n\r\n\r\n"},{"Id":"7009464222","Type":"PullRequestEvent","CreatedAt":"2017-12-19T19:14:59","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8269","RelatedDescription":"Merged pull request \"Fixing the link to the developer guide\" (#8269) at dotnet/cli","RelatedBody":"Fixes https://github.com/dotnet/cli/issues/8256"},{"Id":"7009186876","Type":"PullRequestEvent","CreatedAt":"2017-12-19T18:11:22","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8266","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to release/2.1\" (#8266) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/2.1.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/2.1-20171219-080040\ngit reset --hard upstream/release/2.1\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/2.1-20171219-080040 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7010697151","Type":"IssuesEvent","CreatedAt":"2017-12-20T00:48:14","Actor":"breyed","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/609","RelatedDescription":"Opened issue \"NuGet links to out-of-date release notes\" (#609) at dotnet/standard","RelatedBody":"The \"Release Notes\" section of the [NETStandard.Library](https://www.nuget.org/packages/NETStandard.Library/) NuGet page links to [release notes for an old prerelease](https://github.com/dotnet/core/blob/master/release-notes/1.1/1.1.0-preview1.md). Since the Release Notes section is version independent, it would be better to back the link up to the `release-notes` folder.\r\n\r\nA related issue is #171, which mentions the link, but focuses on the .NET Core vs. .NET Standard distinction."},{"Id":"7009282816","Type":"IssuesEvent","CreatedAt":"2017-12-19T18:33:37","Actor":"diddledan","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/608","RelatedDescription":"Opened issue \"Proposal: add GetEnvironmentVariableAsBool to netstandard\" (#608) at dotnet/standard","RelatedBody":"Currently the dotnet cli has a function which is located at: [src/Microsoft.DotNet.Cli.Utils/EnvironmentProvider.cs Line 106](https://github.com/dotnet/cli/blob/fffe3142ad8043743d83885df2166fd2f80dceca/src/Microsoft.DotNet.Cli.Utils/EnvironmentProvider.cs#L106)\r\n\r\nI think it would be useful to consider this functionality for inclusion into the `System.Environment` namespace.\r\n\r\nThis issue is to raise the idea and garner discussion. I do not believe it would conflict with anything already present, though I've not performed a thorough examination to prove it."},{"Id":"7004949994","Type":"IssuesEvent","CreatedAt":"2017-12-18T23:09:41","Actor":"jnm2","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/601","RelatedDescription":"Closed issue \"Understanding NETStandard.Library as a dependancy in my nuspec\" (#601) at dotnet/standard","RelatedBody":"Should a NETStandard.Library dependency appear in a nuspec?\r\n\r\nWhat does it do to projects that reference the nupkg versus not having it in the nuspec? If my netstandard1.6 library chooses to depend on 1.6.1, doesn't that force any dependent library to also depend on 1.6.1+? Is that a good thing and is that why you'd put it in a nuspec?\r\n\r\nOut of 1.6.0, 1.6.1, 2.0.0, and 2.0.1, the SDK picks 1.6.1 and 2.0.0 to reference for netstandard1.6 and netstandard2.0. Why not 2.0.1 for both?\r\n\r\nIs there a changelog that summarizes the differences in 1.6.1, 2.0.0 and 2.0.1?\r\n\r\nAre there docs that answer these questions? This is the only information I've been able to glean so far which hints that keeping it in the nuspec is correct, but it doesn't answer any of my other questions: \r\n![image](https://user-images.githubusercontent.com/8040367/33782541-21670bc0-dc27-11e7-9071-ac023a71c840.png)\r\n(https://docs.microsoft.com/en-us/nuget/guides/create-net-standard-packages-vs2017#package-the-component)\r\n"},{"Id":"7003958208","Type":"PullRequestEvent","CreatedAt":"2017-12-18T19:06:54","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/pull/444","RelatedDescription":"Closed pull request \"System.DirectoryServices* are scheduled for .net core 2.1 not .net core 2.0\" (#444) at dotnet/standard","RelatedBody":"According to issue [#2089](https://github.com/dotnet/corefx/issues/2089) System.DirectoryServices* won't make it to .netcore before 2.1.\r\n\r\nThis affects also [.NET API Browser](https://docs.microsoft.com/de-de/dotnet/api/system.directoryservices.accountmanagement?view=netcore-2.0) which states .NET Core 2.0 support for System.DirectoryServices*."},{"Id":"6996389704","Type":"IssuesEvent","CreatedAt":"2017-12-16T00:15:25","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/505","RelatedDescription":"Closed issue \"Lots of conflicts when a project references both netstandard1.6 and netstandard2.0 projects\" (#505) at dotnet/standard","RelatedBody":"We have a classic WebApi .NET Framework project that references projects that is either netstandard1.6 and netstandard2.0.\r\n\r\nSome of our core projects uses EF Core 2.0 (which uses netstandard 2.0), while the Microsoft.AspNet.OData library references netstandard1.6. But this genereates lots of conflicts warnings on assemblies within these standards when building like these (there are more warnings than these):\r\n\r\n```\r\n1>          Encountered conflict between 'Reference:C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\\netstandard.library\\2.0.0\\build\\netstandard2.0\\\\ref\\System.AppContext.dll' and 'Reference:C:\\Users\\<user>\\.nuget\\packages\\system.appcontext\\4.1.0\\ref\\netstandard1.6\\System.AppContext.dll'.  Choosing 'Reference:C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\\netstandard.library\\2.0.0\\build\\netstandard2.0\\\\ref\\System.AppContext.dll' because AssemblyVersion '4.1.2.0' is greater than '4.1.0.0'.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\microsoft.win32.registry\\4.0.0\\runtimes\\unix\\lib\\netstandard1.3\\Microsoft.Win32.Registry.dll' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\microsoft.win32.registry\\4.0.0\\runtimes\\win\\lib\\netstandard1.3\\Microsoft.Win32.Registry.dll'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.fedora.23-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\fedora.23-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.fedora.24-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\fedora.24-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.opensuse.13.2-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\opensuse.13.2-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.opensuse.42.1-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\opensuse.42.1-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.rhel.7-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\rhel.7-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.ubuntu.14.04-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\ubuntu.14.04-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.ubuntu.16.04-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\ubuntu.16.04-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.debian.8-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\debian.8-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\runtime.ubuntu.16.10-x64.runtime.native.system.security.cryptography.openssl\\4.3.0\\runtimes\\ubuntu.16.10-x64\\native\\System.Security.Cryptography.Native.OpenSsl.so'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\system.diagnostics.process\\4.1.0\\runtimes\\linux\\lib\\netstandard1.4\\System.Diagnostics.Process.dll' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\system.diagnostics.process\\4.1.0\\runtimes\\osx\\lib\\netstandard1.4\\System.Diagnostics.Process.dll'.  Could not determine winner due to equal file and assembly versions.\r\n1>          Encountered conflict between 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\system.diagnostics.process\\4.1.0\\runtimes\\linux\\lib\\netstandard1.4\\System.Diagnostics.Process.dll' and 'Runtime:C:\\Users\\<user>\\.nuget\\packages\\system.diagnostics.process\\4.1.0\\runtimes\\win\\lib\\netstandard1.4\\System.Diagnostics.Process.dll'.  Could not determine winner due to equal file and assembly versions.\r\n\r\n```\r\n\r\nWhat impact does these have? \r\n\r\nI thought that the idea with these standards was that they should be backward compatible? There shouldn't be any warnings for this at all. \r\n\r\nI find the whole standard thing very non-standard compatible, this is one of the problems I have mixing projects that uses different standards. So it is quite frustrating now."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7011280552","Type":"PullRequestEvent","CreatedAt":"2017-12-20T04:50:25","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25996","RelatedDescription":"Opened pull request \"Remove ErrorType and dependant paths from Microsoft.CSharp\" (#25996) at dotnet/corefx","RelatedBody":"* Remove `ErrAppendMethodParentSym`'s `substMethTyParams` parameter\r\n\r\nOnly ever set to null.\r\n\r\n* Remove `ErrAppendMethodParentSym`\r\n\r\nJust calls into `ErrAppendParentSym` now, so just use that.\r\n\r\n* Remove `UserStringBuilder` handling of `ErrorType`\r\n\r\n`ErrorType` can never reach here.\r\n\r\n* Remove `MethodOrPropertySymbol.errExpImpl`\r\n\r\nOnly ever set to null.\r\n\r\n* Don't replace unfixed type parameters with `ErrorType`\r\n\r\nJust used to test for presence and compare counts. We can do that with the null. They never escape further.\r\n\r\n* Don't use `ErrorType` as dummy type in `ExprMemberGroup`\r\n\r\nIf left null it will still work as a dummy type for conversions, and still won't be iterated past in the method iterator.\r\n\r\n* Remove `ErrorType`\r\n\r\nNow never created.\r\n\r\nThis makes a lot of unreachable paths more obviously unreachable:\r\n\r\n* Remove `CType.SetErrors()`, `InitFromParent()` & `HasErrors()`\r\n\r\n`HasErrors` is always false.\r\n\r\n* Remove path for `CreateBinopForPredefMethodCall` not finding method.\r\n\r\nCan never happen in running dynamic code.\r\n\r\n* Remove path for `CreateUnaryOpForPredefMethodCall` not finding method.\r\n\r\nCan never happen in running dynamic code.\r\n\r\n* Remove path for `expr.Type == null` in `CantConvert`\r\n\r\nCan only happen with `ExprList`, and we never try to convert those. Change to returning exception so calls are obviously an exit point.\r\n\r\n* Remove path in `mustCastCore` for null `dest`\r\n\r\n`dest` can never be null\r\n\r\nThe paths by which `dest` is set are as follows:\r\n\r\n```\r\nmustCastCore\r\n    GenerateAssignmentConversion (op2.Type)\r\n        BindAssignment (op2)\r\n            RuntimeBinder.BindAssigment (creates in CreateArgumentEXPR)\r\n    BindUDConversionCore (pTypeDestination)\r\n        BindUDConversionCore (pTypeDestination)\r\n            bindUserDefinedConversion (typeDst) returns false if this is null\r\n    bindUserDefinedConversion (as above)\r\n    BindUDConversionCore (as above)\r\n    mustCast\r\n        BindEnumUnaOp (creates type)\r\n        BindStandardUnaryOperator (from uofs.GetType(), can never be null)\r\n        BindLiftedEnumArithmeticBinOp (creates type)\r\n        BindLiftedUDBinop (creates type)\r\n        BindLiftedUDUnop (creates type)\r\n        BindNonliftedIncOp (arg.Type)\r\n            BindIncOp\r\n                BindStandardUnaryOperator\r\n                    BindStandardUnaryOperator (recurses with cast)\r\n                    BindUnaryOperation (creates in CreateArgumentEXPR)\r\n        BindNubConversion (nubDst, selected after type check)\r\n        BindEnumBinOp (creates)\r\n        BindLiftedStandardBinOp (creates)\r\n        BindLiftedStandardUnop (selected after type check)\r\n        BindBoolBitwiseOp (creates)\r\n        mustCastInUncheckedContext\r\n            BindEnumUnaOp (selected after type check)\r\n            BindLiftedEnumArithmeticBinOp (creates)\r\n            LScalar (already accessed member, so would throw)\r\n        BindImplicitConversion (returnType, cannot be null)\r\n        mustCast (overload)\r\n            bindUserDefinedConversion (above)\r\n            BindNubConversion (creates)\r\n            BindLiftedUDUnop (above)\r\n                bindUserDefinedConversion (creates)\r\n            BindLiftedUDBinop (creates)\r\n            BindLiftedIncOp (selected based on this parameter)\r\n            BindStandardUnaryOperator (above)\r\n            bindUserDefinedConversion (creates)\r\n            LiftArgument (within check on type)\r\n            CreateLocal (creates)\r\n            BindExplicitConversion (creates)\r\n```\r\n\r\n* Remove `Expr.SetError`\r\n\r\nOnly called if another `Expr` has it set, and hence never.\r\n\r\n* Remove `Expr.IsOK`\r\n\r\nAlways true\r\n\r\n* Remove `EXPRExtensions.isCONSTANT_OK`\r\n\r\nWithout `IsOK` to check this can just be a type check.\r\n\r\n* Remove `BindCallFailedOverloadResolution`\r\n\r\n`BindMethodGroupToArguments` will call `BindToMethod`, which will call `CreateCall` which calls the `ExprCall` constructor, so outside of paths that throw it can never not return an `ExprCall`, so the null check will never succeed."},{"Id":"7010827071","Type":"IssuesEvent","CreatedAt":"2017-12-20T01:38:37","Actor":"caesar1995","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/20294","RelatedDescription":"Closed issue \"[HttpListener] [porting] HttpListenerRequest.ContentLength64 can be overriden from Request.Headers but can't be with netfx\" (#20294) at dotnet/corefx","RelatedBody":"Following tests pass with netfx but are disabled for netcoreapp:\r\n```cs\r\n  [ConditionalTheory(nameof(PlatformDetection) + \".\" + nameof(PlatformDetection.IsNotOneCoreUAP))]\r\n  [InlineData(100)]\r\n  [InlineData(\"-100\")]\r\n  [InlineData(\"\")]\r\n  [InlineData(\"abc\")]\r\n  [InlineData(\"9223372036854775808\")]\r\n  [ActiveIssue(123, TargetFrameworkMonikers.Netcoreapp)]\r\n  public async Task ContentLength_ManuallySetInHeaders_ReturnsExpected(string newValue)\r\n  {\r\n      await GetRequest(\"POST\", null, new string[] { \"Content-Length: 1\" }, (_, request) =>\r\n      {\r\n          Assert.Equal(\"1\", request.Headers[\"Content-Length\"]);\r\n\r\n          request.Headers.Set(\"Content-Length\", newValue);\r\n          Assert.Equal(newValue, request.Headers[\"Content-Length\"]);\r\n          Assert.Equal(1, request.ContentLength64);\r\n\r\n          Assert.True(request.HasEntityBody);\r\n      }, content: \"\\r\\n\");\r\n  }\r\n\r\n  [ConditionalFact(nameof(PlatformDetection) + \".\" + nameof(PlatformDetection.IsNotOneCoreUAP))]\r\n  [ActiveIssue(123, TargetFrameworkMonikers.Netcoreapp)]\r\n  public async Task ContentLength_ManuallyRemovedFromHeaders_DoesNotAffect()\r\n  {\r\n      await GetRequest(\"POST\", null, new string[] { \"Content-Length: 1\" }, (_, request) =>\r\n      {\r\n          Assert.Equal(\"1\", request.Headers[\"Content-Length\"]);\r\n\r\n          request.Headers.Remove(\"Content-Length\");\r\n          Assert.Equal(1, request.ContentLength64);\r\n\r\n          Assert.True(request.HasEntityBody);\r\n      }, content: \"\\r\\n\");\r\n  }\r\n```\r\n\r\nLooking at referencesource the code is exactly the same give or take some formatting."},{"Id":"7010374262","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:57:01","Actor":"rmkerr","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/25993","RelatedDescription":"Merged pull request \"Ensure System.Uri normalizes Unicode hosts when \"file://\" scheme is present\" (#25993) at dotnet/corefx","RelatedBody":"When parsing \"file:\" IRIs containing Unicode, the host and path must be normalized and the results copied over to the canonical IRI string. This fix ensures that always happens.\r\n\r\nThe issue occurs when three things align:\r\n• The URI has the scheme \"file\", and is followed two, or by four or more slashes\r\n• The URI begins with a symbol that is unreserved for URIs, but is reserved for DNS names.\r\n• The URI contains Unicode characters\r\n\r\nThis occurs because of an oversight in the normalization process. The strings that represent the URI are reduced to just the scheme, and are then built up to the canonical version based on the rules associated with that scheme, and on the contents of the remainder of the URI. For example the URI. http://abcd#123 Is reduced to the string http://, and the rules associated with http build the string up to the canonical version, http://abcd. In most cases, the code for file URIs with more than one slash is processed by the same code path that processes DNS IRIs. However, in the case that the authority was not valid for DNS IRIs (such as those beginning with an underscore), the processing would fall through to the code for processing UNC hosts. While UNC hosts are allowed to have Unicode, the code path failed to normalize the Unicode from the URI.\r\n\r\nThis process resulted in an invalid internal state for the URI. The internal string representing the canonical URI would only contain the scheme name, but the integer storing the index of the end of the authority would be set as it was before normalization. Later, a method would try to loop over the internal string until the end of the authority, and would cause an IndexOutOfRange exception.\r\n\r\nThis issue was reported in internal bug 95292."},{"Id":"7010211482","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:13:03","Actor":"wfurt","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/25976","RelatedDescription":"Merged pull request \"disable MulticastInterface_Set_AnyInterface_Succeeds \" (#25976) at dotnet/corefx","RelatedBody":"while investigating failures on Fedora 25, Redhat 7.2 and 7.3 (#24114)\r\nThey are probably caused by environment - packet filter rules as previous failures. \r\n\r\n"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7011335606","Type":"IssuesEvent","CreatedAt":"2017-12-20T05:16:42","Actor":"dpoeschl","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23013","RelatedDescription":"Closed issue \"Add option to change relative path of project builds.\" (#23013) at dotnet/roslyn","RelatedBody":"Please add this option in `Options/Projects and Solutions/Locations`\r\n\r\n - Project Builds Relative Path\r\n\r\ndefault value should be equal to `Projects location` option.\r\n\r\n**Notes to consider:**\r\n\r\nuser should not be able to specify exact build path of project. because it will cause collision on different projects. so if this path is specified for builds:\r\n\r\n`C:\\Project Builds`\r\n\r\nfinal path of each project will automatically resolve to\r\n\r\n`C:\\Project Builds\\[Project Name]\\[bin|obj|etc]`\r\n\r\n---\r\n\r\nI think my previous request #22978 was quite long so I decided to make it simple here. the compelling reason is there so please check it out. thank you.\r\n"},{"Id":"7011155026","Type":"IssuesEvent","CreatedAt":"2017-12-20T03:50:47","Actor":"dpoeschl","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23822","RelatedDescription":"Closed issue \"Refactoring suggestion: replace if-else with ternary operator\" (#23822) at dotnet/roslyn","RelatedBody":"like resharper, it would be nice to have suggestion to replace simple if-else assignments with ternary operators. \r\n\r\n    if(cond) x = i;\r\n    else x = j;\r\n\r\nwould be replaced by \r\n\r\n    x = cond ? i : j;\r\n\r\nits a cheap improvement for cheap but quite nice income."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7010277470","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:30:16","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5136","RelatedDescription":"Opened pull request \"Linux and OSX Package Publish Regression Fix\" (#5136) at dotnet/corert","RelatedBody":"Third time this issue has popped up, but this time in publishing, because of the roundabout way we generate meta-packages. \r\n\r\nThis adds details to the ILCompiler runtimes.json files and only builds the necessary packages during official builds - i.e. runtime packages and the TargetingPack, which was being built multiple times, even though CoreCLR only consumes the win-x64 build. \r\n\r\nI really don't like adding logic to the .builds files. This works as a temporary workaround to get packages published and working, but ideally we would copy CoreCLR's framework in making the package build and publishing selection logic generic for any additional packages."},{"Id":"7008576623","Type":"PullRequestEvent","CreatedAt":"2017-12-19T16:08:11","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5134","RelatedDescription":"Closed pull request \"Remove reflection test hack\" (#5134) at dotnet/corert","RelatedBody":"This was added in #3773 when we started resolving interface calls into direct calls and the line stopped ensuring the interface method is callable with reflection (since there was no visible interface call happening in retail builds). Now that the scanner computes reflectable closure, the hack is no longer needed."},{"Id":"7008508505","Type":"PullRequestEvent","CreatedAt":"2017-12-19T15:56:10","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5135","RelatedDescription":"Merged pull request \"Merge master to nmirror\" (#5135) at dotnet/corert","RelatedBody":""},{"Id":"7008507382","Type":"PullRequestEvent","CreatedAt":"2017-12-19T15:55:58","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5135","RelatedDescription":"Opened pull request \"Merge master to nmirror\" (#5135) at dotnet/corert","RelatedBody":""},{"Id":"7007804313","Type":"PullRequestEvent","CreatedAt":"2017-12-19T13:43:54","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5134","RelatedDescription":"Opened pull request \"Remove reflection test hack\" (#5134) at dotnet/corert","RelatedBody":"This was added in #3773 when we started resolving interface calls into direct calls and the line stopped ensuring the interface method is callable with reflection (since there was no visible interface call happening in retail builds). Now that the scanner computes reflectable closure, the hack is no longer needed."},{"Id":"7007509313","Type":"PullRequestEvent","CreatedAt":"2017-12-19T12:36:46","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5129","RelatedDescription":"Merged pull request \"Add AnalysisBasedMetadataManager\" (#5129) at dotnet/corert","RelatedBody":"(Split into several self-contained commits for reviewability.)\r\n\r\nThis is making progress towards a pluggable metadata generation strategy. After this change, we no longer compute reflection metadata twice in optimized builds (once during the scanning, the second time during the compilation). Instead, the scanner computes the full metadata closure, and the compilation phase uses it to drive code generation and metadata generation. We no longer suffer from the problems caused by things getting inlined and becoming no longer reflectable.\r\n\r\nThe general design goals were:\r\n\r\n* Support a mode where the reflectable closure is computed based on what got compiled. This has two flavors:\r\n  * The closure gets computed by the IL scanner (to provide a deterministic closure that doesn't depend on what things got optimized away)\r\n  * The closure gets computed based on what the codegen backend compiled. This is so that we can have unoptimized builds that don't depend on the IL scanner.\r\n* Support a mode where reflectable closure is provided by an external tool (e.g. the Project N dependency reducer).\r\n* Support a mode where nothing is reflectable. This is to compile things like mrt100_app.dll or to do experiments.\r\n* Support a mode where reflectable closure and the metadata blob are computed ahead of time (Project X).\r\n\r\nThe design relies on multiple metadata managers that the dependency nodes (such as `MethodCodeNode`, or `EETypeNode`) call into to get additional dependencies. Those dependencies depend on what the metadata manager is doing and can be limited to just ensuring we have invoke stubs (Project X), to ensuring we have custom attributes, metadata for owning type and module, etc.\r\n\r\nThe resulting class hierarchy is:\r\n* `MetadataManager` - the base class for everything; handling things that are common.\r\n  * `EmptyMetadataManager` - this one does nothing.\r\n  * `PrecomputedMetadataManager` - for Project X.\r\n  * `GeneratingMetadataManager` - a metadata manager that generates reflection metadata and invoke stubs\r\n    * `UsageBasedMetadataManager` - this one collects necessary metadata based on usage. It uses some supporting node types (like `TypeMetadataNode`) to track additional dependencies of the metadata itself. This enforces invariants like usable custom attribute metadata, metadata for containing types of nested types, etc.)\r\n    * `AnalysisBasedMetadataManager` - this one provides compilation roots based on the things that are required to be reflectable, and uses an ahead of time determined set of things that need metadata. This one can be produced from a `UsageBasedMetadataManager` (for the \"IL scanner before compilation\" scenario), or could be instantiated from data provided by an external tool.\r\n\r\nThere is more work left, but this seems like a reasonable checkpoint. Examples of leftover things is handling of fields (now that we have a scanner, we can have a \"precise\" mode for tracking reflection field usage instead of blanket policy that says all fields are reflectable; we'll still need to support the fallback logic for \"no scanner\" scenarios, but optimized scenarios can get some size on disk benefits)."},{"Id":"7005741078","Type":"PullRequestEvent","CreatedAt":"2017-12-19T04:12:01","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5133","RelatedDescription":"Opened pull request \"Package build\" (#5133) at dotnet/corert","RelatedBody":"This adds `build-packages` to the standard build command. \r\nUntil #4983 and #5123 CoreRT has only supported a single NuGet package, referencing projects directly, which wouldn't interfere with our build and publish pipeline (any build errors would show up earlier).\r\nHowever, with the ILCompiler (and others soon, hopefully) being added, the process to produce them would ideally be integrated into the overall build process.\r\nThis would mimic CoreCLR and CoreFX and correctly mark any failures in building NuGet packages\r\nas build failures. "},{"Id":"7005609723","Type":"PullRequestEvent","CreatedAt":"2017-12-19T03:15:13","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5132","RelatedDescription":"Merged pull request \"Package Build Fix: Add Project reference to meta package\" (#5132) at dotnet/corert","RelatedBody":"Fixes package build crashes due to \"runtime.json\" not being found.\r\n\r\n@jkotas  - turns out the ProjectReferences are what makes NuGet automatically generate a runtime.json file"},{"Id":"7005334752","Type":"PullRequestEvent","CreatedAt":"2017-12-19T01:27:56","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5132","RelatedDescription":"Opened pull request \"Add Project reference to meta package\" (#5132) at dotnet/corert","RelatedBody":"Fixes build crashes due to \"runtime.json\" not being found.\r\n\r\n@jkotas  - turns out the ProjectReferences are what makes NuGet automatically generate a runtime.json file"},{"Id":"7003406030","Type":"PullRequestEvent","CreatedAt":"2017-12-18T17:05:43","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5130","RelatedDescription":"Merged pull request \"Take System.Text.RegularExpressions from UAPAOT\" (#5130) at dotnet/corert","RelatedBody":"The netcore version relies on ILGenerator."},{"Id":"7002926971","Type":"PullRequestEvent","CreatedAt":"2017-12-18T15:37:43","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5131","RelatedDescription":"Opened pull request \"Inline access to non-GC static fields\" (#5131) at dotnet/corert","RelatedBody":"An alternate approach to what was attempted in #3962 (and dotnet/coreclr#12420), this time leveraging preexisting infrastructure in RyuJIT built for accessing RVA static fields. This is limited to non-GC statics, since that's what RyuJIT has.\r\n\r\nIt feels a bit more natural to how JitInterface is structured (e.g. RyuJIT is calling `initClass` to eliminate the need to do the cctor check in some cases). If this is something we would want to take further, the next steps would be:\r\n\r\n1. Update `initClass` to allow generating the inline cctor check (we currently call the ReadyToRun helper to get non-GC static base - this change doesn't affect that).\r\n2. Change `CORINFO_FIELD_INFO` - replace `CORINFO_CONST_LOOKUP fieldLookup` with `CORINFO_LOOKUP fieldLookup` so that we can also do this from shared code.\r\n3. Some updates to handle GC statics and thread statics that I haven't thought about too much yet.\r\n\r\nI don't have plans to do the next steps anytime soon though.\r\n\r\nThe changes to the generated code look like this:\r\n\r\n```csharp\r\ninternal class Program\r\n{\r\n    static int X;\r\n    static int Y;\r\n\r\n    private static int Main()\r\n    {\r\n        return X + Y;\r\n    }\r\n}\r\n```\r\n\r\nBefore:\r\n\r\n```asm\r\ncall        __GetNonGCStaticBase_repro_Program (07FF65ADE2FCCh)  \r\nmov         edx,dword ptr [rax]  \r\nadd         edx,dword ptr [rax+4]  \r\nmov         eax,edx  \r\n```\r\n\r\nAfter:\r\n\r\n```asm\r\nmov         eax,dword ptr [repro_Program::__NONGCSTATICS (07FF66540BBD8h)]  \r\nadd         eax,dword ptr [repro_Program::__NONGCSTATICS+4h (07FF66540BBDCh)]  \r\n```"},{"Id":"7001939953","Type":"PullRequestEvent","CreatedAt":"2017-12-18T12:12:08","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5130","RelatedDescription":"Opened pull request \"Take System.Text.RegularExpressions from UAPAOT\" (#5130) at dotnet/corert","RelatedBody":"The netcore version relies on ILGenerator."},{"Id":"7001911478","Type":"PullRequestEvent","CreatedAt":"2017-12-18T12:05:14","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5129","RelatedDescription":"Opened pull request \"Add AnalysisBasedMetadataManager\" (#5129) at dotnet/corert","RelatedBody":"(Split into several self-contained commits for reviewability.)\r\n\r\nThis is making progress towards a pluggable metadata generation strategy. After this change, we no longer compute reflection metadata twice in optimized builds (once during the scanning, the second time during the compilation). Instead, the scanner computes the full metadata closure, and the compilation phase uses it to drive code generation and metadata generation. We no longer suffer from the problems caused by things getting inlined and becoming no longer reflectable.\r\n\r\nThe general design goals were:\r\n\r\n* Support a mode where the reflectable closure is computed based on what got compiled. This has two flavors:\r\n  * The closure gets computed by the IL scanner (to provide a deterministic closure that doesn't depend on what things got optimized away)\r\n  * The closure gets computed based on what the codegen backend compiled. This is so that we can have unoptimized builds that don't depend on the IL scanner.\r\n* Support a mode where reflectable closure is provided by an external tool (e.g. the Project N dependency reducer).\r\n* Support a mode where nothing is reflectable. This is to compile things like mrt100_app.dll or to do experiments.\r\n* Support a mode where reflectable closure and the metadata blob are computed ahead of time (Project X).\r\n\r\nThe design relies on multiple metadata managers that the dependency nodes (such as `MethodCodeNode`, or `EETypeNode`) call into to get additional dependencies. Those dependencies depend on what the metadata manager is doing and can be limited to just ensuring we have invoke stubs (Project X), to ensuring we have custom attributes, metadata for owning type and module, etc.\r\n\r\nThe resulting class hierarchy is:\r\n* `MetadataManager` - the base class for everything; handling things that are common.\r\n  * `EmptyMetadataManager` - this one does nothing.\r\n  * `PrecomputedMetadataManager` - for Project X.\r\n  * `GeneratingMetadataManager` - a metadata manager that generates reflection metadata and invoke stubs\r\n    * `UsageBasedMetadataManager` - this one collects necessary metadata based on usage. It uses some supporting node types (like `TypeMetadataNode`) to track additional dependencies of the metadata itself. This enforces invariants like usable custom attribute metadata, metadata for containing types of nested types, etc.)\r\n    * `AnalysisBasedMetadataManager` - this one provides compilation roots based on the things that are required to be reflectable, and uses an ahead of time determined set of things that need metadata. This one can be produced from a `UsageBasedMetadataManager` (for the \"IL scanner before compilation\" scenario), or could be instantiated from data provided by an external tool.\r\n\r\nThere is more work left, but this seems like a reasonable checkpoint. Examples of leftover things is handling of fields (now that we have a scanner, we can have a \"precise\" mode for tracking reflection field usage instead of blanket policy that says all fields are reflectable; we'll still need to support the fallback logic for \"no scanner\" scenarios, but optimized scenarios can get some size on disk benefits)."},{"Id":"6999307249","Type":"PullRequestEvent","CreatedAt":"2017-12-17T17:02:26","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5121","RelatedDescription":"Merged pull request \"Update RyuJIT\" (#5121) at dotnet/corert","RelatedBody":"More complicated than usual. This picks up:\r\n\r\n* JitInterface changes\r\n* dotnet/coreclr#15475\r\n\r\nWhen Cbrt/Asinh/Acosh/Atanh is added, we'll want to uncomment the intrinsic recognition."}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7010210916","Type":"PullRequestEvent","CreatedAt":"2017-12-19T22:12:53","Actor":"nguerrera","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1827","RelatedDescription":"Merged pull request \"Merge release/2.1 to master\" (#1827) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.1 into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1-to-master-20171219-080047\ngit reset --hard upstream/master\ngit merge upstream/release/2.1\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1-to-master-20171219-080047 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7010070033","Type":"PullRequestEvent","CreatedAt":"2017-12-19T21:38:34","Actor":"wli3","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1830","RelatedDescription":"Opened pull request \"WIP Pack question\" (#1830) at dotnet/sdk","RelatedBody":"Use WIP PR to ask some questions, I feel it is easier that way"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"943234846079496192","CreatedAt":"2017-12-19T21:41:26+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz (@csharpfritz) in a little more than 2 hours for LIVE CODING. He's working on an @aspnet Core p… https://t.co/Xm2utapspg","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":23,"FavoriteCount":10,"RawContent":null},{"Id":"942039735144452097","CreatedAt":"2017-12-16T14:32:29+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz in 30 minutes for some LIVE CODING and answering your questions about .NET and Visual Studio.  https://t.co/UjBOoFqFp5","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":23,"FavoriteCount":18,"RawContent":null},{"Id":"941295101212549121","CreatedAt":"2017-12-14T13:13:35+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz at 10am ET for a LIVE CODING session.  He'll answer your questions about .NET, Visual Studio, a… https://t.co/qJHWFDaUGf","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":21,"FavoriteCount":14,"RawContent":null},{"Id":"935927507911524352","CreatedAt":"2017-11-29T17:44:41+00:00","UserScreenname":"dotnet","Text":"Who doesn’t? Purple. All. The. Things. https://t.co/65KzPWuvbK","Source":"<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>","RetweetCount":29,"FavoriteCount":4,"RawContent":null}]}},"RunOn":"2017-12-20T05:30:23.6050122Z","RunDurationInMilliseconds":8759}