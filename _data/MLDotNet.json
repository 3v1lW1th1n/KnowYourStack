{"Data":{"GitHub":{"Issues":[{"Id":"352327477","IsPullRequest":true,"CreatedAt":"2018-08-20T23:08:20","Actor":"danmosemsft","Number":"701","RawContent":null,"Title":"Add package tags","State":"open","Body":"Fix https://github.com/dotnet/machinelearning/issues/484\r\n\r\nAdd some tags to the nuget package to help us appear more prominently when searching for \"ML.NET\"\r\n\r\nWe can also add a custom title (see first commit) which apparently helps, but it is probably not a good idea, since as @eerhardt pointed out, one might expect to be able to add `<PackageReference Include=\"ML.NET\" />` if the title is `ML.NET`, but not the package ID.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/701","RelatedDescription":"Open PR \"Add package tags\" (#701)"},{"Id":"352317120","IsPullRequest":true,"CreatedAt":"2018-08-20T22:20:15","Actor":"eerhardt","Number":"700","RawContent":null,"Title":" Replace all ML.Transforms SubComponent usages with IComponentFactory.","State":"open","Body":"Working towards #585\r\n\r\nPlease ignore the first commit, it is being proposed separately as #698. I am using these new constructors in this PR, so I needed to include it.  If you have any comments regarding it directly, please put them on #698.\r\n\r\nThere are 2 \"hacks\" in this PR that I'm not proud of:\r\n\r\n1. `LearnerFeatureSelectionTransform` depends on `SDCA`, but `ML.Transforms` doesn't have a reference to `ML.StandardLearners`. I wasn't sure how to proceed here (add the dependency, or move some code around).  For now I continued to use Dependency Injection to create the component. Please give me your opinion on what the best approach forward would be.\r\n\r\n2. `RffTransform` has an undesirable coupling to which kind of MatrixGenerator it is using (gaussian or not). Previously, it was using the ComponentCatalog to determine which type of MatrixGenerator it was working with before actually creating it. However, I can no longer do that without actually creating the generator, so I needed to make a \"dummy\" instance. I spoke with @yaeldekel, and we decided this was \"OK\" for now, since it typically only used with a small number of columns (i.e. 1). I've logged #699 for this.","Url":"https://github.com/dotnet/machinelearning/pull/700","RelatedDescription":"Open PR \" Replace all ML.Transforms SubComponent usages with IComponentFactory.\" (#700)"},{"Id":"352317080","IsPullRequest":false,"CreatedAt":"2018-08-20T22:20:04","Actor":"eerhardt","Number":"699","RawContent":null,"Title":"RffTransform has undesirable coupling to its MatrixGenerator","State":"open","Body":"`RffTransform` has an undesirable coupling to which kind of MatrixGenerator it is using (gaussian or not). \r\n\r\nhttps://github.com/dotnet/machinelearning/blob/e77f24e68d92f033910a5d783576d1879763d979/src/Microsoft.ML.Transforms/RffTransform.cs#L421-L425\r\n\r\nIt is using the ComponentCatalog to determine which type of MatrixGenerator it was working with before actually creating it. And then depending on the Type, it is doing a different distance scaling algorithm.\r\n\r\nThis type of decision (which algorithm to use for distance scaling) should be done by the MatrixGenerator itself, and not necessarily decided by the RffTransform.\r\n\r\nI am changing RffTransform to no longer use SubComponent. However, I can no longer tell which type of MatrixGenerator is going to be created without actually creating the generator, so I needed to make a \"dummy\" instance. I spoke with @yaeldekel, and we decided this was \"OK\" for now, since it typically only used with a small number of columns (i.e. 1).\r\n\r\nWe should consider refactoring RffTransform and the IFourierDistributionSampler types to allow RffTransform to not have to switch based on whether Gaussian sampling is used or not.","Url":"https://github.com/dotnet/machinelearning/issues/699","RelatedDescription":"Open issue \"RffTransform has undesirable coupling to its MatrixGenerator\" (#699)"},{"Id":"352308659","IsPullRequest":true,"CreatedAt":"2018-08-20T21:48:32","Actor":"eerhardt","Number":"698","RawContent":null,"Title":"Add convenience constructors for TextLoader.","State":"open","Body":"Creating a TextLoader and specifying its arguments manually is too verbose. We should add a few constructor overloads to make it easier.\r\n\r\nThis work item is related to the new API proposal #371","Url":"https://github.com/dotnet/machinelearning/pull/698","RelatedDescription":"Open PR \"Add convenience constructors for TextLoader.\" (#698)"},{"Id":"352284689","IsPullRequest":false,"CreatedAt":"2018-08-20T20:29:34","Actor":"justinormont","Number":"697","RawContent":null,"Title":"Attribution of Wikipedia images","State":"open","Body":"Images in https://github.com/dotnet/machinelearning/tree/master/test/data/images/ need citations to their Wikipedia sources. \r\n\r\n![Banana](https://github.com/dotnet/machinelearning/blob/bdb742d3cc2bc273b18831e7e778f95a81e96a56/test/data/images/banana.jpg?raw=true)\r\n\r\nPerhaps listing in the [README.md](https://github.com/dotnet/machinelearning/blob/5e812d166d01d9cbd4c9ed16d4648041fbb7c83a/test/data/README.md) file? ","Url":"https://github.com/dotnet/machinelearning/issues/697","RelatedDescription":"Open issue \"Attribution of Wikipedia images\" (#697)"},{"Id":"350200569","IsPullRequest":true,"CreatedAt":"2018-08-20T19:52:10","Actor":"Ivanidzo4ka","Number":"677","RawContent":null,"Title":"Introduce examples for pipeline api.","State":"closed","Body":"examples for #584\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/677","RelatedDescription":"Closed or merged PR \"Introduce examples for pipeline api.\" (#677)"},{"Id":"352216279","IsPullRequest":false,"CreatedAt":"2018-08-20T16:53:01","Actor":"yaeldekel","Number":"696","RawContent":null,"Title":"Enable scoring of TensorFlow models in ML.NET","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/issues/696","RelatedDescription":"Open issue \"Enable scoring of TensorFlow models in ML.NET\" (#696)"},{"Id":"352215404","IsPullRequest":false,"CreatedAt":"2018-08-20T16:50:19","Actor":"yaeldekel","Number":"695","RawContent":null,"Title":"Enable scoring of ONNX models in ML.NET","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/issues/695","RelatedDescription":"Open issue \"Enable scoring of ONNX models in ML.NET\" (#695)"},{"Id":"351917460","IsPullRequest":false,"CreatedAt":"2018-08-19T16:53:11","Actor":"ArieJones","Number":"694","RawContent":null,"Title":"Confusion matrices didn't have enough matrices","State":"open","Body":"We are running into this error when we try to do a cross validation of a classifier.. \r\n```\r\nnew StochasticDualCoordinateAscentClassifier()\r\n                {\r\n                    Caching = CachingOptions.Memory,\r\n                    MaxIterations = 100,\r\n                    LossFunction = new SmoothedHingeLossSDCAClassificationLossFunction(),\r\n                    NumThreads = System.Environment.ProcessorCount - 1  //We use one less than the number of processors available\r\n                }\r\n\r\n```\r\nSystem.InvalidOperationException: 'Confusion matrices didn't have enough matrices.'\r\n\r\n\r\nThis seems to be thrown only at the very end.. because it seems to be rolling through just fine ..outputting the below on each iteration.. \r\n\r\n`Not training a calibrator because it is not needed.\r\nAutomatically adding a MinMax normalization transform, use 'norm=Warn' or 'norm=No' to turn this behavior off.\r\nUsing 3 threads to train.\r\nAutomatically choosing a check frequency of 3.\r\nAuto-tuning parameters: L2 = 8.341675E-05.\r\nAuto-tuning parameters: L1Threshold (L1/L2) = 1.\r\nUsing best model from iteration 33.`\r\n\r\n\r\nIs there something that we are doing incorrectly such as we need to specify the number of folds to use? \r\n\r\nThanks,\r\nAJ","Url":"https://github.com/dotnet/machinelearning/issues/694","RelatedDescription":"Open issue \"Confusion matrices didn't have enough matrices\" (#694)"},{"Id":"351880144","IsPullRequest":true,"CreatedAt":"2018-08-19T07:05:42","Actor":"codemzs","Number":"693","RawContent":null,"Title":"Replace DvDateTimeZone, DvDateTime, DvTimeSpan with .NET standard types.","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/pull/693","RelatedDescription":"Open PR \"Replace DvDateTimeZone, DvDateTime, DvTimeSpan with .NET standard types.\" (#693)"},{"Id":"351859667","IsPullRequest":true,"CreatedAt":"2018-08-18T23:24:26","Actor":"codemzs","Number":"692","RawContent":null,"Title":"Replace DvBool with .NET standard type.","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/pull/692","RelatedDescription":"Open PR \"Replace DvBool with .NET standard type.\" (#692)"},{"Id":"351777552","IsPullRequest":true,"CreatedAt":"2018-08-18T01:10:29","Actor":"briancylui","Number":"691","RawContent":null,"Title":"Port all relevant AVX hardware intrinsics C# APIs from SIMD native algorithms","State":"open","Body":"### What's new:\r\n1. Implemented all relevant AVX intrinsics, sharing the same software fallbacks previously implemented in `CpuMathUtils`\r\n2. Implemented unit tests in a way compatible with both AVX and SSE alignments, and both netcoreapp and netstandard\r\n2. Implemented separate performance tests for AVX and SSE intrinsics, except for those that accept `AlignedArray` as an argument\r\n3. Performance test results for all applicable AVX intrinsics are updated in https://github.com/briancylui/machinelearning/issues/1\r\n4. **Note:** This time, most AVX intrinsics with the `U` suffix are implemented from scratch and do not yet have support from [native code](https://github.com/dotnet/machinelearning/blob/b51d9f9060acfcbe84405ce37f9c045654573ee0/src/Native/CpuMathNative/Avx.cpp), which only contains their counterparts with the `X` suffix.\r\n\r\n\r\n### Description from https://github.com/dotnet/machinelearning/pull/668:\r\n1. Implemented all remaining active SSE intrinsics, including their software fallbacks and passing unit tests\r\n2. Implemented the performance tests of all remaining active SSE intrinsics, except for those that accept `AlignedArray` as an argument\r\n3. Performance test results for all applicable, active SSE intrinsics are updated in https://github.com/briancylui/machinelearning/issues/1\r\n\r\n### Description from https://github.com/dotnet/machinelearning/pull/562:\r\n- with unit tests and performance tests for two target frameworks: .NET Core App 3.0 and .NET Standard 2.0.\r\n- .NET Core App 3.0 gets the new C# hardware intrinsics APIs, while .NET Standard 2.0 gets the original native SIMD algorithms.\r\n- Several things have made this multi-targeting feature possible.\r\n   1. The new CpuMathUtils class that contains the new APIs is implemented as a partial class with method definitions split into two separate files (src\\Microsoft.ML.CpuMath\\CpuMathUtils.[target].cs), only one of which is compiled based on the target framework.\r\n   2. The Microsoft.ML.CpuMath.csproj file makes the switching decision to compile the right files based on the target framework.\r\n\r\n### Structure:\r\n1. All new hardware intrinsics APIs are contained in src\\Microsoft.ML.CpuMath.\r\n2. Unit tests for the two target frameworks live in test\\Microsoft.ML.CpuMath.UnitTests.[target], and contain the same content except for the target framework in .csproj.\r\n3. Performance tests live in test\\Microsoft.ML.CpuMath.PerformanceTests.\r\n\r\n### Changes to users:\r\n1. Originally, users call intrinsics APIs via the SseUtils class in src\\Microsoft.ML.CpuMath\\Sse.cs, but now they call them via the new CpuMathUtils class, which will handle switching between SSE and AVX in the future.\r\n2. CpuMathUtils methods and SseUtils methods share the same signature, but CpuMathUtils methods additionally call a new helper class (SseIntrinsics) for C# implementations of SSE operations.\r\n\r\n### Future follow-up for `CpuMath` enhancement\r\n1. Suggestions on `CpuMath` enhancement in this PR scheduled for future follow-ups have been compiled into an issue page (https://github.com/briancylui/machinelearning/issues/2).\r\n\r\ncc: @eerhardt @safern @tannergooding @danmosemsft ","Url":"https://github.com/dotnet/machinelearning/pull/691","RelatedDescription":"Open PR \"Port all relevant AVX hardware intrinsics C# APIs from SIMD native algorithms\" (#691)"},{"Id":"351762242","IsPullRequest":true,"CreatedAt":"2018-08-17T22:57:16","Actor":"eerhardt","Number":"690","RawContent":null,"Title":"Move to netcoreapp2.1","State":"open","Body":"Since .NET Core 2.0 is [getting to the end of its lifetime](https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/), we should upgrade our tests and build infrastructure to .NET Core 2.1.\r\n\r\nFYI - @TomFinley @codemzs @Ivanidzo4ka @Zruty0 ","Url":"https://github.com/dotnet/machinelearning/pull/690","RelatedDescription":"Open PR \"Move to netcoreapp2.1\" (#690)"},{"Id":"350992242","IsPullRequest":true,"CreatedAt":"2018-08-17T22:03:17","Actor":"eerhardt","Number":"681","RawContent":null,"Title":" Replace SubComponent with IComponentFactory in ML.Ensemble","State":"closed","Body":"The next round of SubComponent removal. Now the ML.Ensemble project is SubComponent free.\r\n\r\nWorking towards #585\r\n\r\nNote: I had to move the Argument class's fields down to the concrete class because of the way we handle `SignatureType`. You can use a generic type in an attribute.  However, this allowed me to remove the `TSig` type on the base classes, which is nice since the signature Type shouldn't be in the public API.","Url":"https://github.com/dotnet/machinelearning/pull/681","RelatedDescription":"Closed or merged PR \" Replace SubComponent with IComponentFactory in ML.Ensemble\" (#681)"},{"Id":"351703424","IsPullRequest":false,"CreatedAt":"2018-08-17T18:55:01","Actor":"eerhardt","Number":"689","RawContent":null,"Title":"Consider removing Sweeper, PipelineInference, and ResultProcessor assemblies from Microsoft.ML nuget","State":"open","Body":"We currently have a few assemblies in our `Microsoft.ML` nuget package that aren't part of what we want in our public API surface area.\r\n\r\nThese assemblies include:\r\n\r\n* Microsoft.ML.Maml\r\n* Microsoft.ML.ResultProcessor\r\n* Microsoft.ML.PipelineInference\r\n* Microsoft.ML.Sweeper\r\n\r\nThe last two may some day be part of our public API, but in their current form we don't want to expose them as public API.\r\n\r\nWe should remove these assemblies from our nuget package (maybe put them in a separate nuget package), so external users don't depend on these types. That way we are free to update the API until we are ready to ship it as an official API.\r\n\r\n/cc @Zruty0 @TomFinley ","Url":"https://github.com/dotnet/machinelearning/issues/689","RelatedDescription":"Open issue \"Consider removing Sweeper, PipelineInference, and ResultProcessor assemblies from Microsoft.ML nuget\" (#689)"},{"Id":"351674145","IsPullRequest":true,"CreatedAt":"2018-08-17T17:20:40","Actor":"Zruty0","Number":"688","RawContent":null,"Title":"API scenarios implementation with Estimators","State":"open","Body":"First version of a couple scenarios over Estimators","Url":"https://github.com/dotnet/machinelearning/pull/688","RelatedDescription":"Open PR \"API scenarios implementation with Estimators\" (#688)"},{"Id":"351668715","IsPullRequest":true,"CreatedAt":"2018-08-17T17:03:31","Actor":"Zruty0","Number":"687","RawContent":null,"Title":"API scenarios implemented with Estimators API","State":"closed","Body":"Added some Estimators-based scenarios and stopgap implementations of necessary components","Url":"https://github.com/dotnet/machinelearning/pull/687","RelatedDescription":"Closed or merged PR \"API scenarios implemented with Estimators API\" (#687)"},{"Id":"351625936","IsPullRequest":true,"CreatedAt":"2018-08-17T14:52:54","Actor":"Thomas-S-B","Number":"686","RawContent":null,"Title":"Simplified if-expression","State":"open","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [ ] There's a descriptive title that will make sense to other developers some time from now. \r\n- [ ] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/686","RelatedDescription":"Open PR \"Simplified if-expression\" (#686)"},{"Id":"351395002","IsPullRequest":false,"CreatedAt":"2018-08-16T22:48:03","Actor":"parag-patil","Number":"685","RawContent":null,"Title":"This is not issue - How can I get more learners/Algorithms?","State":"open","Body":"Hi Team,\r\n\r\nI am .NET developer and ML.NET is great start for me to learn Machine Learning.\r\n\r\nBeing .NET developer, I always wanted to do ML in .NET and find TensorFlow and other libraries difficult to understand on first glance.\r\n\r\nTo learn ML.NET, I am working on prediction model, best use case would be Stock prediction. As I can easily get historical data. \r\n\r\nI have following questions,\r\n\r\n1. What is the best algorithm in ML.NET for such use case? In TensorFlow and other libraries, I can see LSTM, Time Series Model and ARIMA etc...\r\n\r\n2.  How can I use one of the below in ML.NET? If available or what is alternative available?\r\n- ARIMA Model\r\n- Long Short Term Memory\r\n- Neural Net - Neural Network for prediction\r\n\r\n3. How can I use ML.NET for Neural Network? For above use case? I know below URL but I don't find proper use cases that will explain when to use which trainer.\r\nhttps://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers?view=ml-dotnet\r\n\r\n4. Rather than predicting single output value, how can I predict series of values i.e. stock prices for next weeks or month? \r\n\r\nI am very much interested in ML.NET but being newbie I don't know from where to start. Learning things by implementing is best way and that is why I have choose Stock Prediction.\r\n\r\nRegards,\r\nParag","Url":"https://github.com/dotnet/machinelearning/issues/685","RelatedDescription":"Open issue \"This is not issue - How can I get more learners/Algorithms?\" (#685)"},{"Id":"351316661","IsPullRequest":true,"CreatedAt":"2018-08-16T18:23:49","Actor":"ganik","Number":"684","RawContent":null,"Title":"HashTransform to handle Floats and Doubles","State":"open","Body":"closes issue #679 ","Url":"https://github.com/dotnet/machinelearning/pull/684","RelatedDescription":"Open PR \"HashTransform to handle Floats and Doubles\" (#684)"},{"Id":"351064227","IsPullRequest":true,"CreatedAt":"2018-08-16T05:50:57","Actor":"codemzs","Number":"683","RawContent":null,"Title":"Replace DvInt* with .NET standard data types.","State":"open","Body":"This change also removes missing value handling for sbyte, short, int and long because default of these values is a null and that does not fit well with sparse vector architecture where default for missing values is a zero. ","Url":"https://github.com/dotnet/machinelearning/pull/683","RelatedDescription":"Open PR \"Replace DvInt* with .NET standard data types.\" (#683)"},{"Id":"351006515","IsPullRequest":false,"CreatedAt":"2018-08-15T23:48:44","Actor":"eerhardt","Number":"682","RawContent":null,"Title":"Consider defaulting Ensemble Stacking to a trainer in StandardLearners","State":"open","Body":"See the conversation here: https://github.com/dotnet/machinelearning/pull/681#discussion_r210432412\r\n\r\nEnsemble Stacking defaults to using FastTree when users don't specify an underlying trainer. This results in a non-ideal dependency from `Microsoft.ML.Ensemble` to `Microsoft.ML.FastTree`, and would cause problems if we ever considered separating FastTree into its own NuGet package.\r\n\r\nWe should consider making a different default trainer under our Stacking use something in the StandardLearners assembly.\r\n\r\n/cc @TomFinley ","Url":"https://github.com/dotnet/machinelearning/issues/682","RelatedDescription":"Open issue \"Consider defaulting Ensemble Stacking to a trainer in StandardLearners\" (#682)"},{"Id":"350937028","IsPullRequest":false,"CreatedAt":"2018-08-15T19:34:12","Actor":"adamshakhabov","Number":"680","RawContent":null,"Title":"Predict similar scheme","State":"open","Body":"_Sorry for my English._\r\n\r\n### Dataset\r\n\r\nThere is dataset which contains files which describe scheme:\r\n\r\nsample #1.txt\r\n```\r\n3103686, 2590304, 2022230, 838696\r\n5530360, 1916721, 2022230, 430823\r\n3103686, 3807071, 2022230, 430823\r\n5705725, 4022485, 2022230, 975943\r\n8043677, 3697167, 2022230, 430823\r\n8043677, 2761756, 2022230, 430823\r\n```\r\n\r\nsample #2.txt\r\n```\r\n2994926, 3072910, 2022230, 1752477\r\n7396944, 3072911, 2022230, 1752476\r\n2994926, 1981531, 5573177, 558310\r\n\r\n```\r\nEach row is rectangle element (on scheme) feature vector (x, y, width, height).\r\n\r\n### Data to predict\r\n\r\nI need train a model which can predict for such input data\r\n\r\ninput.txt\r\n```\r\n3313321, 3259181, 2022230, 558310\r\n7039277, 3454335, 2022230, 558310\r\n5253403, 4207799, 2022231, 558310\r\n4073770, 2445894, 2022230, 558310\r\n6569923, 2445894, 2022230, 558310\r\n```\r\n\r\nsimilar scheme.\r\n\r\nFor example, in the above example for input.txt prediction would be quite if model say that sample #1 most similar for input scheme.\r\n\r\n### Question\r\n\r\nWhich algorithm from ML.NET should I use to solve my task? Of cause I do not expect complete solution, just put me right way.\r\nI have a little bit sub-questions to clarify my problem:\r\n\r\n- How preparing dataset to train: by feature describe or matrix?\r\n\r\n- Before some classifier should I clustering data?","Url":"https://github.com/dotnet/machinelearning/issues/680","RelatedDescription":"Open issue \"Predict similar scheme\" (#680)"},{"Id":"350284502","IsPullRequest":false,"CreatedAt":"2018-08-15T06:18:40","Actor":"MaxAkbar","Number":"678","RawContent":null,"Title":"Incremental Learning\\Training","State":"closed","Body":"Is there a possibility of adding incremental training a model?\r\n","Url":"https://github.com/dotnet/machinelearning/issues/678","RelatedDescription":"Closed issue \"Incremental Learning\\Training\" (#678)"},{"Id":"350526340","IsPullRequest":false,"CreatedAt":"2018-08-14T17:35:21","Actor":"ganik","Number":"679","RawContent":null,"Title":"CategoricalHashTransform should accept Floats and Doubles","State":"open","Body":"Currently CategoricalHashTransform accepts only Text or Key types.\r\n\r\nIf Double is passed in for ex, below error message is shown:\r\nError: *** System.ArgumentOutOfRangeException: 'Source column 'workclass1' has invalid type ('R8'): Expected Text or Key item type.\r\n\r\nIt would be good if it can accept numbers: Ints and Floats. \r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/679","RelatedDescription":"Open issue \"CategoricalHashTransform should accept Floats and Doubles\" (#679)"},{"Id":"349674104","IsPullRequest":true,"CreatedAt":"2018-08-13T20:29:20","Actor":"briancylui","Number":"672","RawContent":null,"Title":"Change SseUtils call sites to call CpuMathUtils instead","State":"closed","Body":"After all active SSE intrinsics have been implemented and tested for correctness and speed, this PR asks to make all external `SseUtils` call sites call `CpuMathUtils` instead.  This would allow us to obtain a baseline performance of C# hardware intrinsics APIs in a future PR.\r\n\r\ncc: @safern @danmosemsft @eerhardt @tannergooding ","Url":"https://github.com/dotnet/machinelearning/pull/672","RelatedDescription":"Closed or merged PR \"Change SseUtils call sites to call CpuMathUtils instead\" (#672)"},{"Id":"350146246","IsPullRequest":false,"CreatedAt":"2018-08-13T18:42:33","Actor":"lefig","Number":"676","RawContent":null,"Title":"Q: Workflow","State":"open","Body":"Hi,\r\n\r\nNot an issue defect to report, but more of an expression of appreciation for an excellent project.\r\n\r\nIn addition, I have a query in terms of process...\r\n\r\nMy csv files tend to be large and the fields likely to be changing on a frequent basis. However, when building models its just so time intensive having to update the class definitions and keep in sync.\r\n\r\nDoes anyone have any suggestions please to optimise this process. Can this be done, perhaps by automated template generation. Alternatively break cv files with many fields down to more granular files. I don't know so I would welcome your thoughts.\r\n\r\nTa\r\nFig   ","Url":"https://github.com/dotnet/machinelearning/issues/676","RelatedDescription":"Open issue \"Q: Workflow\" (#676)"},{"Id":"350101322","IsPullRequest":false,"CreatedAt":"2018-08-13T16:26:29","Actor":"Zruty0","Number":"675","RawContent":null,"Title":"Docs on CategoricalOneHotVectorizer are not clear, incomplete","State":"open","Body":"The 'remarks' section on the docs is really unclear about what  the outputs do, what happens if the value is not found in the dictionary.\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transforms.categoricalonehotvectorizer?view=ml-dotnet\r\n\r\nIn addition, only 3 out of 4 options for output kind are listed, and the documentation for the enum is a stub: \r\nhttps://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transforms.categoricaltransformoutputkind?view=ml-dotnet\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/675","RelatedDescription":"Open issue \"Docs on CategoricalOneHotVectorizer are not clear, incomplete\" (#675)"},{"Id":"349934829","IsPullRequest":false,"CreatedAt":"2018-08-13T08:34:06","Actor":"pan6465190","Number":"674","RawContent":null,"Title":"How to use intput data maybe not sure type.","State":"open","Body":"I want predict  power line of my pv equipment is Healthy. so the input data is a list power data(count may be not ensure). \r\n i did not find the dynamic input of the document.  can you help me. ","Url":"https://github.com/dotnet/machinelearning/issues/674","RelatedDescription":"Open issue \"How to use intput data maybe not sure type.\" (#674)"},{"Id":"349913029","IsPullRequest":false,"CreatedAt":"2018-08-13T07:16:41","Actor":"codemzs","Number":"673","RawContent":null,"Title":"C# native type system instead of DvTypes","State":"open","Body":"# C# native type system instead of DvTypes\r\n## Motivation\r\nMachine Learning datasets often have missing values and to accommodate them along with C# native types without increasing the memory footprint DvType system was created. If we were to use `Nullable<T>` then we are looking at additional memory for `HasValue` boolean field plus another 3 bytes for 4 byte alignment. The C# native types that are replaced using DvTypes are bool as DvBool, sbyte as DvInt1, int16 as DvInt2, int32 as DvInt4, int64 as DvInt8, DvDateTime as System.DateTime, DvDateTimeZone as combination of DvDateTime and DvInt2 offset, DvTimeSpan as SysTimeSpan and string as DvText. Float and Double types already have a special value called NaN that can be used for missing value. DvType system achieves a smaller memory footprint by denoting special value for missing value which is usually the smallest number that can be represented by the native type that is encapsulated by DvType, example, DvInt1's missing value indicator would be SByte.MinValue and in the case of types that represent date/time types it is a value that represent maximum ticks. \r\n\r\nWe plan to remove DvTypes to make IDataView a general commodity that can be used in other products and for this to happen it would be nice if it did not having a dependency on a special type system. If in future we find having DvTypes was useful then we can consider exposing it natively from .NET platform. Once we remove DvTypes then ML.NET platform will be using native C# types. Nullable types or float or double types can be used to represent missing value where needed. In some cases nullable types might take less memory in comparison to float types for example, byte or bool, their nullable type would occupy 2 bytes? and float would occupy 4 bytes. The burden to choose the type is on the user.\r\n\r\n## Column Types \r\nColumns in ML.NET make up the dataset and `ColumnType` defines a column. At high level there are two kinds of column, first is `PrimitiveType` and that comparises of types such as `NumberType`, `BoolType`, `TextType`, `DateTimeType`, `DateTimeZoneType`, `KeyType`, second is `Structured type` and it comparises of `VectorType`. `ColumnType` is primarily made up of `Type` and `DataKind`. `Type` could refer to any type but it is instantiated with a type referred by `DataKind` which is an identifer for data types that comprises of DvTypes, native C# types such as float, double and custom big integer UInt128. \r\n\r\n### NumberTypes\r\nNumberTypes consist of I1, U1, I2, U2, I4, U4, I8, U8, UG, R4, R8 but only I1, I2, I4, I8 are implemented using DvTypes. U1, U2, U4, U8, R4, R8 are just another names for native C# types such as byte, ushort, uint32, uint64, float and double. Float and Double have NaN capability which is used for missing values. Since I1, I2, I4, I8 will be replaced with native C# type and will also need to have option to represent missing values so we need to have two representations for each of these, one that will contain native C# type and second that will be of `Nullable` C# type to accommodate missing value, example, I1 will refer to sbyte? and I1P will refer to just sbyte. This change will need to be incorporated into `DataKind` and new `NumberType` will be created using `DataKind`. \r\n\r\n## Type conversion\r\nDvTypes have implicit and explicit override for assignment operator that handles type conversion. Lets consider DvInt1 for example:\r\n\r\n| To  | From | Current behavior | Helper routine\r\n|:-:|:-:|:-:|:-:|\r\n| DvInt1 | sbyte | Copy the value as it is | N/A\r\n| DvInt1 | sbyte? | Assign missing value if null otherwise copy the value as it is | sbyte = sbyte?\r\n| sbyte | DvInt1 | Copy if not a missing value otherwise throw exception | sbyte = sbyte?\r\n| sbyte? | DvInt1 | Assign null for missing values otherwise copy over | N/A\r\n| DvInt1 | DvBool | Assign missing value for a missing value otherwise copy value over | sbyte = bool?\r\n| DvInt1 | DvInt2 | Cast raw value from short to sbyte and compare it with original value if they are not same assign missing value otherwise casted value  | Either we disallow type conversion or we will need helper routine for every case.\r\n| DvInt1 | DvInt4 | Same as above | Same as above\r\n| DvInt1 | DvInt8 | Same as above | Same as above\r\n| DvInt1 | Float | Assign missing value when the value is NaN or out of range for sbyte | Either we disallow type conversion, or we will need helper routine for every case to check for overflow.\r\n| DvInt1 | Double | Same as above | Same as above.\r\n| Float | DvInt1 | Assign NaN for missing value | float = sbyte?\r\n| Double | DvInt1 | Same as above | double = sbyte?\r\n\r\nSimilar conversion rules exist for DvInt2, DvInt4, DvInt8 and DvBool. Unfortunately, implicit or explicit assignment overrides cannot be made for native C# types which means we will have to define helper routines for specific scenarios. How do we know where we need to handle a particular scenario? Compile\r\nthe code and find? Code inspection? \r\n\r\n## Logical, bitwise and numerical operators\r\nOperations such as `==`, `!=`, `!`, `>`, `>=`, `<`, `<=`, `+`,`-`,`*`,`pow`,`|`,`&` take place between same DvTypes only. They also handle missing values and in the case of arithmetic operators overflow is also handled. Most of these overrides are implemented but only few are actively used. For non-nullable types this is mostly not an issue except for handling overflow but for `Nullable` types we will need to implement overrides for handling nullable and non-nullable logical or bitwise or arithmetic operation. Whenever there is an overflow the resulting value is represented as missing value and the same goes when one of the operands is a missing value.\r\n\r\n## Serialization\r\nDvTypes have their own codecs for efficiently compressing data and writing it to disk, for example, to write DvBool to disk, two bits are used to represent a boolean value, 0x00 is false, 0x01 is true and 0x10 is missing value indicator. Boolean values are written at the level of int32 which has 32 bits that can\r\naccommodate 32/2 or 16 boolean values in 4 bytes as opposed to using 1 byte per boolean value using the naive approach that does not even handle missing value. We can reuse this approach to serialize bool? and bool. For DvInt types a single raw value represents a missing value and non-missing value but in the case of nullable types we can use XML serialization though it might increase the footprint on the disk. \r\n\r\n## Intermediate Language(IL) code generation\r\nML.NET contains a mini compiler that generates IL code at runtime for peak and poke functions that basically perform reflection of objects to set and get values in a more performant manner. Here we can use OpCodes.Stobj to emit IL code for `Nullable` types.\r\n\r\n## Misc.\r\nWherever ML.NET uses DvTypes internally such as DvInt4 for ranges in Key2Vec transform we could use `Nullable` types to accommodate missing values.\r\n\r\nCC: @eerhardt @Zruty0 @Ivanidzo4ka @TomFinley @shauheen ","Url":"https://github.com/dotnet/machinelearning/issues/673","RelatedDescription":"Open issue \"C# native type system instead of DvTypes\" (#673)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-08-21T05:30:31.8698848Z","RunDurationInMilliseconds":1116}