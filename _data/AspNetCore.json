{
	"Data": {
		"Identity-Issues": {
			"Issues": [{
				"Id": "343719379",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T17:11:04",
				"Actor": "Rick-Anderson",
				"Number": "1888",
				"RawContent": null,
				"Title": "No way to resend confirmation email",
				"State": "open",
				"Body": "From #1662\r\n\r\n**No way to resend confirmation email**\r\n\r\nIf you somehow didn't receive (or accidentally deleted, etc.) your confirmation email, then your account is dead forever, because there's no way to resend it. It's worse still if v1 of your site didn't implement confirmation emails, but v2 does, because then all existing users lose their accounts.\r\n\r\nThis is the `#1` ask from the docs feedback.\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1888",
				"RelatedDescription": "Open issue \"No way to resend confirmation email\" (#1888)"
			},
			{
				"Id": "343572939",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T10:19:35",
				"Actor": "binhghi5",
				"Number": "1887",
				"RawContent": null,
				"Title": "Why you remove ApplicationUser?",
				"State": "open",
				"Body": "In 2.0 we use to have an ApplicationUser class. I can add some custom fields and create relationship with another classes. Why you remove ApplicationUser class. Any reason?",
				"Url": "https://github.com/aspnet/Identity/issues/1887",
				"RelatedDescription": "Open issue \"Why you remove ApplicationUser?\" (#1887)"
			},
			{
				"Id": "341647823",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T17:50:38",
				"Actor": "postb99",
				"Number": "1879",
				"RawContent": null,
				"Title": "Why isn't there a FindByNormalizedName method?",
				"State": "closed",
				"Body": "Hello,\r\n\r\nI'm reading UserManager and RoleManager API documentation. I've understood the usefulness of normalized name/email, to have consistent comparison, maybe also a uniqueness value check.\r\n\r\nWhy aren't there FindByNormalizedNameAsync (UserManager and RoleManager) and FindByNormalizedEmail (UserManager) methods?\r\n\r\nThanks for information.",
				"Url": "https://github.com/aspnet/Identity/issues/1879",
				"RelatedDescription": "Closed issue \"Why isn't there a FindByNormalizedName method?\" (#1879)"
			},
			{
				"Id": "342687415",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T17:47:44",
				"Actor": "Ponant",
				"Number": "1884",
				"RawContent": null,
				"Title": "Difference between AddDefaultIdentity and AddIdentity??",
				"State": "closed",
				"Body": "In scaffolding Identity I get this in ASP.NET Core 2.1:\r\n\r\n```\r\n  services.AddDefaultIdentity<ApplicationUser>()\r\n                    .AddEntityFrameworkStores<ApplicationDbContext>();\r\n\r\n```\r\n\r\nWhereas the previous templates produced this\r\n\r\n ```\r\n  services.AddIdentity<ApplicationUser, IdentityRole>()\r\n        .AddEntityFrameworkStores<ApplicationDbContext>()\r\n        .AddDefaultTokenProviders();\r\n```\r\nWhich was clearer.\r\nIs is possible to understand the difference please? What does the former has that the latter does not? Can I just replace the former by the latter?\r\nThanks\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1884",
				"RelatedDescription": "Closed issue \"Difference between AddDefaultIdentity and AddIdentity??\" (#1884)"
			},
			{
				"Id": "342268347",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T13:09:21",
				"Actor": "Dolphinsimon",
				"Number": "1882",
				"RawContent": null,
				"Title": "Register users keep login failed in the default scaffolded identity razor pages.",
				"State": "closed",
				"Body": "In the default scaffolded Identity razor page-Login, users can login with email and password.\r\n```\r\n                <div class=\"form-group\">\r\n                    <label asp-for=\"Input.Email\"></label>\r\n                    <input asp-for=\"Input.Email\" class=\"form-control\" />\r\n                    <span asp-validation-for=\"Input.Email\" class=\"text-danger\"></span>\r\n                </div>\r\n                <div class=\"form-group\">\r\n                    <label asp-for=\"Input.Password\"></label>\r\n                    <input asp-for=\"Input.Password\" class=\"form-control\" />\r\n                    <span asp-validation-for=\"Input.Password\" class=\"text-danger\"></span>\r\n                </div>\r\n```\r\n\r\nHowever, the OnPostAsync() checks email and password with PasswordSignInAsync() witch sign in users\r\nby username and password.\r\n\r\n\r\n```\r\npublic async Task<IActionResult> OnPostAsync(string returnUrl = null)\r\n        {\r\n            returnUrl = returnUrl ?? Url.Content(\"~/\");\r\n\r\n            if (ModelState.IsValid)\r\n            {\r\n                // This doesn't count login failures towards account lockout\r\n                // To enable password failures to trigger account lockout, set lockoutOnFailure: true\r\n                var result = await _signInManager.PasswordSignInAsync(Input.Email, Input.Password, Input.RememberMe, lockoutOnFailure: true);\r\n                if (result.Succeeded)\r\n                {\r\n                    _logger.LogInformation(\"User logged in.\");\r\n                    return LocalRedirect(returnUrl);\r\n                }\r\n                if (result.RequiresTwoFactor)\r\n                {\r\n                    return RedirectToPage(\"./LoginWith2fa\", new { ReturnUrl = returnUrl, RememberMe = Input.RememberMe });\r\n                }\r\n                if (result.IsLockedOut)\r\n                {\r\n                    _logger.LogWarning(\"User account locked out.\");\r\n                    return RedirectToPage(\"./Lockout\");\r\n                }\r\n                else\r\n                {\r\n                    ModelState.AddModelError(string.Empty, \"Invalid login attempt.\");\r\n                    return Page();\r\n                }\r\n            }\r\n\r\n            // If we got this far, something failed, redisplay form\r\n            return Page();\r\n        }\r\n```\r\n\r\n\r\nIt seems that you won't login to your system forever.\r\nSo, witch situation was by designed? Login with username or email?\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1882",
				"RelatedDescription": "Closed issue \"Register users keep login failed in the default scaffolded identity razor pages.\" (#1882)"
			},
			{
				"Id": "342706152",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T18:04:02",
				"Actor": "huxiaozhong",
				"Number": "1885",
				"RawContent": null,
				"Title": "How can i use AspNetCore.Identity  in .net4.7 mvc5",
				"State": "closed",
				"Body": "i want use AspNetCore.Identity in  .net4.7 mvc5 ,can you  help me  or  give me some example;\r\n\r\ni want to know  how to resoleve  SignInManager<User> in Controller",
				"Url": "https://github.com/aspnet/Identity/issues/1885",
				"RelatedDescription": "Closed issue \"How can i use AspNetCore.Identity  in .net4.7 mvc5\" (#1885)"
			},
			{
				"Id": "342777573",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T18:02:50",
				"Actor": "Ponant",
				"Number": "1886",
				"RawContent": null,
				"Title": "Scaffold Identity omits custom ApplicationUser",
				"State": "closed",
				"Body": "**Works**\r\n1) New project 2.1 MVC with no auth\r\n2) Scaffold identity and choose the plus button for the user class\r\n\r\n![scaffoldidentity21](https://user-images.githubusercontent.com/19961806/42952012-cef98632-8b77-11e8-9c61-219423f81672.PNG)\r\n\r\nThe resulting code is expected because it refers to `ApplicationUser`\r\n\r\n`    public class ApplicationDbContext : IdentityDbContext<ApplicationUser>\r\n`\r\n`                services.AddDefaultIdentity<ApplicationUser>()\r\n`\r\n\r\n**Does not work**\r\n1) New project 2.1 MVC with no auth\r\n2) Create a class ApplicationUser that derives from IdentityUser\r\n`    public class ApplicationUser : IdentityUser\r\n`\r\n3) Scaffold identity and choose the **dropdown** button for the user class\r\n\r\n![scaffoldidentity21bug](https://user-images.githubusercontent.com/19961806/42952344-8aa84c10-8b78-11e8-96d4-c37ede8b262c.PNG)\r\n\r\n\r\nThe resulting code is unexpected because it refers to `IdentityUser`. `ApplicationUser `is totally ignored\r\n\r\n`    public class ApplicationDbContext : IdentityDbContext<IdentityUser>\r\n`\r\n`                services.AddDefaultIdentity<IdentityUser>()\r\n`\r\n\r\nBug?",
				"Url": "https://github.com/aspnet/Identity/issues/1886",
				"RelatedDescription": "Closed issue \"Scaffold Identity omits custom ApplicationUser\" (#1886)"
			},
			{
				"Id": "342559767",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T02:48:12",
				"Actor": "christiansk",
				"Number": "1883",
				"RawContent": null,
				"Title": "Make Context virtual in UserStore",
				"State": "open",
				"Body": "Could the [Context property](https://github.com/aspnet/Identity/blob/9ecbefcf21d12d90ac187e1eefe02ed0219edc23/src/EF/UserStore.cs#L126) be marked as virtual in UserStore? I would like to implement my own getter so I can better manage the lifecycle of the DbContext (to enforce better control over the transaction boundaries).\r\nI have implemented an unit of work using the [DbContextScope library](https://github.com/apawsey/DbContextScope) and it's working great throughout my app, so I would like to use it for Identity as well.",
				"Url": "https://github.com/aspnet/Identity/issues/1883",
				"RelatedDescription": "Open issue \"Make Context virtual in UserStore\" (#1883)"
			},
			{
				"Id": "342187541",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T06:00:53",
				"Actor": "maxwang",
				"Number": "1881",
				"RawContent": null,
				"Title": "How can I inject custom code to account controller in Identity core 2.1",
				"State": "open",
				"Body": "Dear Sir/Madam,\r\n\r\nI tried to update my project from .net core 2.0 to core 2.1 and could not find the place to inject my code to account controller. Do I have to change back to .net Identity core 2.0 code? Or could you give me some suggestions?\r\n\r\nThanks.\r\n\r\nRegards,\r\nMax\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1881",
				"RelatedDescription": "Open issue \"How can I inject custom code to account controller in Identity core 2.1\" (#1881)"
			},
			{
				"Id": "341810304",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T08:09:50",
				"Actor": "tiljanssen",
				"Number": "1880",
				"RawContent": null,
				"Title": "AddIdentity should check if IUserSecurityStampStore is implemented before registering a check on securityStamp",
				"State": "open",
				"Body": "If the UserStore does not implement IUserSecurityStampStore, most functionality regarding security stamps will be skipped, but AddIdentity() does register a validation on the securityStamp every 30 minutes.\r\n\r\nThis results in the confusing behaviour that the user is logged out after 30 minutes, even though the cookies did not expire.\r\n\r\nAddIdentity should check whether the UserSecurityStampStore is supported before registering the check, and either throw, or skip the check.\r\n\r\nSee also #1425 ",
				"Url": "https://github.com/aspnet/Identity/issues/1880",
				"RelatedDescription": "Open issue \"AddIdentity should check if IUserSecurityStampStore is implemented before registering a check on securityStamp\" (#1880)"
			},
			{
				"Id": "341347083",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-15T19:58:33",
				"Actor": "dazinator",
				"Number": "1878",
				"RawContent": null,
				"Title": "Custom IdentityUserLogin<int> and EF user store",
				"State": "closed",
				"Body": "I'm using the EF stores.\r\n\r\nThe only change I'd like to make is to add a column to the `AspNetUserLogins` table so that I can also store the refresh token associated with the external login. I think adding a column to an EF model should be fairly straightforward, and it was, but then getting identity to work with it is turning out to be a bit painful :-)\r\n\r\nI derived my own entity from `IdentityUserLogin<int>` and added the additional property:\r\n\r\n```\r\n   public class DennisUserLogin : IdentityUserLogin<int>\r\n   {\r\n        public string RefreshToken { get; set; }\r\n   }\r\n```\r\n\r\nAnd therefore had to derive my own `IdentityDbContext`, passing in that replacement type:\r\n\r\n```\r\n\r\n public class DennisContext : IdentityDbContext<DennisUser, IdentityRole<int>, int, IdentityUserClaim<int>, IdentityUserRole<int>, DennisUserLogin, IdentityRoleClaim<int>, IdentityUserToken<int>>\r\n    {\r\n        public DennisContext(DbContextOptions<DennisContext> options)\r\n            : base(options)\r\n        {\r\n        }\r\n\r\n        protected override void OnModelCreating(ModelBuilder builder)\r\n        {\r\n            base.OnModelCreating(builder);         \r\n            \r\n        }\r\n    }\r\n```\r\n\r\nI was able to then add a new ef migration, and apply that, and I can see the additional column in the database - great.\r\n\r\nNext I needed to be able to set this new property. So I had to find the locations where a new `IdentityUserLogin` entity is created, so that I could also set my additional property before its saved.\r\n\r\nUnfortunately the `UserStore` seems to create this entity, and the there is nowhere in the existing API where I could pass an additional value to it (i.e referesh token). Therefore overriding any existing method on UserStore or UserManager wouldn't cater for my scenario. So I had to add some additional method to UserManager and UserStore that also took a \"refresh token\":\r\n\r\n```\r\n\r\n  public class DennisUserStore : UserStore<DennisUser, IdentityRole<int>, DennisContext, int>, IDennisUserStore\r\n    {\r\n\r\n        private readonly DennisContext _context;\r\n\r\n        public DennisUserStore(DennisContext context, IdentityErrorDescriber describer = null) : base(context, describer)\r\n        {\r\n            _context = context;\r\n        }\r\n        \r\n        \r\n        /// <summary>\r\n        /// Adds the <paramref name=\"login\"/> given to the specified <paramref name=\"user\"/>.\r\n        /// </summary>\r\n        /// <param name=\"user\">The user to add the login to.</param>\r\n        /// <param name=\"login\">The login to add to the user.</param>\r\n        /// <param name=\"cancellationToken\">The <see cref=\"CancellationToken\"/> used to propagate notifications that the operation should be canceled.</param>\r\n        /// <returns>The <see cref=\"Task\"/> that represents the asynchronous operation.</returns>\r\n        public Task AddLoginAsync(DennisUser user, UserLoginInfo login, string refreshToken,\r\n            CancellationToken cancellationToken = default(CancellationToken))\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n            ThrowIfDisposed();\r\n            if (user == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(user));\r\n            }\r\n            if (login == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(login));\r\n            }\r\n            var userLogins = _context.UserLogins;\r\n            var newLogin = CreateDennisUserLogin(user, login);\r\n            newLogin.RefreshToken = refreshToken;\r\n            userLogins.Add(newLogin);\r\n            return Task.FromResult(false);\r\n        }\r\n\r\n        private DennisUserLogin CreateDennisUserLogin(DennisUser user, UserLoginInfo login)\r\n        {\r\n            var dennisUserLogin = new DennisUserLogin();\r\n            dennisUserLogin.LoginProvider = login.LoginProvider;\r\n            dennisUserLogin.ProviderDisplayName = login.ProviderDisplayName;\r\n            dennisUserLogin.ProviderKey = login.ProviderKey;\r\n            dennisUserLogin.UserId = user.Id;\r\n            return dennisUserLogin;\r\n        }\r\n\r\n    }\r\n\r\n```\r\n\r\nand `UserManager`:\r\n\r\n```\r\n\r\n\r\n   public class DennisUserManager : UserManager<DennisUser>\r\n    {\r\n        public DennisUserManager(IUserStore<DennisUser> store, IOptions<IdentityOptions> optionsAccessor, IPasswordHasher<DennisUser> passwordHasher, IEnumerable<IUserValidator<DennisUser>> userValidators, IEnumerable<IPasswordValidator<DennisUser>> passwordValidators, ILookupNormalizer keyNormalizer, IdentityErrorDescriber errors, IServiceProvider services, ILogger<UserManager<DennisUser>> logger) : base(store, optionsAccessor, passwordHasher, userValidators, passwordValidators, keyNormalizer, errors, services, logger)\r\n        {\r\n\r\n        }\r\n\r\n        // IUserLoginStore methods\r\n        private IDennisUserStore GetStore()\r\n        {\r\n\r\n            var cast = Store as IDennisUserStore;\r\n            if (cast == null)\r\n            {\r\n                throw new NotSupportedException(\"Store Not IUserLoginStore\");\r\n            }\r\n            return cast;\r\n        }     \r\n\r\n        public async Task<IdentityResult> AddLoginAsync(DennisUser user, UserLoginInfo login, string refreshToken)\r\n        {\r\n            ThrowIfDisposed();\r\n            var loginStore = GetStore();\r\n            if (login == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(login));\r\n            }\r\n            if (user == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(user));\r\n            }\r\n\r\n            var existingUser = await FindByLoginAsync(login.LoginProvider, login.ProviderKey);\r\n            if (existingUser != null)\r\n            {\r\n                Logger.LogWarning(4, \"AddLogin for user {userId} failed because it was already associated with another user.\", await GetUserIdAsync(user));\r\n                return IdentityResult.Failed(ErrorDescriber.LoginAlreadyAssociated());\r\n            }\r\n            await loginStore.AddLoginAsync(user, login, refreshToken, CancellationToken);\r\n            return await UpdateUserAsync(user);\r\n        }\r\n    }\r\n\r\n```\r\n\r\nSo far this is a lot of work in order to be able to add one property to this entity but I thought I was close.\r\n\r\nI changed the razor UI code to call the new method on my UserManager instead which takes the refresh token,\r\n\r\nNow when I run the app, when attempting an external login, I get the following error:\r\n\r\n> InvalidOperationException: Cannot create a DbSet for 'IdentityUserLogin<int>' because this type is not included in the model for the context.\r\nMicrosoft.EntityFrameworkCore.Internal.InternalDbSet<TEntity>.get_EntityType()\r\nMicrosoft.EntityFrameworkCore.Internal.InternalDbSet<TEntity>.get_EntityQueryable()\r\nMicrosoft.EntityFrameworkCore.Internal.InternalDbSet<TEntity>.System.Linq.IQueryable.get_Provider()\r\nMicrosoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync<TSource, TResult>(MethodInfo operatorMethodInfo, IQueryable<TSource> source, Expression expression, CancellationToken cancellationToken)\r\nMicrosoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync<TSource, TResult>(MethodInfo operatorMethodInfo, IQueryable<TSource> source, LambdaExpression expression, CancellationToken cancellationToken)\r\nMicrosoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.SingleOrDefaultAsync<TSource>(IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, CancellationToken cancellationToken)\r\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)\r\nMicrosoft.AspNetCore.Identity.EntityFrameworkCore.UserStore<TUser, TRole, TContext, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim>.FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)\r\nMicrosoft.AspNetCore.Identity.SignInManager<TUser>.ExternalLoginSignInAsync(string loginProvider, string providerKey, bool isPersistent, bool bypassTwoFactor)\r\nDennis.Areas.Identity.Pages.Account.ExternalLoginModel.OnGetCallbackAsync(string returnUrl, string remoteError) in ExternalLogin.cshtml.cs\r\n-\r\n            {\r\n                ErrorMessage = \"Error loading external login information.\";\r\n                return RedirectToPage(\"./Login\", new { ReturnUrl = returnUrl });\r\n            }\r\n            // Sign in the user with this external login provider if the user already has a login.\r\n            var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false, bypassTwoFactor : true);\r\n            if (result.Succeeded)\r\n            {\r\n                var tokens = info.AuthenticationTokens.ToArray();\r\n                // save the users \r\n                _logger.LogInformation(\"{Name} logged in with {LoginProvider} provider.\", info.Principal.Identity.Name, info.LoginProvider);\r\n                return LocalRedirect(returnUrl);\r\nMicrosoft.AspNetCore.Mvc.RazorPages.Internal.ExecutorFactory+GenericTaskHandlerMethod.Convert<T>(object taskAsObject)\r\n\r\n\r\nIt seems something about the store is still specifically looking for `IdentityUserLogin<int>` which isn't part of my model anymore - because I am using my own derived type `DennisUserLogin`. However it doesn't appear I can inform the user store of that.. What am I missing?",
				"Url": "https://github.com/aspnet/Identity/issues/1878",
				"RelatedDescription": "Closed issue \"Custom IdentityUserLogin<int> and EF user store\" (#1878)"
			},
			{
				"Id": "341346866",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-15T19:47:26",
				"Actor": "dotnet-maestro-bot",
				"Number": "1877",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "open",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @aspnetci\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/Identity merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/Identity/pull/1877",
				"RelatedDescription": "Open PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#1877)"
			},
			{
				"Id": "341165815",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T21:32:17",
				"Actor": "NinoFloris",
				"Number": "1876",
				"RawContent": null,
				"Title": "Can PasswordValidator errors pretty please be merged with UserValidator errors on user create?",
				"State": "open",
				"Body": "Talking about https://github.com/aspnet/Identity/blame/master/src/Core/UserManager.cs#L597\r\nCould instead of returning on `!succeeded` store them, run CreateAsync and merge them with those errors.\r\nThis is blocking a nice api where you get all errors of a registration in one go.",
				"Url": "https://github.com/aspnet/Identity/issues/1876",
				"RelatedDescription": "Open issue \"Can PasswordValidator errors pretty please be merged with UserValidator errors on user create?\" (#1876)"
			},
			{
				"Id": "340801603",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T02:40:43",
				"Actor": "natemcmaster",
				"Number": "1875",
				"RawContent": null,
				"Title": "[2.1]: pin baseline package versions to 2.1.2",
				"State": "closed",
				"Body": "Part of https://github.com/aspnet/Home/issues/3316\n\nThis pins package versions to the 2.1.2 baseline. Universe will not override variables in the 'Pinned' section. This helps ensure that this repo does not upgrade its dependency versions for all future patches of 2.1.",
				"Url": "https://github.com/aspnet/Identity/pull/1875",
				"RelatedDescription": "Closed or merged PR \"[2.1]: pin baseline package versions to 2.1.2\" (#1875)"
			},
			{
				"Id": "337865699",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T18:41:50",
				"Actor": "egmfrs",
				"Number": "1860",
				"RawContent": null,
				"Title": "Determine if Confirmation Email link failed because Token expired",
				"State": "closed",
				"Body": "Is there a way to do this? Like an error code that will return when the email confirmation token has expired?\r\nFor example if the error code was \"TokenExpired\" I could use the following to return the user to a specific view which gives them advice on a process to follow if their token has expired:\r\n\r\n```\r\n        var result = await _userManager.ConfirmEmailAsync(user, code);\r\n        if (result.Succeeded) return View(\"ConfirmEmail\");\r\n\r\n        return View(result.Errors.Any(c => c.Code == \"TokenExpired\") ? \"TokenExpired\" : \"Error\");\r\n```",
				"Url": "https://github.com/aspnet/Identity/issues/1860",
				"RelatedDescription": "Closed issue \"Determine if Confirmation Email link failed because Token expired\" (#1860)"
			},
			{
				"Id": "339455942",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T18:37:56",
				"Actor": "flatproject",
				"Number": "1867",
				"RawContent": null,
				"Title": "Two factor authentication by Email",
				"State": "closed",
				"Body": "Is it possible to configure 2FA via email in a .net core 2.0 or 2.1 application? \r\n\r\nI can't find any information anywhere about it apart from SMS or QR code examples which are not usable in a PCI compliant environment.\r\n\r\nAre there any email 2FA examples anywhere?\r\n\r\nThank you",
				"Url": "https://github.com/aspnet/Identity/issues/1867",
				"RelatedDescription": "Closed issue \"Two factor authentication by Email\" (#1867)"
			},
			{
				"Id": "340309923",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T18:37:20",
				"Actor": "Freakazoid182",
				"Number": "1871",
				"RawContent": null,
				"Title": "Wrong password logging with Warning level",
				"State": "closed",
				"Body": "In my opinion this should be an Information level warning. What is the reason behind a Warning level here?\r\n\r\nhttps://github.com/aspnet/Identity/blob/c7276ce2f76312ddd7fccad6e399da96b9f6fae1/src/Core/UserManager.cs#L711",
				"Url": "https://github.com/aspnet/Identity/issues/1871",
				"RelatedDescription": "Closed issue \"Wrong password logging with Warning level\" (#1871)"
			},
			{
				"Id": "340410768",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-11T21:23:15",
				"Actor": "bigpodgurc",
				"Number": "1874",
				"RawContent": null,
				"Title": "using same ASP.net core identity for multiple web applicaitons",
				"State": "open",
				"Body": "Hello\r\n\r\nI want to have 3 different web applications but want to use same identity back end application so i have SSO. im using Individual user accounts\r\n\r\nthanks",
				"Url": "https://github.com/aspnet/Identity/issues/1874",
				"RelatedDescription": "Open issue \"using same ASP.net core identity for multiple web applicaitons\" (#1874)"
			},
			{
				"Id": "340388845",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-11T20:27:19",
				"Actor": "dotnet-maestro-bot",
				"Number": "1873",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @HaoK\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit fetch --force https://github.com/dotnet-maestro-bot/Identity merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/Identity/pull/1873",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#1873)"
			},
			{
				"Id": "340335156",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-11T17:23:47",
				"Actor": "blowdart",
				"Number": "1872",
				"RawContent": null,
				"Title": "[bug].net core 2.1,Identity will throw exception while implement IdentityUser. But .net core 2.0 is Ok.",
				"State": "open",
				"Body": "_From @Caizhenyu on July 7, 2018 11:58_\n\nI am using asp net core Identity Framework on core 2.1, and I implement my  `ApplicationUser : IdentityUser` .Then there will throw Exception like the screenshot .\r\nBut I found that, the same code is Ok on core 2.0, or I just user IdentityUser not my own ApplicationUser is also ok while `services.AddIdentity<TUser, TRole>`.\r\n\r\nIs it's a core 2.1 bug?\r\n![tim 20180707194836](https://user-images.githubusercontent.com/19528235/42410678-1fcd9ff0-8220-11e8-9bf7-27d4c34b266a.png)\r\n\r\n\n\n_Copied from original issue: aspnet/Security#1804_",
				"Url": "https://github.com/aspnet/Identity/issues/1872",
				"RelatedDescription": "Open issue \"[bug].net core 2.1,Identity will throw exception while implement IdentityUser. But .net core 2.0 is Ok.\" (#1872)"
			},
			{
				"Id": "339303539",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-10T19:56:50",
				"Actor": "tstivers1990",
				"Number": "1866",
				"RawContent": null,
				"Title": "ActivePage declarations missing on scaffolded Identity UI",
				"State": "closed",
				"Body": "Some of the ActivePage declarations are missing on the default scaffolded Identity UI. This causes some pages not to show an active item in the relevant nav section.\r\n\r\nSome pages also use an ActivePage declaration that doesn't have a corresponding item in the navigation section, resulting in those pages not showing an active navigation item.\r\n\r\nI've created a pull request that adds the missing ActivePage declarations, and changes the ones that don't have a corresponding nav element to use an ActivePage declaration with the most relevant nav element. For example, the DeletePersonalData page was using `ViewData[\"ActivePage\"] = ManageNavPages.DeletePersonalData;` There is no nav element for Delete Personal Data. I've changed it to use `ViewData[\"ActivePage\"] = ManageNavPages.PersonalData;` instead, as there is a nav element for Personal Data, and that is the most relevant nav element for the page.\r\n\r\nAny methods and variables within `ManageNavPages` that are no longer used after this changed were removed. For example, the `ManageNavPages.DeletePersonalData` variable is no longer used after the change, and neither is the `ManageNavPages.DeletePeronalDataNavClass` method. Therefore, both of them are removed.\r\n\r\nI've also made the `PageNavClass` method private, as it is never accessed outside of its class and, based on the class' design, should only be referenced by public methods in the class, and not directly outside of the class.\r\n\r\nPR: #1838 ",
				"Url": "https://github.com/aspnet/Identity/issues/1866",
				"RelatedDescription": "Closed issue \"ActivePage declarations missing on scaffolded Identity UI\" (#1866)"
			},
			{
				"Id": "339929777",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-10T17:02:34",
				"Actor": "blowdart",
				"Number": "1870",
				"RawContent": null,
				"Title": "Microsoft Security Advisory CVE-2018-8171: ASP.NET Core Security Feature Bypass Vulnerability",
				"State": "open",
				"Body": "# Microsoft Security Advisory CVE-2018-8171: ASP.NET Core Security Feature Bypass Vulnerability\r\n\r\n## <a name=\"executive-summary\"></a>Executive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in ASP.NET Core. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nMicrosoft is aware of a security feature bypass in ASP.NET Core when the number of incorrect login attempts is not validated. An attacker who successfully exploited this vulnerability could try an infinite number of authentication attempts.\r\n\r\nThe update addresses the vulnerability by correcting how ASP.NET Core validates the number of incorrect login attempts.\r\n\r\n## Announcement\r\n\r\nThe original announcement can be found at https://github.com/aspnet/Announcements/issues/310\r\n\r\n### <a name=\"mitigation-factors\"></a>Mitigation factors\r\n\r\n* If your application does not use ASP.NET Core's implementation of multi-factor authentication you are not affected.\r\n\r\n## <a name=\"affected-software\"></a>Affected software\r\n\r\nAny ASP.NET Core based application that uses Microsoft.AspNetCore.Identity with a vulnerable version listed below.\r\n\r\nPackage name | Vulnerable versions | Secure versions\r\n------------ | ---------------- | -------------------------\r\nMicrosoft.AspNetCore.Identity | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5 <br /> 1.1.0, 1.1.1, 1.1.2, 1.1.3, 1.1.4, 1.1.5 <br /> 2.0.0, 2.0.1, 2.0.2, 2.0.3 <br /> 2.1.0, 2.1.1 | 1.0.6 <br /> 1.1.6 <br /> 2.0.4 <br /> 2.1.2\r\n\r\n## <a name=\"advisory-faq\"></a>Advisory FAQ\r\n\r\n### <a name=\"how-affected\"></a>How do I know if I am affected?\r\n\r\n.NET Core has two types of dependencies: direct and transitive. Direct dependencies are dependencies where you specifically add a package to your project, transitive dependencies occur when you add a package to your project that in turn relies on another package.\r\n\r\nFor example, the `Microsoft.AspNetCore.Mvc` package depends on the `Microsoft.AspNetCore.Mvc.Core` package. When you add a dependency on `Microsoft.AspNetCore.Mvc` in your project, you're taking a transitive dependency on `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\nAny application that has a direct or transitive dependency on the [affected package](#affected-software) can be exposed to the vulnerability if it does not meet any of the [mitigation factors](#mitigation-factors).\r\n\r\n### <a name=\"how-fix\"></a>How do I fix the issue?\r\n\r\n### ASP.NET Core 2.1\r\n\r\nTo update ASP.NET Core 2.1 you should [download](https://www.microsoft.com/net/download) and install the .NET Core SDK 2.1.302 on your development machines and build servers, and the .NET Core Runtime 2.1.2 on your deployment servers. Your application will roll forward to these versions on an application restart.\r\n\r\n### ASP.NET Core 2.0\r\n\r\nIf you're targeting ASP.NET Core 2.0 and using the `Microsoft.AspNetCore.All` metapackage update its version number to 2.0.9 to update the `Microsoft.AspNetCore.Identity` package, recompile, and redeploy. On your deployment servers, you should [download](https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.0.9-download.md) and install the .NET Core 2.0.9 using the Windows Server Hosting Bundle for Windows and the `dotnet-hosting-2.0.9` package for Linux servers.\r\n\r\n### ASP.NET Core 1.0, 1.1 or 2.0 not targeting the metapackage.\r\n\r\n.NET Core projects have two types of dependencies: direct and transitive. You must update your projects using the following instructions to address both types of dependency.\r\n\r\n### <a name=\"project-format\"></a>.NET Core Project formats\r\n\r\n.NET Core has two different project file formats, depending on what software created the project.\r\n\r\n1. `project.json` is the format used in .NET Core 1.0 and Microsoft Visual Studio 2015.\r\n2. `csproj` is the format used in .NET Core 1.1, .NET Core 2.0 and Microsoft Visual Studio 2017.\r\n\r\n#### Direct dependencies\r\n\r\nDirect dependencies are discoverable by examining your `csproj` file or your `project.json` file. They can be fixed by [editing the project file](#direct-dependencies) or using NuGet to update the dependency.\r\n\r\n#### Transitive dependencies\r\n\r\nTransitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.\r\n\r\nTransitive dependencies are reviewable in three ways, depending on your [project format](#project-format):\r\n\r\n* In the Visual Studio Solution Explorer window, which supports searching.\r\n* By examining the `project.assets.json` file contained in the obj directory of your project for `csproj` based projects *OR*.\r\n* By examining the `project.lock.json` file contained in the root directory of your project for `project.json` based projects.\r\n\r\nThe `project.assets.json` and `project.lock.json` files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.\r\n\r\n#### <a name=\"direct-dependencies-vs2017\"></a>Fixing direct dependencies in a csproj based project / Visual Studio 2017\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nThe preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.\r\nThe package version number is in the `Version` attribute. The previous example shows a single direct dependency on `Microsoft.AspNetCore.Identity` version 2.0.0.\r\n\r\nTo update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).\r\nIn this example, update `Microsoft.AspNetCore.Identity` to the appropriate [fixed package number](#affected-software) for your major version. Save the *csproj* file. The example *csproj* now looks as follows:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.4\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nIf you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.\r\n\r\nNow recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.\r\n\r\n#### <a name=\"direct-dependencies-vs2015\"></a> Fixing Direct Dependencies in project.json based project / Visual Studio 2015\r\n\r\nOpen your `project.json` file in your editor. Look for the dependencies section. Below is an example dependencies section:\r\n\r\n``` json\r\n    \"dependencies\": {\r\n      \"Microsoft.NETCore.App\": {\r\n        \"version\": \"1.0.1\",\r\n        \"type\": \"platform\"\r\n      },\r\n     \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n     \"Microsoft.AspNetCore.Identity\" : \"1.0.5\"\r\n    }\r\n```\r\n\r\nThis example has three direct dependencies: `Microsoft.NETCore.App`, `Microsoft.AspNetCore.Mvc.Core` and `Microsoft.AspNetCore.Identity`.\r\n\r\n`Microsoft.NetCore.App` is the platform the application targets, you should ignore this. The other packages expose their version to the right of the package name. In our example, our non-platform packages are version 1.0.1.\r\n\r\nReview your direct dependencies for any instance of the packages and versions listed above. In the example above, there is a direct dependency on a vulnerable package, `Microsoft.AspNetCore.Identity` version 1.0.5.\r\n\r\nTo update to the fixed package, change the version number to be the appropriate package for your release. In the example, this would be updating `Microsoft.AspNetCore.Identity` to 1.0.6.\r\n\r\nAfter updating the vulnerable package versions, save your `project.json` file.\r\n\r\nThe dependencies section in our example `project.json` would now look as follows:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n    \"Microsoft.AspNetCore.Identity \": \"1.0.6\"\r\n  }\r\n```\r\n\r\nIf you are using Visual Studio and save your updated `project.json` file, Visual Studio will restore the new package version. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependency.\r\n\r\nAfter you have addressed all of your direct dependencies, you must also review your transitive dependencies.\r\n\r\nAfter you've addressed all of your direct dependencies, you must review your transitive dependencies.\r\n\r\n#### Discovering and fixing transitive dependencies\r\n\r\nThere are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can review [the `project.assets.json` file](#project-assets-json) or the [the `project.lock.json` file](#project-lock-json).\r\n\r\n##### <a name=\"vs-solution-explorer\"></a>Using Visual Studio Solution Explorer\r\n\r\nTo use Solution Explorer, open the project in Visual Studio, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.\r\n\r\nFor example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:\r\n\r\n![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)\r\n\r\nThe search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.\r\n\r\nUnder the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.\r\nIn screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.\r\nThe `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\n##### <a name=\"project-assets-json\"></a> Manually reviewing project.assets.json (csproj/VS2017)\r\n\r\nOpen the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.\r\nVisual Studio and Visual Studio Code provide JSON friendly editing.\r\n\r\nSearch the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:\r\n\r\n* Examine the line on which they are found, the version number is after the `/`.\r\n* Compare to the [vulnerable versions table](#affected-software).\r\n\r\nFor example, a search result that shows `Microsoft.AspNetCore.Identity/2.0.0` is a reference to version 2.0.0 of `Microsoft.AspNetCore.Identity`.\r\nIf your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to any vulnerable packages, this means either\r\n\r\n* None of your direct dependencies depend on any vulnerable packages, or\r\n* You have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.\r\nLook for `PackageReference` nodes, for example:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nYou must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.\r\nYou do this by adding a new line to the dependencies section, referencing the fixed version.\r\nFor example, if your search showed a transitive reference to a vulnerable `Microsoft.AspNetCore.Identity` version, you'd add a reference to the [fixed package number](#affected-software).\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.4\" />\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nAfter you've added the direct dependency reference, save your *csproj* file.\r\n\r\nIf you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.\r\n\r\n##### <a name=\"project-lock-json\"></a> Manually reviewing project.lock.json (project.json/VS2015)\r\n\r\nOpen the `project.lock.json` file in your editor. We suggest you use an editor that understands json and allows you to collapse and expand nodes to review this file; both Visual Studio and Visual Studio Code provide this functionality.\r\n\r\nIf you are using Visual Studio the `project.lock.json` file is “under” the `project.json` file. Click the right pointing triangle, ▷, to the left of the `project.json` file to expand the solution tree to expose the `project.lock.json` file. The following image shows a project with the `project.json` file expanded to show the `project.lock.json` file.\r\n\r\n![project lock json](https://cloud.githubusercontent.com/assets/796298/25858179/f6e01200-348f-11e7-8a77-7176d8dd3f03.png)\r\n\r\nSearch the `project.lock.json` file for the vulnerable packages, using the format `packagename/`, using each of the package names from the table above. If you find any vulnerable assembly name in your search examine the line on which they are found, the version number is after the `/` and compare to the vulnerable versions table above. For example a search result that shows `Microsoft.AspNetCore.Identity/1.0.1` is a reference to v1.0.1 of `Microsoft.AspNetCore.Identity`.   If your `project.lock.json` file includes references to any of the package versions shown above then you will need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to a vulnerable version of  `Microsoft.AspNetCore.Identity` this means none of your direct dependencies depend on any vulnerable packages or you have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to any of the vulnerable packages you must add a direct dependency to the updated package to your `project.json` file to override the transitive dependency. Open your `project.json` and find the dependencies section. For example:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nFor each of the vulnerable packages your search returned you must add a direct dependency to the updated version by adding it to the `project.json` file. You do this by adding a new line to the dependencies section, referring the fixed version. For example, if your search showed a transitive reference to the vulnerable `Microsoft.AspNetCore.Identity` version 1.0.0 you would add a reference to the appropriate fixed version, 1.0.6. Edit the `project.json` file as follows:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Identity\": \"1.0.6\",\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nAfter you have added direct dependencies to the fixed packages, save your `project.json` file.\r\n\r\nIf you are using Visual Studio save your updated `project.json` file and Visual Studio will restore the new package versions. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependencies.\r\n\r\n#### Rebuilding your application\r\n\r\nFinally you must rebuild your application, test, and redeploy.\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \"as is\" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### Acknowledgments\r\n\r\n[Martin Knafve](https://www.linkedin.com/in/martin-knafve-99187a2/)\r\n\r\n### External Links\r\n\r\n[CVE-2018-8171](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2018-8171)\r\n\r\n### Revisions\r\n\r\nV1.0 (July 10, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2018-07-10_",
				"Url": "https://github.com/aspnet/Identity/issues/1870",
				"RelatedDescription": "Open issue \"Microsoft Security Advisory CVE-2018-8171: ASP.NET Core Security Feature Bypass Vulnerability\" (#1870)"
			},
			{
				"Id": "339822774",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-10T12:35:55",
				"Actor": "tincann",
				"Number": "1869",
				"RawContent": null,
				"Title": "Fix misleading exception message when adding a TokenProvider",
				"State": "open",
				"Body": "",
				"Url": "https://github.com/aspnet/Identity/pull/1869",
				"RelatedDescription": "Open PR \"Fix misleading exception message when adding a TokenProvider\" (#1869)"
			},
			{
				"Id": "339512611",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-09T16:03:47",
				"Actor": "benm-eras",
				"Number": "1868",
				"RawContent": null,
				"Title": "Why are the `DbSet`s in `IdentityUserContext` non-virtual?",
				"State": "open",
				"Body": "In ASP.NET Core 2.x the `DbSet`s defined in the abstract classes `IdentityDbContext` and `IdentityUserContext` are all non-virtual making it much harder to effectively mock my database context that is built on them. It looks like they were virtual in ASP.NET Core 1.x, although the library was arranged differently then, so I am not 100% sure on that. \r\n\r\nIs there a reason that they cannot just be made virtual to facilitate unit testing? I really don't like having to resort to something drastic like Fakes when I could just use Moq etc.\r\n\r\nIf there is a reason they can't be made virtual I would really appreciate it if any one has any ideas on how  I can proceed with mocking my db context that implements `IdentityDbContext`! ",
				"Url": "https://github.com/aspnet/Identity/issues/1868",
				"RelatedDescription": "Open issue \"Why are the `DbSet`s in `IdentityUserContext` non-virtual?\" (#1868)"
			},
			{
				"Id": "339263894",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-08T22:31:57",
				"Actor": "dm-CaT",
				"Number": "1865",
				"RawContent": null,
				"Title": "UserManager -> SetPasswordHashAsync is called before CreateAsync(user)",
				"State": "open",
				"Body": "Is there any reason why when the new user is created with password the password hash is set before user is saved?\r\nI'm trying to implement my own IUserStore/IUserPasswordStore (to use custom DAL). But I got an error because my store cannot set password hash (update record in DB) to non created user.\r\nHere is the code from UserManager which causes an error.\r\n```\r\n        public virtual async Task<IdentityResult> CreateAsync(TUser user, string password)\r\n        {\r\n            ThrowIfDisposed();\r\n            var passwordStore = GetPasswordStore();\r\n            if (user == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(user));\r\n            }\r\n            if (password == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(password));\r\n            }\r\n            // Here is the SetPasswordHashAsync occurs\r\n            var result = await UpdatePasswordHash(passwordStore, user, password);\r\n            if (!result.Succeeded)\r\n            {\r\n                return result;\r\n            }\r\n            // Only here I save user in DB\r\n            return await CreateAsync(user);\r\n        }\r\n```\r\n [Link on method](https://github.com/aspnet/Identity/blob/c60b4d8784550ea868af0c2d08cc14217ae2e940/src/Core/UserManager.cs#L585)\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1865",
				"RelatedDescription": "Open issue \"UserManager -> SetPasswordHashAsync is called before CreateAsync(user)\" (#1865)"
			},
			{
				"Id": "339141041",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-07T12:44:30",
				"Actor": "CeelMarten",
				"Number": "1864",
				"RawContent": null,
				"Title": "Can't configure Identity",
				"State": "closed",
				"Body": "I have a class **ApplicationUser**  witch inherited from **IdentityUser<long>**\r\n```\r\n    public class ApplicationUser : IdentityUser<long>\r\n    {\r\n    }\r\n```\r\nand I want to use it in **ApplicationDbContext** \r\n```\r\n    public class ApplicationDbContext : IdentityDbContext<ApplicationUser>\r\n    {\r\n        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)\r\n            : base(options)\r\n        {\r\n        }\r\n\r\n        protected override void OnModelCreating(ModelBuilder builder)\r\n        {\r\n            base.OnModelCreating(builder);\r\n        }\r\n    }\r\n```\r\n\r\nVisual Studio says that I can't use **ApplicationUser** because there is no implicit reference conversion from **ApplicationUser** to **IdentityUser**. I found this in github where \r\n\r\n```\r\n      services.AddIdentity<ApplicationUser, IdentityRole>()\r\n                .AddEntityFrameworkStores<ApplicationDbContext, long>()\r\n                .AddDefaultTokenProviders();\r\n```\r\nthe solution is to change code from  \r\n`.AddEntityFrameworkStores<ApplicationDbContext>()` to `.AddEntityFrameworkStores<ApplicationDbContext, long>()`\r\nbut there is not overload for this method\r\n",
				"Url": "https://github.com/aspnet/Identity/issues/1864",
				"RelatedDescription": "Closed issue \"Can't configure Identity\" (#1864)"
			},
			{
				"Id": "339134116",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-07T10:03:39",
				"Actor": "ckams",
				"Number": "1863",
				"RawContent": null,
				"Title": "Feature Request—Consider providing ACL in ASP.NET Core Identity",
				"State": "open",
				"Body": "To get some context about the request, see the issue https://github.com/aspnet/Identity/issues/1859\r\n\r\n## Consider providing ACL in Identity\r\nWell as in the title: consider providing ACL in ASP.NET Core though Identity.\r\n\r\n### Some arguments\r\n- ACL is not something too much complex for enterprise level app… \r\n- What Identity provides today, **about group management**, is out to date (again see the issue [1859](https://github.com/aspnet/Identity/issues/1859))…\r\n- Other frameworks oriented **enterprise level app/webapp**, provide, out of the box, ACL support. (See, Zend frameworks, Joomla, etc…)\r\n    - **With all due respect, In comparison, Identity looks like a back to the Past…(there is simply no ACL support at all)**\r\n- Nothing prevents to suggest some improvements, **[or do not mention community involvement](https://www.asp.net/open-source)**…\r\n- You should \"write\" [for customers, **not for simplicity sake**, nor without listening customers](https://github.com/aspnet/Identity/issues/1859#issuecomment-403067317)… And I used to think that ASP.NET Core was for writing enterprise level app, not to write simple blog CMS, **with simplistic group support**…\r\n- it will not cost so much for you, to add ACL support.\r\n\r\n### Design\r\nIt will be simple to integrate some ACL support to Identity, without breaking anything (simply by adding few line of codes, again, take a look at [1859](https://github.com/aspnet/Identity/issues/1859)).\r\n\r\nFor the sake of demonstration:\r\n- Add an Acl table like `IdentityAcl`\r\n- Add a many-to-many relationship table between `IdentityRoles` and `IdentityAcl`;\r\n- Add to `ClaimsIdentity` and `ClaimsPrincipal` … the adequat properties (to avoid having recourse to `Scope` and `IdentityDbContext` for `AuthorizationHandler`)…\r\n- Good doc…\r\n\r\n### Some thoughts\r\nWe do not ask you to write for us our apps, but to provide us with a good, up to date, and real world use framework (**like other frameworks in the market**).",
				"Url": "https://github.com/aspnet/Identity/issues/1863",
				"RelatedDescription": "Open issue \"Feature Request—Consider providing ACL in ASP.NET Core Identity\" (#1863)"
			},
			{
				"Id": "339040922",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-06T21:39:35",
				"Actor": "wilsonrivera",
				"Number": "1862",
				"RawContent": null,
				"Title": "Fixed documentation typo",
				"State": "closed",
				"Body": "Corrected a typo on the XML documentation of the UserId property that made it read \"... sets the of the ...\"",
				"Url": "https://github.com/aspnet/Identity/pull/1862",
				"RelatedDescription": "Closed or merged PR \"Fixed documentation typo\" (#1862)"
			},
			{
				"Id": "337863779",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-06T15:04:21",
				"Actor": "ckams",
				"Number": "1859",
				"RawContent": null,
				"Title": "RoleClaims: Usages Designs and Questions",
				"State": "closed",
				"Body": "**Maybe I am missing something**, but I find RoleClaims \"badly considered\", even neglected.\r\n\r\nWhereas Role Claims/Group Claims are **essential for intranet Apps (Windows authentication), and \"general\" group membership**—without them, it will lead to some repetitive code, **or to write custom Identity**— I find that they are not \"user friendly\".\r\n\r\nSo I have some questions, and will share some thoughts.\r\n\r\n## Usages of RoleClaims\r\nWhat is the purpose of RoleClaims in Identity?\r\n- How to use them **accordingly to you**?\r\n    - This subject is not documented.\r\n    - I find no sample on github;\r\n- Do you consider to remove them in the future?\r\n    - It seems—badly considered—and that it could be…\r\n    - if yes, how you will replace them? (How??? Knowing that, most of us cannot rely on something \"ephemeral\")\r\n\r\n## Design and limitations\r\nIf we want to use RoleClaims as it should (in a many-to-many relationship) like AspNetUserRoles table, we find that some pieces are missing…\r\n- No documentation…\r\n- No many-to-many relationship table between Roles and Claims, ready to use;\r\n- Weird property `public virtual TKey RoleId { get; set; }` in `IdentityRoleClaim`;\r\n- Not ready to use in `AuthorizationHandler` as\r\n    - Nothing ready to use in `ClaimsIdentity` and `ClaimsPrincipal` classes, to get RoleClaims;\r\n    - If we use DI in `AuthorizationHandler`, we have to register the `AuthorizationHandler` as `scope` to get access to RoleManager/UserManager, etc…\r\n\r\n## Consequences\r\n- We have to do some choice: singleton vs RoleClaims access;\r\n- Write many-to-many relationship table between Roles and RoleClaims;\r\n- Keeping useless property `public virtual TKey RoleId { get; set; }` in `IdentityRoleClaim`;\r\n\r\n**But If we want to get something nice and simple, particularly with `AuthorizationHandler`:**\r\n- With or without the current RoleClaims Api, we have to dive into Identity Customization, **because nothing is ready to use as it should be…**\r\n\r\n## Conclusion\r\nCan you reconsider the importance of RoleClaims in Identity, and provide us \"a better design\"?",
				"Url": "https://github.com/aspnet/Identity/issues/1859",
				"RelatedDescription": "Closed issue \"RoleClaims: Usages Designs and Questions\" (#1859)"
			},
			{
				"Id": "338215212",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-05T15:45:58",
				"Actor": "zhulien-ivanov",
				"Number": "1861",
				"RawContent": null,
				"Title": "ConfirmEmailAsync in UserManager is not doing a check if the email is already confirmed",
				"State": "closed",
				"Body": "Hey. Shouldn't the **`ConfirmEmailAsync`** method in **`UserManager`** do a check if the email is already confirmed? Is it an adequate behaviour to successfully confirm an already confirmed email? It basically don't change the outcome in any way(and the operation can be considered as successful), because the email confirmation state stays the same, but shouldn't it be considered an exceptional behaviour and be accompanied with an error?",
				"Url": "https://github.com/aspnet/Identity/issues/1861",
				"RelatedDescription": "Closed issue \"ConfirmEmailAsync in UserManager is not doing a check if the email is already confirmed\" (#1861)"
			}],
			"ResultType": "GitHubIssue"
		},
		"Kestrel-Issues": {
			"Issues": [{
				"Id": "343743677",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-23T18:26:03",
				"Actor": "joshfree",
				"Number": "2744",
				"RawContent": null,
				"Title": "System.IO.IOException in Kestrel (.net core 2.1.300) on Windows",
				"State": "open",
				"Body": "Original issue from https://github.com/dotnet/core/issues/1798 \r\n\r\n\r\n**_@tamasVajda commented 5 days ago_**\r\nWe use .net core app with hosted Kestrel web server. During Some requests Kestrel throw the following exception at the end of the corresponding request:\r\n\r\n> info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]\r\n>       Request finished in 1.0512ms 200\r\n> info: Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets[14]\r\n>       Connection id \"0HLFB5I99V5O0\" communication error.\r\n> System.IO.IOException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond ---> System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketAwaitable.GetResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.ProcessReceives()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.DoReceive()\r\n>    --- End of inner exception stack trace ---\r\n> info: Microsoft.AspNetCore.Server.Kestrel[20]\r\n>       Connection id \"0HLFB5I99V5O0\" request processing ended abnormally.\r\n> System.IO.IOException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond ---> System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketAwaitable.GetResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.ProcessReceives()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.DoReceive()\r\n>    --- End of inner exception stack trace ---\r\n>    at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n>    at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n>    at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication`1 application)\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequestsAsync[TContext](IHttpApplication`1 application)\r\n>    at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n>    at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n>    at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.ProcessSends()\r\n>    at Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal.SocketConnection.DoSend() \r\n\r\nThe server tries to provide a file to the client like the following example:\r\n\r\n>  public async Task ProcessRequest(HttpContext context)\r\n>         {\r\n>  // some file operations\r\n>    string sourcePath = context.Request.Query[\"File2Download\"].ToString();\r\n>                if (!File.Exists(fileToSend))\r\n>                 {\r\n>                     context.Response.StatusCode = StatusCodes.Status404NotFound;\r\n>                     return;\r\n>                 }\r\n>                 await context.Response.SendFileAsync(fileToSend);\r\n> }\r\n\r\nOn client site we use System.Net.Http.HttpClient without redefining Default request header, and PostAsync to sending the get request to the server.\r\n\r\nIf the connection would broken it would throw kestrel connection lost exception instead of this. \r\n\r\nThis issue occurred just on Windows 10, on Cent OS 7, and on Debian 9 the same scenario doesn't cause this problem.\r\n\r\n Have you any idea what can cause this \r\n\r\n> System.IO.IOException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond ---> System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond   exception?\r\n\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2744",
				"RelatedDescription": "Open issue \"System.IO.IOException in Kestrel (.net core 2.1.300) on Windows\" (#2744)"
			},
			{
				"Id": "343269349",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T22:54:39",
				"Actor": "Tratcher",
				"Number": "2743",
				"RawContent": null,
				"Title": "Enable Http/2 by default",
				"State": "open",
				"Body": " #2720 Making the default protocols Http1 and Http2. We want this for the previews to gather feedback. If it doesn't work out we can disable it again for RTM.\r\n\r\nWith these defaults:\r\nFor TLS it will rely on ALPN to select Http2 or else fall back to Http1.\r\nFor non-TLS it will pick Http1 (I removed one error check to enable this).\r\n\r\nOnce we get stephen's flow control [PR](#2740) in then we should be ready for this.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2743",
				"RelatedDescription": "Open PR \"Enable Http/2 by default\" (#2743)"
			},
			{
				"Id": "342901827",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T20:07:23",
				"Actor": "dotnet-maestro-bot",
				"Number": "2738",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @halter73\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2738",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2738)"
			},
			{
				"Id": "343205219",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T18:27:28",
				"Actor": "Tratcher",
				"Number": "2742",
				"RawContent": null,
				"Title": "Consider using response headers & data padding",
				"State": "open",
				"Body": "https://tools.ietf.org/html/rfc7540#section-6.1\r\n\"   DATA frames MAY also contain padding.  Padding can be added to DATA\r\n   frames to obscure the size of messages.  Padding is a security\r\n   feature; see Section 10.7.\"\r\n\r\n\"The HEADERS frame can include padding. \"\r\n\r\nhttps://tools.ietf.org/html/rfc7540#section-10.7\r\n\"   Padding can be used to obscure the exact size of frame content and is\r\n   provided to mitigate specific attacks within HTTP, for example,\r\n   attacks where compressed content includes both attacker-controlled\r\n   plaintext and secret data (e.g., [BREACH]).\"\r\n\r\n@blowdart \r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2742",
				"RelatedDescription": "Open issue \"Consider using response headers & data padding\" (#2742)"
			},
			{
				"Id": "342124180",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T15:58:34",
				"Actor": "Tratcher",
				"Number": "2731",
				"RawContent": null,
				"Title": "Validate Http/2 pseudo headers",
				"State": "closed",
				"Body": " #2205 #2263 #2659 https://github.com/aspnet/KestrelHttpServer/issues/2154#issuecomment-395504675\r\n\r\nThese fields were not being properly validated or decoded (path). When they're invalid send a RST frame. The remaining exception is Host validation since the shared code there would need to be re-written, it currently sends a 400 which is passible.\r\n\r\nI split the Http2Connection tests into Http2Stream tests for behavior specific to the Http2Stream class.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2731",
				"RelatedDescription": "Closed or merged PR \"Validate Http/2 pseudo headers\" (#2731)"
			},
			{
				"Id": "343071376",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-20T11:23:13",
				"Actor": "leomathas",
				"Number": "2741",
				"RawContent": null,
				"Title": "ar",
				"State": "closed",
				"Body": "",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2741",
				"RelatedDescription": "Closed issue \"ar\" (#2741)"
			},
			{
				"Id": "342954893",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-20T02:52:40",
				"Actor": "halter73",
				"Number": "2740",
				"RawContent": null,
				"Title": "Implement HTTP/2 input flow control",
				"State": "open",
				"Body": "#2710",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2740",
				"RelatedDescription": "Open PR \"Implement HTTP/2 input flow control\" (#2740)"
			},
			{
				"Id": "342914601",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T22:44:13",
				"Actor": "ryanbrandenburg",
				"Number": "2739",
				"RawContent": null,
				"Title": "Broken tests: RegisterAddresses_HostName_Success et al",
				"State": "open",
				"Body": "This test [fails](http://aspnetci/viewLog.html?buildId=509500&buildTypeId=XPlat_HighSierraOsxUniverse) every time with on of the following errors:\r\n```\r\nSystem.Net.Sockets.SocketException : Device not configured\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetSocket(Uri requestUri)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStream(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(String requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_Success(String addressInput, String[] testUrls, Int32 testPort) in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 190\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_HostName_Success() in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 39\r\n--- End of stack trace from previous location where exception was thrown ---\r\n------- Stdout: -------\r\n| [0.001s] TestLifetime Information: Starting test RegisterAddresses_HostName_Success at 2018-07-19T04:58:28\r\n| [0.010s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting starting\r\n| [0.018s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting started\r\n| [0.018s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Loaded hosting startup assembly Sockets.FunctionalTests\r\n| [0.054s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting shutdown\r\n| [0.059s] TestLifetime Information: Finished test RegisterAddresses_HostName_Success in 0.057792s\r\n```\r\n[or](http://aspnetci/viewLog.html?buildId=509842&tab=buildResultsDiv&buildTypeId=XPlat_HighSierraOsxUniverse#testNameId-64104852415917104)\r\n```\r\n======= Failed test run #1 ==========\r\nSystem.Net.Sockets.SocketException : Connection refused\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetSocket(Uri requestUri)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStream(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(String requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_Success(String addressInput, String[] testUrls, Int32 testPort) in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 190\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_HostName_Success() in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 39\r\n--- End of stack trace from previous location where exception was thrown ---\r\n------- Stdout: -------\r\n| [0.001s] TestLifetime Information: Starting test RegisterAddresses_HostName_Success at 2018-07-19T19:19:11\r\n| [0.011s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting starting\r\n| [0.016s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting started\r\n| [0.017s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Loaded hosting startup assembly Sockets.FunctionalTests\r\n| [0.022s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting shutdown\r\n| [0.026s] TestLifetime Information: Finished test RegisterAddresses_HostName_Success in 0.024921s\r\n======= Failed test run #2 ==========\r\nSystem.Net.Sockets.SocketException : Connection refused\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetSocket(Uri requestUri)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStream(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(Uri requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Testing.HttpClientSlim.GetStringAsync(String requestUri, Boolean validateCertificate)\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_Success(String addressInput, String[] testUrls, Int32 testPort) in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 190\r\n   at Microsoft.AspNetCore.Server.Kestrel.FunctionalTests.AddressRegistrationTests.RegisterAddresses_HostName_Success() in /_/test/Kestrel.FunctionalTests/AddressRegistrationTests.cs:line 39\r\n--- End of stack trace from previous location where exception was thrown ---\r\n------- Stdout: -------\r\n| [0.001s] TestLifetime Information: Starting test RegisterAddresses_HostName_Success at 2018-07-19T19:23:23\r\n| [0.005s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting starting\r\n| [0.007s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting started\r\n| [0.007s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Loaded hosting startup assembly Libuv.FunctionalTests\r\n| [0.010s] Microsoft.AspNetCore.Hosting.Internal.WebHost Debug: Hosting shutdown\r\n| [0.014s] TestLifetime Information: Finished test RegisterAddresses_HostName_Success in 0.012739s\r\n```\r\n\r\nCC @Eilon for triaging.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2739",
				"RelatedDescription": "Open issue \"Broken tests: RegisterAddresses_HostName_Success et al\" (#2739)"
			},
			{
				"Id": "342469952",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T21:37:04",
				"Actor": "halter73",
				"Number": "2732",
				"RawContent": null,
				"Title": "Responses are sometimes written after the unexpected end of request content",
				"State": "closed",
				"Body": "There's a race that sometimes occurs when a connection is half closed mid request body where Kestrel will still write a response. This is even after the application code reading the request body observes the BadHttpRequestException. Even weirder yet, if the app swallows the BadHttpRequestException, a 200 status response will be written.\r\n\r\nSee [this](http://aspnetci/viewLog.html?buildId=507772&buildTypeId=Lite_KestrelStressTest).",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2732",
				"RelatedDescription": "Closed issue \"Responses are sometimes written after the unexpected end of request content\" (#2732)"
			},
			{
				"Id": "342897418",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T21:34:01",
				"Actor": "halter73",
				"Number": "2737",
				"RawContent": null,
				"Title": "Stop using InvalidOperationExceptions to signal invalid ASCII during parsing",
				"State": "open",
				"Body": "GetAsciiStringNonNullCharacters() currently throws an InvalidOperationException fo invalid or chacters, and the parsing logic catches these InvalidOperationExceptions at [various](https://github.com/aspnet/KestrelHttpServer/blob/6551eae321cd6306b485906ea47e8d41e932d65b/src/Kestrel.Core/Internal/Http/Http1Connection.cs#L469) [layers](https://github.com/aspnet/KestrelHttpServer/blob/6551eae321cd6306b485906ea47e8d41e932d65b/src/Kestrel.Core/Internal/Http/Http1Connection.cs#L261) to handle the bad request appropriately.\r\n\r\nIdeally we could switch to calling a TryGetAsciiStringNonNullCharacters method, but if propagating failure down the stack proves too difficult, we should at least move to a custom exception type so we don't end up obscuring real product bugs by inadvertently swallowing InvalidOperationExceptions thrown by other methods.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2737",
				"RelatedDescription": "Open issue \"Stop using InvalidOperationExceptions to signal invalid ASCII during parsing\" (#2737)"
			},
			{
				"Id": "342521214",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T21:18:58",
				"Actor": "halter73",
				"Number": "2734",
				"RawContent": null,
				"Title": "Stop writing responses after the unexpected end of request content",
				"State": "closed",
				"Body": "#2732 ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2734",
				"RelatedDescription": "Closed or merged PR \"Stop writing responses after the unexpected end of request content\" (#2734)"
			},
			{
				"Id": "341099998",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T20:25:38",
				"Actor": "Tratcher",
				"Number": "2722",
				"RawContent": null,
				"Title": "Kestrel test hangs (Control flow?)",
				"State": "closed",
				"Body": "I've seen several kestrel test CI hangs in the last week. E.g.:\r\nhttp://aspnetci/viewLog.html?buildId=504305&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\nhttp://aspnetci/viewLog.html?buildId=503757&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\nhttp://aspnetci/viewLog.html?buildId=503644&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\nhttp://aspnetci/viewLog.html?buildId=503531&buildTypeId=Lite_KestrelStressTest&tab=buildLog\r\n\r\nHere are some stacks that look like a new flow control deadlock. @halter73 \r\nGOAWAY_Received_RelievesConnectionBackpressure\r\n```\r\nThread id=4204\r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.Dispose() \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException abortReason) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException abortReason) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Stream.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException abortReason) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection+<ProcessRequestsAsync>d__41<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Runtime.CompilerServices.ValueTaskAwaiter+<>c.<.cctor>b__9_0(System.Object state) \r\nat System.IO.Pipelines.InlineScheduler.Schedule(System.Action<System.Object> action, System.Object state) \r\nat System.IO.Pipelines.Pipe.TrySchedule(System.IO.Pipelines.PipeScheduler scheduler, System.IO.Pipelines.CompletionData& completionData) \r\nat System.IO.Pipelines.Pipe.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Pipelines.Pipe+DefaultPipeWriter.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<FlushAsync>d__166.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<FlushAsync>d__166>(Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<FlushAsync>d__166& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests.FlushAsync(System.IO.Pipelines.PipeWriter writableBuffer) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests.SendAsync(System.ReadOnlySpan<System.Byte> span) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests.SendGoAwayAsync() \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<GOAWAY_Received_RelievesConnectionBackpressure>d__130.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action action, System.Boolean allowInlining, System.Threading.Tasks.Task& currentTask) \r\nat System.Threading.Tasks.Task.FinishContinuations() \r\nat System.Threading.Tasks.Task.FinishStageThree() \r\nat System.Threading.Tasks.Task<System.__Canon>.TrySetResult(System.__Canon result) \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame>.SetResult(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame result) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<ExpectAsync>d__199.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action action, System.Boolean allowInlining, System.Threading.Tasks.Task& currentTask) \r\nat System.Threading.Tasks.Task.FinishContinuations() \r\nat System.Threading.Tasks.Task.FinishStageThree() \r\nat System.Threading.Tasks.Task<System.__Canon>.TrySetResult(System.__Canon result) \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame>.SetResult(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame result) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<ReceiveFrameAsync>d__197.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Runtime.CompilerServices.ValueTaskAwaiter+<>c.<.cctor>b__9_0(System.Object state) \r\nat System.IO.Pipelines.InlineScheduler.Schedule(System.Action<System.Object> action, System.Object state) \r\nat System.IO.Pipelines.Pipe.TrySchedule(System.IO.Pipelines.PipeScheduler scheduler, System.IO.Pipelines.CompletionData& completionData) \r\nat System.IO.Pipelines.Pipe.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Pipelines.Pipe+DefaultPipeWriter.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StreamSafePipeFlusher.FlushAsync(System.Int64 count, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer outputProducer, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter.FlushAsync(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer outputProducer, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseStream.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Stream.FlushAsync() \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d>(Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0.<GOAWAY_Received_RelievesConnectionBackpressure>b__0(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7>(Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7& stateMachine) \r\nat Microsoft.AspNetCore.Testing.DummyApplication.ProcessRequestAsync(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequestsAsync<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection+<>c__58<Microsoft.AspNetCore.Http.HttpContext>.<StartStream>b__58_0(System.Object state) \r\nat System.Threading.QueueUserWorkItemCallback.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() \r\nat System.Threading.ThreadPoolWorkQueue.Dispatch() \r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() \r\nU-->M\r\n```\r\n```\r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter.WriteDataAsync(System.Int32 streamId, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2StreamOutputFlowControl flowControl, System.Buffers.ReadOnlySequence<System.Byte> data, System.Boolean endStream) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer+<ProcessDataWrites>d__19.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object stateMachine) \r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) \r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run() \r\nat System.Runtime.CompilerServices.ValueTaskAwaiter+<>c.<.cctor>b__9_0(System.Object state) \r\nat System.IO.Pipelines.InlineScheduler.Schedule(System.Action<System.Object> action, System.Object state) \r\nat System.IO.Pipelines.Pipe.TrySchedule(System.IO.Pipelines.PipeScheduler scheduler, System.IO.Pipelines.CompletionData& completionData) \r\nat System.IO.Pipelines.Pipe.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Pipelines.Pipe+DefaultPipeWriter.FlushAsync(System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StreamSafePipeFlusher.FlushAsync(System.Int64 count, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer outputProducer, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer.WriteDataAsync(System.ReadOnlySpan<System.Byte> data, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.WriteAsync(System.ReadOnlyMemory<System.Byte> data, System.Threading.CancellationToken cancellationToken) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseStream.WriteAsync(System.Byte[] buffer, System.Int32 offset, System.Int32 count, System.Threading.CancellationToken cancellationToken) \r\nat System.IO.Stream.WriteAsync(System.Byte[] buffer, System.Int32 offset, System.Int32 count) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d>(Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0+<<GOAWAY_Received_RelievesConnectionBackpressure>b__0>d& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Tests.Http2ConnectionTests+<>c__DisplayClass130_0.<GOAWAY_Received_RelievesConnectionBackpressure>b__0(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7>(Microsoft.AspNetCore.Testing.DummyApplication+<ProcessRequestAsync>d__7& stateMachine) \r\nat Microsoft.AspNetCore.Testing.DummyApplication.ProcessRequestAsync(Microsoft.AspNetCore.Http.HttpContext context) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequests>d__188<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>.MoveNext() \r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start<Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>>(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+<ProcessRequestsAsync>d__187<Microsoft.AspNetCore.Http.HttpContext>& stateMachine) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequestsAsync<Microsoft.AspNetCore.Http.HttpContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<Microsoft.AspNetCore.Http.HttpContext> application) \r\nat Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection+<>c__58<Microsoft.AspNetCore.Http.HttpContext>.<StartStream>b__58_0(System.Object state) \r\nat System.Threading.QueueUserWorkItemCallback.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() \r\nat System.Threading.ThreadPoolWorkQueue.Dispatch() \r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() \r\nU-->M\r\n```",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2722",
				"RelatedDescription": "Closed issue \"Kestrel test hangs (Control flow?)\" (#2722)"
			},
			{
				"Id": "342857282",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T20:25:02",
				"Actor": "dotnet-maestro-bot",
				"Number": "2736",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @davidfowl\n* @halter73\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2736",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2736)"
			},
			{
				"Id": "342594220",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-19T18:49:46",
				"Actor": "davidfowl",
				"Number": "2735",
				"RawContent": null,
				"Title": "Complete the transport pipes after connection middleware runs",
				"State": "closed",
				"Body": "- It's a safe guard for code that doesn't complete the pipes (makes sure we don't leak memory).\r\n- It simplifies writing ConnectionHandlers",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2735",
				"RelatedDescription": "Closed or merged PR \"Complete the transport pipes after connection middleware runs\" (#2735)"
			},
			{
				"Id": "341287512",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-19T17:56:41",
				"Actor": "VenkateshSrini",
				"Number": "2725",
				"RawContent": null,
				"Title": "Unable to use HTTPS certificate with Kestrel indocker",
				"State": "closed",
				"Body": "Hi,\r\nI have been trying to dockerize a Simple ASP.NET core API app running Kestrel with Https enabled. I have followed all the instructions available but nothing seems to work. A detailed issue is created here\r\n[Docker with HTTPS ASP.NET Core 2.1](https://github.com/dotnet/dotnet-docker/issues/630#issuecomment-404865564). The link also provides the code and various methods that we are trying to get it working. \r\n\r\nPlease help us in this regard\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2725",
				"RelatedDescription": "Closed issue \"Unable to use HTTPS certificate with Kestrel indocker\" (#2725)"
			},
			{
				"Id": "342518336",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-18T22:47:46",
				"Actor": "Tratcher",
				"Number": "2733",
				"RawContent": null,
				"Title": "Verify request and response Content-Length",
				"State": "open",
				"Body": "https://tools.ietf.org/html/rfc7540#section-8.1.2.6\r\n\r\nIn http2 requests and responses use the chunk style data frames to transfer the body and indicate when it's complete. However the Content-Length header is still supported and MUST be cross-checked against the number of bytes received or sent. A mismatch is a stream level protocol error.\r\n\r\nWe can also use the Content-Length tracking to know when to set the End_Stream flag rather than waiting until the app pipeline exits. Compare with https://github.com/aspnet/KestrelHttpServer/issues/2678\r\n(Q: How would that optimization interact with trailers? Related: https://github.com/aspnet/KestrelHttpServer/issues/2630) ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2733",
				"RelatedDescription": "Open issue \"Verify request and response Content-Length\" (#2733)"
			},
			{
				"Id": "341923938",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-17T13:39:37",
				"Actor": "baal2000",
				"Number": "2730",
				"RawContent": null,
				"Title": "Deeply recursive ConnectionAbortedException handling after HttpRequestStream.ValidateState ",
				"State": "open",
				"Body": "We are getting the following 850 calls deep recursive ConnectionAbortedException stack logged that does not cause any noticeable issues at the moment but still doesn't look right. \r\n\r\nKestrel and .Net Core version: 2.1.1\r\n\r\n```\r\nMicrosoft.AspNetCore.Connections.ConnectionAbortedException: The connection was aborted\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at System.IO.Pipelines.PipeCompletion.ThrowLatchedException()\r\n at System.IO.Pipelines.Pipe.GetReadResult(ReadResult& result)\r\n at System.IO.Pipelines.Pipe.GetReadAsyncResult()\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.AdaptedPipeline.WriteOutputAsync(Stream stream)\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.ValidateState(CancellationToken cancellationToken)\r\n at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.ReadAsync(...)\r\n at System.IO.StreamReader.ReadBufferAsync()\r\n at System.IO.StreamReader.ReadToEndAsyncInternal()  \r\n```",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2730",
				"RelatedDescription": "Open issue \"Deeply recursive ConnectionAbortedException handling after HttpRequestStream.ValidateState \" (#2730)"
			},
			{
				"Id": "341648195",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T22:13:35",
				"Actor": "gerardtoconnor",
				"Number": "2729",
				"RawContent": null,
				"Title": "Connection Hanging after prior request not closed out",
				"State": "closed",
				"Body": "I've tried my best to figure out the issue without opening an issue but nothing seems to work.\r\n\r\nI have been experimenting with a new web framework format for FSharp & TechEmpower benchmark tests and everything seemed fine but I noticed that when I try re-request a path the request stays stuck pending. It appears the prior request that delivered is not correctly closing out. I am returning a Task from a `AsyncTaskMethodBuilder` in my Invoke middleware and I am setting it's result at the very end of the final body write. I am able to run a HttpContext.Abort() after the SetResult and that removes the issue but some requests then come back as abort errors. Is there some way to force close out / Dispose of the connection/HttpContext as it seems there's a hanging reference or something that is preventing it being cleaned up/closed out\r\n\r\n[Middleware Invoke](https://github.com/gerardtoconnor/FrameworkBenchmarks/tree/master/frameworks/FSharp/Zebra/src/App/Program.fs)\r\n\r\n[Hybrid State Machine](https://github.com/gerardtoconnor/FrameworkBenchmarks/tree/master/frameworks/FSharp/Zebra/src/App/State.fs)\r\n\r\n```fsharp\r\n[<Struct>]\r\ntype FinishStateAwaiter(methodBuilder:AsyncTaskMethodBuilder,ctx:HttpContext) =\r\n    interface IAsyncStateMachine with\r\n        member __.MoveNext() =         \r\n            methodBuilder.SetResult()  // Sets result of Task returned at invoke which should close out connection\r\n            \r\n            ctx.Abort()  // << Forced to abort connection as stays open even after Task SetResult above\r\n        member __.SetStateMachine sm = methodBuilder.SetStateMachine sm \r\n```\r\n\r\n\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2729",
				"RelatedDescription": "Closed issue \"Connection Hanging after prior request not closed out\" (#2729)"
			},
			{
				"Id": "341347093",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T18:41:06",
				"Actor": "dotnet-maestro-bot",
				"Number": "2726",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @aspnetci\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit pull\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2726",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2726)"
			},
			{
				"Id": "341198133",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-16T17:55:21",
				"Actor": "halter73",
				"Number": "2724",
				"RawContent": null,
				"Title": "Fix deadlock in GOAWAY_Received_RelievesConnectionBackpressure",
				"State": "closed",
				"Body": "#2722\r\n\r\n@Tratcher ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2724",
				"RelatedDescription": "Closed or merged PR \"Fix deadlock in GOAWAY_Received_RelievesConnectionBackpressure\" (#2724)"
			},
			{
				"Id": "341587113",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T17:16:21",
				"Actor": "olamide1234",
				"Number": "2728",
				"RawContent": null,
				"Title": "Booking ",
				"State": "closed",
				"Body": "I want to know more ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2728",
				"RelatedDescription": "Closed issue \"Booking \" (#2728)"
			},
			{
				"Id": "341573742",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-16T15:45:15",
				"Actor": "Naragato",
				"Number": "2727",
				"RawContent": null,
				"Title": "Dev HTTPS Certificate not loading when assembly name differs from project name.",
				"State": "open",
				"Body": "If your project name differs from the assembly name the dev ssl certificate isn't loaded.  A certificate is created with the project name, but the library uses the assembly name.\r\n\r\nThe result is the following exception:\r\n\r\n```System.InvalidOperationException: 'Unable to configure HTTPS endpoint. No server certificate was \r\nspecified, and the default developer certificate could not be found.\r\nTo generate a developer certificate run 'dotnet dev-certs https'. To trust the certificate (Windows and macOS only) run 'dotnet dev-certs https --trust'.\r\nFor more information on configuring HTTPS see https://go.microsoft.com/fwlink/?linkid=848054.'\r\n```\r\n\r\nRenaming said certificate to the assembly works, until the certificate is recreated.  As a temporary work around I'm using a symbolic link.\r\n",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2727",
				"RelatedDescription": "Open issue \"Dev HTTPS Certificate not loading when assembly name differs from project name.\" (#2727)"
			},
			{
				"Id": "340756936",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T23:48:14",
				"Actor": "dotnet-maestro-bot",
				"Number": "2719",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n* @halter73\n* @natemcmaster\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2719",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2719)"
			},
			{
				"Id": "341116186",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-13T18:25:45",
				"Actor": "Eilon",
				"Number": "2723",
				"RawContent": null,
				"Title": "Need a better error message when kestrel cannot get the requested port",
				"State": "open",
				"Body": "_From @richlander on May 4, 2018 0:14_\n\n#This is what I see when Kestrel cannot get the port I asked for. This is on .NET Core 2.1 RC1 (with a 2.0 app).\r\n\r\n```console\r\npi@raspberrypi:~/dotnet-docker/samples/aspnetapp/aspnetapp $ export ASPNETCORE_URLS=http://+:80\r\npi@raspberrypi:~/dotnet-docker/samples/aspnetapp/aspnetapp $ dotnet run\r\ncrit: Microsoft.AspNetCore.Server.Kestrel[0]\r\n      Unable to start Kestrel.\r\nMicrosoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.UvException: Error -13 EACCES permission denied\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.LibuvFunctions.ThrowError(Int32 statusCode)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.LibuvFunctions.ThrowIfErrored(Int32 statusCode)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.Internal.Networking.LibuvFunctions.tcp_bind(UvTcpHandle handle, SockAddr\r\n```\n\n_Copied from original issue: aspnet/Home#3114_",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2723",
				"RelatedDescription": "Open issue \"Need a better error message when kestrel cannot get the requested port\" (#2723)"
			},
			{
				"Id": "340801614",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T03:34:13",
				"Actor": "natemcmaster",
				"Number": "2721",
				"RawContent": null,
				"Title": "[2.1]: pin baseline package versions to 2.1.2",
				"State": "closed",
				"Body": "Part of https://github.com/aspnet/Home/issues/3316\n\nThis pins package versions to the 2.1.2 baseline. Universe will not override variables in the 'Pinned' section. This helps ensure that this repo does not upgrade its dependency versions for all future patches of 2.1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2721",
				"RelatedDescription": "Closed or merged PR \"[2.1]: pin baseline package versions to 2.1.2\" (#2721)"
			},
			{
				"Id": "340494645",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-13T00:21:40",
				"Actor": "natemcmaster",
				"Number": "2717",
				"RawContent": null,
				"Title": "[2.1] Remove usage of the Microsoft.Extensions.Buffers.Sources package",
				"State": "closed",
				"Body": "This moves source code that used to be in aspnet/Common. It was only used here, so this simplifies the process of working with these internal-only APIs.\r\n\r\ncref https://github.com/aspnet/Common/pull/386",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2717",
				"RelatedDescription": "Closed or merged PR \"[2.1] Remove usage of the Microsoft.Extensions.Buffers.Sources package\" (#2717)"
			},
			{
				"Id": "340788716",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T20:36:09",
				"Actor": "Tratcher",
				"Number": "2720",
				"RawContent": null,
				"Title": "Enable Http/2 by default for TLS connections",
				"State": "open",
				"Body": "This is an ask from @DamianEdwards and @shirhatti. \r\n\r\nPreferably this will be enabled for preview1 so we can get feedback. ",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2720",
				"RelatedDescription": "Open issue \"Enable Http/2 by default for TLS connections\" (#2720)"
			},
			{
				"Id": "340393218",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-12T18:20:49",
				"Actor": "halter73",
				"Number": "2715",
				"RawContent": null,
				"Title": " Merge branch 'release/2.1' into release/2.2",
				"State": "closed",
				"Body": "#2709",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2715",
				"RelatedDescription": "Closed or merged PR \" Merge branch 'release/2.1' into release/2.2\" (#2715)"
			},
			{
				"Id": "340728308",
				"IsPullRequest": true,
				"CreatedAt": "2018-07-12T17:46:28",
				"Actor": "dotnet-maestro-bot",
				"Number": "2718",
				"RawContent": null,
				"Title": "[automated] Merge branch 'release/2.2' => 'master'",
				"State": "closed",
				"Body": "I detected changes in the release/2.2 branch which have not been merged yet to master.\r\nI'm a robot and am configured to help you automatically keep master up to date, so\r\nI've opened this PR.\r\n\r\nThis PR merges commits made on release/2.2 by the following committers:\n\n\r\n\r\n## Instructions for merging\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, please complete this PR\r\nby creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nYou can also do this on command line:\r\n```\r\ngit checkout master\r\ngit fetch --force https://github.com/dotnet-maestro-bot/KestrelHttpServer merge/release/2.2-to-master:merge/release/2.2-to-master\r\ngit merge merge/release/2.2-to-master\r\ngit push\r\n```\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging.\r\n\r\nPlease contact ASP.NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.",
				"Url": "https://github.com/aspnet/KestrelHttpServer/pull/2718",
				"RelatedDescription": "Closed or merged PR \"[automated] Merge branch 'release/2.2' => 'master'\" (#2718)"
			},
			{
				"Id": "340477675",
				"IsPullRequest": false,
				"CreatedAt": "2018-07-12T03:35:33",
				"Actor": "FZ14",
				"Number": "2716",
				"RawContent": null,
				"Title": "Windows Authentication (Kerberos/NTLM) in asp.net core linux",
				"State": "open",
				"Body": "Hello.\r\nEnterprise Application Development still requires Windows Authentication (via NTLM/Kerberos).\r\nIt perhaps in asp.net core development model on kestrel server in Linux?",
				"Url": "https://github.com/aspnet/KestrelHttpServer/issues/2716",
				"RelatedDescription": "Open issue \"Windows Authentication (Kerberos/NTLM) in asp.net core linux\" (#2716)"
			}],
			"ResultType": "GitHubIssue"
		}
	},
	"RunOn": "2018-07-24T05:30:22.990787Z",
	"RunDurationInMilliseconds": 17242
}
