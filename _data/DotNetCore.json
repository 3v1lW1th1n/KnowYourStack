{"Data":{"Blog":{"FeedItems":[{"Title":"Introducing Tensor for multi-dimensional Machine Learning and AI data","PublishedOn":"2017-11-15T22:00:18+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Overview Tensor is an exchange type for homogenous multi-dimensional data for 1 to N dimensions. The motivation behind introducing Tensor&#60;T&#62; is to make it easy for Machine Learning library...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/introducing-tensor-for-multi-dimensional-machine-learning-and-ai-data/","RawContent":null},{"Title":"Introducing Nullable Reference Types in C#","PublishedOn":"2017-11-15T20:00:47+00:00","CommentsCount":37,"FacebookCount":0,"Summary":"Today we released a prototype of a C# feature called &#8220;nullable reference types&#8220;, which is intended to help you find and fix most of your null-related bugs before they blow up at runtime....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/","RawContent":null},{"Title":"Announcing F# support for .NET Core and .NET Standard projects in Visual Studio","PublishedOn":"2017-11-15T19:00:49+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"We&#8217;re pleased to announce that Visual Studio 2017 15.5 Preview 4 now supports F# projects targeting .NET Core, .NET Standard, and .NET Framework through the .NET Core SDK. Some of you have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/announcing-f-support-for-net-core-and-net-standard-projects-in-visual-studio/","RawContent":null},{"Title":"Welcome to C# 7.2 and Span","PublishedOn":"2017-11-15T19:00:26+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"C# 7.2 is the latest point release of C#, and adds a number of small but useful features. All the features are described in wonderful detail in the docs. Start with the overview, What&#8217;s new in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/welcome-to-c-7-2-and-span/","RawContent":null},{"Title":".NET Core November 2017 Update","PublishedOn":"2017-11-15T05:25:23+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core November Update. This includes .NET Core 1.0.8, 1.1.5 and 2.0.1 and .NET Core SDK 1.1.5 and 2.0.3. Details regarding the security issues addressed by this release...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-core-november-2017-update/","RawContent":null},{"Title":".NET Framework November 2017 Security and Quality Rollup","PublishedOn":"2017-11-15T03:54:36+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Today, we are releasing the November 2017 Security and Quality Rollup. Security This release contains no new security updates. The most recent .NET security updates were shipped with the September...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-framework-november-2017-security-and-quality-rollup/","RawContent":null},{"Title":"Modernize existing .NET apps with Windows Containers and Azure","PublishedOn":"2017-11-01T23:14:48+00:00","CommentsCount":22,"FacebookCount":0,"Summary":"As part of the series of posts announced at this initial blog post (.NET Application Architecture Guidance) that explores each of the architecture areas currently covered by our team, this current...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/01/modernize-existing-net-apps-with-windows-containers-and-azure/","RawContent":null},{"Title":"Introducing API Analyzer","PublishedOn":"2017-10-31T23:24:24+00:00","CommentsCount":31,"FacebookCount":0,"Summary":"This post was written by Olia Gavrysh. Have you ever wondered which APIs are deprecated and which should you use instead? Or have you ever used an API and then found out it didn&#8217;t work on Mac or...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/31/introducing-api-analyzer/","RawContent":null},{"Title":"Welcome to C# 7.1","PublishedOn":"2017-10-31T22:39:48+00:00","CommentsCount":78,"FacebookCount":0,"Summary":"With C# we have always tended towards major releases: bundle a lot of features up, and release less frequently. We even went so far as routinely omitting the traditional &#34;.0&#34; when we talked...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/31/welcome-to-c-7-1/","RawContent":null},{"Title":"Moving to real time test discovery in Test Explorer","PublishedOn":"2017-10-30T22:46:58+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"Real time test discovery is a new Visual Studio feature that uses a Roslyn analyzer to discover tests and populate the test explorer in real time without requiring you to build your project. This...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/30/real-time-test-discovery/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6816687850","Type":"IssuesEvent","CreatedAt":"2017-11-06T20:30:07","Actor":"Petermarcu","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Closed issue \"File system watcher crash\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."},{"Id":"6797468573","Type":"PullRequestEvent","CreatedAt":"2017-11-01T23:04:17","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Opened pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6767783059","Type":"IssuesEvent","CreatedAt":"2017-10-26T05:52:31","Actor":"HarelM","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Opened issue \"File system watcher crach\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6854176970","Type":"IssuesEvent","CreatedAt":"2017-11-14T18:00:49","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Reopened issue \"Microsoft Security Advisory CVE-2017-11770 : Malformed Certificate can cause Denial of Service\" (#44) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-11770 \r\n## Malformed Certificate can cause Denial of Service\r\n### Executive Summary \r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1, and 2.0. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed certificate or other ASN.1 formatted data could lead to a denial of service via an infinite loop on Linux and macOS.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.8, 1.1.5 and 2.0.1. Developers are advised to update their .NET Core SDK to version 2.0.3 or 1.1.5.\r\n### Discussion\r\n\r\nPlease use **** TODO: FILL IN ISSUE LINK *** for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n.NET Core applications running on Windows are not affected by this vulnerability. \r\n\r\n## Affected Software\r\nThe vulnerabilities affect any Microsoft .NET Core project if it uses any of affected runtime versions listed blow and is running on Linux.\r\n\r\nPlatform  | Runtime Version | Fixed runtime version\r\n----------------|----------------| -------------------------\r\nLinux | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.7<br />1.1.0, 1.1.1, 1.1.2, 1.1.4<br />2.0.0 |  1.0.8<br />1.1.5<br />2.0.1\r\nmacOS | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.7<br />1.1.0, 1.1.1, 1.1.2, 1.1.4 |  1.0.8<br />1.1.5\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.7 or lower, or 1.1.2 or lower, or 2.0.0 is affected. The default version of the .NET core runtime can be listed by running `dotnet --info`, which should produce output in the form of \r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n\r\n```\r\n\r\nAs this only displays the latest version of the runtime installed it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. By default these are\r\n\r\n| Operating System          | Location          |\r\n|---------------------------|-------------------|\r\n| macOS | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/       |\r\n| Supported Linux platforms | /usr/share/dotnet/shared/Microsoft.NETCore.App/       |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you do not have a directory for 1.0.8, 1.1.5 or 2.0.1 then any applications targeting .NET Core will be vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest runtimes or SDKs. Typically application servers only install a runtime package, developer machines install SDKs. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). Version 1.1.5 will also install version 1.0.8 of the runtime.\r\n\r\nIf you have built a [self-contained application](https://docs.microsoft.com/en-us/dotnet/core/deploying/#self-contained-deployments-scd) you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n## Other Information\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including Terms and Conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue where you can ask questions.\r\n\r\n### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [application.runtime.config](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application and editing the framework version and setting `rollForward` to `false`. This should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nNote that this file is optional, you may need to create it for each application alongside the executable.\r\n\r\n### Acknowledgments\r\n\r\nThanks to Bachraty Gergely for reporting this issue.\r\n\r\n### External Links\r\n\r\n[CVE-2017-11770](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8585)\r\n\r\n### Revisions\r\n\r\nV1.0 (Nov 14, 2017): Advisory published.\r\n\r\n_Version 1.0_\r\n_Last Updated 2017-11-14_"},{"Id":"6853282986","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:23:02","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/48","RelatedDescription":"Closed issue \"Reserved\" (#48) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853280485","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:35","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/47","RelatedDescription":"Closed issue \"Reserved\" (#47) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n\r\n"},{"Id":"6853280272","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:33","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/47","RelatedDescription":"Opened issue \"Reserved\" (#47) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n\r\n"},{"Id":"6853278942","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:20","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/46","RelatedDescription":"Closed issue \"Reserved\" (#46) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853278548","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/46","RelatedDescription":"Opened issue \"Reserved\" (#46) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853276874","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:58","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/45","RelatedDescription":"Closed issue \"Reserved\" (#45) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853274106","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:28","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Closed issue \"Reserved\" (#44) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853272527","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:12","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Opened issue \"Reserved\" (#44) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6840049093","Type":"IssuesEvent","CreatedAt":"2017-11-10T22:00:55","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/27","RelatedDescription":"Reopened issue \"microsoft/dotnet Docker Hub README adopts segmented OS/Arch style\" (#27) at dotnet/announcements","RelatedBody":"# microsoft/dotnet Docker Hub README adopts segmented OS/Arch style\r\n\r\nThe Docker Hub README style used by [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) and [microsoft/dotnet-nightly](https://hub.docker.com/r/microsoft/dotnet-nightly/) has been updated to use a new model that is segmented by OS and chip architecture.\r\n\r\nYou can see an example of the new style in the following image. \r\n\r\n<img width=\"803\" alt=\"screen shot 2017-08-13 at 10 44 34 pm\" src=\"https://user-images.githubusercontent.com/2608468/29259667-0c73b3e4-8079-11e7-9c43-26894534ca7a.png\">\r\n\r\n## Discussion\r\n\r\nYou can share your thoughts on this change or see what others are saying at:\r\n\r\n* [dotnet/dotnet-docker #275](https://github.com/dotnet/dotnet-docker/issues/275)\r\n\r\n## Details\r\n\r\n* [dotnet/dotnet-docker-nightly #328](https://github.com/dotnet/dotnet-docker-nightly/pull/328)\r\n* [moby/moby #33759](https://github.com/moby/moby/issues/33759)\r\n\r\nThe [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) repo (and by extension [microsoft/dotnet-nightly](https://hub.docker.com/r/microsoft/dotnet-nightly/)) has been steadily  growing with each release of .NET Core and also of the underlying operating systems that we support. We wanted to present simple-to-read tag lists.  As the repo has grown, the tag list has gotten longer and more complicated. \r\n\r\nThe addition of `arm32v7` to the repo caused us to spend considerable time thinking about repo organization generally. We looked at other approaches and also talked to Docker employees about their long-term plans for `arm32v7` in particular.\r\n\r\nWe considered various options:\r\n\r\n* Split the repo by architecture (this seemed to match what Debian and other official repos were doing). See [debian](https://hub.docker.com/_/debian/) and [arm32v7/debian](https://hub.docker.com/r/arm32v7/debian/). Note how the [Debian GitHub repo](https://github.com/debuerreotype/docker-debian-artifacts) is structured, branching by architecture.\r\n* Split the repo by SDK and Runtime. We've discussed this multiple times but we believe that discoverability would be a significant challenge. Also, other peer development platforms do not segment on the SDK/Runtime boundary.\r\n* Stay the course on the repo structure, but adopt a new (hopefully better) approach for the tag list.\r\n\r\nThere are three main reasons that we adopted a new README style:\r\n\r\n* Multi-arch tags are visually awkward when you have multiple versions of an operating system for a given tag type. For example, the dotnet repo offers both Debian 8 and 9 variants of the `2-sdk` tag. Only one of them can participate in the multi-arch tag while the other variant (in this case Debian 8) is only available with the longer tag name: `2.0.0-sdk-jessie`. The way the bullets in the tag list compose looks odd, as you can see in the following image. It also doesn't communicate the relationship between tags well. <img width=\"724\" alt=\"screen shot 2017-08-13 at 11 14 22 pm\" src=\"https://user-images.githubusercontent.com/2608468/29260189-2f58da84-807d-11e7-868e-7e1f888fd42d.png\">\r\n* A multi-arch-first tag list works well when all OSes offer the same image types, but is poor at showing differences when they don't. The .NET Core offering for `arm32v7` is quite limited currently. We wanted to make that obvious.\r\n* We believe that most users look at the README with a specific OS in mind. We thought that it was best to cater to that, providing a simplified view for a given OS.\r\n\r\nThe downside is that this README style is unique (AFAIK). We've never tried to be novel with our Docker offering, but fit into existing conventions. This is our first significant departure from Docker norms. There is a lot changing in the Docker space, with multi-arch and `arm32v7` being top of the list (as it relates to this topic). As a result, we thought that now was a good time for experimentation based on the conclusion that the existing README style no longer scales to our needs. Our conversations with Docker employees also led us to believe that there are no good established answers to these challenges.\r\n\r\nPlease give us your feedback @ [dotnet/dotnet-docker #275](https://github.com/dotnet/dotnet-docker/issues/275)."},{"Id":"6840048672","Type":"IssuesEvent","CreatedAt":"2017-11-10T22:00:48","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/24","RelatedDescription":"Reopened issue \" .NET Standard 2.0 is final\" (#24) at dotnet/announcements","RelatedBody":"## Summary\r\n\r\n[.NET Standard 2.0](https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md) is final. \r\n\r\nYou can now start producing .NET Standard 2.0 libraries and NuGet packages. Please use the latest [.NET Core 2.0 Preview 2](https://www.microsoft.com/net/core/preview) as it contains many improvements that were necessary to provide a good experience.\r\n      \r\n## Details\r\n\r\n* **Bigger API Surface**: We have more than doubled the set of available APIs from **13k** in [.NET Standard 1.6](https://github.com/dotnet/standard/blob/master/docs/versions/netstandard1.6.md) to **32k** in [.NET Standard 2.0](https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md). Most of the added APIs are .NET Framework APIs. These additions make it much easier to port existing code to .NET Standard, and, by extension, to any .NET implementation of .NET Standard, such as .NET Core 2.0 and the upcoming version of UWP.\r\n\r\n* **.NET Framework compatibility mode**: The vast majority of NuGet packages are currently still targeting .NET Framework. Many projects are currently blocked from moving to .NET Standard because not all their dependencies are targeting .NET Standard yet. That's why we added a compatibility mode that allows .NET Standard projects to depend on .NET Framework libraries as if they were compiled for .NET Standard. Of course, this may not work in all cases (for instance, if the .NET Framework binaries uses WPF), but we found that [70% of all NuGet packages on nuget.org are API compatible][video] with .NET Standard 2.0, so in practice it unblocks many projects.\r\n\r\n[video]: https://www.youtube.com/watch?v=iIlQer4LEac\r\n\r\n* **Broad platform support**. .NET Standard 2.0 is [supported on the following platforms](https://github.com/dotnet/standard/blob/master/docs/versions.md):\r\n    - .NET Framework 4.6.1\r\n    - .NET Core 2.0\r\n    - Mono 5.4\r\n    - Xamarin.iOS 10.14\r\n    - Xamarin.Mac 3.8\r\n    - Xamarin.Android 7.5\r\n    - UWP is work in progress and will ship later this year.\r\n\r\n## Tooling Prerequisites\r\n\r\nIn general, make sure you run the latest version of the tooling:\r\n\r\n* **.NET Core SDK**. You always need to install [.NET Core 2.0 Preview 2](https://www.microsoft.com/net/core/preview). This also includes the CLI (`dotnet`) for building packages, so if you only want to use the CLI, you can stop here.\r\n* **Visual Studio**. If you want to use Visual Studio for authoring .NET Standard 2.0 libraries, you also need to install [Visual Studio 2017 15.3](https://www.visualstudio.com/vs/preview/). Make sure to use 15.3 and not an earlier version, as this release addressed a couple of key issues to provide a good experience. If you only need to consume .NET Standard 2.0 libraries, you can do that even in Visual Studio 2015 but you'll need NuGet client 3.6 or higher ([download from Nuget.org/downloads](https://www.nuget.org/downloads))\r\n* **Visual Studio for Mac**. The latest version of [Visual Studio for Mac](https://www.visualstudio.com/vs/visual-studio-mac/) supports building .NET Standard 2.0 libraries. \r\n* **Rider**. The [latest version](https://www.jetbrains.com/rider/download) also has support for .NET Standard 2.0.\r\n\r\nLearn more [by reading the .NET Standard FAQ](http://aka.ms/netstandardfaq).\r\n\r\n## Discussion\r\n\r\nFor discussion, see https://github.com/dotnet/standard/issues/439."},{"Id":"6840048225","Type":"IssuesEvent","CreatedAt":"2017-11-10T22:00:40","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/22","RelatedDescription":"Reopened issue \".NET Core Support for macOS High Sierra\" (#22) at dotnet/announcements","RelatedBody":"# .NET Core Support for macOS High Sierra\r\n\r\n## Summary\r\n\r\n.NET Core 1.x and 2.0 do not currently support macOS High Sierra (version 10.13, currently in beta) due to changes in macOS. The .NET Core team has been testing macOS High Sierra builds and has filed bugs with Apple so that the two products can work better together.\r\n\r\nWe intend to have both .NET Core 1.x and 2.0 supporting macOS High Sierra by the time Apple ships the final production release. We are hoping to ship .NET Core 2.0 RTW with High Sierra support.\r\n\r\nAs .NET Core support for macOS High Sierra is improved, this announcement will be updated with the new status.\r\n\r\n## Impact\r\n\r\n.NET Core does not work on macOS High Sierra.\r\n\r\n## Details\r\n\r\n* [dotnet/core #677](https://github.com/dotnet/core/issues/677) -- tracking bug\r\n* [dotnet/corefx #22243](https://github.com/dotnet/corefx/pull/22243) -- workaround for issue 33294006, listed below.\r\n\r\nWe have reported the following issues to Apple as part of supporting .NET Core on macOS High Sierra.\r\n\r\n> Note: The issue links can only be accessed by Apple employees.\r\n\r\n* [33275095](https://bugreport.apple.com/web/?problemID=33275095) SSL Failure: macOS 10.13 (17A291j) SecureTransport in server mode can select ciphersuites not applicable to the TLS version.\r\n\r\n    **.NET Core Note:** When hosting an [SslStream](https://docs.microsoft.com/dotnet/api/system.net.security.sslstream?view=netcore-2.0) limited to TLS 1.0 or TLS 1.1 clients other than Apple SecureTransport may fail to connect.\r\n\r\n* [33143630](https://bugreport.apple.com/web/?problemID=33143630) macOS 10.13 (17A291j) SecTrustExecute fails with no error building revocation-enabled chain against a self-issued certificate.\r\n    \r\n    **.NET Core Note:** In this situation an Apple-specific derived type of CryptographicException will be thrown with a message of “No error”.\r\n\r\n* [33294006](https://bugreport.apple.com/web/?problemID=33294006) macOS 10.13 (17A291j) libcurl changing to LibreSSL changes thread-safety model from safe to unsafe \r\n    \r\n    **.NET Core Note:** A functioning workaround is in place, but it may regress performance for parallel HTTP requests (to avoid crashes caused by the loss of thread safety).\r\n\r\n* [32948209](https://bugreport.apple.com/web/?problemID=32948209) CCCryptorReset returns kCCUnimplemented for ECB on 10.13.\r\n\r\n    **.NET Core Note:** .NET Core has worked around this regression, so it should not be user-impacting."}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6862326432","Type":"PullRequestEvent","CreatedAt":"2017-11-16T04:36:42","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15045","RelatedDescription":"Merged pull request \"don't use Compiler:: if we are currently in this namescape.\" (#15045) at dotnet/coreclr","RelatedBody":"It can confuse that this method does not have access to the Compiler fields.\r\n"},{"Id":"6862049261","Type":"PullRequestEvent","CreatedAt":"2017-11-16T02:47:02","Actor":"morganbr","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14863","RelatedDescription":"Merged pull request \"HashCode based on xxHash32\" (#14863) at dotnet/coreclr","RelatedBody":"## [Migrated Pull Request](https://github.com/dotnet/corefx/pull/25013)\r\n\r\nSee the original PR for full discussion on the code.\r\n\r\nFixes [\"Proposal: Add System.HashCode to make it easier to generate good hash codes.\"](https://github.com/dotnet/corefx/issues/14354) in corefx.\r\n\r\nWorks by maintaining the xxHash32 state variables (v1 -> v4, length) as well as a queue of values that fall outside of the block size (16 bytes/4 ints). The seed is initialized to random bytes.\r\n\r\nTests against known xxHash32 vectors are provided in the original pull request.\r\n\r\n## [Performance](https://github.com/jcdickinson/Benchmarks/tree/corefx-hashcode)\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.10.9, OS=Windows 10 Redstone 2 (10.0.15063)\r\nProcessor=Intel Core i7-4800MQ CPU 2.70GHz (Haswell), ProcessorCount=8\r\nFrequency=2630627 Hz, Resolution=380.1375 ns, Timer=TSC\r\n.NET Core SDK=2.0.2\r\n  [Host]     : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT\r\n  DefaultJob : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT\r\n\r\n\r\n```\r\n |                  Method |     Mean |     Error |    StdDev | Scaled |\r\n |------------------------ |---------:|----------:|----------:|-------:|\r\n |                  Unsafe | 79.98 ns | 1.4723 ns | 1.3772 ns |   1.00 |\r\n |    'Calls, No Inlining' | 40.34 ns | 0.1778 ns | 0.1576 ns |   0.50 |\r\n | 'Unrolled, No Inlining' | 12.19 ns | 0.0433 ns | 0.0384 ns |   0.15 |\r\n |       'Calls, Inlining' | 34.55 ns | 0.1372 ns | 0.1216 ns |   0.43 |\r\n |    'Unrolled, Inlining' | 12.22 ns | 0.0885 ns | 0.0785 ns |   0.15 |\r\n\r\n## Deviations from xxHash32\r\n\r\n* Length is stored as the number of hashed fields (not bytes). It is multiplied at the end by 4 so that it behaves exactly like xxHash32.\r\n* The structure won't accept more than `uint.MaxValue` values, failing with an `OverflowException`. This is to prevent the possibility of it re-initializing.\r\n* The code that mixes in individual bytes is omitted - this struct only accepts `int`.\r\n\r\n\r\n## 3rd Party Code\r\n\r\nSubmission containing materials of a third party: \r\n\r\n | Author | Project | License | Comments |\r\n |------- |--------:|--------:|---------:|\r\n | Cyan4973 | [xxHash](https://github.com/Cyan4973/xxHash) | BSD | Reference, not copied code |\r\n\r\ncc: @morganbr"},{"Id":"6862022562","Type":"PullRequestEvent","CreatedAt":"2017-11-16T02:37:24","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15040","RelatedDescription":"Merged pull request \"Fix calling convention gap in ILGenerator.EmitCalli\" (#15040) at dotnet/coreclr","RelatedBody":"ILGenerator is missing the overload of EmitCalli that takes a System.Runtime.InteropServices.CallingConvention enum. This is the unmanaged calling convention enum that includes CDecl.\r\n\r\nFixes: https://github.com/dotnet/corefx/issues/9800"},{"Id":"6861855957","Type":"IssuesEvent","CreatedAt":"2017-11-16T01:37:49","Actor":"RussKeldorph","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/14077","RelatedDescription":"Closed issue \"Can not connect to remote Raspberry PI running Windows IoT over SSH by Visual Studio 2017\" (#14077) at dotnet/coreclr","RelatedBody":"When connecting to remote Raspberry PI running Windows IoT over SSH by Visual Studio 2017 (version 15.3.4), there is an error so that can not connect successfully.  The exception information such as:\r\n\r\n`liblinux.ExceptionBase: Could not retrieve the system properties. Please see the inner exception for more details. ---> liblinux.Shell.CommandingException: Timed out executing command 'cat /etc/*-release', waited for 15137.9066ms. ---> liblinux.Ssh.Common.SshOperationTimeoutException: Command 'cat /etc/*-release' has timed out.\r\n   at liblinux.Ssh.SshCommand.WaitOnHandle(WaitHandle waitHandle)\r\n   at liblinux.Ssh.SshCommand.EndExecute(IAsyncResult asyncResult)\r\n   at liblinux.Shell.NonHostedCommand.OnRun()\r\n   --- End of inner exception stack trace ---\r\n   at liblinux.Shell.NonHostedCommand.OnRun()\r\n   at liblinux.Shell.CommonCommandBase.Run()\r\n   at liblinux.Shell.CommandHost.ExecuteCommand(String commandText, TimeSpan timeout)\r\n   at liblinux.Shell.CommandHost.ExecuteCommand(String commandText, Int32 timeout)\r\n   at liblinux.Shell.CommandHost.ExecuteCommand(String commandText)\r\n   at liblinux.DistributionId.GetSystemId(IRemoteSystem remoteSystem)\r\n   at liblinux.DistributionId.GetDistributionId(IRemoteSystem remoteSystem)\r\n   at liblinux.SystemProperties.Populate()\r\n   --- End of inner exception stack trace ---\r\n   at liblinux.SystemProperties.Populate()\r\n   at liblinux.SystemProperties..ctor(IRemoteSystem remoteSystem)\r\n   at liblinux.UnixSystem.get_Properties()\r\n   at SSHConnectionUI.MainWindow.login_Click(Object sender, RoutedEventArgs e)\r\n`\r\n\r\nBut when using Putty or SecureCRT tool to connect, it is ok. Additionally, visual studio 2017 can connect to remote Raspberry PI running with Linux.\r\n"},{"Id":"6861787949","Type":"PullRequestEvent","CreatedAt":"2017-11-16T01:14:19","Actor":"safern","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15048","RelatedDescription":"Merged pull request \"Mark packages as non-stable and bump to 1.0.11 servicing\" (#15048) at dotnet/coreclr","RelatedBody":"cc: @weshaggard "},{"Id":"6861743297","Type":"PullRequestEvent","CreatedAt":"2017-11-16T00:59:13","Actor":"safern","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15055","RelatedDescription":"Opened pull request \"Mark packages as non-stable and bump to 1.1.6\" (#15055) at dotnet/coreclr","RelatedBody":"cc: @weshaggard "},{"Id":"6861559996","Type":"PullRequestEvent","CreatedAt":"2017-11-15T23:57:01","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15054","RelatedDescription":"Opened pull request \"Update CoreClr to preview1-25915-04 (master)\" (#15054) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6862279279","Type":"PullRequestEvent","CreatedAt":"2017-11-16T04:15:46","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8030","RelatedDescription":"Merged pull request \"Update SDK to 15.5.0-preview-20171116-1\" (#8030) at dotnet/cli","RelatedBody":""},{"Id":"6861936039","Type":"PullRequestEvent","CreatedAt":"2017-11-16T02:06:23","Actor":"AndyGerlicher","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8031","RelatedDescription":"Opened pull request \"MSBuild 15.5.179\" (#8031) at dotnet/cli","RelatedBody":"Drop preview tag, no other changes. Shiproom approved, PR here: https://devdiv.visualstudio.com/DevDiv/MSBuild/_git/VS/pullrequest/94489?_a=overview"},{"Id":"6861803346","Type":"PullRequestEvent","CreatedAt":"2017-11-16T01:19:41","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8029","RelatedDescription":"Merged pull request \"Update CoreSetup to preview1-25915-02 (master)\" (#8029) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6861793701","Type":"PullRequestEvent","CreatedAt":"2017-11-16T01:16:17","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8030","RelatedDescription":"Opened pull request \"Update SDK to 15.5.0-preview-20171116-1\" (#8030) at dotnet/cli","RelatedBody":""},{"Id":"6861621828","Type":"IssuesEvent","CreatedAt":"2017-11-16T00:16:56","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/8028","RelatedDescription":"Closed issue \"Where is the 2.0.3 SDK?\" (#8028) at dotnet/cli","RelatedBody":"Links on Github are broken and I can't seem to find the download anywhere.\r\n\r\nMagically my developer machine automatically got this installed, I imagine because I updated VS2017 and now deploying to other machines fails because it doesn't have a .net core 2.0.3 store...\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"6861587363","Type":"PullRequestEvent","CreatedAt":"2017-11-16T00:05:38","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8021","RelatedDescription":"Merged pull request \"Merge release/1.1.0-MSRC into rel/1.1.0\" (#8021) at dotnet/cli","RelatedBody":"This was a clean merge."},{"Id":"6861520102","Type":"PullRequestEvent","CreatedAt":"2017-11-15T23:44:23","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8029","RelatedDescription":"Opened pull request \"Update CoreSetup to preview1-25915-02 (master)\" (#8029) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6861398168","Type":"PullRequestEvent","CreatedAt":"2017-11-15T23:08:20","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8026","RelatedDescription":"Merged pull request \"Updating Roslyn version.\" (#8026) at dotnet/cli","RelatedBody":"@natidea \r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6861388302","Type":"PullRequestEvent","CreatedAt":"2017-11-15T23:05:41","Actor":"jcagme","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/577","RelatedDescription":"Merged pull request \"Update BuildTools to prerelease-02215-01 (master)\" (#577) at dotnet/standard","RelatedBody":"<details><summary>Discarded auto-update commits (click to expand)</summary><auto-pr-discard-list>\r\n\r\n * [`1b89883`](https://github.com/dotnet-maestro-bot/standard/commits/1b898838df83cd248e0959eaf63e511955106710) Update BuildTools to prerelease-02214-03\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/113/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/184/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/184/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`7fd93db`](https://github.com/dotnet-maestro-bot/standard/commits/7fd93db33ffd29fc214e3d17d134d1a599212366) Update BuildTools to prerelease-02213-01\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/110/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/181/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/181/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`97ddc45`](https://github.com/dotnet-maestro-bot/standard/commits/97ddc45eb5d9364ab37dd31b74b4a667089fa47d) Update BuildTools to prerelease-02210-05\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`a10466a`](https://github.com/dotnet-maestro-bot/standard/commits/a10466a48da962f5fd9854682b0f3335c8a10bd8) Update BuildTools to prerelease-02210-04\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`afd36ca`](https://github.com/dotnet-maestro-bot/standard/commits/afd36ca99111932dc7149ccb4d1e8a8f28fd4de4) Update BuildTools to prerelease-02210-03\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`44c5fd6`](https://github.com/dotnet-maestro-bot/standard/commits/44c5fd6aca184b7e37b92e456a94698b089b1231) Update BuildTools to prerelease-02210-02\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`a1e312e`](https://github.com/dotnet-maestro-bot/standard/commits/a1e312e65de72f0a31733a23198739f8b6c617eb) Update BuildTools to prerelease-02210-01\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/107/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/178/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/178/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`9cb5180`](https://github.com/dotnet-maestro-bot/standard/commits/9cb518056561ce83190331fa753d53ac97acf5d0) Update BuildTools to prerelease-02209-01\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/106/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/176/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/176/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`9796f23`](https://github.com/dotnet-maestro-bot/standard/commits/9796f23982a58234b8f86d3e86eec6082a0add2a) Update BuildTools to prerelease-02208-05\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/105/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/173/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/173/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`cda7769`](https://github.com/dotnet-maestro-bot/standard/commits/cda7769f8adcafc7c1cc63207ec909765866b283) Update BuildTools to prerelease-02208-04\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/104/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/172/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/172/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`c97ca45`](https://github.com/dotnet-maestro-bot/standard/commits/c97ca45b8eb8bfc80af7c776849208e4cfccec73) Update BuildTools to prerelease-02208-03\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/103/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/171/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/171/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`144be30`](https://github.com/dotnet-maestro-bot/standard/commits/144be301dbe3f4c8e38e4c06605124ac846c3296) Update BuildTools to prerelease-02207-02\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/102/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/170/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/170/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n * [`96b79ff`](https://github.com/dotnet-maestro-bot/standard/commits/96b79ffc66e1e45eb46c450c3a584752695b9576) Update BuildTools to prerelease-02207-01\r\n   * :heavy_check_mark: **license/cla** All CLA requirements met. [Details](https://cla.dotnetfoundation.org/dotnet/standard?pullRequest=577)\r\n   * :heavy_check_mark: **OSX10.12** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/OSX10.12_prtest/101/)\r\n   * :heavy_check_mark: **Ubuntu16.04** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Ubuntu16.04_prtest/169/)\r\n   * :heavy_check_mark: **Windows_NT** Build finished.  [Details](https://ci.dot.net/job/dotnet_standard/job/master/job/Windows_NT_prtest/169/)\r\n   * :heavy_check_mark: **WIP** ready for review [Details](https://github.com/apps/wip)\r\n\r\n</auto-pr-discard-list></details>"},{"Id":"6861035215","Type":"PullRequestEvent","CreatedAt":"2017-11-15T21:42:19","Actor":"dseefeld","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/585","RelatedDescription":"Opened pull request \"Add retry logic for setup of dotnet cli\" (#585) at dotnet/standard","RelatedBody":"Copy init-tools.sh retry logic from corefx.  Also adding display_error_message() function.\r\n\r\nFixes dotnet/core-eng#1966"},{"Id":"6857338372","Type":"IssuesEvent","CreatedAt":"2017-11-15T09:00:26","Actor":"valeriob","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/584","RelatedDescription":"Opened issue \"Guide on how to build a netstandard library with native dependencies\" (#584) at dotnet/standard","RelatedBody":"Hi,\r\nis there some documentation already about it ? I looked for it without luck.\r\nMaybe where i can understand also the packaging story and the resolution, publishing etc. to diagnose problems.\r\n\r\nThanks"},{"Id":"6856797223","Type":"IssuesEvent","CreatedAt":"2017-11-15T06:20:14","Actor":"rebulanyum","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/571","RelatedDescription":"Closed issue \"System.Runtime.Serialization.Json nuget package error\" (#571) at dotnet/standard","RelatedBody":"Hello.\r\n\r\nI've started to use .NetCore version=1.0.0-preview2-003121 with Visual Studio 2015. My project.json file is below:\r\n\r\n```javascript\r\n{\r\n  \"version\": \"1.0.0-*\",\r\n  \"frameworks\": {\r\n    \"netstandard2.0\": {\r\n      \"dependencies\": {\r\n        \"System.Runtime.Serialization.Xml\": \"4.3.0\",\r\n        \"System.Runtime.Serialization.Json\": \"4.3.0\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nMy code file is below:\r\n```csharp\r\nusing System.Runtime.Serialization;\r\nusing System.Runtime.Serialization.Json;\r\n\r\nnamespace NetCoreTests\r\n{\r\n    public class Class1\r\n    {\r\n        public Class1()\r\n        {\r\n            XmlObjectSerializer ser = new DataContractJsonSerializer(typeof(int));\r\n        }\r\n    }\r\n}\r\n```\r\nAnd this is the error I get when I try to build the solution:\r\n```\r\nCS0029\tCannot implicitly convert type 'System.Runtime.Serialization.Json.DataContractJsonSerializer' to 'System.Runtime.Serialization.XmlObjectSerializer'\tNetCoreTests..NETStandard,Version=v2.0\r\n```\r\n\r\nLooks like `DataContractJsonSerializer` class in System.Runtime.Serialization.Json nuget package doesn't inherit `XmlObjectSerializer` class in System.Runtime.Serialization.Xml nuget package. I can see that in general there's no dependency between these 2 nuget packages; however, if you check 4 and later versions of .Net Framework `DataContractJsonSerializer` always inherits from `XmlObjectSerializer` because as far as I know every DataContractSerializer inherits from `XmlObjectSerializer`. Even in this repository this inheritance exists:\r\nhttps://github.com/dotnet/standard/blob/master/netstandard/ref/System.Runtime.Serialization.cs#L332\r\n\r\nCan you please fix the nuget packages? Or what can you advice for me about this situation?"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6862220505","Type":"IssuesEvent","CreatedAt":"2017-11-16T03:51:40","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25289","RelatedDescription":"Opened issue \"HttpListener failure on Windows ARM\" (#25289) at dotnet/corefx","RelatedBody":"   System.Net.HttpListenerException: Invalid access to memory location\r\n   at System.Net.HttpListener.BeginGetContext(AsyncCallback callback, Object state)\r\n   at DotNetCoreHttpListener.Program.Main(String[] args) in C:\\src\\DotNetCoreHttpListener\\Program.cs:line 22"},{"Id":"6862076514","Type":"IssuesEvent","CreatedAt":"2017-11-16T02:57:05","Actor":"morganbr","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/issues/14354","RelatedDescription":"Reopened issue \"Proposal: Add System.HashCode to make it easier to generate good hash codes.\" (#14354) at dotnet/corefx","RelatedBody":"# Update 6/16/17: Looking for volunteers\r\n\r\nThe API shape has been finalized. However, we're still deciding on the best hash algorithm out of [a list of candidates](https://github.com/dotnet/corefx/issues/14354#issuecomment-305028686) to use for the implementation, and we need someone to help us measure the throughput/distribution of each algorithm. If you'd like to take that role up, please leave a comment below and @karelz will assign this issue to you.\r\n\r\n# Update 6/13/17: Proposal accepted!\r\n\r\nHere's the API that was approved by @terrajobst at https://github.com/dotnet/corefx/issues/14354#issuecomment-308190321:\r\n\r\n```cs\r\n// Will live in the core assembly\r\n// .NET Framework : mscorlib\r\n// .NET Core      : System.Runtime / System.Private.CoreLib\r\nnamespace System\r\n{\r\n    public struct HashCode\r\n    {\r\n        public static int Combine<T1>(T1 value1);\r\n        public static int Combine<T1, T2>(T1 value1, T2 value2);\r\n        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3);\r\n        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);\r\n        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);\r\n\r\n        public void Add<T>(T value);\r\n        public void Add<T>(T value, IEqualityComparer<T> comparer);\r\n\r\n        [Obsolete(\"Use ToHashCode to retrieve the computed hash code.\", error: true)]\r\n        [EditorBrowsable(Never)]\r\n        public override int GetHashCode();\r\n\r\n        public int ToHashCode();\r\n    }\r\n}\r\n```\r\n\r\nThe original text of this proposal follows.\r\n\r\n# Rationale\r\n\r\nGenerating a good hash code should not require use of ugly magic constants and bit twiddling on our code. It should be less tempting to write a bad-but-concise `GetHashCode` implementation such as\r\n\r\n```cs\r\nclass Person\r\n{\r\n    public override int GetHashCode() => FirstName.GetHashCode() + LastName.GetHashCode();\r\n}\r\n```\r\n\r\n# Proposal\r\n\r\nWe should add a `HashCode` type to enscapulate hash code creation and avoid forcing devs to get mixed up in the messy details. Here is my proposal, which is based off of https://github.com/dotnet/corefx/issues/14354#issuecomment-305019329, with a few minor revisions.\r\n\r\n```cs\r\n// Will live in the core assembly\r\n// .NET Framework : mscorlib\r\n// .NET Core      : System.Runtime / System.Private.CoreLib\r\nnamespace System\r\n{\r\n    public struct HashCode\r\n    {\r\n        public static int Combine<T1>(T1 value1);\r\n        public static int Combine<T1, T2>(T1 value1, T2 value2);\r\n        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3);\r\n        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);\r\n        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);\r\n\r\n        public void Add<T>(T value);\r\n        public void Add<T>(T value, IEqualityComparer<T> comparer);\r\n        public void AddRange<T>(T[] values);\r\n        public void AddRange<T>(T[] values, int index, int count);\r\n        public void AddRange<T>(T[] values, int index, int count, IEqualityComparer<T> comparer);\r\n\r\n        [Obsolete(\"Use ToHashCode to retrieve the computed hash code.\", error: true)]\r\n        public override int GetHashCode();\r\n\r\n        public int ToHashCode();\r\n    }\r\n}\r\n```\r\n\r\n## Remarks\r\n\r\nSee @terrajobst's comment at https://github.com/dotnet/corefx/issues/14354#issuecomment-305019329 for the goals of this API; all of his remarks are valid. I would like to point out these ones in particular, however:\r\n\r\n- The API **does not need** to produce a strong cryptographic hash\r\n- The API will provide \"a\" hash code, but not guarantee a particular hash code algorithm. This allows us to use a different algorithm later or use different algorithms on different architectures.\r\n- The API will guarantee that within a given process the same values will yield the same hash code. Different instances of the same app will likely produce different hash codes due to randomization. This allows us to ensure that consumers cannot persist hash values and accidentally rely on them being stable across runs (or worse, versions of the platform)."},{"Id":"6862049293","Type":"IssuesEvent","CreatedAt":"2017-11-16T02:47:02","Actor":"morganbr","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/14354","RelatedDescription":"Closed issue \"Proposal: Add System.HashCode to make it easier to generate good hash codes.\" (#14354) at dotnet/corefx","RelatedBody":"# Update 6/16/17: Looking for volunteers\r\n\r\nThe API shape has been finalized. However, we're still deciding on the best hash algorithm out of [a list of candidates](https://github.com/dotnet/corefx/issues/14354#issuecomment-305028686) to use for the implementation, and we need someone to help us measure the throughput/distribution of each algorithm. If you'd like to take that role up, please leave a comment below and @karelz will assign this issue to you.\r\n\r\n# Update 6/13/17: Proposal accepted!\r\n\r\nHere's the API that was approved by @terrajobst at https://github.com/dotnet/corefx/issues/14354#issuecomment-308190321:\r\n\r\n```cs\r\n// Will live in the core assembly\r\n// .NET Framework : mscorlib\r\n// .NET Core      : System.Runtime / System.Private.CoreLib\r\nnamespace System\r\n{\r\n    public struct HashCode\r\n    {\r\n        public static int Combine<T1>(T1 value1);\r\n        public static int Combine<T1, T2>(T1 value1, T2 value2);\r\n        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3);\r\n        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);\r\n        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);\r\n\r\n        public void Add<T>(T value);\r\n        public void Add<T>(T value, IEqualityComparer<T> comparer);\r\n\r\n        [Obsolete(\"Use ToHashCode to retrieve the computed hash code.\", error: true)]\r\n        [EditorBrowsable(Never)]\r\n        public override int GetHashCode();\r\n\r\n        public int ToHashCode();\r\n    }\r\n}\r\n```\r\n\r\nThe original text of this proposal follows.\r\n\r\n# Rationale\r\n\r\nGenerating a good hash code should not require use of ugly magic constants and bit twiddling on our code. It should be less tempting to write a bad-but-concise `GetHashCode` implementation such as\r\n\r\n```cs\r\nclass Person\r\n{\r\n    public override int GetHashCode() => FirstName.GetHashCode() + LastName.GetHashCode();\r\n}\r\n```\r\n\r\n# Proposal\r\n\r\nWe should add a `HashCode` type to enscapulate hash code creation and avoid forcing devs to get mixed up in the messy details. Here is my proposal, which is based off of https://github.com/dotnet/corefx/issues/14354#issuecomment-305019329, with a few minor revisions.\r\n\r\n```cs\r\n// Will live in the core assembly\r\n// .NET Framework : mscorlib\r\n// .NET Core      : System.Runtime / System.Private.CoreLib\r\nnamespace System\r\n{\r\n    public struct HashCode\r\n    {\r\n        public static int Combine<T1>(T1 value1);\r\n        public static int Combine<T1, T2>(T1 value1, T2 value2);\r\n        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3);\r\n        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);\r\n        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);\r\n        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);\r\n\r\n        public void Add<T>(T value);\r\n        public void Add<T>(T value, IEqualityComparer<T> comparer);\r\n        public void AddRange<T>(T[] values);\r\n        public void AddRange<T>(T[] values, int index, int count);\r\n        public void AddRange<T>(T[] values, int index, int count, IEqualityComparer<T> comparer);\r\n\r\n        [Obsolete(\"Use ToHashCode to retrieve the computed hash code.\", error: true)]\r\n        public override int GetHashCode();\r\n\r\n        public int ToHashCode();\r\n    }\r\n}\r\n```\r\n\r\n## Remarks\r\n\r\nSee @terrajobst's comment at https://github.com/dotnet/corefx/issues/14354#issuecomment-305019329 for the goals of this API; all of his remarks are valid. I would like to point out these ones in particular, however:\r\n\r\n- The API **does not need** to produce a strong cryptographic hash\r\n- The API will provide \"a\" hash code, but not guarantee a particular hash code algorithm. This allows us to use a different algorithm later or use different algorithms on different architectures.\r\n- The API will guarantee that within a given process the same values will yield the same hash code. Different instances of the same app will likely produce different hash codes due to randomization. This allows us to ensure that consumers cannot persist hash values and accidentally rely on them being stable across runs (or worse, versions of the platform)."},{"Id":"6862022912","Type":"IssuesEvent","CreatedAt":"2017-11-16T02:37:32","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/issues/9800","RelatedDescription":"Reopened issue \"CallingConvention gap in ILGenerator.EmitCalli\" (#9800) at dotnet/corefx","RelatedBody":"Based on [this stackoverflow submission](http://stackoverflow.com/questions/38129594/emitcalli-net-core-alternative/38134706#38134706).\n\nIt seems like there is a bit of a feature gap in the current interface for `ILGenerator`. .NET Core has a `EmitCalli` method, but the calling conventions it supports do not line up exactly with the ones exposed from the .NET Framework: https://msdn.microsoft.com/en-us/library/d81ee808(v=vs.110).aspx\n\nWe should understand if this is a meaningful gap, or if the use cases for the .NET Framework version can still be covered by the new version.\n\nWe may already be considering adding this functionality back as part of our bigger API compat push.\n\ncc: @AtsushiKan \n"},{"Id":"6862022574","Type":"IssuesEvent","CreatedAt":"2017-11-16T02:37:24","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/9800","RelatedDescription":"Closed issue \"CallingConvention gap in ILGenerator.EmitCalli\" (#9800) at dotnet/corefx","RelatedBody":"Based on [this stackoverflow submission](http://stackoverflow.com/questions/38129594/emitcalli-net-core-alternative/38134706#38134706).\n\nIt seems like there is a bit of a feature gap in the current interface for `ILGenerator`. .NET Core has a `EmitCalli` method, but the calling conventions it supports do not line up exactly with the ones exposed from the .NET Framework: https://msdn.microsoft.com/en-us/library/d81ee808(v=vs.110).aspx\n\nWe should understand if this is a meaningful gap, or if the use cases for the .NET Framework version can still be covered by the new version.\n\nWe may already be considering adding this functionality back as part of our bigger API compat push.\n\ncc: @AtsushiKan \n"},{"Id":"6861915978","Type":"PullRequestEvent","CreatedAt":"2017-11-16T01:59:17","Actor":"JeremyKuhne","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25288","RelatedDescription":"Opened pull request \"Use FILE_TIME in WIN32_FILE_ATTRIBUTE_DATA\" (#25288) at dotnet/corefx","RelatedBody":"Cleaning up in preparation for other changes"},{"Id":"6861883377","Type":"IssuesEvent","CreatedAt":"2017-11-16T01:47:42","Actor":"Deren-Liao","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25287","RelatedDescription":"Opened issue \"Is it possible to run test against runtime only?\" (#25287) at dotnet/corefx","RelatedBody":"I was able to build and run corefx tests.  \r\nMy work has a constraint that it need to use docker image less than 500MB in size. \r\nThe docker image contains corefx, coreclr and with built tests is 13.4 GB  \r\n\r\nI wonder if it is possible that I copy minimum required files to the microsoft/dotnet:2.0-runtime-jessie image and have the test run? "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6862447268","Type":"PullRequestEvent","CreatedAt":"2017-11-16T05:29:35","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23210","RelatedDescription":"Opened pull request \"Prototype: integrating with ILVerify and classifying differences\" (#23210) at dotnet/roslyn","RelatedBody":"Relates to https://github.com/dotnet/roslyn/issues/22872"},{"Id":"6862286172","Type":"PullRequestEvent","CreatedAt":"2017-11-16T04:18:59","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23209","RelatedDescription":"Opened pull request \"recursive-patterns(2): Add support for recursive patterns in `is`\" (#23209) at dotnet/roslyn","RelatedBody":"- Add support for recursive patterns in `is`.\r\n- Add the discard pattern `_`.\r\n- Add skeletal IOperation support.\r\n- Adjust tests per changes in `is pattern` code gen.\r\n\r\nThis is the second of several PRs for the implementation of recursive pattern-matching, each of which builds on the previous. This was previously offered for review in #23139. Until the first PR https://github.com/dotnet/roslyn/pull/23208 is integrated, you will also see the changes from that PR included here. You should review https://github.com/dotnet/roslyn/pull/23208 first, and only review new deltas in this review.\r\n\r\n@AlekseyTs @agocke Please review.\r\n/cc @dotnet/roslyn-compiler "},{"Id":"6862271738","Type":"PullRequestEvent","CreatedAt":"2017-11-16T04:12:29","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23208","RelatedDescription":"Opened pull request \"recursive-patterns(1): Parsing changes for recursive pattern-matching\" (#23208) at dotnet/roslyn","RelatedBody":"Parsing changes for recursive pattern-matching,\r\ncurrently enabled by `/features:patterns2`\r\n\r\nThis is the first of several PRs for the implementation of recursive pattern-matching, each of which builds on the previous. This was previously offered for review in #22718.\r\n\r\n@AlekseyTs @agocke Please review.\r\n"},{"Id":"6862184678","Type":"IssuesEvent","CreatedAt":"2017-11-16T03:37:17","Actor":"VSadov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23207","RelatedDescription":"Opened issue \"Consider merging AbstractFlowPass and PreciseAbstractFlowPass\" (#23207) at dotnet/roslyn","RelatedBody":"There were good intentions in separating AbstractFlowPass and PreciseAbstractFlowPass, but right now the diff seems to be unused.\r\n\r\nIn particular `PreciseAbstractFlowPass.VisitTryStatement` is essentially a dead code right now since the containing class is abstract and the method is overriden in the only derived class.\r\n\r\nThe problem with dead code is that we cannot effectively maintain or evolve it since it cannot be tested.\r\n\r\nFor once, I think the `PreciseAbstractFlowPass.VisitTryStatement` may have the same bug as in https://github.com/dotnet/roslyn/issues/19831 , or maybe not - I cannot tell one way or another, nor I can tell how it could be fixed and the fix tested.\r\n\r\nIt can always be fetched from history if needed again. I think we should remove the method and merge two types.\r\n"}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6862325257","Type":"PullRequestEvent","CreatedAt":"2017-11-16T04:36:11","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4944","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#4944) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6862058433","Type":"PullRequestEvent","CreatedAt":"2017-11-16T02:50:20","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4944","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#4944) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6861912050","Type":"PullRequestEvent","CreatedAt":"2017-11-16T01:57:53","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4943","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#4943) at dotnet/corert","RelatedBody":""},{"Id":"6861810667","Type":"PullRequestEvent","CreatedAt":"2017-11-16T01:22:12","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4943","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#4943) at dotnet/corert","RelatedBody":""},{"Id":"6861678010","Type":"PullRequestEvent","CreatedAt":"2017-11-16T00:36:26","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4942","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4942) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6861566558","Type":"PullRequestEvent","CreatedAt":"2017-11-15T23:59:08","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4942","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4942) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6861404577","Type":"PullRequestEvent","CreatedAt":"2017-11-15T23:10:01","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4941","RelatedDescription":"Opened pull request \"[WIP] ILCompiler package publish\" (#4941) at dotnet/corert","RelatedBody":"Adding additional packages to the publish pipeline. Would like some feedback - outputting all built packages to a single folder feels a bit messy, but is how CoreCLR and CoreFX seem to deal with package publish. \r\n\r\ncc @MichalStrehovsky @nattress @jkotas \r\n"},{"Id":"6861339764","Type":"PullRequestEvent","CreatedAt":"2017-11-15T22:53:05","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4940","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4940) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6861325989","Type":"PullRequestEvent","CreatedAt":"2017-11-15T22:49:34","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4940","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4940) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6861307780","Type":"PullRequestEvent","CreatedAt":"2017-11-15T22:45:00","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4939","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#4939) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"6861740053","Type":"PullRequestEvent","CreatedAt":"2017-11-16T00:58:07","Actor":"livarcocc","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1741","RelatedDescription":"Merged pull request \"Adding one more condition so that we can override adding shims for net471 in case they are required\" (#1741) at dotnet/sdk","RelatedBody":"cc: @livarcocc @dsplaisted \r\n\r\nPorting change https://github.com/dotnet/sdk/pull/1731 to release/15.5 branch"},{"Id":"6861594413","Type":"PullRequestEvent","CreatedAt":"2017-11-16T00:07:52","Actor":"joperezr","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1741","RelatedDescription":"Opened pull request \"Adding one more condition so that we can override adding shims for net471 in case they are required\" (#1741) at dotnet/sdk","RelatedBody":"cc: @livarcocc @dsplaisted \r\n\r\nPorting change https://github.com/dotnet/sdk/pull/1731 to release/15.5 branch"},{"Id":"6861141383","Type":"PullRequestEvent","CreatedAt":"2017-11-15T22:06:03","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1736","RelatedDescription":"Merged pull request \"The 'PushToBlobFeed' call cannot find the NuPkgs\" (#1736) at dotnet/sdk","RelatedBody":"The 'PushToBlobFeed' call cannot find the NuPkgs because \"OutputPath\" changes."},{"Id":"6860949407","Type":"PullRequestEvent","CreatedAt":"2017-11-15T21:23:18","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/pull/1737","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to release/15.5\" (#1737) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/15.5.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/15.5-20171115-080039\ngit reset --hard upstream/release/15.5\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/15.5-20171115-080039 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6860818286","Type":"PullRequestEvent","CreatedAt":"2017-11-15T20:53:59","Actor":"livarcocc","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1731","RelatedDescription":"Merged pull request \"Adding one more condition so that we can override adding shims for net471 in case they are required\" (#1731) at dotnet/sdk","RelatedBody":"cc: @livarcocc @AlexGhiondea @weshaggard @dsplaisted \r\n\r\nDuring my testing I found one more thing that we can improve with the current targets. The problem to solve, is that in the case your app is in a state where we don't automatically detect that you need the shims (for example if you don't directly reference a netstandard based library but one of your dependencies does) and you are targeting .NET 4.7.1, there is no quick property that you can set in order to force the shims to be deployed with the app. The only current workaround for that, would be to add a direct reference to a netstandard based component directly, so that our logic kicks in. I don't think that this is a good behavior, which is why I would like to try to squish this change in, so that if users need to deploy the shims for 4.7.1, they can simpy set property `<DependsOnNETStandard>true</DependsOnNETStandard>` in order to accomplish that."},{"Id":"6860333878","Type":"IssuesEvent","CreatedAt":"2017-11-15T19:08:19","Actor":"KathleenDollard","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/1740","RelatedDescription":"Opened issue \"MacOs install summary page shows wrong version\" (#1740) at dotnet/sdk","RelatedBody":"After installing .NET Core SDK 2.0.3, the MacOs summary page is as attached. The title correctly says 2.0.3, but twice on the page it says 2.0.0\r\n\r\n![screen shot 2017-11-15 at 10 57 58 am](https://user-images.githubusercontent.com/5844318/32854975-3ac53162-c9f5-11e7-8dde-5685da6ad846.png)\r\n"},{"Id":"6860184589","Type":"PullRequestEvent","CreatedAt":"2017-11-15T18:36:01","Actor":"eerhardt","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1732","RelatedDescription":"Merged pull request \"Remove old workarounds that are no longer necessary.\" (#1732) at dotnet/sdk","RelatedBody":"Also, fix a merge issue where a group of code got duplicated unnecessarily.\r\n\r\nhttps://github.com/Microsoft/msbuild/issues/720 has been closed for a long time.\r\n\r\nhttps://github.com/dotnet/roslyn/issues/12167 is about to be closed since the issue no longer repos with the latest .NET Core SDK."},{"Id":"6859613888","Type":"IssuesEvent","CreatedAt":"2017-11-15T16:41:46","Actor":"pranavkm","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/1739","RelatedDescription":"Opened issue \"Reference assemblies are incorrectly being marked as references\" (#1739) at dotnet/sdk","RelatedBody":"Seems like the opposite of #1738 \r\n\r\nI'm working on updating AspNetCore's repositories to use the 2.2 SDK. With the 2.0.0 SDK, when attempting to publish a Mvc application (https://github.com/aspnet/MvcPrecompilation/blob/dev/testapps/RazorPagesApp/RazorPagesApp.csproj for reference) for `net461`, `Microsoft.Win32.Primitives` (among others) is recorded as a `referenceassembly` in the deps file:\r\n\r\n```js\r\n\"Microsoft.Win32.Primitives/4.0.3.0\": {\r\n  \"type\": \"referenceassembly\",\r\n  \"serviceable\": false,\r\n  \"sha512\": \"\"\r\n},\r\n```\r\n\r\nWith 2.2.0-preview1-007522 SDK, it ends up in the deps file as a `reference`:\r\n```js\r\n\"Microsoft.Win32.Primitives/4.0.3.0\": {\r\n  \"type\": \"reference\",\r\n  \"serviceable\": false,\r\n  \"sha512\": \"\"\r\n},\r\n```\r\n\r\nThis in turn causes view compilation to fail, with \r\n```C#\r\nCannot find compilation library location for package 'Microsoft.Win32.Primitives'\r\n     at Microsoft.Extensions.DependencyModel.CompilationLibrary.ResolveReferencePaths(ICompilationAssemblyResolver resolver, List`1 assemblies)\r\n     at Microsoft.Extensions.DependencyModel.CompilationLibrary.ResolveReferencePaths()\r\n     at Microsoft.AspNetCore.Mvc.ApplicationParts.AssemblyPart.<>c.<GetReferencePaths>b__8_0(CompilationLibrary library)\r\n```\r\n\r\n"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"930891655422627840","CreatedAt":"2017-11-15T20:14:00+00:00","UserScreenname":"dotnet","Text":"And .NET support for new type Tensor&lt;T&gt; for making it easy to consume ML models! https://t.co/hc2d45S8xA… https://t.co/3ozhgcMLFo","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":45,"FavoriteCount":26,"RawContent":null},{"Id":"930889390716362752","CreatedAt":"2017-11-15T20:05:00+00:00","UserScreenname":"dotnet","Text":"Introducing Nullable Reference Types in C# https://t.co/JGzo1B0MX0 #MSFTConnect","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":131,"FavoriteCount":99,"RawContent":null},{"Id":"930879325703778304","CreatedAt":"2017-11-15T19:25:00+00:00","UserScreenname":"dotnet","Text":"Learn all about Span&lt;T&gt; in C# from @jaredpar https://t.co/VqyFhWyYzU #MSFTConnect https://t.co/iQXWmJUT1n","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":106,"FavoriteCount":58,"RawContent":null},{"Id":"930878066112413696","CreatedAt":"2017-11-15T19:20:00+00:00","UserScreenname":"dotnet","Text":"Watch @MadsTorgersen show us what's new with C# 7.1 &amp; 7.2 and a preview of C# 8.0 https://t.co/K3StaNc71s… https://t.co/lK52YqAXoa","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":184,"FavoriteCount":109,"RawContent":null},{"Id":"930876221054791680","CreatedAt":"2017-11-15T19:12:40+00:00","UserScreenname":"dotnet","Text":"Any .NET developers interested in moving their .NET Framework services to the cloud without code changes? This is a… https://t.co/ZZ9fJdPsT4","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":32,"FavoriteCount":13,"RawContent":null},{"Id":"930874291427540992","CreatedAt":"2017-11-15T19:05:00+00:00","UserScreenname":"dotnet","Text":"Welcome to C# 7.2 and Span https://t.co/OKkr3uZHMX #MSFTConnect","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":164,"FavoriteCount":111,"RawContent":null},{"Id":"930670100662968321","CreatedAt":"2017-11-15T05:33:37+00:00","UserScreenname":"dotnet","Text":".NET Core November 2017 Update https://t.co/ZdBeZU5Lz4","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":103,"FavoriteCount":75,"RawContent":null}]}},"RunOn":"2017-11-16T05:30:21.7091678Z","RunDurationInMilliseconds":7862}