{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":20,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":38,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7868735705","Type":"PullRequestEvent","CreatedAt":"2018-06-24T03:20:59","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18620","RelatedDescription":"Merged pull request \"Use correct basic block to check legality of PInvoke callsite for inlining\" (#18620) at dotnet/coreclr","RelatedBody":"It is the same logic as used in other similar places"},{"Id":"7868675067","Type":"PullRequestEvent","CreatedAt":"2018-06-24T02:12:08","Actor":"Anipik","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18624","RelatedDescription":"Closed pull request \"Fixing the failure of parameter name for invalid mode in eventwaithandle\" (#18624) at dotnet/coreclr","RelatedBody":""},{"Id":"7868640520","Type":"PullRequestEvent","CreatedAt":"2018-06-24T01:30:28","Actor":"Anipik","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18624","RelatedDescription":"Opened pull request \"Fixing the failure of parameter name for invalid mode in eventwaithandle\" (#18624) at dotnet/coreclr","RelatedBody":""},{"Id":"7868621111","Type":"PullRequestEvent","CreatedAt":"2018-06-24T01:07:10","Actor":"stephentoub","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18623","RelatedDescription":"Opened pull request \"Simply type names in Corelib\" (#18623) at dotnet/coreclr","RelatedBody":"I don't know if we want to do this now, or wait for more unification with corert, but it didn't take very long with VS' auto-fix support, so I figured I'd submit it now and we can decide to take it or punt until later.  It's just been bothering me when making code changes in corelib in particular that the same file, class, and maybe even method contains both styles. :)\r\n\r\ncc: @jkotas, @danmosemsft "},{"Id":"7868284460","Type":"PullRequestEvent","CreatedAt":"2018-06-23T19:37:07","Actor":"hsharber","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18622","RelatedDescription":"Opened pull request \"Removed dead strings used in debug-only code\" (#18622) at dotnet/coreclr","RelatedBody":"Removed strings used in debug-only code in ex.cpp\r\n\r\nFix #18420"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7867803687","Type":"IssuesEvent","CreatedAt":"2018-06-23T13:37:18","Actor":"bujie","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/782","RelatedDescription":"Opened issue \"dotnet 2.1.300 in  centos 7     The SSL connection could not be established, see inner exception\" (#782) at dotnet/standard","RelatedBody":"Error: One or more errors occurred. (The SSL connection could not be established, see inner exception.)\r\nCode:\r\n            var http = new System.Net.Http.HttpClient();\r\n            http.DefaultRequestHeaders.Add(\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36\");\r\n            http.GetStringAsync(\"https://www.23us.net/90/90325/23873102.html\");\r\n\r\nNormal in Centos7, most of them will produce this error\r\nEverything works fine under Windows"},{"Id":"7863206549","Type":"IssuesEvent","CreatedAt":"2018-06-22T09:51:56","Actor":"ramsubbaraoc","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/781","RelatedDescription":"Opened issue \"How to read configuration files using .net standard libraries\" (#781) at dotnet/standard","RelatedBody":"I want to my use the same .net standard library for .NET Core and .NET Framework applications. Different type of config files are supported for .NET Core. If i have to read the config files irrespective of if it is web.config/app.config/appsetting.json using .net standard library what is the class that i have to use. \r\n"},{"Id":"7860997872","Type":"IssuesEvent","CreatedAt":"2018-06-21T22:01:18","Actor":"pomeara","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/780","RelatedDescription":"Closed issue \".net core and .net standard projects\" (#780) at dotnet/standard","RelatedBody":"I've been working on a .NET Core project which uses a .NET Standard back-end and from what I can tell this is mainly due to the OAuth only being implemented in .NET Standard.  I was wanting a pure .NET Core solution, however am now considering that it's probably less painful to just have all back end DLLs as .NET Standard libraries as I started to split the back end up into different layers (repos, domain, etc) and found that the OAuth restriction was causing a painful issue with what could reference what) - thoughts?"},{"Id":"7859387848","Type":"IssuesEvent","CreatedAt":"2018-06-21T16:26:40","Actor":"pmarangoni","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/777","RelatedDescription":"Closed issue \"Problem upgrading NETStandard.Library from 2.0.1 to 2.0.3\" (#777) at dotnet/standard","RelatedBody":"- ASP.NET MVC project\r\n- Using NuGet, I see there is a new version of NETStandardLibrary so I elect to upgrade it\r\n- After upgrading to 2.0.3, I can no longer build the solution. I get this error:\r\nThis project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them. For more information (blah, blah, blah)… The missing file is ..\\packages\\NETStandard.Library.2.0.1\\build\\NETStandard.Library.targets\r\n\r\nThe only way to proceed is to revert back to 2.0.1."},{"Id":"7856759706","Type":"IssuesEvent","CreatedAt":"2018-06-21T08:39:58","Actor":"pomeara","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/780","RelatedDescription":"Opened issue \".net core and .net standard projects\" (#780) at dotnet/standard","RelatedBody":"I've been working on a .NET Core project which uses a .NET Standard back-end and from what I can tell this is mainly due to the OAuth only being implemented in .NET Standard.  I was wanting a pure .NET Core solution, however am now considering that it's probably less painful to just have all back end DLLs as .NET Standard libraries as I started to split the back end up into different layers (repos, domain, etc) and found that the OAuth restriction was causing a painful issue with what could reference what) - thoughts?"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7868795911","Type":"PullRequestEvent","CreatedAt":"2018-06-24T04:29:41","Actor":"bartonjs","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30572","RelatedDescription":"Merged pull request \"NetFX compatibility fixes for X500DistinguishedName.\" (#30572) at dotnet/corefx","RelatedBody":"Fixes https://github.com/dotnet/corefx/issues/27466."},{"Id":"7868795905","Type":"IssuesEvent","CreatedAt":"2018-06-24T04:29:40","Actor":"bartonjs","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/27466","RelatedDescription":"Closed issue \"Cannot decode X500DistinguishedName correctly with T61String.\" (#27466) at dotnet/corefx","RelatedBody":"In an ASP.NET CORE 2.0 project under MAC OS, we have a byte array which is the raw data of the x500 distinguished name, to decode it with the X500DistinguishedName class, the value can be decoded if it is a printable string, but the value CANNOT be decoded if it is a T61String.\r\n\r\nIt's OK in:\r\n1) Windows platform (all projects)\r\n2) MAC, .NET Framework project\r\nIt's NOT OK in:\r\n1) MAC, ASP.NET CORE 2.0 project\r\n\r\nSteps:\r\n1) Run the following codes in a ASP.NET CORE 2.0 project. \r\n// CN=GrapeCity inc., OU=Tools Development, O=GrapeCity inc., L=Sendai Izumi-ku, S=Miyagi, C=JP\r\n// the CN, OU, O value is T61String\r\n// the L, S, C value is printable string\r\nvar base64 = \"MIGGMQswCQYDVQQGEwJKUDEPMA0GA1UECBMGTWl5YWdpMRgwFgYDVQQHEw9TZW5kYWkgSXp1bWkta3UxFzAVBgNVBAoUDkdyYXBlQ2l0eSBpbmMuMRowGAYDVQQLFBFUb29scyBEZXZlbG9wbWVudDEXMBUGA1UEAxQOR3JhcGVDaXR5IGluYy4=\";\r\n            var bytes = System.Convert.FromBase64String(base64);\r\n            var x500name = new System.Security.Cryptography.X509Certificates.X500DistinguishedName(bytes);\r\n            var name = x500name.Name;\r\n2) get's the value of name.\r\n<observed>CN=\"\", OU=\"\", O=\"\", L=Sendai Izumi-ku, S=Miyagi, C=JP\r\n<expected>CN=GrapeCity inc., OU=Tools Development, O=GrapeCity inc., L=Sendai Izumi-ku, S=Miyagi, C=JP\r\n"},{"Id":"7868783593","Type":"PullRequestEvent","CreatedAt":"2018-06-24T04:15:40","Actor":"JeremyKuhne","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30625","RelatedDescription":"Opened pull request \"Remove rest of GPRECT & GPRECTF usages\" (#30625) at dotnet/corefx","RelatedBody":"They match up directly with managed Rectangle and RectangleF structs. Using the native structs directly eliminates unnecessary copies and complexity.\r\n\r\nThere are **two** commits, one with a style pass, the other with actual functional changes.\r\n\r\nMetafile can probably be cleaned up more. It is checking for empty rectangles and calling overloads with a \"null\" HandleRef. We should be able to use actual pointers and reduce all of the duplication. I'll follow up, need to double check code to make sure I'm not regressing anything.\r\n\r\nBlend is another thing that can be cleaned up. It can get data directly into the target arrays. (See `LinearGradientBrush.Blend`)\r\n\r\nThis is a follow up to #30244.\r\n"},{"Id":"7868730046","Type":"PullRequestEvent","CreatedAt":"2018-06-24T03:14:27","Actor":"JeremyKuhne","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30244","RelatedDescription":"Merged pull request \"Kill allocations in GraphicsPath/Graphics \" (#30244) at dotnet/corefx","RelatedBody":"This removes a great deal of the unneeded allocations in GraphicsPath and Graphics. Points and rectangles match the native types exactly and don't need special marshalling outside of pinning arrays.\r\n\r\nThis removes all usages of GPPOINT/F.  Many GPRECT/F usages were removed, but still exist in other classes.\r\n\r\nThe first commit is #30237, which is also in PR"},{"Id":"7868667066","Type":"IssuesEvent","CreatedAt":"2018-06-24T02:02:35","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30624","RelatedDescription":"Closed issue \"Access SortedList<Tkey, TValue> by index\" (#30624) at dotnet/corefx","RelatedBody":"```SortedList<Tkey, TValue>``` has these two methods:\r\n1- IndexOfKey\r\n2- IndexOfValue\r\nThey return the index of the item in the sorted list, but there is no way to access any item by its index! The only method that uses the index is RemoveAt!\r\nSo, why there is no Indexer that accepts the index? This class is a LIST not a Dictionary, and lists are accessible by index.\r\n\r\n"},{"Id":"7868648014","Type":"IssuesEvent","CreatedAt":"2018-06-24T01:39:51","Actor":"MohammadHamdyGhanem","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30624","RelatedDescription":"Opened issue \"Access SortedList<Tkey, TValue> by index\" (#30624) at dotnet/corefx","RelatedBody":"'''SortedList<Tkey, TValue>''' has these two methods:\r\n1- IndexOfKey\r\n2- IndexOfValue\r\nThey return the index of the item in the sorted list, but there is no way to access any item by its index! The only method that uses the index is RemoveAt!\r\nSo, why there is no Indexer that accepts the index? This class is a LIST not a Dictionary, and lists are accessible by index.\r\n\r\n"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7868581336","Type":"PullRequestEvent","CreatedAt":"2018-06-24T00:19:21","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6002","RelatedDescription":"Merged pull request \"Plumbing to generate calli PInvoke stubs\" (#6002) at dotnet/corert","RelatedBody":"Contributes to #5587"},{"Id":"7868381427","Type":"PullRequestEvent","CreatedAt":"2018-06-23T20:59:14","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6001","RelatedDescription":"Merged pull request \"Mark a few methods with NoInline attribute\" (#6001) at dotnet/corert","RelatedBody":""},{"Id":"7868130015","Type":"PullRequestEvent","CreatedAt":"2018-06-23T17:30:40","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5999","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#5999) at dotnet/corert","RelatedBody":""},{"Id":"7868129771","Type":"PullRequestEvent","CreatedAt":"2018-06-23T17:30:28","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6002","RelatedDescription":"Opened pull request \"Plumbing to generate calli PInvoke stubs\" (#6002) at dotnet/corert","RelatedBody":"Contributes to #5587"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1010269960948465665","CreatedAt":"2018-06-22T21:15:03+00:00","UserScreenname":"dotnet","Text":".NET Core 2.0 End of Life Extended to October 1, 2018 https://t.co/KQAlfqjfGv","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":48,"FavoriteCount":49,"RawContent":null},{"Id":"1010268594725269504","CreatedAt":"2018-06-22T21:09:37+00:00","UserScreenname":"dotnet","Text":".NET Core 2.1 June Update https://t.co/GJkOJkg0zJ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":121,"FavoriteCount":80,"RawContent":null},{"Id":"1010144767924154368","CreatedAt":"2018-06-22T12:57:34+00:00","UserScreenname":"dotnet","Text":"It's #fsharp Friday on Fritz and Friends with our friend @csharpfritz  -- tune in today and learn about… https://t.co/tBMBYu7qnC","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":19,"FavoriteCount":11,"RawContent":null},{"Id":"1009783192751099904","CreatedAt":"2018-06-21T13:00:48+00:00","UserScreenname":"dotnet","Text":"These two are always great to learn from separately, and today they're working together.  You won't want to miss… https://t.co/DhpOULOjfn","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":3,"RawContent":null},{"Id":"1009514602428710912","CreatedAt":"2018-06-20T19:13:31+00:00","UserScreenname":"dotnet","Text":".NET Core 2.0 will reach End of Life on September 1, 2018 https://t.co/5PoTWEAQgt","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":263,"FavoriteCount":296,"RawContent":null},{"Id":"1009477602791133186","CreatedAt":"2018-06-20T16:46:30+00:00","UserScreenname":"dotnet","Text":"Call for papers now open for #dotnetconf virtual event in September! Present to our worldwide community. No travel… https://t.co/KraqcAKxAo","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":332,"FavoriteCount":246,"RawContent":null},{"Id":"1009207915775811584","CreatedAt":"2018-06-19T22:54:51+00:00","UserScreenname":"dotnet","Text":"The RyuJIT transition is complete! https://t.co/JhkSV0Aybh","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":317,"FavoriteCount":169,"RawContent":null},{"Id":"1008787534451638272","CreatedAt":"2018-06-18T19:04:25+00:00","UserScreenname":"dotnet","Text":"Staying up-to-date with .NET Container Images https://t.co/09vnrG5uqh /cc @aspnet @Docker @DockerCon","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":219,"FavoriteCount":117,"RawContent":null},{"Id":"1008746685697150976","CreatedAt":"2018-06-18T16:22:06+00:00","UserScreenname":"dotnet","Text":"Building distributed applications with Orleans https://t.co/GgWRQHcdPP","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":65,"FavoriteCount":26,"RawContent":null}]}},"RunOn":"2018-06-24T05:30:36.6132176Z","RunDurationInMilliseconds":7302}