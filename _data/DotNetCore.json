{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":20,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":38,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7867143278","Type":"PullRequestEvent","CreatedAt":"2018-06-23T04:12:43","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18612","RelatedDescription":"Merged pull request \"Moved EventWaitHandle.cs to shared\" (#18612) at dotnet/coreclr","RelatedBody":"Related Corert PR ;- https://github.com/dotnet/corert/pull/5996"},{"Id":"7867099983","Type":"IssuesEvent","CreatedAt":"2018-06-23T03:30:59","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18617","RelatedDescription":"Opened issue \"macOS Mojave: Support for Hardened Runtime\" (#18617) at dotnet/coreclr","RelatedBody":"From https://github.com/xamarin/xamarin-macios/issues/4288 / https://github.com/mono/mono/issues/9210 :\r\n\r\nIn macOS Mojave, Apple has introduced support for Hardened Runtime. (This is fully explained somewhere in the WWDC 2018 slides, but I cannot right now find exactly where.) One of the hardening mechanisms is a limitation on JIT techniques. It is still fully possible and supported, but the MAP_JIT flag must be passed to mmap() calls, and a specific entitlement must also be present in the code signature. \r\n\r\nhttps://developer.apple.com/videos/play/wwdc2018/702/ 20 minute mark has details."},{"Id":"7867055048","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:51:04","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18592","RelatedDescription":"Merged pull request \"Pass RID to crossgen\" (#18592) at dotnet/coreclr","RelatedBody":"Port of https://github.com/dotnet/corert/pull/5963."},{"Id":"7867013254","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:14:16","Actor":"noahfalk","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18606","RelatedDescription":"Merged pull request \"Fix incorrect usage of ILCodeVersion::AsNode (issue #18602)\" (#18606) at dotnet/coreclr","RelatedBody":"When the debugger is querying the active rejit IL for an IL method that has not been rejitted, it incorrectly creates a VMPTR_ILCodeVersionNode for a code version that shouldn't have one.\r\n\r\n\r\nFixes #18602 \r\nPTAL @kouvel \r\n\r\nI'm starting with a minimal fix that we could look at cherry picking for 2.1 servicing, then we can come back with potentially a more aggressive fix that would only go into v.next."},{"Id":"7867013252","Type":"IssuesEvent","CreatedAt":"2018-06-23T02:14:16","Actor":"noahfalk","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18602","RelatedDescription":"Closed issue \"\"Go to disassembly\" in VS aborts debugging session\" (#18602) at dotnet/coreclr","RelatedBody":"Repro:\r\n\r\n- Attach VS to CoreCLR process\r\n- Find frame in System.Private.Corelib\r\n- Select \"Go to disassembly\"\r\n\r\nResult: \r\n\r\nmsvsmon.exe crashes\r\n"},{"Id":"7866988284","Type":"PullRequestEvent","CreatedAt":"2018-06-23T01:52:17","Actor":"stephentoub","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18616","RelatedDescription":"Opened pull request \"Change string.Compare(...) == 0 occurrences to string.Equals(...)\" (#18616) at dotnet/coreclr","RelatedBody":""}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7863206549","Type":"IssuesEvent","CreatedAt":"2018-06-22T09:51:56","Actor":"ramsubbaraoc","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/781","RelatedDescription":"Opened issue \"How to read configuration files using .net standard libraries\" (#781) at dotnet/standard","RelatedBody":"I want to my use the same .net standard library for .NET Core and .NET Framework applications. Different type of config files are supported for .NET Core. If i have to read the config files irrespective of if it is web.config/app.config/appsetting.json using .net standard library what is the class that i have to use. \r\n"},{"Id":"7860997872","Type":"IssuesEvent","CreatedAt":"2018-06-21T22:01:18","Actor":"pomeara","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/780","RelatedDescription":"Closed issue \".net core and .net standard projects\" (#780) at dotnet/standard","RelatedBody":"I've been working on a .NET Core project which uses a .NET Standard back-end and from what I can tell this is mainly due to the OAuth only being implemented in .NET Standard.  I was wanting a pure .NET Core solution, however am now considering that it's probably less painful to just have all back end DLLs as .NET Standard libraries as I started to split the back end up into different layers (repos, domain, etc) and found that the OAuth restriction was causing a painful issue with what could reference what) - thoughts?"},{"Id":"7859387848","Type":"IssuesEvent","CreatedAt":"2018-06-21T16:26:40","Actor":"pmarangoni","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/777","RelatedDescription":"Closed issue \"Problem upgrading NETStandard.Library from 2.0.1 to 2.0.3\" (#777) at dotnet/standard","RelatedBody":"- ASP.NET MVC project\r\n- Using NuGet, I see there is a new version of NETStandardLibrary so I elect to upgrade it\r\n- After upgrading to 2.0.3, I can no longer build the solution. I get this error:\r\nThis project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them. For more information (blah, blah, blah)… The missing file is ..\\packages\\NETStandard.Library.2.0.1\\build\\NETStandard.Library.targets\r\n\r\nThe only way to proceed is to revert back to 2.0.1."},{"Id":"7856759706","Type":"IssuesEvent","CreatedAt":"2018-06-21T08:39:58","Actor":"pomeara","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/780","RelatedDescription":"Opened issue \".net core and .net standard projects\" (#780) at dotnet/standard","RelatedBody":"I've been working on a .NET Core project which uses a .NET Standard back-end and from what I can tell this is mainly due to the OAuth only being implemented in .NET Standard.  I was wanting a pure .NET Core solution, however am now considering that it's probably less painful to just have all back end DLLs as .NET Standard libraries as I started to split the back end up into different layers (repos, domain, etc) and found that the OAuth restriction was causing a painful issue with what could reference what) - thoughts?"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7867145989","Type":"PullRequestEvent","CreatedAt":"2018-06-23T04:15:22","Actor":"dotnet-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30621","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#30621) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7867048934","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:45:56","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/30289","RelatedDescription":"Closed pull request \"Trivial update WindowsRuntimeResourceManager\" (#30289) at dotnet/corefx","RelatedBody":"Update PRIExceptionInfo field's name caused by https://github.com/dotnet/coreclr/pull/18417"},{"Id":"7867047960","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:45:06","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30440","RelatedDescription":"Merged pull request \"Use public implementation WindowsRuntime ExceptionSupport\" (#30440) at dotnet/corefx","RelatedBody":"Use public implementation AttachRestrictedErrorInfo and ReportUnhandledError() from S.P.Corelib to remove InternalVisiable dependency between S.R.WindowsRuntime and S.P.Corelib"},{"Id":"7867042775","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:40:40","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30562","RelatedDescription":"Merged pull request \"Pass RID to crossgen\" (#30562) at dotnet/corefx","RelatedBody":"Fixes #30043"},{"Id":"7867042770","Type":"IssuesEvent","CreatedAt":"2018-06-23T02:40:40","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30043","RelatedDescription":"Closed issue \"crossgen.sh: line 80: $2: unbound variable\" (#30043) at dotnet/corefx","RelatedBody":"When trying to run `build.sh` on a clean check out from WSL."},{"Id":"7866993297","Type":"PullRequestEvent","CreatedAt":"2018-06-23T01:56:55","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30615","RelatedDescription":"Merged pull request \"Fix race in TaskCancelWaitTestCases.TaskCancelWait1()\" (#30615) at dotnet/corefx","RelatedBody":"When `CancelChildren` is enabled (currently only in the `TaskCancelWait1` test) we're hitting a race in `TaskCancelWaitTest.CreateTask()`:\r\n\r\n1. Let's assume Task A is processing `node`\r\n2. Task A spawns a new Task B for processing `node_1`\r\n3. Task B starts and signals the `_countdownEvent`\r\n4. `RealRun()` on the main thread exits the wait on `_countdownEvent`\r\n5. `RealRun()` calls `Verify()` which loops through all the nodes and calls `VerifyCancel()`\r\n6. We get an assertion because `CancellationToken.IsCancellationRequested` is false\r\n7. Task A continues and sets the CancellationToken on the child(ren), but it is already too late by this point\r\n\r\nTo fix this race we wait on the task in `RealRun()` before proceeding to the verification step.\r\n\r\nThis uncovered another issue:\r\nSince `_countdownEvent` is accessed by multiple threads we have another race between checking `_countdownEvent.IsSet` and `_countdownEvent.Signal()`.\r\n\r\nThis caused a `System.InvalidOperationException: Invalid attempt made to decrement the event's count below zero.` Fixed it by locking access to the `_countdownEvent`.\r\n\r\nFixes https://github.com/dotnet/corefx/issues/20457\r\nFixes https://github.com/mono/mono/issues/6920\r\n\r\n/cc @stephentoub "},{"Id":"7866993290","Type":"IssuesEvent","CreatedAt":"2018-06-23T01:56:55","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/20457","RelatedDescription":"Closed issue \"TaskCancelWait1 failed with Task which has been explicitly cancel-requested either by parent must have CancellationRequested set as true\\nExpected: True\\nActual:   False\" (#20457) at dotnet/corefx","RelatedBody":"\r\nhttps://mc.dot.net/#/user/stephentoub/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fportable~2Fcli~2F/fb8b5bd13c0251b01a88cd3e65962ec2575fb023/workItem/System.Threading.Tasks.Tests/analysis/xunit/System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTestCases~2FTaskCancelWait1\r\n\r\n```\r\nTask which has been explicitly cancel-requested either by parent must have CancellationRequested set as true\\nExpected: True\\nActual:   False\r\nStack Trace :\r\n   at System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTest.VerifyCancel(TaskInfo current) in /mnt/j/workspace/dotnet_corefx/master/portable-linux-Config_Debug+OuterLoop_false_prtest/src/System.Threading.Tasks/tests/Task/TaskCancelWaitTest.cs:line 262\r\n   at System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTest.<Verify>b__12_0(TaskInfo current) in /mnt/j/workspace/dotnet_corefx/master/portable-linux-Config_Debug+OuterLoop_false_prtest/src/System.Threading.Tasks/tests/Task/TaskCancelWaitTest.cs:line 208\r\n   at System.Threading.Tasks.Tests.CancelWait.TaskInfo.Traversal(Action`1 predicate) in /mnt/j/workspace/dotnet_corefx/master/portable-linux-Config_Debug+OuterLoop_false_prtest/src/System.Threading.Tasks/tests/Task/TaskCancelWaitTest.cs:line 584\r\n   at System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTest.Verify() in /mnt/j/workspace/dotnet_corefx/master/portable-linux-Config_Debug+OuterLoop_false_prtest/src/System.Threading.Tasks/tests/Task/TaskCancelWaitTest.cs:line 203\r\n   at System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTest.RealRun() in /mnt/j/workspace/dotnet_corefx/master/portable-linux-Config_Debug+OuterLoop_false_prtest/src/System.Threading.Tasks/tests/Task/TaskCancelWaitTest.cs:line 118\r\n   at System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTestCases.TaskCancelWait1() in /mnt/j/workspace/dotnet_corefx/master/portable-linux-Config_Debug+OuterLoop_false_prtest/src/System.Threading.Tasks/tests/Task/TaskCancelWaitTests.cs:line 25\r\n```\r\n\r\nalso @Priya91 saw here\r\n\r\n\r\nhttps://mc.dot.net/#/user/stephentoub/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fportable~2Fcli~2F/fb8b5bd13c0251b01a88cd3e65962ec2575fb023/workItem/System.Threading.Tasks.Tests/analysis/xunit/System.Threading.Tasks.Tests.CancelWait.TaskCancelWaitTestCases~2FTaskCancelWait1\r\n"},{"Id":"7866992537","Type":"PullRequestEvent","CreatedAt":"2018-06-23T01:56:12","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30620","RelatedDescription":"Opened pull request \"Change string.Compare(..., Ordinal{IgnoreCase}) == 0 to use Equals\" (#30620) at dotnet/corefx","RelatedBody":""},{"Id":"7866974632","Type":"IssuesEvent","CreatedAt":"2018-06-23T01:40:17","Actor":"karelz","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30587","RelatedDescription":"Closed issue \"HttpClient: HTTPS requests fail in .NET Core 2.1 under proxy\" (#30587) at dotnet/corefx","RelatedBody":"HTTPS requests fail on .NET Core 2.1 under a proxy, the response is a 407 proxy required error.\r\n\r\nI've made a repo demonstrating it working under netcore20 and not under netcore21: https://github.com/talanc/dotnetcore-proxytest\r\nYou need to be in a proxy environment for netcore21 to fail.\r\n\r\nBackground: I was in the process of converting an ASP.NET Core 2.0 application to 2.1 and I saw 1 of my tests fail when moving the target framework from netcore20 to netcore21 (no code changes). I thought it was a bit odd because I have two very similar tests with the only difference being 1 does a HTTP GET and the other does HTTPS GET.\r\n\r\nEnvironment: I'm running Windows 7 (x64) under a corporate network proxy.\r\n\r\nI'm willing to help with testing potential fixes and workarounds."},{"Id":"7866958571","Type":"IssuesEvent","CreatedAt":"2018-06-23T01:26:42","Actor":"karelz","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/29271","RelatedDescription":"Closed issue \"DataContractJsonSerializer: I-JSON Option Request\" (#29271) at dotnet/corefx","RelatedBody":"Related: https://github.com/javaee/jsonb-spec/issues/80"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7867143701","Type":"PullRequestEvent","CreatedAt":"2018-06-23T04:13:08","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6000","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6000) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7867071906","Type":"PullRequestEvent","CreatedAt":"2018-06-23T03:05:26","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5996","RelatedDescription":"Closed pull request \"[JustFOrView]Moved EventWaitHandle.cs to shared\" (#5996) at dotnet/corert","RelatedBody":"Related coreclr pr https://github.com/dotnet/coreclr/pull/18612"},{"Id":"7867039578","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:37:57","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5999","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#5999) at dotnet/corert","RelatedBody":""},{"Id":"7867039238","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:37:39","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5998","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#5998) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7867029579","Type":"PullRequestEvent","CreatedAt":"2018-06-23T02:29:03","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5998","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#5998) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7866619452","Type":"PullRequestEvent","CreatedAt":"2018-06-22T22:27:59","Actor":"nattress","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5997","RelatedDescription":"Opened pull request \"Generate Main method\" (#5997) at dotnet/corert","RelatedBody":"Make the Jit available from the ILCompiler.ReadyToRun project. I have a PR to refactor the Jit into a separate project in master but didn't want to block on that.\r\n\r\nRestrict the root providers in ready-to-run mode such that the entry point is the only thing that acts as a root (other than the ready-to-run header).\r\n\r\nAdd DebugInformationProvider and DevirtualizationManager to `ReadyToRunCodegenCompilationBuilder`. I thought we could simplify and remove them but that was wrong. Using a combination of EmptyMetadataManager, NullDebugInformationProvider, and the default implementation of DevirtualizationManager is sufficient to compile Main."},{"Id":"7866549609","Type":"PullRequestEvent","CreatedAt":"2018-06-22T22:05:24","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5996","RelatedDescription":"Opened pull request \"[JustFOrView]Moved EventWaitHandle.cs to shared\" (#5996) at dotnet/corert","RelatedBody":"Related coreclr pr https://github.com/dotnet/coreclr/pull/18612"},{"Id":"7866359072","Type":"PullRequestEvent","CreatedAt":"2018-06-22T21:11:42","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5995","RelatedDescription":"Merged pull request \"Fix WebApi sample\" (#5995) at dotnet/corert","RelatedBody":""},{"Id":"7866189586","Type":"PullRequestEvent","CreatedAt":"2018-06-22T20:30:32","Actor":"nattress","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5988","RelatedDescription":"Merged pull request \"Emit Ready-to-run header\" (#5988) at dotnet/corert","RelatedBody":"Write out the ready-to-run (managed native) header, which outputs directory entries for each of the various tables. Currently we write out the CompilerIdentifierNode, a simple example showing how we'll write out the other tables.\r\n\r\nThe header is very similar to the existing CoreRT ready-to-run header with a few differences. For example, the section count is Int16 on CoreRT but Int32 on CoreCLR. The section pointers are also encoded differently (pointer relocs on CoreRT, baseless RVAs on CoreCLR). Also, each section reference can have flags on CoreRT.\r\n\r\nThe image produced by ILCompiler currently is not loadable by CoreCLR, which needs further investigation."},{"Id":"7865882301","Type":"PullRequestEvent","CreatedAt":"2018-06-22T19:16:51","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5990","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5990) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7865880411","Type":"PullRequestEvent","CreatedAt":"2018-06-22T19:16:22","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5995","RelatedDescription":"Opened pull request \"Fix WebApi sample\" (#5995) at dotnet/corert","RelatedBody":""}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1010269960948465665","CreatedAt":"2018-06-22T21:15:03+00:00","UserScreenname":"dotnet","Text":".NET Core 2.0 End of Life Extended to October 1, 2018 https://t.co/KQAlfqjfGv","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":28,"FavoriteCount":30,"RawContent":null},{"Id":"1010268594725269504","CreatedAt":"2018-06-22T21:09:37+00:00","UserScreenname":"dotnet","Text":".NET Core 2.1 June Update https://t.co/GJkOJkg0zJ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":74,"FavoriteCount":48,"RawContent":null},{"Id":"1010144767924154368","CreatedAt":"2018-06-22T12:57:34+00:00","UserScreenname":"dotnet","Text":"It's #fsharp Friday on Fritz and Friends with our friend @csharpfritz  -- tune in today and learn about… https://t.co/tBMBYu7qnC","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":18,"FavoriteCount":9,"RawContent":null},{"Id":"1009783192751099904","CreatedAt":"2018-06-21T13:00:48+00:00","UserScreenname":"dotnet","Text":"These two are always great to learn from separately, and today they're working together.  You won't want to miss… https://t.co/DhpOULOjfn","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":3,"RawContent":null},{"Id":"1009514602428710912","CreatedAt":"2018-06-20T19:13:31+00:00","UserScreenname":"dotnet","Text":".NET Core 2.0 will reach End of Life on September 1, 2018 https://t.co/5PoTWEAQgt","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":260,"FavoriteCount":294,"RawContent":null},{"Id":"1009477602791133186","CreatedAt":"2018-06-20T16:46:30+00:00","UserScreenname":"dotnet","Text":"Call for papers now open for #dotnetconf virtual event in September! Present to our worldwide community. No travel… https://t.co/KraqcAKxAo","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":287,"FavoriteCount":216,"RawContent":null},{"Id":"1009207915775811584","CreatedAt":"2018-06-19T22:54:51+00:00","UserScreenname":"dotnet","Text":"The RyuJIT transition is complete! https://t.co/JhkSV0Aybh","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":316,"FavoriteCount":169,"RawContent":null},{"Id":"1008787534451638272","CreatedAt":"2018-06-18T19:04:25+00:00","UserScreenname":"dotnet","Text":"Staying up-to-date with .NET Container Images https://t.co/09vnrG5uqh /cc @aspnet @Docker @DockerCon","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":220,"FavoriteCount":117,"RawContent":null},{"Id":"1008746685697150976","CreatedAt":"2018-06-18T16:22:06+00:00","UserScreenname":"dotnet","Text":"Building distributed applications with Orleans https://t.co/GgWRQHcdPP","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":65,"FavoriteCount":27,"RawContent":null}]}},"RunOn":"2018-06-23T05:30:33.3640793Z","RunDurationInMilliseconds":7198}