{"Data":{"Blog":{"FeedItems":[{"Title":"Entity Framework 6.2 Runtime Released","PublishedOn":"2017-10-26T21:32:59+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today we announce the availability of EF 6.2 runtime in NuGet.org. Entity Framework (EF) is Microsoft&#8217;s traditional object/relational mapper (O/RM) for .NET Framework. To understand the difference between EF6 and EF Core, please refer to our documentation. How to obtain the new package You can install EF 6.2 either using the &#8220;Manage NuGet Packages&#8221; option... <a aria-label=\"read more about Entity Framework 6.2 Runtime Released\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/26/entity-framework-6-2-runtime-released/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/26/entity-framework-6-2-runtime-released/","RawContent":null},{"Title":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018","PublishedOn":"2017-10-23T16:41:13+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"This post was written by Varun Venkatesan, Li Tian, and Juan Rodriguez, engineers at Intel. They are excited to share .NET Core-specific enhancements that Intel has made to VTune Amplifier 2018. We&#8217;re excited to have a new tool to use to help make .NET Core faster on Intel chips. Intel has been a strong partner in the development... <a aria-label=\"read more about .NET Core Performance Profiling with Intel® VTune™ Amplifier 2018\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/","RawContent":null},{"Title":"Experiment with Azure for FREE!","PublishedOn":"2017-10-19T14:00:11+00:00","CommentsCount":36,"FacebookCount":0,"Summary":"What is Azure? What can it do for me? Do I need it? How do I find out? How do I use it? Will it help my business? Can it help my career? With all the things Azure can do, it&#8217;s hard to know where to start answering these important questions. But there&#8217;s a really... <a aria-label=\"read more about Experiment with Azure for FREE!\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/","RawContent":null},{"Title":"Announcing the .NET Framework 4.7.1","PublishedOn":"2017-10-17T21:26:30+00:00","CommentsCount":34,"FacebookCount":0,"Summary":"Today, we are announcing the release of the .NET Framework 4.7.1. It’s included in the Windows 10 Fall Creators Update. .NET Framework 4.7.1 is also available on Windows 7+ and Windows Server 2008 R2+.  We’ve added support for targeting the .NET Framework 4.7.1 in Visual Studio 2017 15.5. The .NET Framework 4.7.1 includes improvements in several areas: Accessibility improvements... <a aria-label=\"read more about Announcing the .NET Framework 4.7.1\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/","RawContent":null},{"Title":".NET Framework October 2017 Preview of Quality Rollup","PublishedOn":"2017-10-17T20:56:56+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Preview of Quality Rollup. This type of rollup is intended for businesses that want to the preview or use quality improvements as soon as they are available. Quality and Reliability This release contains the following quality and reliability improvements. CLR Code optimization bug for x64 C# code targeting... <a aria-label=\"read more about .NET Framework October 2017 Preview of Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/","RawContent":null},{"Title":"RyuJIT Just-in-Time Compiler Optimization Enhancements","PublishedOn":"2017-10-17T05:16:50+00:00","CommentsCount":15,"FacebookCount":0,"Summary":"I&#8217;d like to tell you about some of the recent changes we&#8217;ve made as part of our ongoing work to extend the optimization capabilities of RyuJIT, the MSIL-to-native code generator used by .NET Core and .NET Framework. I hope it will make for an interesting read, and offer some insight into the sorts of optimization opportunities we have... <a aria-label=\"read more about RyuJIT Just-in-Time Compiler Optimization Enhancements\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/","RawContent":null},{"Title":".NET Framework October 2017 Security and Quality Rollup","PublishedOn":"2017-10-11T06:02:21+00:00","CommentsCount":16,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Security and Quality Rollup. The update applies to all supported Windows versions. It includes a known issue for Windows 10 1507 (see below). Security This release contains no new security updates. Quality and Reliability This release contains the following quality and reliability improvements. WPF WPF fails to load... <a aria-label=\"read more about .NET Framework October 2017 Security and Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/net-framework-october-2017-security-and-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/net-framework-october-2017-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing UWP Support for .NET Standard 2.0","PublishedOn":"2017-10-10T22:57:46+00:00","CommentsCount":107,"FacebookCount":0,"Summary":"This post was mostly written by Rich Lander with contributions from Immo Landwerth. Today, we are releasing huge updates to UWP for .NET developers. The really big improvement is adding support for .NET Standard 2.0. UWP developers now have access to ~ 20k more APIs. This release brings UWP to partity with the other .NET implementations... <a aria-label=\"read more about Announcing UWP Support for .NET Standard 2.0\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/announcing-uwp-support-for-net-standard-2-0/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/announcing-uwp-support-for-net-standard-2-0/","RawContent":null},{"Title":".NET Framework 4.7.1 Runtime and Compiler Features","PublishedOn":"2017-09-28T23:56:59+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"This post describes the new Runtime, Compiler and Base Class Library (BCL) improvements in the .NET Framework 4.7.1. You can try out these features by downloading the Developer Pack, described in the Welcome to the .NET Framework 4.7.1 Early Access blog post.  BCL &#8211; .NET Standard 2.0 Support .NET Framework 4.7.1 has built-in support for .NET Standard 2.0. .NET Framework 4.7.1... <a aria-label=\"read more about .NET Framework 4.7.1 Runtime and Compiler Features\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/28/net-framework-4-7-1-runtime-and-compiler-features/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/28/net-framework-4-7-1-runtime-and-compiler-features/","RawContent":null},{"Title":"Build a web service with F# and .NET Core 2.0","PublishedOn":"2017-09-26T16:39:23+00:00","CommentsCount":13,"FacebookCount":0,"Summary":"Earlier this year, I wrote about an update to the roadmap for F# and .NET Core. I had mentioned that there were a number of things you could build with F# and .NET Core today, such as web services. In this post, I&#8217;ll walk through building a web service with F# and .NET Core 2.0... <a aria-label=\"read more about Build a web service with F# and .NET Core 2.0\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6767783059","Type":"IssuesEvent","CreatedAt":"2017-10-26T05:52:31","Actor":"HarelM","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Opened issue \"File system watcher crach\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."},{"Id":"6650451504","Type":"IssuesEvent","CreatedAt":"2017-09-28T16:22:10","Actor":"hughbe","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/87","RelatedDescription":"Opened issue \"PRs to repos outside of dotnet/* pattern should not always thank for signing the CLA\" (#87) at dotnet/home","RelatedBody":"For example: https://github.com/mono/libgdiplus/pull/109\r\n\r\nI have already signed the CLI. On the dotnet/corefx etc. projects, I don't get the extra message:\r\n\r\n```\r\n@hughbe,\r\nThanks for having already signed the Contribution License Agreement. Your agreement was validated by .NET Foundation. We will now review your pull request.\r\nThanks,\r\n.NET Foundation Pull Request Bot\r\n```\r\n\r\nJust a small gripe, as I get an email each time I do this. I've seen this in Mono and Xunit.\r\n\r\n/cc @karelz I know this is unrelated to corefx but maybe you know the right person/repo to route this to :D\r\n"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6766996801","Type":"IssuesEvent","CreatedAt":"2017-10-26T00:24:01","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/36","RelatedDescription":"Opened issue \"microsoft/dotnet-framework images now support Windows Server 1709\" (#36) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework images now support Windows Server 1709\r\n\r\n[Windows Server Version 1709](https://blogs.technet.microsoft.com/windowsserver/2017/10/17/windows-server-version-1709-available-for-download/) was released earlier this month. [microsoft/windowsservercore](https://hub.docker.com/r/microsoft/windowsservercore/) images have been updated to support [Windows Server 1709](https://docs.microsoft.com/en-us/windows-server/get-started/whats-new-in-windows-server-1709). These images can be identified with the `1709` [tag](https://hub.docker.com/r/microsoft/windowsservercore/tags/).\r\n\r\nThe following repos have been updated:\r\n\r\n* [microsoft/aspnet](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #35](https://github.com/Microsoft/dotnet-framework-docker/issues/35)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #31](https://github.com/Microsoft/dotnet-framework-docker/pull/31)\r\n* [microsoft/dotnet-framework-docker #34](https://github.com/Microsoft/dotnet-framework-docker/pull/34)\r\n* [microsoft/dotnet-framework-docker #32](https://github.com/Microsoft/dotnet-framework-docker/issues/32)\r\n\r\n.NET Framework Docker images now support Windows Server 1709, the latest version of Windows Server.\r\n\r\n.NET Framework 3.5 and 4.7.1 images are available for Windows Server 1709. Windows Server 1709 includes the .NET Framework 4.7.1. .NET Framework 4.6.2 and .NET Framework 4.7 images are only available with Windows Server 2016 images. You can see an example of 1709-based images in the following example.\r\n\r\n![.NET Framework Windows 1709 images](https://user-images.githubusercontent.com/2608468/32028249-6684a82c-b9a2-11e7-8afa-1b1abf89eb3b.png)\r\n\r\nYou can identify Windows Server 1709-based .NET Framework images with the tag substring `windowsservercore-1709` and Windows Server 2016 images with the tag substring `windowsservercore-10.0.14393`. You will likely notice that the 1709-based images are easier to identify than the Windows Server 2016 ones. \r\n\r\nChanges have been made in Windows Server 1709 that affect the [compatibility of Windows container images](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility). The practical impact is that Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creative Update hosts cannot load Windows Server 1709 images. Windows 10 Fall Creative Update and Windows Server 1709 can load both original Windows Server 2016 and Windows Server 1709 images. Windows Server 1709 requires Hyper-V isolation (`docker run --isolation=hyperv`) in order to load Windows Server 2016 images.\r\n\r\nGiven the compatibility differences with Windows container images, .NET Framework images will adopt [manifest lists](https://github.com/Microsoft/dotnet-framework-docker/issues/32) so that a single logical tag, like `4.7.1`, can be used on both older and newer Windows 10 and Windows Server versions. `docker pull microsoft/dotnet-framework:4.7.1` will pull a Windows Server 2016 image on Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creators Update machines. The same command will pull a Windows Server 1709 based image on Windows Server 1709 and Windows 10 Fall Creators Update machines. The same rules apply to FROM lines. [.NET Core](https://hub.docker.com/r/microsoft/dotnet) Docker images use this same feature to support Linux and Windows hosts and AMD64 and ARM32 hosts with the same logical tag, like `2.0-runtime`.\r\n\r\nThe following tags will be updated to use manifest lists:\r\n\r\n- `latest`\r\n- `4.7.1`\r\n- `3.5`\r\n\r\nYou need [Docker 17.10](https://docs.docker.com/release-notes/docker-ce/#17100-ce-2017-10-17) or later to use Windows-version-specific manifest list tags. The following change from the Docker 17.10 release notes is the one that enables this functionality.\r\n\r\n* Add support for Windows version filtering on pull [moby/moby#35090](https://github.com/moby/moby/pull/35090)\r\n\r\nYou are only recommended to use manifest tags if you want flexibility for development and deployment environments. That's what manifest tags deliver. In general, you should select the most specific tag you can. The more specific the tag, the more predictable the result of each `docker pull` and `docker build` will be."},{"Id":"6761784781","Type":"IssuesEvent","CreatedAt":"2017-10-25T04:03:38","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/35","RelatedDescription":"Opened issue \"microsoft/dotnet-framework latest tag updated to 4.7.1\" (#35) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework latest tag updated to 4.7.1\r\n\r\nThe [.NET Framework 4.7.1](https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/) was released earlier this month. The [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework) `latest` [tag](https://hub.docker.com/r/microsoft/dotnet-framework/tags/) was also updated.\r\n\r\nThe .NET Framework 4.7.1 is represented by the `microsoft/dotnet-framework:4.7.1` tag.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #33](https://github.com/Microsoft/dotnet-framework-docker/issues/33)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #28](https://github.com/Microsoft/dotnet-framework-docker/pull/28)\r\n* [microsoft/dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework 4.7.1 image is now available as a Docker image. The `latest` tag points to the same image.\r\n\r\nThe following repos were updated:\r\n\r\n* [microsoft/asp](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\nThe [microsoft/dotnet-framework-samples](https://hub.docker.com/r/microsoft/dotnet-framework-samples) repo has not yet been updated.\r\n\r\nWe recommend that you use version-specific tags for production apps. For experimentation or while an application is in development, using the `latest` tag is a fine practice.\r\n\r\nWe recently found a [significant performance issue with .NET Framework Docker images](https://github.com/dotnet/announcements/issues/33). The .NET Framework 4.7.1 image includes the fix for that problem.\r\n"},{"Id":"6729762964","Type":"IssuesEvent","CreatedAt":"2017-10-17T21:21:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/34","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2017-8585 : Malformed Culture can cause application crash\" (#34) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-8585 \r\n## Malformed Culture can cause application to crash\r\n### Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed string request could cause an application to crash and lead to a denial of service.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.7 and 1.1.4. Developers are advised to update their .NET Core SDK to version 1.1.4.\r\n\r\n### Discussion\r\n\r\nUse https://github.com/dotnet/corefx/issues/24703 for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n\r\n.NET Core 2.0 is not affected by this issue.\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.6 or lower versions, or 1.1.2 or lower versions is affected. The latest version of the .NET core runtime you have installed in your computer can be listed by running `dotnet --info`. Running that command produces an output similar to the following:\r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\nAs this command only displays the latest version of the runtime installed (or the version set in the *global.json* file), it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location          |\r\n|------------------|-------------------|\r\n| Windows          | C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\ |\r\n| macOS            | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n| [Supported Linux platforms](https://docs.microsoft.com/dotnet/core/linux-prerequisites#supported-linux-versions) | /usr/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.7 and 1.1.4, then any applications targeting 1.0 or 1.1 of .NET Core are vulnerable.\r\n\r\nAlso, even if you have a directory for 1.0.7 and 1.1.4 present in your system, if you've deployed [self-contained applications](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd) targeting the impacted versions, these applications are also vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). .NET Core 1.1.4 SDK installs both versions 1.0.7 and 1.1.4 of the .NET Core runtime.\r\n\r\nIf you've built a [self-contained application](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd), you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [*application.runtime.config*](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application. Set the framework version to the desired version and the `rollForward` property to `false`. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the *application.runtime.config* file is an optional file, you may need to create one for each application and add it alongside the executable."},{"Id":"6725652001","Type":"IssuesEvent","CreatedAt":"2017-10-17T06:48:14","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/33","RelatedDescription":"Opened issue \".NET Framework Docker Performance Issue Resolved\" (#33) at dotnet/announcements","RelatedBody":"# .NET Framework Docker Performance Issue Resolved\r\n\r\nMultiple people have [reported](https://github.com/Microsoft/dotnet-framework-docker/issues/25) that [.NET Framework performance in Docker images is poor](https://github.com/moby/moby/issues/33096). In the cases reported, performance was an order of magnitude slower than expected.\r\n\r\nThis issue has now been resolved for [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) images. It was due to incorrectly generated NGEN images. They are now correctly generated and expected performance has been restored.\r\n\r\n## Discussion \r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet-framework-docker #29](https://github.com/Microsoft/dotnet-framework-docker/pull/29)\r\n\r\n## Details\r\n\r\n* [dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework uses [NGEN](https://docs.microsoft.com/dotnet/framework/tools/ngen-exe-native-image-generator) as a primary mechanism for startup performance. .NET Framework assemblies are compiled to native code with the NGEN tool as part of the .NET Framework setup process. The benefit of these files is that they can be loaded and executed without any additional significant extra work required by the Common Language Runtime (CLR). The lack of  additional work means that performance is very good.\r\n\r\nNGEN image generation interacts with a Windows subsystem that is not correctly supported in Windows containers. NGEN images are generated in Windows containers, but they are not valid. Fortunately, the CLR can still run in the presence of invalid images, but code execution is much slower.\r\n\r\nWe are in the process of fixing Windows containers so that NGEN will work correctly. In the interim, we have updated the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) images to correctly generate NGEN images. The [microsoft/windowsservercore/](https://hub.docker.com/r/microsoft/windowsservercore/) images still have the performance problem that was initially reported. We are working on updating Windows containers so that NGEN works as expected. You are recommended to use the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) base image if you can, so that you can get better performance.\r\n\r\nOne of the developers that reported the performance issue shared basic performance results. The first two rows are the before state. The last row is the dotnet-framework image after the fix. The improvement is quite significant.\r\n\r\n> Runing `powershell -command (measure-command { powershell -command exit }).TotalSeconds` in various images on our CI server produced this table of timings:\r\n \r\n| time (s) | image |\r\n|----------|--------|\r\n|10.7212372| microsoft/windowsservercore |\r\n|8.3278793  | microsoft/dotnet-framework:4.7|\r\n|0.6426073  | microsoft/dotnet-framework:4.7 (after fix)|\r\n"},{"Id":"6645912196","Type":"IssuesEvent","CreatedAt":"2017-09-27T19:47:08","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/32","RelatedDescription":"Opened issue \".NET Framework 4.7.1 provides built-in support for .NET Standard 2.0\" (#32) at dotnet/announcements","RelatedBody":"## Summary\r\n\r\n.NET Framework 4.7.1 will have built-in support for .NET Standard 2.0. This means that you don't have to deploy any additional files or use binding redirects to use .NET Standard 2.0 libraries.\r\n\r\nFor a demo, check out [this video][video].\r\n\r\n## Details\r\n\r\nWhile libraries targeting [.NET Standard 2.0][ns20post] are can be consumed by applications and libraries [targeting .NET Framework 4.6.1][nstable] and higher, not all files that are required for .NET Standard libraries were part of .NET Framework 4.6.1. In fact, .NET Framework 4.6.1 was shipped before .NET Standard 2.0 was even designed. That's why building an application targeting .NET Framework 4.6.1 (as well as 4.6.2 and 4.7) will have to deploy additional files.\r\n\r\n* If you use **Visual Studio 2017 15.3** or higher, these files are automatically copied to the application's output folder.\r\n\r\n* If you use **Visual Studio 2015 and [use NuGet 3.6][nuget36]**, we'll prompt you to install a [support package][vs2015support] which will handle copying the files to the output directory.\r\n\r\nStarting with .NET Framework 4.7.1 these files no longer have to be deployed with the application -- they are built right into the .NET Framework itself.\r\n\r\n.NET Framework 4.7.1 also adds[about 200 missing APIs][missingapis] that were part of .NET Standard 2.0 but not actually implemented by .NET Framework 4.6.1, 4.6.2 or 4.7.\r\n\r\nThis also removes the need for [binding redirects][netfx-issues] when using .NET Standard libraries on .NET Framework because the CLR automatically unifies version numbers of assemblies that are part of the platform.\r\n\r\nLearn more [by reading the .NET Standard FAQ](http://aka.ms/netstandardfaq).\r\n\r\n## Discussion\r\n\r\nDiscussion\r\n\r\nFor a discussion, please go to dotnet/standard#514.\r\n\r\n[ns20post]: https://blogs.msdn.microsoft.com/dotnet/2017/08/14/announcing-net-standard-2-0/\r\n[nstable]: https://docs.microsoft.com/en-us/dotnet/standard/net-standard\r\n[nuget36]: https://dist.nuget.org/visualstudio-2015-vsix/v3.6.0/NuGet.Tools.vsix\r\n[vs2015support]: https://aka.ms/netstandard-build-support-netfx\r\n[missingapis]: https://github.com/dotnet/standard/blob/master/netstandard/src/ApiCompatBaseline.net461.txt\r\n[netfx-issues]: https://github.com/dotnet/standard/issues/481\r\n[video]: https://www.youtube.com/watch?v=u67Eu_IgEMs\r\n\r\nhttps://github.com/dotnet/standard/issues/514"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6777885121","Type":"PullRequestEvent","CreatedAt":"2017-10-28T02:21:43","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14733","RelatedDescription":"Opened pull request \"Fix another overly agressive assert\" (#14733) at dotnet/coreclr","RelatedBody":"Fix #14732"},{"Id":"6777851536","Type":"IssuesEvent","CreatedAt":"2017-10-28T01:53:49","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/14732","RelatedDescription":"Opened issue \"[RyuJIT/x86][JitStressRegs=8] Assertion failed '!nextRefPosition->RequiresRegister()'\" (#14732) at dotnet/coreclr","RelatedBody":"This is similar to #14624. It is an overly aggressive assert that needs to be loosened when the register candidates have been constrained for stress testing.\r\nIt appeared in the ARM altjit stress testing, but is actually an x86 failure."},{"Id":"6777847516","Type":"PullRequestEvent","CreatedAt":"2017-10-28T01:50:22","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14717","RelatedDescription":"Merged pull request \"Fix FixedReg assert\" (#14717) at dotnet/coreclr","RelatedBody":"With JitStressRegs (various values) it is possible to have RefPositions that have a single candidate, even though they are not really a fixed reference to the given register.\r\n\r\nFix #14624"},{"Id":"6777847515","Type":"IssuesEvent","CreatedAt":"2017-10-28T01:50:22","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/14624","RelatedDescription":"Closed issue \"[RyuJIT/arm32][JitStressRegs=8] Assertion failed 'refPosition->isFixedRegRef || (refPosition->nextRefPosition != nullptr && refPosition->nextRefPosition->isFixedRegRef)'\" (#14624) at dotnet/coreclr","RelatedBody":"There are a number of these failures in arm altjit jitstressregs=8, due to my refactoring checkin."},{"Id":"6777746879","Type":"PullRequestEvent","CreatedAt":"2017-10-28T00:36:58","Actor":"Maoni0","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14719","RelatedDescription":"Merged pull request \"Don't wake up other GC threads when we decide to not proceed with the GC\" (#14719) at dotnet/coreclr","RelatedBody":"When we don't proceed with the GC, we don't reset gc_start_event, and if there's nothing else to do, other GC threads will keep busy looping in gc_thread_function. There's no good place to reset the event so I just made it not wait for other GC threads at all. I intentionally kept the proceed_with_gc_p global var 'cause it makes the flow easier to follow 'cause it's clear that other threads will call garbage_collect when we decide to proceed with the GC.\r\n\r\nNote that if the process is actually doing something, like allocating, it would work, on machines with HT at least. I have not tried on machines without HT."},{"Id":"6777683199","Type":"PullRequestEvent","CreatedAt":"2017-10-28T00:00:19","Actor":"vancem","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14721","RelatedDescription":"Merged pull request \"Enable Portable Pdb generation\" (#14721) at dotnet/coreclr","RelatedBody":"When https://github.com/dotnet/corefx/pull/24025 goes through to change coreFX over to use portable PDBs we want to do the same for System.private.Corelib.pdb in CoreCLR.   This change does this.\r\n\r\nThis is mostly for uniformity, and the fact that generating portable PDBs for all managed code is our plan going forward.   "},{"Id":"6777573623","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:08:26","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14703","RelatedDescription":"Merged pull request \"Delete dead code\" (#14703) at dotnet/coreclr","RelatedBody":""},{"Id":"6777572508","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:07:59","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14723","RelatedDescription":"Merged pull request \"Revise class hierarchy for some EqualityComparer<T> subclasses\" (#14723) at dotnet/coreclr","RelatedBody":"Make GenericEqualityComparer<T> a final class and reparent\r\nNonRandomizedStringEqualityComparer.\r\n\r\nAlso add a note to the jit sources indicating why we can't be more aggressive\r\nabout devirtualizing `get_Default` if we have a shared type (in particular\r\n__Canon)."},{"Id":"6777482708","Type":"PullRequestEvent","CreatedAt":"2017-10-27T22:32:44","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14715","RelatedDescription":"Merged pull request \"Add regression test for double counting retbuf\" (#14715) at dotnet/coreclr","RelatedBody":"This relates to #14667."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6777778291","Type":"IssuesEvent","CreatedAt":"2017-10-28T00:58:01","Actor":"rkeithhill","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7928","RelatedDescription":"Opened issue \"dotnet is not finding 2.0.0 SDK on system with it installed in the user's AppData dir\" (#7928) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nOn a clean system (no previous .NET Core installs) Install 2.0.2 SDK from http://dot.net\r\nGit clone the PowerShell repo: `git clone --recursive https://github.com/PowerShell/PowerShell.git`\r\nOpen PowerShell prompt and cd to PowerShell repo\r\nExecute: `Import-Module .\\build.psm1`, then `Start-PSBootstrap` and finally `Start-PSBuild`.\r\nThat will install .NET Core 2.0.0 into the user's AppData folder\r\nNote: we have a global.json file in the repo root that pegs the SDK at 2.0.0\r\nThe Start-PSBuild command does a `dotnet --version` check and fails if it isn't `2.0.0`.\r\n\r\n## Expected  behavior\r\nglobal.json set to 2.0.0 should cause `dotnet --version` to return 2.0.0.\r\n\r\n## Actual behavior\r\n`dotnet --version` returns 2.0.2 so this particular user can't build even though he has 2.0.0 SDK installed.\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\nNot sure.  The original [issue](https://github.com/PowerShell/PowerShell/issues/5260) was filed on the PowerShell repo.\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"6777768034","Type":"IssuesEvent","CreatedAt":"2017-10-28T00:50:55","Actor":"rkeithhill","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7927","RelatedDescription":"Opened issue \"Need command list installed runtimes and SDKs\" (#7927) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nTell a project contributor to find out which versions of the .NET Core SDK they have installed to help you troubleshoot a build problem they are having.  \r\n\r\n## Expected  behavior\r\nYou tell the user to run `dotnet list` to get a list of installed runtimes and SDKs.  Or perhaps there is a switch to control which is listed.\r\n\r\n## Actual behavior\r\nBasically you tell them [this](https://github.com/dotnet/announcements/issues/34) for the runtimes:\r\n\r\nOperating System | Location\r\n-- | --\r\nWindows | C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\\r\nmacOS | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/\r\nSupported Linux platforms | /usr/share/dotnet/shared/Microsoft.NETCore.App/\r\n\r\nand to dir another set of directories for the SDKs.  That's a spew.\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n```\r\n.NET Command Line Tools (2.0.0)\r\n\r\nProduct Information:\r\n Version:            2.0.0\r\n Commit SHA-1 hash:  cdcd1928c9\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.0\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"6777710621","Type":"IssuesEvent","CreatedAt":"2017-10-28T00:15:01","Actor":"KathleenDollard","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7926","RelatedDescription":"Opened issue \"Update the --info output\" (#7926) at dotnet/cli","RelatedBody":"Update --info to the following scheme:\r\n\r\n```bash\r\n$ dotnet --info\r\n.NET Core SDK Information:\r\n  SDK Version:  x.y.z\r\n  SDK Build:    e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n\r\nRuntime Environment:\r\n  OS Name:      Mac OS X\r\n  OS Version:   10.12\r\n  OS Platform:  Darwin\r\n  RID:          osx.10.12-x64\r\n  Base Path:    /usr/local/share/dotnet/sdk/2.0.0/\r\n\r\n.NET Core Host (dotnet) Information:\r\n  Host Version: x.y.z\r\n  Host Build:   fab8861ac7faf042c87a5c2f9f2d04c98b69f297\r\n\r\n```\r\n\r\n\r\n\r\n"},{"Id":"6777537245","Type":"PullRequestEvent","CreatedAt":"2017-10-27T22:53:50","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7924","RelatedDescription":"Merged pull request \"Updating the version of the command line parser.\" (#7924) at dotnet/cli","RelatedBody":""},{"Id":"6777534505","Type":"PullRequestEvent","CreatedAt":"2017-10-27T22:52:53","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7890","RelatedDescription":"Merged pull request \"update fsharp compiler for preview release\" (#7890) at dotnet/cli","RelatedBody":"Update dotnet cli to latest F# compiler."},{"Id":"6777494387","Type":"IssuesEvent","CreatedAt":"2017-10-27T22:36:59","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/7696","RelatedDescription":"Closed issue \"Use MSBuild /restore for implicit restore\" (#7696) at dotnet/cli","RelatedBody":"Commands that perform an implicit restore (invoke MSBuild /t:Restore and then build normally) should move to use the `/restore` command-line flag to reduce JIT compile time.\r\n\r\nSee https://github.com/Microsoft/msbuild/pull/2414\r\n"},{"Id":"6777492803","Type":"IssuesEvent","CreatedAt":"2017-10-27T22:36:24","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/7009","RelatedDescription":"Closed issue \"Cannot pass /clp:NoSummary to dotnet build\" (#7009) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\n```\r\ndotnet build /clp:NoSummary\r\n```\r\n\r\n## Expected  behavior\r\n\r\nNo build summary shall be displayed (e.g. duplicated errors).\r\n\r\nThe behaviour should be the same as using it with msbuild:\r\n\r\n```\r\n$ dotnet msbuild /clp:NoSummary\r\nMicrosoft (R) Build Engine version 15.3.388.41745 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nProgram.cs(5,21): error CS0116: A namespace cannot directly contain members such as fields or methods [/Users/martin.ullrich/tmp/tmp.csproj]\r\n```\r\n\r\n## Actual behavior\r\n\r\nBuild summary is displayed:\r\n\r\n```\r\n$ dotnet build /clp:NoSummary\r\nMicrosoft (R) Build Engine version 15.3.388.41745 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nProgram.cs(5,21): error CS0116: A namespace cannot directly contain members such as fields or methods [/Users/martin.ullrich/tmp/tmp.csproj]\r\n\r\nBuild FAILED.\r\n\r\nProgram.cs(5,21): error CS0116: A namespace cannot directly contain members such as fields or methods [/Users/martin.ullrich/tmp/tmp.csproj]\r\n    0 Warning(s)\r\n    1 Error(s)\r\n\r\nTime Elapsed 00:00:01.50\r\n```\r\n\r\nThis seems to be because the implementation of the `build` verb always appends `/clp:Summary` to the arguments, overriding the passed in arguments.\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n```\r\n.NET Command Line Tools (2.0.0-preview2-006502)\r\n\r\nProduct Information:\r\n Version:            2.0.0-preview2-006502\r\n Commit SHA-1 hash:  07dfded669\r\n\r\nRuntime Environment:\r\n OS Name:     Mac OS X\r\n OS Version:  10.12\r\n OS Platform: Darwin\r\n RID:         osx.10.12-x64\r\n Base Path:   /usr/local/share/dotnet/sdk/2.0.0-preview2-006502/\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0-preview2-25407-01\r\n  Build    : 40c565230930ead58a50719c0ec799df77bddee9\r\n```\r\n\r\n\r\n\r\n\r\n"},{"Id":"6777483938","Type":"PullRequestEvent","CreatedAt":"2017-10-27T22:33:11","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7896","RelatedDescription":"Merged pull request \"Use msbuild /restore instead of a separate process\" (#7896) at dotnet/cli","RelatedBody":"Use msbuild /restore instead of separate invocations where possible\r\n\r\nFix #7696\r\n\r\nThis saves 300ms on my machine for incremental build of a simple console app (from 1.4s to 1.1s).\r\n\r\nWe still have to miss out on this optimization when there is -f|--framework argument because we cannot force a TargetFramework global property on to the restore evaluation. Doing so completely breaks restore by applying the TargetFramework to all projects transitively. The correct behavior is to restore for all frameworks, then build/publish/etc for the given target framework. Achieving that still requires two distinct msbuild process invocations.\r\n\r\nThis also changes the verbosity of implicit restore from quiet to that of the subsequent command (default=minimal). Similar to global properties, we cannot specify a distinct console verbosity for the /restore portion of the overall execution. For consistency, we apply the same verbosity change to the case where we still use two separate msbuild invocations.\r\n\r\nOutput Before:\r\n```\r\n[Logo]\r\n  qwert -> D:\\temp\\qwert\\bin\\Debug\\netcoreapp2.0\\qwert.dll.\r\n[Summary]\r\n```\r\n\r\nOutput After:\r\n```\r\n[Logo]\r\n  Restoring packages for D:\\temp\\qwert\\qwert.csproj...\r\n  Installing Newtonsoft.Json 10.0.3.\r\n  Restore completed in 763.37 ms for D:\\temp\\qwert\\qwert.csproj.\r\n  qwert -> D:\\temp\\qwert\\bin\\Debug\\netcoreapp2.0\\qwert.dll\r\n[Summary]\r\n```\r\n\r\nIn the incremental no-op restore case, only the line about \"Restore completed in X for Y\" is added. \r\n\r\nhttps://github.com/NuGet/Home/issues/4695 tracks reducing restores output when verbosity is minimal.\r\n\r\n\r\nThis also fixes an issue where the separate restore invocation's msbuild log would be overwritten by the subsequent command execution. However, this remains unfixed in the case where we still use two separate msbuild invocations.\r\n\r\nThe first two commits are strictly separate, but were getting in the way of test changes I needed to make so I tackled them here.\r\n* Remove necessary handling of verbosity in RestoreCommand\r\n* Fix #7009, Cannot pass /clp:NoSummary to dotnet build\r\n"},{"Id":"6776838716","Type":"PullRequestEvent","CreatedAt":"2017-10-27T19:29:21","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7925","RelatedDescription":"Merged pull request \"Update SDK version to 15.5.0-preview-20171027-2\" (#7925) at dotnet/cli","RelatedBody":"@MattGertz FYI this is a SDK version flow"},{"Id":"6776560437","Type":"PullRequestEvent","CreatedAt":"2017-10-27T18:20:59","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/7925","RelatedDescription":"Opened pull request \"Update SDK version to 15.5.0-preview-20171027-2\" (#7925) at dotnet/cli","RelatedBody":"@MattGertz FYI this is a SDK version flow"},{"Id":"6776546827","Type":"PullRequestEvent","CreatedAt":"2017-10-27T18:17:45","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/7924","RelatedDescription":"Opened pull request \"Updating the version of the command line parser.\" (#7924) at dotnet/cli","RelatedBody":""},{"Id":"6776504429","Type":"PullRequestEvent","CreatedAt":"2017-10-27T18:07:13","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7842","RelatedDescription":"Merged pull request \"Fix relative path handling on Windows.\" (#7842) at dotnet/cli","RelatedBody":"On Windows, `PathUtility.GetRelativePath` was not properly handling\r\npaths that differed by case in the drive reference (e.g. \"C:\\\" vs.\r\n\"c:\\\").  The fix was to add the missing case-insensitive comparison\r\nargument.\r\n\r\nReplaced uses of `PathUtility.GetRelativePath` with\r\n`Path.GetRelativePath` where possible (requires 2.0.0+).\r\n\r\nAdditionally, `PathUtility.RemoveExtraPathSeparators` was not handling\r\npaths with drive references on Windows.  If the path contained a drive\r\nreference, the separator between the drive reference and the first part\r\nof the path was removed.  This is due to `Path.Combine` not handling\r\nthis case, so an explicit concatenation of the separator was added.\r\n\r\nThis commit resolves issue #7699."},{"Id":"6776467602","Type":"PullRequestEvent","CreatedAt":"2017-10-27T17:58:26","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7919","RelatedDescription":"Merged pull request \".NET Core SDK Telemetry Change: Adopt Hashing\" (#7919) at dotnet/cli","RelatedBody":"https://github.com/dotnet/cli/issues/7918"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6777662687","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:49:20","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/561","RelatedDescription":"Merged pull request \"Update BuildTools to prerelease-02127-10 (master)\" (#561) at dotnet/standard","RelatedBody":""},{"Id":"6777661672","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:48:49","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/562","RelatedDescription":"Merged pull request \"Merge dev/release/2.0.0 branch to master\" (#562) at dotnet/standard","RelatedBody":"cc @eerhardt @dagood "},{"Id":"6777517406","Type":"PullRequestEvent","CreatedAt":"2017-10-27T22:46:02","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/562","RelatedDescription":"Opened pull request \"Merge dev/release/2.0.0 branch to master\" (#562) at dotnet/standard","RelatedBody":"cc @eerhardt @dagood "},{"Id":"6777280643","Type":"PullRequestEvent","CreatedAt":"2017-10-27T21:26:06","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/561","RelatedDescription":"Opened pull request \"Update BuildTools to prerelease-02127-10 (master)\" (#561) at dotnet/standard","RelatedBody":""},{"Id":"6776899813","Type":"IssuesEvent","CreatedAt":"2017-10-27T19:45:03","Actor":"rychlym","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/560","RelatedDescription":"Opened issue \"msbuild error - .NET 4.7.1 console app referrencing dotnet standard 2.0 lib\" (#560) at dotnet/standard","RelatedBody":"Hello, \r\nI got in troubles on my dev environments with switching from .NET Framework 4.6.1 to  4.7.1.\r\nFinally I tried to create simple solution with (console app 4.7.1+ lib ,targeting .netstandard2.0), which build  ended up with:\r\nerror CS0012: The type 'Object' is defined in an assembly that is not referenced. You must add a reference to assembly 'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.\r\n\r\nBasically, according to  [Immo Landwerth's video ](https://www.youtube.com/watch?v=u67Eu_IgEMs) it should work :) , but It did't. \r\ndifferences to the video env, I encountered are to the environment on video are:\r\n-  I have newer VS 2017 15.4.1 then I have omitted to install .NET 4.6.2,.NET 4.7 \r\n![image](https://user-images.githubusercontent.com/11144487/32121786-521311cc-bb5e-11e7-9b55-e72aa01bd8d7.png)\r\n- .NET Core SDK 2.0.2\r\n- didn't work on both Win10 1607 build 14393.17770 and 1709 bild 16299.19\r\n\r\n"},{"Id":"6776610191","Type":"PullRequestEvent","CreatedAt":"2017-10-27T18:32:55","Actor":"chcosta","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/553","RelatedDescription":"Merged pull request \"Add transport feed as a source\" (#553) at dotnet/standard","RelatedBody":""},{"Id":"6776142839","Type":"IssuesEvent","CreatedAt":"2017-10-27T16:41:03","Actor":"Petermarcu","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/559","RelatedDescription":"Closed issue \".Net Plaform Standard implementation on .Net 4.7 has version inconsistency for System.Net.Http\" (#559) at dotnet/standard","RelatedBody":"@santhoshkumarmksss commented on [Thu Oct 26 2017](https://github.com/dotnet/core/issues/1050)\n\nI have been using WCF service with .Net 4.7 version and it has project reference of Standard library with version 1.6. If I am using reflection getting bellow error\r\n\r\nSystem.IO.FileLoadException: 'Could not load file or assembly 'System.Runtime, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)'\r\n\r\nCode which generates error:\r\n  Type type = (from assembly in AppDomain.CurrentDomain.GetAssemblies()\r\n                         where assembly.GetName().Name == \"TestStandard\"\r\n                         select assembly.GetType(\"MoE.ERS.DTO.ResourceRequests.PlaygroupResourceRequestDTO\")).FirstOrDefault();\r\n\r\nI have attached sample project reference for which i am getting below error. Also i tried binding redirect in Web.config and still no luck. \r\n\r\nAny quick help will be much appreciated.\r\n\r\n[WcfService1.zip](https://github.com/dotnet/core/files/1420552/WcfService1.zip)\r\n\r\n\r\n\r\n\n\n"},{"Id":"6776139442","Type":"IssuesEvent","CreatedAt":"2017-10-27T16:40:15","Actor":"Petermarcu","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/556","RelatedDescription":"Closed issue \"GZipStream not working as expected on compress.\" (#556) at dotnet/standard","RelatedBody":"I'm using .NET standard and had ported some code from .NET 4.5.2.\r\n\r\n## Expected outcome:\r\n\r\n`Dispose()` **_or_** `Flush()` should be enough for the compressed contents to get copied to the inner stream.\r\n\r\n## Actual outcome\r\n\r\n***Both*** Flush and Dispose are required to get the correct amount of bytes back from the gzipstream:\r\n\r\n```\r\nusing (var gzip = new GZipStream(ms, CompressionLevel.Optimal, true))\r\n{\r\n    gzip.Write(jsonBytes, 0, jsonBytes.Length);\r\n    gzip.Flush();\r\n}\r\nbuffer = ms.ToArray();\r\n```\r\n\r\nWith just flush, I get 190 instead of 200 bytes:\r\n\r\n```csharp\r\nusing (var gzip = new GZipStream(ms, CompressionLevel.Optimal))\r\n{\r\n    gzip.Write(jsonBytes, 0, jsonBytes.Length);\r\n    gzip.Flush();\r\n    buffer = ms.ToArray();\r\n}\r\n```\r\n\r\nWith only Dispose i get 194 of the 200 expected bytes:\r\n\r\n```csharp\r\nusing (var gzip = new GZipStream(ms, CompressionLevel.Optimal, true))\r\n{\r\n    gzip.Write(jsonBytes, 0, jsonBytes.Length);\r\n}\r\nbuffer = ms.ToArray();\r\n```\r\n"},{"Id":"6775978374","Type":"IssuesEvent","CreatedAt":"2017-10-27T16:03:14","Actor":"Petermarcu","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/559","RelatedDescription":"Opened issue \".Net Plaform Standard implementation on .Net 4.7 has version inconsistency for System.Net.Http\" (#559) at dotnet/standard","RelatedBody":"@santhoshkumarmksss commented on [Thu Oct 26 2017](https://github.com/dotnet/core/issues/1050)\n\nI have been using WCF service with .Net 4.7 version and it has project reference of Standard library with version 1.6. If I am using reflection getting bellow error\r\n\r\nSystem.IO.FileLoadException: 'Could not load file or assembly 'System.Runtime, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)'\r\n\r\nCode which generates error:\r\n  Type type = (from assembly in AppDomain.CurrentDomain.GetAssemblies()\r\n                         where assembly.GetName().Name == \"TestStandard\"\r\n                         select assembly.GetType(\"MoE.ERS.DTO.ResourceRequests.PlaygroupResourceRequestDTO\")).FirstOrDefault();\r\n\r\nI have attached sample project reference for which i am getting below error. Also i tried binding redirect in Web.config and still no luck. \r\n\r\nAny quick help will be much appreciated.\r\n\r\n[WcfService1.zip](https://github.com/dotnet/core/files/1420552/WcfService1.zip)\r\n\r\n\r\n\r\n\n\n"},{"Id":"6773294300","Type":"IssuesEvent","CreatedAt":"2017-10-27T04:50:51","Actor":"Edward-Zhou","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/554","RelatedDescription":"Closed issue \"Microsoft.AspNetCore.Mvc.Razor.Compilation.CompilationFailedException : One or more compilation failures occurred\" (#554) at dotnet/standard","RelatedBody":"For this error, I have tried multiple solutions which is provided by Github. But, none of them worked. Please help to check whether this issue reopen on new environment like below.\r\nEnvironment:\r\nVS 2017 Version 15.4.1\r\nDotnet Version 2.0.2\r\n\r\nReproduce Steps:\r\n\r\n1. Create an Asp.Net Core Web Application->.NET Core and Asp.net Core 2.0-> Web Application(Model-View-Controller)\r\n2. Create an xUnit Test Project(.NET Core) \r\n3. Follow this link [Integration testing in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/testing/integration-testing)\r\n4. Add <PreserveCompilationContext>true</PreserveCompilationContext> to Test.csproj which is pointed at above link.\r\n5. Run test method will return below error.\r\n\r\n> Microsoft.AspNetCore.Mvc.Razor.Compilation.CompilationFailedException : One or more compilation failures occurred:\r\newiqttdv.z4g(4,62): error CS0012: The type 'Attribute' is defined in an assembly that is not referenced. You must add a reference to assembly 'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.\r\n\r\nUpdate: \r\nAfter following [this suggestion](https://github.com/aspnet/Hosting/issues/959#issuecomment-286351703) , this error gone, but, it produce below new error.\r\n\r\n> Message: System.IO.FileNotFoundException : Could not load file or assembly 'Microsoft.VisualStudio.Web.CodeGeneration, Culture=neutral, PublicKeyToken=null'. The system cannot find the file specified.\r\n\r\nWhat is the possible way to resolve \"Microsoft.AspNetCore.Mvc.Razor.Compilation.CompilationFailedException\"?\r\n\r\nAny help would be appreciated."},{"Id":"6772894105","Type":"IssuesEvent","CreatedAt":"2017-10-27T01:57:30","Actor":"santhoshkumarmksss","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/558","RelatedDescription":"Opened issue \".Net Plaform Standard implementation on .Net 4.7 has version inconsistency for System.Net.Http Be as descriptive as you can with your title.\" (#558) at dotnet/standard","RelatedBody":"I have been using WCF service with .Net 4.7 version and it has project reference of Standard library with version 1.6. If I am using reflection getting bellow error\r\n\r\nSystem.IO.FileLoadException: 'Could not load file or assembly 'System.Runtime, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)'\r\n\r\nCode which generates error:\r\n  Type type = (from assembly in AppDomain.CurrentDomain.GetAssemblies()\r\n                         where assembly.GetName().Name == \"TestStandard\"\r\n                         select assembly.GetType(\"MoE.ERS.DTO.ResourceRequests.PlaygroupResourceRequestDTO\")).FirstOrDefault();\r\n\r\nI have attached sample project reference for which i am getting below error. Also i tried binding redirect in Web.config and still no luck. \r\n\r\nAny quick help will be much appreciated.\r\n[WcfService1.zip](https://github.com/dotnet/standard/files/1420554/WcfService1.zip)\r\n"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6777855280","Type":"IssuesEvent","CreatedAt":"2017-10-28T01:56:51","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/17793","RelatedDescription":"Closed issue \"Proposal: Add Overlaps(...) extension method for ReadOnlySpan<T>\" (#17793) at dotnet/corefx","RelatedBody":"### Problem\r\n\r\nA method reading from a `ReadOnlySpan<T>` and writing to a `Span<T>` may produce incorrect results if the two spans overlap and the method overwrites data it has not read yet.\r\n\r\nHere is a minimal but complete example that demonstrates the problem:\r\n\r\n```csharp\r\npublic static void Twice(ReadOnlySpan<byte> src, Span<byte> dst)\r\n{\r\n    for (var i = 0; i < src.Length; i++)\r\n    {\r\n        dst[2 * i + 0] = src[i];\r\n        dst[2 * i + 1] = src[i];\r\n    }\r\n}\r\n\r\n[Fact]\r\npublic static void Test1()\r\n{\r\n    var src = new byte[] { 1, 2, 3, 4, 5, 6 };\r\n    var dst = new byte[] { 1, 2, 3, 4, 5, 6 };\r\n\r\n    Twice(new ReadOnlySpan<byte>(src, 0, 3), new Span<byte>(dst));\r\n\r\n    Assert.Equal(new byte[] { 1, 1, 2, 2, 3, 3 }, dst);\r\n    // works!\r\n}\r\n\r\n[Fact]\r\npublic static void Test2()\r\n{\r\n    var src = new byte[] { 1, 2, 3, 4, 5, 6 };\r\n    var dst = src;\r\n\r\n    Twice(new ReadOnlySpan<byte>(src, 0, 3), new Span<byte>(dst));\r\n\r\n    Assert.Equal(new byte[] { 1, 1, 2, 2, 3, 3 }, dst);\r\n    // fails! actual value: { 1, 1, 1, 1, 1, 1 }\r\n}\r\n```\r\n\r\nIt's a very small corner case, but it can lead to very subtle, hard-to-find bugs.\r\n\r\nThe problem can be prevented in `Twice` by\r\n* making a defensive copy, or\r\n* adding a check if the two spans overlap.\r\n\r\nThe copy is much more expensive, so it would be nice if it could be avoided.\r\n\r\nWith `ArraySegment<T>` arguments, the check can look like this:\r\n\r\n```csharp\r\npublic static void Twice(ArraySegment<byte> src, ArraySegment<byte> dst)\r\n{\r\n    if (src.Array == dst.Array &&\r\n        src.Offset < dst.Offset + dst.Count &&\r\n        dst.Offset < src.Offset + src.Count)\r\n    {\r\n        throw new ArgumentException();\r\n    }\r\n\r\n    for (int i = 0; i < src.Count; i++)\r\n    {\r\n        dst.Array[dst.Offset + 2 * i + 0] = src.Array[src.Offset + i];\r\n        dst.Array[dst.Offset + 2 * i + 1] = src.Array[src.Offset + i];\r\n    }\r\n}\r\n```\r\n\r\nThis proposal is to add an API that enables similar checks for spans.\r\n\r\n### Proposed API\r\n\r\n```csharp\r\npublic static class SpanExtensions\r\n{\r\n    public static bool Overlaps<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second);\r\n}\r\n```\r\n\r\n*Open questions:*\r\n\r\n* Are overloads for all four combinations of `Span<T>` and `ReadOnlySpan<T>` needed\r\n* Should the name be `Overlaps` (like `Equals`) or `Overlap` (like `SequenceEqual`)\r\n* Should the method return `true` or `false` if one or both of the spans is empty\r\n* Should the method return the overlapping range rather than a `bool`\r\n* Does it belong in SpanExtensions\r\n* ...\r\n\r\n*Usage:*\r\n\r\n```csharp\r\npublic static void Twice(ReadOnlySpan<byte> src, Span<byte> dst)\r\n{\r\n    if (src.Overlaps(dst))\r\n    {\r\n        throw new ArgumentException();\r\n        // or\r\n        src = src.ToArray();\r\n    }\r\n\r\n    for (int i = 0; i < src.Length; i++)\r\n    {\r\n        dst[2 * i + 0] = src[i];\r\n        dst[2 * i + 1] = src[i];\r\n    }\r\n}\r\n```\r\n\r\n### Prototype Implementation\r\n\r\nI've come up with the following implementation that I would use if there is no strong need for an official API. It's based on the current implementation of the [`SpanHelpers.CopyTo<T>`](https://github.com/dotnet/corefx/blob/f17a94868f4a62c22c75b5710d19ab928f896e5e/src/System.Memory/src/System/SpanHelpers.cs#L23) method.\r\n\r\n```csharp\r\npublic static class SpanExtensions\r\n{\r\n    public static bool Overlaps<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second)\r\n    {\r\n        ref T x1 = ref first.DangerousGetPinnableReference();\r\n        ref T y1 = ref second.DangerousGetPinnableReference();\r\n\r\n        ref T x2 = ref Unsafe.Add(ref x1, first.Length);\r\n        ref T y2 = ref Unsafe.Add(ref y1, second.Length);\r\n\r\n        // return (x1 < y2) && (y1 < x2)\r\n        IntPtr diff1 = Unsafe.ByteOffset(ref x1, ref y2);\r\n        IntPtr diff2 = Unsafe.ByteOffset(ref y1, ref x2);\r\n\r\n        return (IntPtr.Size == sizeof(int) ? (int)diff1 > 0 : (long)diff1 > 0)\r\n            && (IntPtr.Size == sizeof(int) ? (int)diff2 > 0 : (long)diff2 > 0);\r\n    }\r\n}\r\n```\r\n\r\nIt looks simple, but I'm not sure if it's correct. For example, is it legal to have `Unsafe.Add` return a `ref` past the end of a span if the `ref` is not dereferenced?\r\n\r\n------\r\n\r\n### Update\r\n\r\n:boom: The above implementation has a number of problems. A pull request with the latest code is [here](https://github.com/dotnet/corefx/pull/18731)."},{"Id":"6777855243","Type":"IssuesEvent","CreatedAt":"2017-10-28T01:56:49","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/18750","RelatedDescription":"Closed issue \"API Proposal: Span<T> - find if one span contains another; perhaps IsSliceOf\" (#18750) at dotnet/corefx","RelatedBody":"From https://github.com/dotnet/corefxlab/issues/827 by @mgravell\r\n\r\nA scenario I find myself needing is to see whether one span is a sub-span of another. This test is semantically valid for  both array and pointer spans, and is a related operation to `Slice`\r\n\r\nSuggested API:\r\n\r\n```\r\nSpan<T>\r\n    bool IsSliceOf(Span<T> span);\r\n    bool IsSliceOf(Span<T> span, out int offset);\r\n```\r\n\r\nwhere it is:\r\n- `true` if both spans are array-based, for the exact same array, where the inner offet >= outer offset, and inner offset+count <= outer offset+count\r\n- `true` if both spans are pointer-based, and inner ptr >= outer ptr and inner ptr+count <= outer ptr+count\r\n- `false`  otherwise\r\n\r\nor could be unified to:\r\n\r\n```\r\n    int GetSliceIndex(Span<T> span)\r\n```\r\n\r\n(returns -1 if not a slice; kinda ugly)\r\n\r\nWould be happy to contribute towards the code, but wanted to discuss API first.\r\n\r\nhttps://github.com/dotnet/corefxlab/issues/827#issuecomment-296100325:\r\n> The specific example was trying to find the parent block that owns a range (one of several known blocks) so we can do a slice and dice - however, it occurs that the moment I say \"one of several\" it is clear that we aren't talking just about stack-based spans, so all of this could work just as well against Buffer-T if that would be preferable. The exact scenario was: https://github.com/davidfowl/Channels/pull/86/files#diff-2265f88526c85122b370d0d37969d072R620 (search IsSliceOf).\r\n\r\nRelated to: https://github.com/dotnet/corefx/issues/17793\r\n\r\nPrevious PR: https://github.com/dotnet/corefxlab/pull/830"},{"Id":"6777786239","Type":"PullRequestEvent","CreatedAt":"2017-10-28T01:03:34","Actor":"safern","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24935","RelatedDescription":"Opened pull request \"Fix system formatter tests hitting netfx inbox binplace issue\" (#24935) at dotnet/corefx","RelatedBody":"Fixes: https://github.com/dotnet/corefx/issues/24928\r\n\r\nThis were failing in my PR because they where actually hitting PNSE from the new assemblies generated by my changes where netstandard will be PNSE assembly. Whenever I fix the bin place issue I will revisit this test data and revert this commits.\r\n\r\ncc: @danmosemsft "},{"Id":"6777717328","Type":"PullRequestEvent","CreatedAt":"2017-10-28T00:18:42","Actor":"shmao","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24934","RelatedDescription":"Opened pull request \"Add S.SM.Syndication in Compat-pack.\" (#24934) at dotnet/corefx","RelatedBody":""},{"Id":"6777701400","Type":"IssuesEvent","CreatedAt":"2017-10-28T00:10:10","Actor":"shmao","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/24894","RelatedDescription":"Closed issue \"DateTimeParser in class Atom10FeedFormatter return wrong result.\" (#24894) at dotnet/corefx","RelatedBody":"Atom10FeedFormatter can not convert `string dateTimeString = \"2017-10-11T11:25:55Z\";` to class `DateTimeOffset` when load from feed file.\r\nThe DateTimeParser use the codes are as below ([source](https://github.com/dotnet/corefx/blob/master/src/System.ServiceModel.Syndication/src/System/ServiceModel/Syndication/DateTimeHelper.cs#L59)):\r\n```\r\npublic static Func<string, string, string, DateTimeOffset> CreateAtom10DateTimeParser()\r\n{\r\n    return (dateTimeString, localName, ns) =>\r\n    {\r\n        DateTimeOffset dto;\r\n        if (Rfc3339DateTimeParser(dateTimeString, out dto))\r\n        {\r\n            return dto;\r\n        }\r\n\r\n        // Unable to parse - using a default date;\r\n        return new DateTimeOffset();\r\n    };\r\n}\r\n\r\nprivate static bool Rfc3339DateTimeParser(string dateTimeString, out DateTimeOffset dto)\r\n{\r\n    // RFC3339 uses the W3C Profile of ISO 8601 so using the date time format string \"O\" will achieve this.\r\n    return DateTimeOffset.TryParseExact(dateTimeString, \"O\", null as IFormatProvider, DateTimeStyles.AllowWhiteSpaces, out dto);\r\n}\r\n```\r\nThe format **\"O\"** in code:\r\n```\r\nDateTimeOffset.TryParseExact(dateTimeString, \"O\", null as IFormatProvider,DateTimeStyles.AllowWhiteSpaces, out dto);\r\n```\r\nCan not parse the `dateTimeString = \"2017-10-11T11:25:55Z\"`.\r\nIt think it maybe relate to PR #24613."},{"Id":"6777701386","Type":"PullRequestEvent","CreatedAt":"2017-10-28T00:10:10","Actor":"shmao","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24899","RelatedDescription":"Merged pull request \"Fixed Bugs with DateTime Parsing\" (#24899) at dotnet/corefx","RelatedBody":"The bug was that `Rfc3339DateTimeParser` couldn't parse string like `2003-12-13T18:30:02Z`. The fix was to use the original `Atom10FeedFormatter.DateFromString`.\r\n\r\nFix #24894"},{"Id":"6777680326","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:58:51","Actor":"vancem","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24025","RelatedDescription":"Merged pull request \"Use Portable PDBs and turn on SourceLink\" (#24025) at dotnet/corefx","RelatedBody":"This pull request, as well as its companion in the CoreClr repository are tiny (they basically set an MSBUILD variable), but the result is that we generate Portable PDBs rather than MS-PDBs during the build).\r\n\r\nThe immediate value of this change is that we can turn on SourceLink support which allows Visual Studio to 'just work' and step into source it fetches from this Github repository.    This is an important step in getting this working for our shipped builds.  \r\n\r\nIt is possible to get SourceLink working without generating Portable PDBs but I believe we want to move in this direction sooner rather than later because.\r\n\r\n1. ASP.NET ships this way (and we expect most code will ship using Portable PDBs)  \r\n2. This is the way we ship on Linux\r\n3. VSCode only supports portable PDBs (at least in my experimentation).      \r\n4. Because of (1) we already have support for generating MS-PDBs from the portable ones and uploading them to Microsoft Symbol Servers (which currently only support \r\n\r\nIn short, uniformity is good, and this makes us significantly more uniform.   The only issue is what 'breaks'.   Because of (4), it is not clear that any important scenario is actually broken by the change.  To the degree that we publish PDBs via the MS symbol server, those were converted before publication so things will work as the do now.    For private builds, VS works with portable PDBs.    Tests should be using portable (so they can run on Linux too).   Now I am sure that we might break something, but we are likely to be close enough that it is easier/better to simply try it and clean it up (or revert it), if we run into issues. \r\n\r\nBut I have marked this NO-MERGE for the time being so that we can vet any concerns.  If after several days of vetting we have addressed all concerns we would be in a position to proceed.  \r\n\r\nPlease include anyone you believe may be impacted by this.  \r\n\r\n@dagood @mikem8361 @ericstj  @jkotas  @lt72 @Petermarcu @markwilkie @weshaggard @tmat @Eilon @karelz @danmosemsft "},{"Id":"6777675727","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:56:21","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24811","RelatedDescription":"Merged pull request \"Add pkg for System.Diagnostics.PerformanceCounter\" (#24811) at dotnet/corefx","RelatedBody":"This change adds System.Diagnostics.PerformanceCounter to the compat\r\npack."}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6777959575","Type":"PullRequestEvent","CreatedAt":"2017-10-28T03:27:34","Actor":"heejaechang","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22865","RelatedDescription":"Merged pull request \"made NFW to bucket things better\" (#22865) at dotnet/roslyn","RelatedBody":"this is a port of https://github.com/dotnet/roslyn/pull/22657 from post 15.5 branch.\r\n\r\n..\r\n\r\nNFW API allows caller to supply extra info to make bucketing better.\r\n\r\nthis takes advantage of that ability for certain exception types which we know inner or remote exception is more important than the generic outer exception.\r\n\r\n**Customer scenario**\r\n\r\nThere is no user facing changes due to this.\r\n\r\n**Bugs this fixes:**\r\n\r\nhttps://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/515509\r\n\r\nthere is no bug this is fixing. this is on going effort to make non fatal watson (NFW) experience better. this should reduce cases where we over-bucket NFW issues.\r\n\r\n**Workarounds, if any**\r\n\r\nthere is no workaround.\r\n\r\n**Risk**\r\n\r\nsome existing NFW issues will be bucketed differently than before. hopefully less over bucketing. but it also means we lose tracking and start fresh for those issues. but most likely those issues should be ones that were over bucketed so hit count was probably meaningless anyway.\r\n\r\n**Performance impact**\r\n\r\nthis doesn't reduce number of NFW which is the one that affects perf. this just lets Watson to have more info when it buckets reports.\r\n\r\n**Is this a regression from a previous update?**\r\n\r\nNo\r\n\r\n**Root cause analysis:**\r\n\r\nNFW didn't have enough info to separate reports to different bucket since it only got info on outer generic exceptions such as AggregateException or RemoteInvocationException but not inner or remote exception that actually matter.\r\n\r\nunit tests are also added.\r\n\r\n**How was the bug found?**\r\n\r\ninvestigating NFW issues.\r\n"},{"Id":"6777830500","Type":"IssuesEvent","CreatedAt":"2017-10-28T01:36:29","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22834","RelatedDescription":"Closed issue \"Fix more instances of GetSpecialType(SpecialType.System_Object, diagnostics, node)\" (#22834) at dotnet/roslyn","RelatedBody":"This was fixed for unary operator, but @AlekseyTs [spotted](https://github.com/dotnet/roslyn/pull/22739#issuecomment-338749075) some more instances."},{"Id":"6777830061","Type":"PullRequestEvent","CreatedAt":"2017-10-28T01:36:10","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22888","RelatedDescription":"Merged pull request \"Failed binding of unary operators should use error type, not object\" (#22888) at dotnet/roslyn","RelatedBody":"Aleksey had spotted more instance of a problem reported by a customer. This PR fixes those as well.\r\n\r\nFixes https://github.com/dotnet/roslyn/issues/22834\r\nRelates to https://github.com/dotnet/roslyn/pull/22739"},{"Id":"6777730212","Type":"PullRequestEvent","CreatedAt":"2017-10-28T00:26:25","Actor":"333fred","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22854","RelatedDescription":"Merged pull request \"Remove IConversionExpression.IsExplicitInCode\" (#22854) at dotnet/roslyn","RelatedBody":"Fixes https://github.com/dotnet/roslyn/issues/22824. Since we have `IOperation.IsImplicit`, this property is redundant.\r\n\r\nVSO : https://devdiv.visualstudio.com/DevDiv/NET%20Developer%20Experience%20Productivity/_workitems/edit/515269"},{"Id":"6777730204","Type":"IssuesEvent","CreatedAt":"2017-10-28T00:26:25","Actor":"333fred","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22824","RelatedDescription":"Closed issue \"IConversion.IsExplicitInCode is redundant\" (#22824) at dotnet/roslyn","RelatedBody":"We now expose IOperation.IsImplicit, so IConversion.IsExplicitInCode is redundant and can be removed."},{"Id":"6777610144","Type":"IssuesEvent","CreatedAt":"2017-10-27T23:24:02","Actor":"heejaechang","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22897","RelatedDescription":"Opened issue \"optimize memory used by MethodTypeInferrer\" (#22897) at dotnet/roslyn","RelatedBody":"we got this bug from users.\r\n\r\nhttps://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems/edit/511590\r\n\r\nlooked, etl from the users\r\nhttps://vsfeedback.azurewebsites.net/api/fileBlobMetrics/getAzureBlobFromTransferId?transferId=c0009e1c397b45f98ca81dc47aa829ae636443843938150072\r\n\r\nlooks like issue is this allocating a lot of memory.\r\nhttp://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Semantics/OverloadResolution/MethodTypeInference.cs,266\r\n\r\n...\r\n\r\nName | Inc % | Inc\r\n-- | -- | --\r\nType System.Collections.Generic.HashSet`1[Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol][] | 4.1 | 149,242,976\r\n+ clr!EtwCallout | 4.1 | 149,242,976\r\n+ clr!CoTemplate_qqhxpzqp | 4.1 | 149,242,976\r\n+ clr!WKS::gc_heap::fire_etw_allocation_event | 4.1 | 149,242,976\r\n+ clr!WKS::gc_heap::try_allocate_more_space | 4.1 | 149,242,976\r\n+ clr!WKS::gc_heap::allocate_more_space | 4.1 | 149,242,976\r\n+ clr!WKS::GCHeap::Alloc | 4.1 | 149,242,976\r\n+ clr!Alloc | 4.1 | 149,242,976\r\n+ clr!AllocateArrayEx | 4.1 | 149,242,976\r\n+ clr!JIT_NewArr1 | 4.1 | 149,242,976\r\n+ Microsoft.CodeAnalysis.CSharp!Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer..ctor(class Microsoft.CodeAnalysis.CSharp.ConversionsBase,value class System.Collections.Immutable.ImmutableArray`1,class Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,value class System.Collections.Immutable.ImmutableArray`1,value class System.Collections.Immutable.ImmutableArray`1,value class System.Collections.Immutable.ImmutableArray`1) | 4.1 | 149,242,976\r\n+ Microsoft.CodeAnalysis.CSharp!MethodTypeInferrer.InferTypeArgumentsFromFirstArgument | 4.1 | 146,890,316\r\n+ Microsoft.CodeAnalysis.CSharp!MethodTypeInferrer.Infer | 0.1 | 2,352,660\r\n\r\n...\r\n\r\nlooks like this is internal types with many internal collections (it is not exposed to outside)\r\n\r\n_exactBounds = new HashSet<TypeSymbol>[methodTypeParameters.Length];\r\n_upperBounds = new HashSet<TypeSymbol>[methodTypeParameters.Length];\r\n_lowerBounds = new HashSet<TypeSymbol>[methodTypeParameters.Length];\r\n\r\nso, pooling could save all these allocations.\r\n--\r\n\r\nalso this looks like used only internally, and create new array when exposed to outside. seems good candidate to pool by using array builder?\r\n\r\n_fixedResults = new TypeSymbol[methodTypeParameters.Length];\r\n"}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6777731016","Type":"PullRequestEvent","CreatedAt":"2017-10-28T00:26:56","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4829","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4829) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6777659814","Type":"PullRequestEvent","CreatedAt":"2017-10-27T23:47:57","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4829","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4829) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6777207015","Type":"PullRequestEvent","CreatedAt":"2017-10-27T21:04:43","Actor":"luqunl","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4828","RelatedDescription":"Merged pull request \"Add correct AssemblyMetadataAttribute for Framework Assembly\" (#4828) at dotnet/corert","RelatedBody":"With Project file cotains Property <IsDotNetFrameworkProductAssembly>true</IsDotNetFrameworkProductAssembly>, the final assembly will contain the following assembly attribute and will consider as Framework Assembly.\r\n[assembly: AssemblyMetadata(\".NETFrameworkAssembly\", \"\")]"},{"Id":"6777069284","Type":"PullRequestEvent","CreatedAt":"2017-10-27T20:28:25","Actor":"luqunl","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4828","RelatedDescription":"Opened pull request \"Add correct AssemblyMetadataAttribute for Framework Assembly\" (#4828) at dotnet/corert","RelatedBody":"With Project file cotains Property <IsDotNetFrameworkProductAssembly>true</IsDotNetFrameworkProductAssembly>, the final assembly will contain the following assembly attribute and will consider as Framework Assembly.\r\n[assembly: AssemblyMetadata(\".NETFrameworkAssembly\", \"\")]"},{"Id":"6777040944","Type":"PullRequestEvent","CreatedAt":"2017-10-27T20:21:00","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4827","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4827) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6777035985","Type":"PullRequestEvent","CreatedAt":"2017-10-27T20:19:46","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4827","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4827) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6776991445","Type":"PullRequestEvent","CreatedAt":"2017-10-27T20:08:07","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4826","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4826) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6776688767","Type":"PullRequestEvent","CreatedAt":"2017-10-27T18:52:01","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4826","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4826) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6776616084","Type":"PullRequestEvent","CreatedAt":"2017-10-27T18:34:24","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4825","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4825) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6776441241","Type":"PullRequestEvent","CreatedAt":"2017-10-27T17:52:24","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4823","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#4823) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6776440584","Type":"PullRequestEvent","CreatedAt":"2017-10-27T17:52:15","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4824","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4824) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6776391155","Type":"PullRequestEvent","CreatedAt":"2017-10-27T17:40:28","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4824","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4824) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"923592986562142208","CreatedAt":"2017-10-26T16:51:42+00:00","UserScreenname":"dotnet","Text":"Wish you could run the code sample you read in a book? You can now with Azure Notebooks. https://t.co/evx8HPzzqe","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":117,"FavoriteCount":70,"RawContent":null},{"Id":"923344981602942977","CreatedAt":"2017-10-26T00:26:13+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework images now support Windows Server 1709 https://t.co/enC2cjj2ds /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":40,"FavoriteCount":22,"RawContent":null},{"Id":"923037554265296896","CreatedAt":"2017-10-25T04:04:36+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework latest tag updated to 4.7.1 https://t.co/NuV11juPrm /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":43,"FavoriteCount":22,"RawContent":null},{"Id":"922503653402882049","CreatedAt":"2017-10-23T16:43:04+00:00","UserScreenname":"dotnet","Text":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018  https://t.co/TPKfGvwNLH /cc @intel","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":97,"FavoriteCount":56,"RawContent":null},{"Id":"921143443912474624","CreatedAt":"2017-10-19T22:38:05+00:00","UserScreenname":"dotnet","Text":"New .NET Rocks podcast with @coolcsh on understanding #dotnet standard &amp; future of #dotnetcore… https://t.co/b8BCeZKEqz","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":41,"FavoriteCount":20,"RawContent":null},{"Id":"920400974321147904","CreatedAt":"2017-10-17T21:27:47+00:00","UserScreenname":"dotnet","Text":"Announcing the .NET Framework 4.7.1 https://t.co/Vu3bilF8bZ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":382,"FavoriteCount":345,"RawContent":null},{"Id":"920393493557555205","CreatedAt":"2017-10-17T20:58:03+00:00","UserScreenname":"dotnet","Text":".NET Framework October 2017 Preview of Quality Rollup https://t.co/oVqxMXye74","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":16,"FavoriteCount":16,"RawContent":null},{"Id":"920179824576028673","CreatedAt":"2017-10-17T06:49:00+00:00","UserScreenname":"dotnet","Text":".NET Framework Docker Performance Issue Resolved https://t.co/FST3EfcLtS","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":55,"FavoriteCount":30,"RawContent":null},{"Id":"920157146309730305","CreatedAt":"2017-10-17T05:18:54+00:00","UserScreenname":"dotnet","Text":"RyuJIT Just-in-Time Compiler Optimization Enhancements https://t.co/dhO8rAqiSI","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":133,"FavoriteCount":79,"RawContent":null}]}},"RunOn":"2017-10-28T05:30:19.2926116Z","RunDurationInMilliseconds":6863}