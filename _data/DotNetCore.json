{"Data":{"Blog":{"FeedItems":[{"Title":"Calling all Desktop Developers: how should UI development be improved?","PublishedOn":"2018-03-23T18:01:31+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"The user interface (UI) of any application is critical in making your app convenient and efficient for the folks using it. When developing applications for Enterprise use, a good UI can shave time off...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/23/calling-all-desktop-developers-how-should-ui-development-be-improved/","RawContent":null},{"Title":".NET Framework 4.7.2 Developer Pack Early Access build 3056 is available!","PublishedOn":"2018-03-08T23:22:13+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are happy to share an Early Access build with the .NET Framework 4.7.2 Developer Pack. The .NET Framework 4.7.2 Developer Pack lets developers build applications that target the .NET...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/08/net-framework-4-7-2-developer-pack-early-access-build-3056-is-available/","RawContent":null},{"Title":"F# language and tools update for Visual Studio 2017 version 15.6","PublishedOn":"2018-03-06T18:28:06+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"With the release of Visual Studio 2017 version 15.6, we’re excited to share updates to the F# language and core library, F# tooling in Visual Studio, and infrastructure updates that concern OSS...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/06/f-language-and-tools-update-for-visual-studio-2017-version-15-6/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1 Preview 1","PublishedOn":"2018-02-27T18:11:29+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"Today we are releasing the first preview of EF Core 2.1, alongside .NET Core 2.1 Preview 1 and ASP.NET Core 2.1 Preview 1. The new bits are available in NuGet as part of the individual packages, and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/announcing-entity-framework-core-2-1-preview-1/","RawContent":null},{"Title":"Announcing .NET Core 2.1 Preview 1","PublishedOn":"2018-02-27T18:08:23+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are announcing .NET Core 2.1 Preview 1. It is the first public release of .NET Core 2.1. We have great improvements that we want to share and that we would love to get your feedback on,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/announcing-net-core-2-1-preview-1/","RawContent":null},{"Title":"Calling All Desktop Developers: How do you interact with data?","PublishedOn":"2018-02-27T17:00:36+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Connecting to databases and services is an important part of desktop application development for many of our customers. Visual Studio provides a variety of tools and technologies that can help you...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/calling-all-desktop-developers-how-do-you-interact-with-data/","RawContent":null},{"Title":"Azure Blob Storage as a Network Drive","PublishedOn":"2018-02-26T16:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Many applications make use of a network drive to backup and store files. When I was in university I found myself constantly coding for fun, and one example took the form of a network share for my...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/26/azure-blob-storage-as-a-network-drive/","RawContent":null},{"Title":".NET Framework February 2018 Security and Quality Rollup","PublishedOn":"2018-02-14T04:27:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the February 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework January 2018 Security and Quality Rollup for the latest security updates....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/13/net-framework-february-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Machine Learning in .NET – Help us build the right experience!","PublishedOn":"2018-02-13T17:17:58+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"In the past few years, Machine Learning (ML) and Artificial Intelligence (AI) have paved the road for building smarter applications through advancements in speech recognition, computer vision,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/13/machine-learning-in-net-help-us-build-the-right-experience/","RawContent":null},{"Title":"Announcing .NET Framework 4.7.2 Early Access build 3052!","PublishedOn":"2018-02-05T21:55:13+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.7.2 Early Access build 3052 for your feedback. .NET Framework 4.7.2 is the next version of the .NET Framework. It is currently feature-complete and in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/05/announcing-net-framework-4-7-2-early-access-build-3052/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7452103949","Type":"PullRequestEvent","CreatedAt":"2018-03-29T07:03:03","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/97","RelatedDescription":"Merged pull request \"update CLA PDF link\" (#97) at dotnet/home","RelatedBody":""},{"Id":"7419410563","Type":"IssuesEvent","CreatedAt":"2018-03-22T14:02:36","Actor":"vvavrychuk","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/99","RelatedDescription":"Opened issue \"not working \"Linux Distribution\" dropdown on http://www.microsoft.com/net/learn/get-started/linux \" (#99) at dotnet/home","RelatedBody":"On the page http://www.microsoft.com/net/learn/get-started/linux dropdown \"Linux Distribution\" has no effect on the installation instruction next to him (they are always displayed for RedHat).\r\n\r\n![screenshot from 2018-03-22 16-02-19](https://user-images.githubusercontent.com/152563/37775020-6ec5778e-2dea-11e8-9ea3-b33e26c1c4e1.png)\r\n"},{"Id":"7192252734","Type":"PullRequestEvent","CreatedAt":"2018-02-03T01:30:47","Actor":"karann-msft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Opened pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7187459205","Type":"PullRequestEvent","CreatedAt":"2018-02-02T05:26:03","Actor":"mairaw","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/97","RelatedDescription":"Opened pull request \"update CLA PDF link\" (#97) at dotnet/home","RelatedBody":""},{"Id":"7102763357","Type":"PullRequestEvent","CreatedAt":"2018-01-16T00:17:04","Actor":"galatrash-at-dnn","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Opened pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7097053889","Type":"PullRequestEvent","CreatedAt":"2018-01-14T15:15:00","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Opened pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7065382954","Type":"PullRequestEvent","CreatedAt":"2018-01-06T19:21:47","Actor":"ctaggart","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Opened pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7387413694","Type":"IssuesEvent","CreatedAt":"2018-03-15T21:18:32","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/63","RelatedDescription":"Reopened issue \"Transport Layer Security (TLS) best practices with the .NET Framework article published\" (#63) at dotnet/announcements","RelatedBody":"# Transport Layer Security (TLS) best practices with the .NET Framework article published\r\n\r\nA new article was published that discusses the Transport Layer Security (TLS) best practices at https://docs.microsoft.com/dotnet/framework/network-programming/tls.\r\n\r\nTo ensure .NET Framework applications remain secure, the TLS version should **not** be hardcoded. .NET Framework applications should use the TLS version the operating system (OS) supports.\r\n\r\nThe (TLS) best practices article targets developers who are:\r\n* Directly using the System.Net APIs (for example, `System.Net.Http.HttpClient` and `System.Net.Security.SslStream`).\r\n* Directly using WCF clients and services using the `System.ServiceModel` namespace.\r\n* Using [Azure Cloud Services](https://azure.microsoft.com/services/cloud-services/) Web and Worker roles to host and run your application. See the [Azure Cloud Services](https://docs.microsoft.com/dotnet/framework/network-programming/tls#azure-cloud-services) section.\r\n\r\nThe article explains how to enable the strongest security available for the version of the .NET Framework that your app targets and runs on.\r\n\r\nThe section [Audit your code and make code changes](https://docs.microsoft.com/dotnet/framework/network-programming/tls#audit-your-code-and-make-code-changes) covers auditing and updating your code.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\ndotnet/docs#4675"},{"Id":"7387391842","Type":"IssuesEvent","CreatedAt":"2018-03-15T21:13:45","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/63","RelatedDescription":"Closed issue \"Transport Layer Security (TLS) best practices with the .NET Framework article published\" (#63) at dotnet/announcements","RelatedBody":"# Transport Layer Security (TLS) best practices with the .NET Framework article published\r\n\r\nA new article was published that discussed the Transport Layer Security (TLS) best practices at https://docs.microsoft.com/dotnet/framework/network-programming/tls.\r\n\r\nTo ensure .NET Framework applications remain secure, the TLS version should **not** be hardcoded. .NET Framework applications should use the TLS version the operating system (OS) supports.\r\n\r\nThe (TLS) best practices article targets developers who are:\r\n* Directly using the System.Net APIs (for example, `System.Net.Http.HttpClient` and `System.Net.Security.SslStream`).\r\n* Directly using WCF clients and services using the `System.ServiceModel` namespace.\r\n* Using [Azure Cloud Services](https://azure.microsoft.com/services/cloud-services/) Web and Worker roles to host and run your application. See the [Azure Cloud Services](https://docs.microsoft.com/dotnet/framework/network-programming/tls#azure-cloud-services) section.\r\n\r\nThe article explains how to enable the strongest security available for the version of the .NET Framework that your app targets and runs on.\r\n\r\nThe section [Audit your code and make code changes](https://docs.microsoft.com/dotnet/framework/network-programming/tls#audit-your-code-and-make-code-changes) covers auditing and updating your code.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\ndotnet/docs#4675"},{"Id":"7373349220","Type":"IssuesEvent","CreatedAt":"2018-03-13T17:01:53","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/62","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-0875: Hash Collison can cause Denial of Service\" (#62) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-0875: Hash Collison can cause Denial of Service\r\n## Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 2.0 (including other minor and patch releases).\r\nThis advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public versions of .NET Core where a malicious file or web request could cause a denial of service (DoS) attack.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.10, 1.1.7 or 2.0.6. Developers are advised to update their .NET Core SDK to versions 1.1.8 or 2.1.101.\r\n\r\n## Discussion\r\n\r\nUse *TBD* for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\nNone\r\n\r\n### Affected Software\r\n\r\nAny application running against .NET Core 1.0.9 or lower versions, 1.1.6 or lower minor versions or 2.0.5 or lower minor versions is affected. \r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\nAny application running against .NET Core 1.0.9 or lower versions, 1.1.6 or lower minor versions or 2.0.5 or lower minor versions is affected. \r\n\r\nA complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location |\r\n|------------------|----------|\r\n| Windows\t| `C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\` |\r\n| macOS\t| `/usr/local/share/dotnet/shared/Microsoft.NETCore.App/` |\r\n| Supported Linux platforms\t| `/usr/share/dotnet/shared/Microsoft.NETCore.App/` |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.10, 1.1.7 and 2.0.6, then any applications targeting the respective major/minor versions, 1.0 or 1.1 or 2.0 of .NET Core are vulnerable.\r\n\r\nAdditionally, if you've deployed self-contained applications targeting any of the impacted versions, these applications are also vulnerable and must be recompiled and redeployed.\r\n\r\n#### How do I fix my affected application?\r\n\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. \r\nInstallers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). \r\n.NET Core 1.1.8 SDK installs both versions 1.0.10 and 1.1.7 of the .NET Core runtime.\r\n\r\nIf you've built a self-contained application, you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the `application.runtime.config` file for that application. Set the framework version to the desired version and the `rollForward` property to false. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the `application.runtime.config` file is an optional file, you may need to create one for each application and add it alongside the executable.\r\n\r\n### Acknowledgments\r\n[Ben Adams](https://twitter.com/ben_a_adams) of [Illyriad Games](https://www.illyriad.co.uk/)\r\n\r\n### External Links\r\n[CVE-2018-0875](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0875)\r\n\r\n### Revisions\r\n\r\nV1.0 (Mar 13, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n_Last Updated 2018-03-13_\r\n"},{"Id":"7301596554","Type":"IssuesEvent","CreatedAt":"2018-02-27T06:10:33","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/61","RelatedDescription":"Opened issue \"New offline books released for Visual Studio 2017\" (#61) at dotnet/announcements","RelatedBody":"# New offline books released for Visual Studio 2017\r\n\r\nEarlier this month, we released an update to Offline Books for the Visual Studio 2017 Help Viewer.\r\n\r\nThis release includes new .NET books, including .NET Core Guide, .NET Guide, .NET Framework Guide and the .NET API Reference. It also includes the latest content for Visual Studio 2017 version 15.5, the latest updates to Visual Basic, C# (7.1 and 7.2), F#, ASP.NET Core, NuGet, SQL Server, and the Universal Windows Platform.\r\n\r\nThe .NET Guide, .NET Framework Guide and .NET API Reference books together are a replacement for the .NET Framework 4.6 and 4.5 book, which can be removed. Just be aware that the new .NET API Reference book currently displays the API syntax block for C# only, but examples are shown in other languages, just like the experience you currently have on docs.microsoft.com.If you need to see the API syntax for Visual Basic, C++/CLI or F#, then you should keep the old book until the new reference book is updated again in a few weeks. Once you remove the .NET Framework 4.6 and 4.5 book, you cannot reinstall it.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\n- https://github.com/dotnet/docs/issues/4502\r\n\r\n## Add new content\r\n\r\nYou will see these new books when you have Help Viewer installed and choose **Help** > **Add and Remove Content** from the Visual Studio 2017 main menu. If you don't see this menu item, then [open the Visual Studio Installer](https://docs.microsoft.com/visualstudio/install/modify-visual-studio), click the **More** dropdown and choose **Modify**. When the component list appears, choose **Individual Components** at the top, then check **Help Viewer**.\r\n\r\n![help_viewer_component](https://user-images.githubusercontent.com/12971179/36713111-c9d49a7c-1b40-11e8-918a-e7e3619669a2.png)\r\n\r\n## Help Viewer Installation\r\n\r\nTo start the installation, select the **Modify** button in the lower right corner of the Installer window.\r\n\r\nTo update individual books whose status is \"Updates available\", remove the book and then click **Add** to get the new version. To update all your books at once, select the link in the lower right corner of the **Add and Remove Content** window:\r\n\r\n![offline-books](https://user-images.githubusercontent.com/12971179/36713028-75b944f6-1b40-11e8-91c4-4830355f815e.png)"},{"Id":"7300537622","Type":"IssuesEvent","CreatedAt":"2018-02-27T00:12:10","Actor":"eerhardt","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/60","RelatedDescription":"Opened issue \"System.Runtime.Intrinsics in .NET Core 2.1\" (#60) at dotnet/announcements","RelatedBody":"# System.Runtime.Intrinsics in .NET Core 2.1\r\n\r\n.NET Core 2.1 has been adding platform intrinsic APIs to support directly calling processor specific instructions, such as Intel’s x86 SIMD instructions.  See the [initial platform intrinsics design](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md) for more information.\r\n\r\nWe have decided that it makes the most sense for this intrinsics feature to ship in a “preview” status in the .NET Core 2.1 RTM timeframe.  This means that the runtime support we are implementing will be included, but the assembly exposing the intrinsics will only be available to projects via explicit reference to a “preview-only” package.  These APIs won’t be included in the official .NET Core 2.1 packages.\r\n\r\nGiven our limited time and resources, recent changes in the approach we take to expose the intrinsics, and API changes prompted by design feedback from the community, we don’t believe there is enough time to settle these APIs for 2.1. We plan to follow the pattern of other recent features like Span<T> and Memory<T> that first shipped in preview before formally joining the supported API surface.  Not only would we expect the next version of .NET Core to support more intrinsics than could be supported in 2.1, but we expect to have real usage examples in CoreFX and higher level components as well.  These real world examples, as well as feedback from customers who opt in to the preview, should give us the confidence we need to officially support the APIs going forward.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\nhttps://github.com/dotnet/corefx/issues/27486\r\n\r\n## Details\r\n\r\nIn the coming days, we plan on removing System.Runtime.Intrinsics.dll from the Microsoft.NETCore.App package.  This means any libraries/applications that are using these APIs will no longer compile by default, and will not run on new builds of .NET Core 2.1.\r\n\r\nAt the same time, we will start producing a new System.Runtime.Intrinsics.Experimental NuGet package.  In order to continue using these APIs on .NET Core 2.1, a project will need to add a reference to this new package.\r\n\r\nAs its name implies, this package is experimental and should only be used for preview purposes.  It isn’t expected to be used in production scenarios.  Future version of .NET Core (after 2.1) will be allowed to break this package. This enables us respond to future feedback that requires the APIs to be modified.\r\n\r\nIn the future, when we are confident we have the intrinsic APIs right, we will stop producing the System.Runtime.Intrinsics.Experimental package. The platform intrinsics APIs will then be added back to Microsoft.NETCore.App and will be officially supported."},{"Id":"7273056222","Type":"IssuesEvent","CreatedAt":"2018-02-21T02:28:03","Actor":"KathleenDollard","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/57","RelatedDescription":"Opened issue \"Manually Uninstall .NET Core SDK 2.2.0-Preview Nightly Builds\" (#57) at dotnet/announcements","RelatedBody":"# Manually Uninstall .NET Core SDK 2.2.0-Preview Nightly Builds\r\n\r\n[A change in the version number strategy for .NET Core SDK](https://github.com/dotnet/designs/pull/29) resulted in some nightly builds having a higher version number. This higher version number will block the installation of the correct .NET Core SDK.\r\n\r\nIf you have installed nightly builds of the .NET Core SDK that start with version number that begin with `2.2.0-preview1`, you must manually uninstall these preview builds before later versions of the SDK with version numbers like 2.1.xxx will be available. This may have occurred by installing nightly builds of the .NET Core SDK or nightly builds of Visual Studio 15.5 Preview. \r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n[dotnet/cli #8652](https://github.com/dotnet/cli/issues/8652)\r\n\r\n## Details\r\n\r\n[We changed the version number strategy for .NET Core SDK](https://github.com/dotnet/designs/pull/29) as development was ongoing. Because of this, version numbers on the old scheme appeared in nightly builds. Unfortunately, these numbers are higher than the version numbers in the new scheme. All of the newer SDKs for .NET Core 2.1 will be ignored due to this higher version number; this includes newer nightly builds, public previews and eventual releases.\r\n\r\nThese older version numbers are similar to the following, with the last several different values in the last six digits:\r\n\r\n```\r\n2.2.0-preview1-008000\r\n```\r\n\r\nSince the newer versions are in the form:\r\n\r\n```\r\n2.1.300-preview1-008000\r\n```\r\n\r\n## Call to Action\r\n\r\nIf you have installed nightly builds. Please uninstall any .NET SDK versions that start with 2.2.0-preview1."}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7482810940","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:57:54","Actor":"stephentoub","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17432","RelatedDescription":"Opened pull request \"Improve {u}int/long.ToString/TryFormat throughput by pre-computing the length\" (#17432) at dotnet/coreclr","RelatedBody":"The first commit just moves the Count{Hex}Digits methods from https://github.com/dotnet/corefx/blob/master/src/System.Memory/src/System/Buffers/Text/Utf8Formatter/FormattingHelpers.cs into a partial FormattingHelpers.CountDigits.cs file in the shared partition.  Once those changes replicate to corefx, I'll dedup the code there.\r\n\r\nThe second commit then uses Count{Hex}Digits in the ToString and TryFormat methods of int, uint, long, and ulong, in particular for the default D format (and some G configurations) as well as the X format. Currently we create a temporary buffer on the stack, format into it, and then copy from that stack buffer into either the target span (for TryFormat) or into a new string (for ToString. Following the approach (and sharing the same code) from Utf8Formatter, where it first counts the number of digits in the output in order to determine an exact length, this commit changes the implementation to skip the temporary buffer and just format directly into the destination span or string.\r\n\r\nContributes to https://github.com/dotnet/coreclr/issues/15364\r\ncc: @jkotas, @ahsonkhan, @danmosemsft \r\n\r\n| System.Runtime.Performance.Tests.dll                            | Before | After | Diff  | \r\n|-----------------------------------------------------------------|--------|-------|-------| \r\n| System.Tests.Perf_Int32.ToString(value: 0)                      | 12.75  | 10.85 | 1.18x | \r\n| System.Tests.Perf_Int32.ToString(value: 1)                      | 12.89  | 10.87 | 1.19x | \r\n| System.Tests.Perf_Int32.ToString(value: -1)                     | 21.77  | 18.36 | 1.19x | \r\n| System.Tests.Perf_Int32.ToString(value: 1283)                   | 13.80  | 12.62 | 1.09x | \r\n| System.Tests.Perf_Int32.ToString(value: -1283)                  | 24.29  | 19.91 | 1.22x | \r\n| System.Tests.Perf_Int32.ToString(value: 12837467)               | 16.09  | 15.29 | 1.05x | \r\n| System.Tests.Perf_Int32.ToString(value: -12837467)              | 28.17  | 23.59 | 1.19x | \r\n| System.Tests.Perf_Int32.ToString(value: 2147483647)             | 17.83  | 17.17 | 1.04x | \r\n| System.Tests.Perf_Int32.ToString(value: -2147483648)            | 28.93  | 24.75 | 1.17x | \r\n| System.Tests.Perf_Int32.TryFormat(value: 0)                     | 13.46  | 7.35  | 1.83x | \r\n| System.Tests.Perf_Int32.TryFormat(value: 1)                     | 13.57  | 7.38  | 1.84x | \r\n| System.Tests.Perf_Int32.TryFormat(value: -1)                    | 23.64  | 14.33 | 1.65x | \r\n| System.Tests.Perf_Int32.TryFormat(value: 1283)                  | 14.29  | 9.11  | 1.57x | \r\n| System.Tests.Perf_Int32.TryFormat(value: -1283)                 | 25.64  | 15.95 | 1.61x | \r\n| System.Tests.Perf_Int32.TryFormat(value: 12837467)              | 16.26  | 11.74 | 1.39x | \r\n| System.Tests.Perf_Int32.TryFormat(value: -12837467)             | 28.19  | 18.55 | 1.52x | \r\n| System.Tests.Perf_Int32.TryFormat(value: 2147483647)            | 17.55  | 13.46 | 1.30x | \r\n| System.Tests.Perf_Int32.TryFormat(value: -2147483648)           | 29.63  | 20.01 | 1.48x | \r\n| System.Tests.Perf_Int64.ToString(value: 0)                      | 16.11  | 11.52 | 1.40x | \r\n| System.Tests.Perf_Int64.ToString(value: 2)                      | 15.60  | 11.72 | 1.33x | \r\n| System.Tests.Perf_Int64.ToString(value: -2)                     | 23.14  | 18.62 | 1.24x | \r\n| System.Tests.Perf_Int64.ToString(value: 21)                     | 15.58  | 12.08 | 1.29x | \r\n| System.Tests.Perf_Int64.ToString(value: -21)                    | 23.05  | 18.74 | 1.23x | \r\n| System.Tests.Perf_Int64.ToString(value: 214)                    | 16.41  | 12.44 | 1.32x | \r\n| System.Tests.Perf_Int64.ToString(value: -214)                   | 24.77  | 19.18 | 1.29x | \r\n| System.Tests.Perf_Int64.ToString(value: 2147)                   | 17.20  | 13.40 | 1.28x | \r\n| System.Tests.Perf_Int64.ToString(value: -2147)                  | 24.74  | 20.36 | 1.22x | \r\n| System.Tests.Perf_Int64.ToString(value: 21474)                  | 17.78  | 13.99 | 1.27x | \r\n| System.Tests.Perf_Int64.ToString(value: -21474)                 | 26.44  | 20.80 | 1.27x | \r\n| System.Tests.Perf_Int64.ToString(value: 214748)                 | 19.29  | 14.63 | 1.32x | \r\n| System.Tests.Perf_Int64.ToString(value: -214748)                | 26.31  | 21.64 | 1.22x | \r\n| System.Tests.Perf_Int64.ToString(value: 2147483)                | 18.58  | 15.38 | 1.21x | \r\n| System.Tests.Perf_Int64.ToString(value: -2147483)               | 27.34  | 22.50 | 1.22x | \r\n| System.Tests.Perf_Int64.ToString(value: 21474836)               | 19.92  | 15.91 | 1.25x | \r\n| System.Tests.Perf_Int64.ToString(value: -21474836)              | 28.94  | 23.57 | 1.23x | \r\n| System.Tests.Perf_Int64.ToString(value: 214748364)              | 21.16  | 16.96 | 1.25x | \r\n| System.Tests.Perf_Int64.ToString(value: -214748364)             | 29.22  | 24.02 | 1.22x | \r\n| System.Tests.Perf_Int64.ToString(value: 2147483647)             | 20.91  | 17.52 | 1.19x | \r\n| System.Tests.Perf_Int64.ToString(value: -2147483648)            | 29.79  | 24.91 | 1.20x | \r\n| System.Tests.Perf_Int64.ToString(value: 4294967295000000000)    | 28.11  | 25.64 | 1.10x | \r\n| System.Tests.Perf_Int64.ToString(value: -4294967295000000000)   | 38.00  | 32.82 | 1.16x | \r\n| System.Tests.Perf_Int64.ToString(value: 4294967295000000001)    | 28.29  | 25.37 | 1.12x | \r\n| System.Tests.Perf_Int64.ToString(value: -4294967295000000001)   | 37.98  | 32.92 | 1.15x | \r\n| System.Tests.Perf_Int64.ToString(value: 92233720368)            | 23.49  | 19.77 | 1.19x | \r\n| System.Tests.Perf_Int64.ToString(value: -92233720368)           | 32.46  | 26.81 | 1.21x | \r\n| System.Tests.Perf_Int64.ToString(value: 922337203685)           | 24.38  | 20.55 | 1.19x | \r\n| System.Tests.Perf_Int64.ToString(value: -922337203685)          | 33.12  | 28.09 | 1.18x | \r\n| System.Tests.Perf_Int64.ToString(value: 9223372036854)          | 24.76  | 21.66 | 1.14x | \r\n| System.Tests.Perf_Int64.ToString(value: -9223372036854)         | 33.59  | 28.63 | 1.17x | \r\n| System.Tests.Perf_Int64.ToString(value: 92233720368547)         | 25.18  | 22.44 | 1.12x | \r\n| System.Tests.Perf_Int64.ToString(value: -92233720368547)        | 34.20  | 28.82 | 1.19x | \r\n| System.Tests.Perf_Int64.ToString(value: 922337203685477)        | 25.86  | 21.90 | 1.18x | \r\n| System.Tests.Perf_Int64.ToString(value: -922337203685477)       | 35.22  | 28.95 | 1.22x | \r\n| System.Tests.Perf_Int64.ToString(value: 9223372036854775)       | 26.15  | 22.77 | 1.15x | \r\n| System.Tests.Perf_Int64.ToString(value: -9223372036854775)      | 35.98  | 29.56 | 1.22x | \r\n| System.Tests.Perf_Int64.ToString(value: 92233720368547758)      | 26.96  | 23.60 | 1.14x | \r\n| System.Tests.Perf_Int64.ToString(value: -92233720368547758)     | 37.16  | 30.31 | 1.23x | \r\n| System.Tests.Perf_Int64.ToString(value: 922337203685477580)     | 27.66  | 24.16 | 1.14x | \r\n| System.Tests.Perf_Int64.ToString(value: -922337203685477580)    | 37.60  | 30.96 | 1.21x | \r\n| System.Tests.Perf_Int64.ToString(value: 9223372036854775807)    | 30.28  | 26.95 | 1.12x | \r\n| System.Tests.Perf_Int64.ToString(value: -9223372036854775808)   | 41.47  | 33.76 | 1.23x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 0)                     | 16.67  | 8.01  | 2.08x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 2)                     | 15.28  | 8.07  | 1.89x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -2)                    | 24.01  | 14.63 | 1.64x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 21)                    | 16.00  | 9.15  | 1.75x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -21)                   | 24.82  | 14.96 | 1.66x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 214)                   | 16.27  | 9.81  | 1.66x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -214)                  | 25.33  | 15.91 | 1.59x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 2147)                  | 16.65  | 10.52 | 1.58x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -2147)                 | 26.83  | 16.42 | 1.63x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 21474)                 | 17.45  | 11.13 | 1.57x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -21474)                | 26.92  | 16.59 | 1.62x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 214748)                | 17.71  | 11.71 | 1.51x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -214748)               | 27.18  | 17.66 | 1.54x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 2147483)               | 19.02  | 12.18 | 1.56x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -2147483)              | 28.04  | 18.34 | 1.53x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 21474836)              | 18.76  | 13.16 | 1.43x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -21474836)             | 29.07  | 18.67 | 1.56x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 214748364)             | 19.35  | 13.65 | 1.42x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -214748364)            | 29.63  | 19.78 | 1.50x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 2147483647)            | 20.41  | 14.13 | 1.44x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -2147483648)           | 30.42  | 20.92 | 1.45x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 4294967295000000000)   | 27.36  | 21.16 | 1.29x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -4294967295000000000)  | 36.75  | 27.20 | 1.35x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 4294967295000000001)   | 27.10  | 21.35 | 1.27x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -4294967295000000001)  | 36.55  | 27.21 | 1.34x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 92233720368)           | 22.23  | 17.38 | 1.28x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -92233720368)          | 31.76  | 22.69 | 1.40x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 922337203685)          | 24.25  | 16.95 | 1.43x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -922337203685)         | 32.23  | 23.23 | 1.39x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 9223372036854)         | 23.20  | 17.66 | 1.31x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -9223372036854)        | 32.78  | 23.79 | 1.38x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 92233720368547)        | 23.90  | 18.21 | 1.31x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -92233720368547)       | 32.98  | 24.20 | 1.36x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 922337203685477)       | 24.49  | 18.40 | 1.33x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -922337203685477)      | 34.17  | 24.35 | 1.40x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 9223372036854775)      | 25.04  | 20.20 | 1.24x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -9223372036854775)     | 35.39  | 25.29 | 1.40x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 92233720368547758)     | 26.46  | 19.82 | 1.33x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -92233720368547758)    | 35.27  | 25.63 | 1.38x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 922337203685477580)    | 26.59  | 21.72 | 1.22x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -922337203685477580)   | 35.66  | 26.36 | 1.35x | \r\n| System.Tests.Perf_Int64.TryFormat(value: 9223372036854775807)   | 28.94  | 22.80 | 1.27x | \r\n| System.Tests.Perf_Int64.TryFormat(value: -9223372036854775808)  | 37.46  | 29.98 | 1.25x | \r\n| System.Tests.Perf_UInt32.ToString(value: 0)                     | 13.21  | 10.39 | 1.27x | \r\n| System.Tests.Perf_UInt32.ToString(value: 1)                     | 12.88  | 10.61 | 1.21x | \r\n| System.Tests.Perf_UInt32.ToString(value: 1283)                  | 13.74  | 12.67 | 1.09x | \r\n| System.Tests.Perf_UInt32.ToString(value: 12837467)              | 16.11  | 15.03 | 1.07x | \r\n| System.Tests.Perf_UInt32.ToString(value: 4294967295)            | 17.54  | 16.14 | 1.09x | \r\n| System.Tests.Perf_UInt32.TryFormat(value: 0)                    | 13.38  | 7.22  | 1.85x | \r\n| System.Tests.Perf_UInt32.TryFormat(value: 1)                    | 13.47  | 7.22  | 1.87x | \r\n| System.Tests.Perf_UInt32.TryFormat(value: 1283)                 | 14.88  | 9.16  | 1.62x | \r\n| System.Tests.Perf_UInt32.TryFormat(value: 12837467)             | 16.36  | 11.56 | 1.42x | \r\n| System.Tests.Perf_UInt32.TryFormat(value: 4294967295)           | 17.33  | 13.18 | 1.31x | \r\n| System.Tests.Perf_UInt64.ToString(value: 0)                     | 2.99   | 2.35  | 1.28x | \r\n| System.Tests.Perf_UInt64.ToString(value: 1000000000000000000)   | 5.54   | 5.16  | 1.08x | \r\n| System.Tests.Perf_UInt64.ToString(value: 18446744073709551615)  | 6.16   | 6.14  | 1.00x | \r\n| System.Tests.Perf_UInt64.ToString(value: 2)                     | 2.97   | 2.38  | 1.25x | \r\n| System.Tests.Perf_UInt64.ToString(value: 21)                    | 3.13   | 2.46  | 1.27x | \r\n| System.Tests.Perf_UInt64.ToString(value: 214)                   | 3.23   | 2.67  | 1.21x | \r\n| System.Tests.Perf_UInt64.ToString(value: 2147)                  | 3.40   | 2.86  | 1.19x | \r\n| System.Tests.Perf_UInt64.ToString(value: 21474)                 | 3.46   | 2.93  | 1.18x | \r\n| System.Tests.Perf_UInt64.ToString(value: 214748)                | 3.53   | 3.03  | 1.17x | \r\n| System.Tests.Perf_UInt64.ToString(value: 2147483)               | 3.62   | 3.17  | 1.14x | \r\n| System.Tests.Perf_UInt64.ToString(value: 21474836)              | 3.80   | 3.30  | 1.15x | \r\n| System.Tests.Perf_UInt64.ToString(value: 214748364)             | 4.03   | 3.58  | 1.13x | \r\n| System.Tests.Perf_UInt64.ToString(value: 2147483647)            | 4.13   | 3.53  | 1.17x | \r\n| System.Tests.Perf_UInt64.ToString(value: 4294967295000000000)   | 5.58   | 5.48  | 1.02x | \r\n| System.Tests.Perf_UInt64.ToString(value: 4294967295000000001)   | 5.65   | 5.19  | 1.09x | \r\n| System.Tests.Perf_UInt64.ToString(value: 92233720368)           | 4.62   | 4.07  | 1.13x | \r\n| System.Tests.Perf_UInt64.ToString(value: 922337203685)          | 4.75   | 4.17  | 1.14x | \r\n| System.Tests.Perf_UInt64.ToString(value: 9223372036854)         | 4.74   | 4.47  | 1.06x | \r\n| System.Tests.Perf_UInt64.ToString(value: 92233720368547)        | 4.95   | 4.77  | 1.04x | \r\n| System.Tests.Perf_UInt64.ToString(value: 922337203685477)       | 5.02   | 4.49  | 1.12x | \r\n| System.Tests.Perf_UInt64.ToString(value: 9223372036854775)      | 5.17   | 4.64  | 1.11x | \r\n| System.Tests.Perf_UInt64.ToString(value: 92233720368547758)     | 5.28   | 4.88  | 1.08x | \r\n| System.Tests.Perf_UInt64.ToString(value: 922337203685477580)    | 5.55   | 5.44  | 1.02x | \r\n| System.Tests.Perf_UInt64.ToString(value: 9223372036854775807)   | 5.95   | 5.53  | 1.08x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 0)                    | 3.14   | 1.67  | 1.88x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 1000000000000000000)  | 5.49   | 4.27  | 1.28x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 18446744073709551615) | 5.95   | 4.69  | 1.27x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 2)                    | 3.12   | 1.64  | 1.90x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 21)                   | 3.19   | 1.85  | 1.72x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 214)                  | 3.38   | 1.94  | 1.74x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 2147)                 | 3.40   | 2.05  | 1.66x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 21474)                | 3.48   | 2.19  | 1.59x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 214748)               | 3.54   | 2.35  | 1.50x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 2147483)              | 3.70   | 2.40  | 1.54x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 21474836)             | 3.69   | 2.65  | 1.39x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 214748364)            | 3.90   | 2.67  | 1.46x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 2147483647)           | 4.06   | 2.77  | 1.47x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 4294967295000000000)  | 5.71   | 4.33  | 1.32x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 4294967295000000001)  | 5.45   | 4.26  | 1.28x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 92233720368)          | 4.47   | 3.35  | 1.34x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 922337203685)         | 4.57   | 3.42  | 1.34x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 9223372036854)        | 5.05   | 3.55  | 1.42x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 92233720368547)       | 4.80   | 3.73  | 1.29x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 922337203685477)      | 4.92   | 3.73  | 1.32x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 9223372036854775)     | 5.10   | 3.82  | 1.34x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 92233720368547758)    | 5.14   | 3.95  | 1.30x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 922337203685477580)   | 5.29   | 4.09  | 1.30x | \r\n| System.Tests.Perf_UInt64.TryFormat(value: 9223372036854775807)  | 5.79   | 4.61  | 1.26x | \r\n"},{"Id":"7482478561","Type":"PullRequestEvent","CreatedAt":"2018-04-05T01:38:59","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17431","RelatedDescription":"Opened pull request \"LSRA: remove last uses only at use point\" (#17431) at dotnet/coreclr","RelatedBody":"LSRA maintains liveness within a block to determine what's live across a call. It uses the last use bits on lclVar nodes to remove them from the set. However, this should be done at the point of use rather than at the point where the lclVar is encountered in the execution stream.\r\n\r\nFix #17389"},{"Id":"7482365951","Type":"PullRequestEvent","CreatedAt":"2018-04-05T00:54:29","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17421","RelatedDescription":"Merged pull request \"JIT: refine x86 gc reg kill set for CORINFO_HELP_INIT_PINVOKE_FRAME\" (#17421) at dotnet/coreclr","RelatedBody":"This helper only kills EAX/ESI on x86, so make sure that is reflected in\r\nthe gc kill set.\r\n\r\nResolves #17404."},{"Id":"7482365941","Type":"IssuesEvent","CreatedAt":"2018-04-05T00:54:29","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17404","RelatedDescription":"Closed issue \"jit x86: possible issue with preserved register set for CORINFO_HELP_INIT_PINVOKE_FRAME\" (#17404) at dotnet/coreclr","RelatedBody":"The [x86 jitstress1 gcstress0xC failure](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc_jitstress1_prtest/28/) in baseservices_threading._commitstackonlyasneeded_DefaultStackCommit seems to be a problem with `CORINFO_HELP_INIT_PINVOKE_FRAME` claiming to kill gc refs in `EDX` when it doesn't.\r\n\r\nProblematic method is `<>c:<RunTest>b__9_3(ref):this` which has disassembly (annotated w/ GC info):\r\n```asm\r\n058258f8 55              push    ebp\r\n058258f9 8bec            mov     ebp,esp\r\n058258fb 57              push    edi\r\n058258fc 56              push    esi\r\n058258fd 53              push    ebx\r\n058258fe 83ec1c          sub     esp,1Ch\r\n;; end prolog\r\n05825901 8d7ddc          lea     edi,[ebp-24h]   +EDX\r\n05825904 e85fdd5efb      call    CORINFO_HELP_INIT_PINVOKE_FRAME (00e13668)  +EDI\r\n05825909 8bcd            mov     ecx,ebp   -EDX ?? -EDI\r\n0582590b 894df0          mov     dword ptr [ebp-10h],ecx\r\n0582590e 8bca            mov     ecx,edx\r\n>>> 05825910 ff15b85c280b    call    dword ptr ds:[0B285CB8h] (StackCommitTest.Finalizer.CreateUnreferencedObject(System.Action), mdToken: 06000011)\r\n```\r\nAs you can see `EDX` is killed for GC after the first call when it is clearly live down to the move before the second call.\r\n\r\nThe root cause seems to be that `CORINFO_HELP_INIT_PINVOKE_FRAME` is not special cased in `Compiler::compNoGCHelperCallKillSet` and so reports the default set of callee killed registers, which includes `EDX`.\r\n\r\nAdding a special case for this for x86 fixes the gc stress regression.\r\n\r\nSeems like we could assert that the set of GC kills at a call is a subset of the set of regular kills maybe?\r\n\r\nSplitting this one off from #17027 / #17330.\r\n\r\ncc @RussKeldorph  @dotnet/jit-contrib \r\n"},{"Id":"7482336155","Type":"PullRequestEvent","CreatedAt":"2018-04-05T00:42:34","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17430","RelatedDescription":"Opened pull request \"Update CoreClr to preview3-26405-01 (master)\" (#17430) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"7482328446","Type":"PullRequestEvent","CreatedAt":"2018-04-05T00:39:51","Actor":"Anipik","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17429","RelatedDescription":"Opened pull request \"Added Apis For TryGetFullPath\" (#17429) at dotnet/coreclr","RelatedBody":"Fixes :- https://github.com/dotnet/corefx/issues/28258\r\nRemoveRelativeSegments Test PR:- https://github.com/dotnet/corefx/pull/28835\r\nApi Test PR :-"},{"Id":"7482325516","Type":"PullRequestEvent","CreatedAt":"2018-04-05T00:38:48","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17274","RelatedDescription":null,"RelatedBody":""},{"Id":"7482325446","Type":"PullRequestEvent","CreatedAt":"2018-04-05T00:38:46","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17274","RelatedDescription":"Closed pull request \"[NO MERGE] Dummy change for dotnet:dev/unix_test_workflow\" (#17274) at dotnet/coreclr","RelatedBody":""},{"Id":"7482187357","Type":"IssuesEvent","CreatedAt":"2018-04-04T23:50:21","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17428","RelatedDescription":"Opened issue \"x86 gcstress 0xC zapdisable heapverify1 failures\" (#17428) at dotnet/coreclr","RelatedBody":"Forking from #17330.\r\n\r\nJIT_Methodical._ELEMENT_TYPE_IU__il_dbgu_fld\r\nJIT_Methodical._ELEMENT_TYPE_IU__il_relu_fld\r\n\r\nExample runs with failures: [14](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc_zapdisable_heapverify1_prtest/14/), [15](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc_zapdisable_heapverify1_prtest/15/)\r\n\r\nHaven't been able to repro these locally. Failure is just a bogus return code with no other indication of error. Tests are not multithreaded. Failure may be HW/OS version specific?\r\n\r\nReturn code in failing CI has odd pattern 0xCCCCCD40 (debug) or 0xCCCCCDC4 (rel) which may be a clue. Will keep at it.\r\n\r\nNote we have 0x0CCCCCCCD used in the gc at places as an \"invalid gc value\" when the shadow heap is enabled. However, enabling the shadow heap appears to require heapverify=2 and we're running with heapverify=1.\r\n\r\nheapverify=1 also fills free memory within a heap to 0xCC.\r\n"},{"Id":"7482179273","Type":"PullRequestEvent","CreatedAt":"2018-04-04T23:47:35","Actor":"weshaggard","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17392","RelatedDescription":"Merged pull request \"Update CoreFx to servicing-26403-03 (release/2.0.0)\" (#17392) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"7482177536","Type":"PullRequestEvent","CreatedAt":"2018-04-04T23:46:59","Actor":"weshaggard","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17426","RelatedDescription":"Merged pull request \"Update BuildTools to preview3-02704-01 (master)\" (#17426) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7482870325","Type":"PullRequestEvent","CreatedAt":"2018-04-05T04:24:21","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9001","RelatedDescription":"Opened pull request \"Automatic build numbers flow into installers\" (#9001) at dotnet/cli","RelatedBody":"Fixes https://github.com/dotnet/cli/issues/8042\r\n"},{"Id":"7482806777","Type":"IssuesEvent","CreatedAt":"2018-04-05T03:56:06","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/8999","RelatedDescription":"Closed issue \"Add Nuget source commands to cli?\" (#8999) at dotnet/cli","RelatedBody":"The cli has some nuget commands that can be used, [ref](https://docs.microsoft.com/en-us/nuget/tools/dotnet-commands).\r\n\r\nWhat does everyone think about adding more? I'm specifically interested in being able to add nuget sources using the cli. \r\n\r\nMy use case is in AWS CodePipeline. CodePipeline uses an Ubuntu image to run dotnet builds, and I cannot access that image (AFAIK). The image has the dotnet cli installed, but it does not have the nuget cli installed. I'd like to add a private nuget source before running the build, but I can't without the nuget cli. I might be able to install nuget via apt-get at the start of the build, but it would be nice to use the dotnet cli to add a nuget source since I use it for every other step of the build.\r\n\r\nThoughts?\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"7482780225","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:43:59","Actor":"dotnet-maestro-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9000","RelatedDescription":"Opened pull request \"Update Roslyn to beta4-62805-01 (master)\" (#9000) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7482300388","Type":"IssuesEvent","CreatedAt":"2018-04-05T00:29:25","Actor":"mattcbaker","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8999","RelatedDescription":"Opened issue \"Add Nuget source commands to cli?\" (#8999) at dotnet/cli","RelatedBody":"The cli has some nuget commands that can be used, [ref](https://docs.microsoft.com/en-us/nuget/tools/dotnet-commands).\r\n\r\nWhat does everyone think about adding more? I'm specifically interested in being able to add nuget sources using the cli. \r\n\r\nMy use case is in AWS CodePipeline. CodePipeline uses an Ubuntu image to run dotnet builds, and I cannot access that image (AFAIK). The image has the dotnet cli installed, but it does not have the nuget cli installed. I'd like to add a private nuget source before running the build, but I can't without the nuget cli. I might be able to install nuget via apt-get at the start of the build, but it would be nice to use the dotnet cli to add a nuget source since I use it for every other step of the build.\r\n\r\nThoughts?\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"7482270079","Type":"IssuesEvent","CreatedAt":"2018-04-05T00:18:10","Actor":"sdmaclea","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8998","RelatedDescription":"Opened issue \"[Arm64/Arm] crossgen cli tools\" (#8998) at dotnet/cli","RelatedBody":"Arm64 & Arm crosscomponent crossgen tools are available and are being consumed by coreclr core-setup to crossgen the runtime.\r\n\r\nThey are not yet being used by cli to crossgen the SDK (done for x64).\r\n\r\nOne of the issues is that the crosscomponent crossgen tool is contained in a private coreclr package which is enacapsulated by core-setup.  ClI does not seem to have the necessary version info to reference the correct package.\r\n\r\nOptions:\r\n+ Core-setup redistribute the crosscomponent crossgen tool(s)\r\n+ Create a mechanism to determine the correct coreclr package version.\r\n\r\nFor arm64 the crosscomponent crossgen tool is here \r\n```\r\ntransport.runtime.linux-arm64.microsoft.netcore.runtime.coreclr/*/tools/x64_arm64/crossgen\r\n```"},{"Id":"7482206981","Type":"PullRequestEvent","CreatedAt":"2018-04-04T23:56:50","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/cli/pull/8997","RelatedDescription":null,"RelatedBody":"This is the most tricky part of consume bring your own shim. CLI will need to select the most fit RID given the shims folder layout in nupkg. This function is to pick that. \r\n\r\nSay there is folder `win10-x64, win-x64, win, linux`, CLI need to pick the right shim folder to use according to machine RID (say it is windows 10 x64). And this function take these rids as input and return `win10-x64`.\r\n\r\nThe hardest part is to compare `win10-x64` and `win-x64` when they are both available. _RuntimeFallbacks_ field in _DependencyContext_ will give you all the node in between specific rid to node path. If other rids, `win-x64` in the path, we can way `win10-x64` is more specific than `win-x64`.\r\n\r\nAlso, could you understand it by just reading the code? if not i will paste above as comment\r\n\r\n![image](https://user-images.githubusercontent.com/6993335/38338303-e419621a-381d-11e8-842c-8d99d08d12ee.png)\r\n"},{"Id":"7482198283","Type":"PullRequestEvent","CreatedAt":"2018-04-04T23:53:52","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8997","RelatedDescription":"Closed pull request \"WIP Add TryGetMostFitRuntimeIdentifier\" (#8997) at dotnet/cli","RelatedBody":"This is the most tricky part of consume bring your own shim. CLI will need to select the most fit RID given the shims folder layout in nupkg. This function is to pick that. \r\n\r\nSay there is folder `win10-x64, win-x64, win, linux`, CLI need to pick the right shim folder to use according to machine RID (say it is windows 10 x64). And this function take these rids as input and return `win10-x64`.\r\n\r\nThe hardest part is to compare `win10-x64` and `win-x64` when they are both available. _RuntimeFallbacks_ field in _DependencyContext_ will give you all the node in between specific rid to node path. If other rids, `win-x64` in the path, we can way `win10-x64` is more specific than `win-x64`.\r\n\r\nAlso, could you understand it by just reading the code? if not i will paste above as comment\r\n\r\n![image](https://user-images.githubusercontent.com/6993335/38338303-e419621a-381d-11e8-842c-8d99d08d12ee.png)\r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7481565567","Type":"PullRequestEvent","CreatedAt":"2018-04-04T21:05:28","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/700","RelatedDescription":"Opened pull request \"Update BuildTools to preview3-02704-01 (master)\" (#700) at dotnet/standard","RelatedBody":""},{"Id":"7481560439","Type":"PullRequestEvent","CreatedAt":"2018-04-04T21:04:25","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/695","RelatedDescription":"Merged pull request \"Update BuildTools to preview3-02703-02 (master)\" (#695) at dotnet/standard","RelatedBody":""},{"Id":"7467609091","Type":"PullRequestEvent","CreatedAt":"2018-04-02T15:55:55","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/699","RelatedDescription":"Opened pull request \"Don't fail trimming on missing files\" (#699) at dotnet/standard","RelatedBody":"Instead, warn if that file happens to be included in the closure.\r\n\r\nFixes #697\r\n\r\nIt's still not clear to me this is required, but we can add it.  It may even be more appropriate to error."},{"Id":"7462410593","Type":"IssuesEvent","CreatedAt":"2018-03-31T15:52:06","Actor":"metadings","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/698","RelatedDescription":"Closed issue \"New Version Hell\" (#698) at dotnet/standard","RelatedBody":"Look. I thought .NET would solve this problem.\r\n\r\nNow you do have .NET Framework 2.0, 4.0, 4.5, .NET Standard 1.x, 2.x, .NET Core 1.x, 2.x - you could compile once for all of them, but you've decided to use stupid `#if NETSTANDARD1_x` directives without value (like [this](https://github.com/metadings/Blake2B.cs/pull/2/files)). You do have a lot of DLLs again and no way to detect which platform is running (`readonly static bool IsMono = Type.GetType(\"Mono.Runtime\") != null`).\r\n\r\nI want you to cancel .NET standard; in favor of just .NET framework (and mono)."},{"Id":"7462024550","Type":"IssuesEvent","CreatedAt":"2018-03-31T11:14:43","Actor":"metadings","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/698","RelatedDescription":"Opened issue \"New Version Hell\" (#698) at dotnet/standard","RelatedBody":"Look. I thought .NET would solve this problem.\r\n\r\nNow you do have .NET Framework 2.0, 4.0, 4.5, .NET Standard 1.x, 2.x, .NET Core 1.x, 2.x - you could compile for all of them, but you've decided to use stupid #if directives. You do have a lot of DLLs again and no way to detect which platform is running (IsMono = Type.GetType(\"Mono.Runtime\") != null).\r\n\r\nI want you to cancel .NET core and standard; in favor of just .NET and mono."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7482990950","Type":"PullRequestEvent","CreatedAt":"2018-04-05T05:17:27","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28845","RelatedDescription":"Opened pull request \"Update CoreFx, ProjectNTfs, ProjectNTfsTestILC to preview3-26405-01, beta-26405-00, beta-26405-00, respectively (master)\" (#28845) at dotnet/corefx","RelatedBody":""},{"Id":"7482955262","Type":"PullRequestEvent","CreatedAt":"2018-04-05T05:02:02","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/28844","RelatedDescription":"Merged pull request \"Remove unnecessary span lines from perf formatting tests\" (#28844) at dotnet/corefx","RelatedBody":"cc: @ahsonkhan "},{"Id":"7482836939","Type":"PullRequestEvent","CreatedAt":"2018-04-05T04:09:42","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/27763","RelatedDescription":"Merged pull request \"Handle recycled child PIDs\" (#27763) at dotnet/corefx","RelatedBody":"When the user keeping references to old processes, a new child would re-use some state of an old process with the same PID.\r\nThis causes the following code to throw when PID is recycled (https://github.com/dotnet/corefx/issues/27249#issuecomment-367288949).\r\n```C#\r\n            List<Process> processes = new List<Process>();\r\n            for (int i = 0; i < 1_000_000; i++)\r\n            {\r\n                if (i % 100 == 0)\r\n                {\r\n                    System.Console.Write(\".\");\r\n                }\r\n                try\r\n                {\r\n                    var process = new Process();\r\n                    processes.Add(process);\r\n                    process.StartInfo.FileName = \"/usr/bin/sleep\";\r\n                    process.StartInfo.Arguments = \"0\";\r\n                    process.EnableRaisingEvents = true;\r\n                    process.Start();\r\n\r\n                    process.WaitForExit();\r\n                }\r\n                catch\r\n                {\r\n                    System.Console.WriteLine($\"Exception when creating process {i}\");\r\n                    throw;\r\n                }\r\n            }\r\n```\r\n\r\nWe detect when the PID is recycled and use a new ProcessWaitState for the new child.\r\nAlso, we ensure the ProcessWaitHandle is using the same ProcessWaitState as the Process it was created for.\r\n\r\nThe above test code no longer throws now when the PID is recycled. I have not added a test because it takes a long time to run.\r\n\r\nCC @stephentoub @danmosemsft "},{"Id":"7482825900","Type":"PullRequestEvent","CreatedAt":"2018-04-05T04:04:37","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28844","RelatedDescription":"Opened pull request \"Remove unnecessary span lines from perf formatting tests\" (#28844) at dotnet/corefx","RelatedBody":"cc: @ahsonkhan "},{"Id":"7482807955","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:56:37","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/28797","RelatedDescription":"Merged pull request \"Add a few IdnMapping tests\" (#28797) at dotnet/corefx","RelatedBody":"Validate that we get the same string object back when we expect to.\r\n\r\nDepends on https://github.com/dotnet/coreclr/pull/17399 to pass.\r\n\r\ncc: @danmosemsft, @tarekgh "},{"Id":"7482801841","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:53:51","Actor":"Clockwork-Muse","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28843","RelatedDescription":"Opened pull request \"Consolidate http date parsing\" (#28843) at dotnet/corefx","RelatedBody":"Fixes #12513\r\nFollowup to #28541 \r\n\r\nFixes the following bugs for Http date parsing in System.Net.Requests:\r\n - considered ANSI dates to be local (to the _receiver_, no less), instead of UTC/GMT like the spec says.\r\n - accepted offset values (ie, `+05:00`), but didn't actually use them.\r\n - would throw `ArrayIndexOutOfBoundsException` if a string token didn't have enough distinguishing characters (ie, `'S'` throws, because it needs to check the next character for `'a'`/`'u'` for Saturday/Sunday)\r\n\r\nFor System.Net.Requests, with respect to the original behavior:\r\n- Retains case insensitivity of the original (mostly - UTC/GMT must now be uppercase).\r\n- Drops ability to use partially matching day-of-week/month strings (ie, the original parses `\"Surprise\"` as `\"Sunday\"`).\r\n- Drops ability to use non-matching date/day-of-week strings (ie `\"Sat, 25 Mar 2018 16:33:01 GMT\"` - the 25th was actually a Sunday)\r\n- Drops ability to use arbitrary characters as separators.\r\n- Now allows arbitrary amounts of whitespace between tokens.\r\n\r\ncc: @stephentoub @geoffkizer @karelz @rmkerr @davidsh @caesar1995 @wfurt "},{"Id":"7482712491","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:14:48","Actor":"VSadov","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/28832","RelatedDescription":"Merged pull request \"Enable skipped test.\" (#28832) at dotnet/corefx","RelatedBody":"Test refers to a closed issue https://github.com/dotnet/corefx/issues/13541 and indeed passes"},{"Id":"7482662269","Type":"PullRequestEvent","CreatedAt":"2018-04-05T02:53:21","Actor":"mark-cordell","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28842","RelatedDescription":"Opened pull request \"Enable connection pooling for requests that use different client certificates…\" (#28842) at dotnet/corefx","RelatedBody":"Enable connection pooling for requests that use different client certificates or server certificate callbacks. This allows setting these options on a per-request basis, which has much better perf for scenarios that want to share a session between requests that use different options for these.\r\n\r\n#28841 "},{"Id":"7482649862","Type":"IssuesEvent","CreatedAt":"2018-04-05T02:48:05","Actor":"mark-cordell","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/28841","RelatedDescription":"Opened issue \"WinHttpHandler perf optimization for ClientCertificates, ServerCertificateValidationCallback\" (#28841) at dotnet/corefx","RelatedBody":"In a larger server app, there may be scenarios where different parts of the code need to use different client certificates on a per-request basis. Same with ServerCertificateValidationCallback. The native WinHttp library lets you efficiently pool connections across a session, and set client certificates and perform custom certificate validation on a per-request basis within that session, but the managed library forces you to share these settings across all requests in a session. People often use ServerCertificateValidationCallback as an instance delegate on some object that has a much shorter lifetime than the session.\r\n\r\nIt would be good if the managed library just let you set these on a per-request basis. It's really hard to get good perf otherwise."},{"Id":"7482638316","Type":"PullRequestEvent","CreatedAt":"2018-04-05T02:43:12","Actor":"MisinformedDNA","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28840","RelatedDescription":"Opened pull request \"Clean up dead code for System.Collections*\" (#28840) at dotnet/corefx","RelatedBody":"#17905 "},{"Id":"7482622972","Type":"PullRequestEvent","CreatedAt":"2018-04-05T02:36:31","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/28839","RelatedDescription":"Closed pull request \"Update CoreClr, CoreFx to preview3-26405-01, preview3-26405-01, respectively (master)\" (#28839) at dotnet/corefx","RelatedBody":""}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7482955957","Type":"PullRequestEvent","CreatedAt":"2018-04-05T05:02:20","Actor":"agocke","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/pull/19444","RelatedDescription":"Closed pull request \"Mark local function default parameter expressions as used\" (#19444) at dotnet/roslyn","RelatedBody":"**Customer scenario**\r\n\r\nReferencing a local/local-function with `nameof` or a constant expression in a local function default parameter expression does not mark the other variable as used. This would emit a warning, and cause VS to suggest to eliminate the variable - which doesn't work, as it *is* being used.\r\n\r\n**Bugs this fixes:**\r\n\r\n#16821, #16454\r\n\r\n**Workarounds, if any**\r\n\r\nUser ignores the warning.\r\n\r\n**Risk**\r\n\r\nThe only major modification is changing the way `SourceComplexParameterSymbol` calculates the default value (it now holds onto the bound expression) - but it's unlikely this would affect anything.\r\n\r\n**Performance impact**\r\n\r\nExtra allocation when storing the `ConstantValue` and `BoundExpression` (to allow a single Interlocked.CompExch to update both), plus retaining the `BoundExpression`. Note this only happens in `SourceComplexParameterSymbol`, which is a subset of all parameters - only \"special\" ones (complex means \"has default value\", etc.)\r\n\r\n**Is this a regression from a previous update?**\r\n\r\nNo.\r\n\r\n**Root cause analysis:**\r\n\r\nOverlooked probably because it's not a very intrusive error, easy to ignore and not report. The case where this could go wrong is also new (with local functions), as we never needed to report usage before (but note that a couple tests changed - a normal method referencing a static variable in a default param now recognizes it as being used)\r\n\r\n**How was the bug found?**\r\n\r\nGithub issues (linked above)\r\n\r\n---\r\n\r\nPing @dotnet/roslyn-compiler for review. The weirdest thing up for review is probably the LazyDefaultValue class I created - I think that's the cleanest way to do it (lazy init two fields linked together), but I'm open for other suggestions."},{"Id":"7482871491","Type":"PullRequestEvent","CreatedAt":"2018-04-05T04:24:52","Actor":"AlekseyTs","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/25947","RelatedDescription":"Opened pull request \"Merge 'dotnet/dev15.7.x' into dataflow\" (#25947) at dotnet/roslyn","RelatedBody":""},{"Id":"7482788775","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:47:53","Actor":"agocke","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/25946","RelatedDescription":"Opened pull request \"Visit default value in local function parameters\" (#25946) at dotnet/roslyn","RelatedBody":"### Customer scenario\r\n\r\nThe definite assignment pass did not visit local function default value\r\nexpressions, which could result in incorrect warnings about unused\r\nvariables or missing definite assignment errors. This change fixes that\r\nproblem, however it requires us to rebind default value expressions to\r\nproduce bound nodes, since the bound nodes are not otherwise stored\r\nafter calculating the constant value.\r\n\r\n### Bugs this fixes\r\n\r\nFixes #16821\r\n\r\n### Workarounds, if any\r\n\r\nNone.\r\n\r\n### Risk\r\n\r\nThis should just be duplicating work we're already doing in other places. When\r\nnew definite assignment errors would be produced, other errors should also\r\nbe produced since only constant values are permitted in default value expressions\r\nand all constant values are definitely assigned.\r\n\r\n### Performance impact\r\n\r\nProbably not too big, but this could cause a slow down due to extra binding.\r\n\r\n### Is this a regression from a previous update?\r\n\r\nNo.\r\n\r\n### Root cause analysis\r\n\r\nUnique problem to local functions. Methods do not have the problem since they\r\nare checked for warnings about fields in a completely different way. Lambdas\r\ndo not have a problem since they cannot have optional parameters with default\r\nvalues.\r\n\r\n### How was the bug found?\r\n\r\nCustomer reported\r\n"},{"Id":"7482779272","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:43:32","Actor":"CyrusNajmabadi","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/25945","RelatedDescription":"Opened pull request \"Proof of concept: Pull common methods up to base type in syntax api.\" (#25945) at dotnet/roslyn","RelatedBody":"Proof of concept approach for: https://github.com/dotnet/roslyn/issues/25936\r\n\r\nI created this to help further that discussion by seeing how many members we'd need to create, and how large it would expand the public surface area of the syntax model."},{"Id":"7482727834","Type":"IssuesEvent","CreatedAt":"2018-04-05T03:21:16","Actor":"OmarTawfik","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/20050","RelatedDescription":"Closed issue \"Debug asserts in LocalRewriter.BuildArgumentsInEvaluationOrder in invalid code\" (#20050) at dotnet/roslyn","RelatedBody":"**Version Used**: Latest sources\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Copy/paste C#:\r\n\r\n```C#\r\n    public class C\r\n    {\r\n        void M()\r\n        {\r\n            string.Format(format: \"\", format: \"\");\r\n        }\r\n    }\r\n```\r\n\r\n2. Waiting usually does it. Or cut/paste the `string.Format` line, Or `Ctrl+.` on the error squiggle, etc.\r\n\r\n**Expected Behavior**: No Debug.Asserts\r\n\r\n**Actual Behavior**: Debug.Asserts\r\n\r\n**Example Stack:**\r\n```\r\n>\tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.BuildArgumentsInEvaluationOrder(Microsoft.CodeAnalysis.SyntaxNode syntax, Microsoft.CodeAnalysis.CSharp.Symbol methodOrIndexer, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol optionalParametersMethod, bool expanded, System.Collections.Immutable.ImmutableArray<int> argsToParamsOpt, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CSharp.BoundExpression> arguments, Microsoft.CodeAnalysis.CSharp.Binder binder) Line 668\tC#\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeArgumentsInEvaluationOrder(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.SyntaxNode syntax, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CSharp.BoundExpression> arguments, Microsoft.CodeAnalysis.CSharp.Symbol methodOrIndexer, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol optionalParametersMethod, bool expanded, System.Collections.Immutable.ImmutableArray<int> argsToParamsOpt, bool invokedAsExtensionMethod) Line 526\tC#\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArguments.AnonymousMethod__0(Microsoft.CodeAnalysis.CSharp.BoundExpression n) Line 129\tC#\r\n \t[External Code]\t\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.DeriveArguments(Microsoft.CodeAnalysis.CSharp.BoundExpression boundNode, Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.Symbol methodOrIndexer, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol optionalParametersMethod, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CSharp.BoundExpression> boundArguments, System.Collections.Immutable.ImmutableArray<string> argumentNamesOpt, System.Collections.Immutable.ImmutableArray<int> argumentsToParametersOpt, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.RefKind> argumentRefKindsOpt, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol> parameters, bool expanded, Microsoft.CodeAnalysis.SyntaxNode invocationSyntax, bool invokedAsExtensionMethod) Line 115\tC#\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.ArgumentsInEvaluationOrder.get() Line 63\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitInvocationExpression(Microsoft.CodeAnalysis.Semantics.IInvocationExpression operation) Line 205\tC#\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 69\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 79\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitExpressionStatement(Microsoft.CodeAnalysis.Semantics.IExpressionStatement operation) Line 187\tC#\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 756\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 79\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitArray<Microsoft.CodeAnalysis.IOperation>(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> list) Line 21\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.VisitBlockStatement(Microsoft.CodeAnalysis.Semantics.IBlockStatement operation) Line 53\tC#\r\n \tMicrosoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor) Line 82\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationWalker.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 34\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.OperationCollector.Visit(Microsoft.CodeAnalysis.IOperation operation) Line 79\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Semantics.OperationExtensions.DescendantsAndSelf(Microsoft.CodeAnalysis.IOperation operation) Line 33\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver<Microsoft.CodeAnalysis.CSharp.SyntaxKind>.GetOperationsToAnalyze(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> operationBlocks) Line 2077\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver<Microsoft.CodeAnalysis.CSharp.SyntaxKind>.TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference decl, int declarationIndex, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool shouldExecuteSyntaxNodeActions, bool shouldExecuteOperationActions, bool shouldExecuteCodeBlockActions, bool shouldExecuteOperationBlockActions, bool isInGeneratedCode, System.Threading.CancellationToken cancellationToken) Line 1802\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver<Microsoft.CodeAnalysis.CSharp.SyntaxKind>.TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol, System.Threading.CancellationToken cancellationToken) Line 1639\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessSymbolDeclared(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent symbolEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 964\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessEventCore(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent e, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 919\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessEvent(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent e, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 906\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool prePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 893\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool prePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 826\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ExecutePrimaryAnalysisTaskAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, bool usingPrePopulatedEventQueue, System.Threading.CancellationToken cancellationToken) Line 418\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AttachQueueAndProcessAllEventsAsync(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue<Microsoft.CodeAnalysis.Diagnostics.CompilationEvent> eventQueue, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState analysisStateOpt, System.Threading.CancellationToken cancellationToken) Line 347\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.ComputeAnalyzerDiagnosticsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver driver, Microsoft.CodeAnalysis.Diagnostics.AsyncQueue<Microsoft.CodeAnalysis.Diagnostics.CompilationEvent> eventQueue, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope analysisScope, System.Threading.CancellationToken cancellationToken) Line 827\tC#\r\n \tMicrosoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.ComputeAnalyzerDiagnosticsAsync.AnonymousMethod__1() Line 659\tC#\r\n \t[External Code]\t\r\n```"},{"Id":"7482727304","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:21:03","Actor":"OmarTawfik","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/25730","RelatedDescription":"Merged pull request \"Assert duplicate named arguments produce correct diagnostics\" (#25730) at dotnet/roslyn","RelatedBody":"### Customer scenario\r\nGetting IOperations trees on call expressions that have duplicate explicitly named arguments, will cause a `Debug.Assert()` to throw in the compiler. Example:\r\n```C#\r\n    public class C\r\n    {\r\n        void M()\r\n        {\r\n            string.Format(format: \"\", format: \"\");\r\n        }\r\n    }\r\n```\r\n### Bugs this fixes\r\nFixes #20050 \r\n### Workarounds, if any\r\nNone.\r\n### Risk\r\nLow. One line fix.\r\n### Is this a regression from a previous update?\r\nNo.\r\n### Root cause analysis\r\nIt is a case where we didn't count for invalid arguments when constructing the IOperations tree.\r\n### How was the bug found?\r\nReported on GitHub."},{"Id":"7482725701","Type":"IssuesEvent","CreatedAt":"2018-04-05T03:20:22","Actor":"OmarTawfik","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/25399","RelatedDescription":"Closed issue \"partial methods shouldn't be allowed to have different ref-kinds\" (#25399) at dotnet/roslyn","RelatedBody":"**Version Used**: master\r\n\r\n**Steps to Reproduce**:\r\n```cs\r\npartial class C {\r\n    partial void M(in int i);\r\n    partial void M(ref int i) {}  \r\n}\r\n```\r\n**Expected Behavior**: Error: ref-kind doesn't match\r\n\r\n` CS0759: No defining declaration found for implementing declaration of partial method `\r\n\r\n**Actual Behavior**: No error\r\n\r\n\r\n/cc @OmarTawfik "},{"Id":"7482725036","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:20:06","Actor":"OmarTawfik","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/25893","RelatedDescription":"Merged pull request \"Partial methods implementation should match declaration parameter ref kinds\" (#25893) at dotnet/roslyn","RelatedBody":"### Customer scenario\r\n\r\nCustomers should not be able to implement partial methods having parameters with a different ref kind than the definition. The compiler should produce diagnostics and prevent that. Currently, the following invalid code passes without errors:\r\n\r\n```csharp\r\npartial class C {\r\n    partial void M(in int i);\r\n    partial void M(ref int i) {}  \r\n}\r\n```\r\n\r\nSince this is a breaking change, @dotnet/roslyn-compat-council will be notified and will get approval before merging.\r\n\r\n### Bugs this fixes\r\n\r\nFixes #25399\r\n\r\n### Workarounds, if any\r\n\r\nNone.\r\n\r\n### Risk\r\n\r\nLow risk. This is producing an error in a corner case scenario where code shouldn't have been allowed in first place.\r\n\r\n### Performance impact\r\n\r\nNegligible.\r\n\r\n### Is this a regression from a previous update?\r\n\r\nIt is a breaking change.\r\n\r\n### How was the bug found?\r\n\r\nReported on GitHub by a contributor.\r\n\r\ncc @dotnet/roslyn-compiler for review."},{"Id":"7482711420","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:14:19","Actor":"VSadov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/pull/24299","RelatedDescription":"Closed pull request \"Makes range operators built-in operators\" (#24299) at dotnet/roslyn","RelatedBody":""},{"Id":"7482710054","Type":"PullRequestEvent","CreatedAt":"2018-04-05T03:13:42","Actor":"VSadov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/pull/25883","RelatedDescription":"Closed pull request \"Cherry-pick stackalloc constant folding from master to dev15.7.x\" (#25883) at dotnet/roslyn","RelatedBody":"\r\n- it is a nice feature to have\r\n- having better codegen in master causes issues when tests merge from dev15.7.x to master."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7482950183","Type":"IssuesEvent","CreatedAt":"2018-04-05T04:59:54","Actor":"xoofx","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5647","RelatedDescription":"Closed issue \"Assembly.Location returns null\" (#5647) at dotnet/corert","RelatedBody":"From a discussion  #5017:\r\n\r\n> @MichalStrehovsky\r\n>> Update Benchmark.NET to call Assembly.Location instead?\r\n>\r\n> We throw from that too :).\r\n>\r\n>Assembly.Location is really difficult to support in an AOT compiled app because:\r\n>\r\n> The original assembly doesn't exist in the filesystem. There's only a virtualized version of it present somewhere in the native executable that we use in reflection to pretend everything is in it's right place.\r\nEven the mapping from logical assembly to native executable is 1:n (1 managed assembly can be spread into multiple native executables - think a shared library that has some commonly used types from e.g. System.Private.CoreLib in it, and an app EXE that needs a less common type from CoreLib)\r\n> Whatever we pretend is not going to help Benchmark.NET to accomplish what it's trying to do anyway.\r\n\r\nI'm typically using `Assembly.Location` to load resources (e.g native shared lib/dll) that are collocated with the assembly... \r\nI understand that returning a location for an assembly that doesn't exist would be more troublesome, so it seems that using `AppDomain.CurrentDomain.BaseDirectory` would give a rough similar behavior (not strictly equal, but at least to get something working across .NET platforms)... \r\nI'm fine with this workaround, just wanted to make sure that it is the preferred way for doing such things, in case you recommend something more adequate?"},{"Id":"7482139348","Type":"PullRequestEvent","CreatedAt":"2018-04-04T23:34:06","Actor":"A-And","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5651","RelatedDescription":"Opened pull request \"Quality of Life improvements to CoreFX testing infra\" (#5651) at dotnet/corert","RelatedBody":"Also fixes a linking issue in Linux connected to gss (similar to #5644 for OSX) .\r\nImproves brittleness of the framework and brings up some inconsistencies across platforms. "},{"Id":"7481658603","Type":"PullRequestEvent","CreatedAt":"2018-04-04T21:25:12","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5650","RelatedDescription":"Merged pull request \"Update CoreFX dependencies\" (#5650) at dotnet/corert","RelatedBody":"Fixes #5645."},{"Id":"7481658589","Type":"IssuesEvent","CreatedAt":"2018-04-04T21:25:12","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5645","RelatedDescription":"Closed issue \"Method not found: System.ReadOnlyMemory`1<Byte>.Retain(Boolean) -> System.Buffers.MemoryHandle \" (#5645) at dotnet/corert","RelatedBody":"I'm hitting a `MissingMethodException` in the `ReadOnlyMemory<T>` class when using a HttpClient. I suspect this might be a case of mismatching dependencies / the API change for Span/Memory that hasn't completely solidified yet. Is there a workaround for this or will it resolve itself when the dependencies get in sync?\r\n\r\n\r\n```\r\nSystem.MissingMethodException: Method not found: 'System.Buffers.MemoryHandle System.ReadOnlyMemory`1<Byte>.Retain(Boolean)'.\r\n   at test!<BaseAddress>+0x521d1f\r\n   at Internal.Runtime.CompilerHelpers.ThrowHelpers.ThrowMissingMethodException(ExceptionStringID, String) + 0x5\r\n   at System.Net.Security.SslStreamPal.EncryptMessage(SafeDeleteContext, ReadOnlyMemory`1, Int32, Int32, Byte[]&, Int32&) + 0x11\r\n   at System.Net.Security.SecureChannel.Encrypt(ReadOnlyMemory`1, Byte[]&, Int32&) + 0xeb\r\n   at System.Net.Security.SslStreamInternal.WriteSingleChunk[TWriteAdapter](TWriteAdapter, ReadOnlyMemory`1) + 0x193\r\n   at System.Net.Security.SslStreamInternal.WriteAsyncInternal[TWriteAdapter](TWriteAdapter, ReadOnlyMemory`1) + 0x13b\r\n   at System.Net.Security.SslStream.WriteAsync(ReadOnlyMemory`1, CancellationToken) + 0xbc\r\n   at System.Net.Http.HttpConnection.WriteToStreamAsync(ReadOnlyMemory`1) + 0x17c\r\n   at System.Net.Http.HttpConnection.FlushAsync() + 0xa7\r\n   at System.Net.Http.HttpConnection.<SendAsyncCore>d__59.MoveNext() + 0x35ee\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() + 0x30\r\n   at System.Net.Http.HttpConnectionPool.<SendWithRetryAsync>d__36.MoveNext() + 0x3e4\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() + 0x30\r\n   at test!<BaseAddress>+0x5036f2\r\n   at System.Net.Http.RedirectHandler.<SendAsync>d__4.MoveNext() + 0x13c\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() + 0x30\r\n   at test!<BaseAddress>+0x5036f2\r\n   at System.Net.Http.HttpClient.<FinishSendAsyncBuffered>d__62.MoveNext() + 0x42f\r\n```\r\n"},{"Id":"7481403510","Type":"PullRequestEvent","CreatedAt":"2018-04-04T20:33:04","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5650","RelatedDescription":"Opened pull request \"Update CoreFX dependencies\" (#5650) at dotnet/corert","RelatedBody":"Fixes #5645."},{"Id":"7481331638","Type":"PullRequestEvent","CreatedAt":"2018-04-04T20:18:51","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5644","RelatedDescription":"Merged pull request \"Add gss as NativeFramework on OSX to support System.Net.Security.Native.a linking\" (#5644) at dotnet/corert","RelatedBody":"When using features from CoreFX that rely on System.Net.Security.Native.a, the 'gss' Framework needs to be linked in on OSX.\r\nI'm not sure if this should go here automatically, but I guess there shouldn't be any downsides to providing the Framework link if it isn't used."},{"Id":"7478246197","Type":"PullRequestEvent","CreatedAt":"2018-04-04T10:58:01","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5649","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5649) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7475770070","Type":"IssuesEvent","CreatedAt":"2018-04-03T23:08:49","Actor":"zpodlovics","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5648","RelatedDescription":"Opened issue \"F# HelloWorld fails with ILCompiler.CodeGenerationFailedException: Code generation failed ---> ILCompiler.ScannerFailedException: VTable of type 'Microsoft.FSharp.Core.FSharpFunc`2<Microsoft.FSharp.Core.Unit, System.__Canon>' not computed by the IL scanner. You can work around by running the compilation with scanner disabled.\" (#5648) at dotnet/corert","RelatedBody":"I have modified the HelloWorld [1] example to F# and tried to compile it with CoreRT. \r\n[helloworld.zip](https://github.com/dotnet/corert/files/1873738/helloworld.zip)\r\n\r\n\r\nThe ILCompiler fails with the following message:\r\n\r\n```\r\ndotnet publish -c Release -r linux-x64\r\nMicrosoft (R) Build Engine version 15.5.180.51428 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restoring packages for /tmp/helloworld/helloworld.fsproj...\r\n  Generating MSBuild file /tmp/helloworld/obj/helloworld.fsproj.nuget.g.props.\r\n  Restore completed in 1.77 sec for /tmp/helloworld/helloworld.fsproj.\r\n  helloworld -> /tmp/helloworld/bin/Release/netcoreapp2.0/linux-x64/helloworld.dll\r\n  /usr/bin/clang-3.9\r\n  Generating native code\r\nEXEC : error : Code generation failed [/tmp/helloworld/helloworld.fsproj]\r\n  ILCompiler.CodeGenerationFailedException: Code generation failed ---> ILCompiler.ScannerFailedException: VTable of type 'Microsoft.FSharp.Core.FSharpFunc`2<Microsoft.FSharp.Core.Unit, System.__Canon>' not computed by the IL scanner. You can work around by running the compilation with scanner disabled.\r\n     at ILCompiler.ILScanResults.ScannedVTableProvider.GetSlice(TypeDesc type)\r\n     at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n     at ILCompiler.Compilation.HasFixedSlotVTable(TypeDesc type)\r\n     at Internal.JitInterface.CorInfoImpl.getCallInfo(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult)\r\n     at Internal.JitInterface.CorInfoImpl._getCallInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult)\r\n     --- End of inner exception stack trace ---\r\n     at Internal.JitInterface.CorInfoImpl.CompileMethod(IMethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL)\r\n     at ILCompiler.RyuJitCompilation.ComputeDependencyNodeDependencies(List`1 obj)\r\n     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes()\r\n     at ILCompiler.RyuJitCompilation.CompileInternal(String outputFile, ObjectDumper dumper)\r\n     at ILCompiler.Compilation.ILCompiler.ICompilation.Compile(String outputFile, ObjectDumper dumper)\r\n     at ILCompiler.Program.Run(String[] args)\r\n     at ILCompiler.Program.Main(String[] args)\r\n/home/zpodlovics/.nuget/packages/microsoft.dotnet.ilcompiler/1.0.0-alpha-26403-02/build/Microsoft.NETCore.Native.targets(171,5): error MSB3073: The command \"\"/home/zpodlovics/.nuget/packages/runtime.linux-x64.microsoft.dotnet.ilcompiler/1.0.0-alpha-26403-02/tools/ilc\" @\"obj/Release/netcoreapp2.0/linux-x64/native/helloworld.ilc.rsp\"\" exited with code 1. [/tmp/helloworld/helloworld.fsproj]\r\n```\r\n\r\nUsing a more recent version (4.3.*) of F# dependency have the same problem (by modifying the fsproj file):\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <Compile Include=\"Program.fs\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"FSharp.Core\" Version=\"4.3.*\" />\r\n    <PackageReference Include=\"Microsoft.DotNet.ILCompiler\" Version=\"1.0.0-alpha-*\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n\r\n```\r\n\r\nThe exception seems to raised from here:\r\nhttps://github.com/dotnet/corert/blob/master/src/ILCompiler.Compiler/src/Compiler/ILScanner.cs#L155\r\n\r\n[1] https://github.com/dotnet/corert/tree/master/samples/HelloWorld"},{"Id":"7473066773","Type":"IssuesEvent","CreatedAt":"2018-04-03T14:25:14","Actor":"xoofx","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5647","RelatedDescription":"Opened issue \"Assembly.Location returns null\" (#5647) at dotnet/corert","RelatedBody":"From a discussion  #5017:\r\n\r\n> @MichalStrehovsky\r\n>> Update Benchmark.NET to call Assembly.Location instead?\r\n>\r\n> We throw from that too :).\r\n>\r\n>Assembly.Location is really difficult to support in an AOT compiled app because:\r\n>\r\n> The original assembly doesn't exist in the filesystem. There's only a virtualized version of it present somewhere in the native executable that we use in reflection to pretend everything is in it's right place.\r\nEven the mapping from logical assembly to native executable is 1:n (1 managed assembly can be spread into multiple native executables - think a shared library that has some commonly used types from e.g. System.Private.CoreLib in it, and an app EXE that needs a less common type from CoreLib)\r\n> Whatever we pretend is not going to help Benchmark.NET to accomplish what it's trying to do anyway.\r\n\r\nI'm typically using `Assembly.Location` to load resources (e.g native shared lib/dll) that are collocated with the assembly... \r\nI understand that returning a location for an assembly that doesn't exist would be more troublesome, so it seems that using `AppDomain.CurrentDomain.BaseDirectory` would give a rough similar behavior (not strictly equal, but at least to get something working across .NET platforms)... \r\nI'm fine with this workaround, just wanted to make sure that it is the preferred way for doing such things, in case you recommend something more adequate?"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7482538201","Type":"PullRequestEvent","CreatedAt":"2018-04-05T02:02:41","Actor":"tmat","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/2113","RelatedDescription":"Opened pull request \"Update RepoToolset to 1.0.0-beta2-62804-01\" (#2113) at dotnet/sdk","RelatedBody":""},{"Id":"7481879527","Type":"IssuesEvent","CreatedAt":"2018-04-04T22:17:56","Actor":"nguerrera","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/2098","RelatedDescription":"Closed issue \"Do not assume specific location of dotnet CLI\" (#2098) at dotnet/sdk","RelatedBody":"The tests currently assume dotnet CLI is installed in `$(RepoRoot)/.dotnet`:\r\n\r\nhttps://github.com/dotnet/sdk/blob/master/src/Tests/Microsoft.NET.TestFramework/ToolsetInfo.cs#L119\r\n\r\nInstead the tests should use `DOTNET_INSTALL_DIR` environment variable to locate dotnet CLI.\r\n\r\nIn future we might want to change this to `DOTNET_ROOT`, once it's implemented."},{"Id":"7481879456","Type":"PullRequestEvent","CreatedAt":"2018-04-04T22:17:55","Actor":"nguerrera","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/2112","RelatedDescription":"Merged pull request \"Merge release/2.1.3xx to master\" (#2112) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.3xx into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.3xx-to-master\ngit reset --hard upstream/master\ngit merge upstream/release/2.1.3xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.3xx-to-master --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7481222187","Type":"PullRequestEvent","CreatedAt":"2018-04-04T19:56:39","Actor":"nguerrera","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/2109","RelatedDescription":"Merged pull request \" Fix F# typo, add smoke tests, Fix behaviour for implicit defines\" (#2109) at dotnet/sdk","RelatedBody":"This Fixes: \r\n1.  a typo in the FSharp targets files:   https://github.com/dotnet/sdk/compare/master...KevinRansom:addtests?expand=1#diff-28f8d0028b86867ebcdb1cc7ecc55a3cR26\r\n2.  Adds smoke tests for building F# .dll's and .exe's\r\n\r\n3.  Also fixes an issue with implicit #defines\r\n\r\nThanks\r\n\r\nKevin\r\n\r\n/cc @livarcocc @nguerrera \r\n\r\n"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"981533325767606273","CreatedAt":"2018-04-04T14:05:55+00:00","UserScreenname":"dotnet","Text":"Jeff (@csharpfritz) is working with @Azure Q &amp; A Maker today to improve his chat-bot for Twitch and Mixer.  Tune in… https://t.co/MLdDPdKPTL","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":9,"FavoriteCount":0,"RawContent":null}]}},"RunOn":"2018-04-05T05:30:19.7969274Z","RunDurationInMilliseconds":7493}