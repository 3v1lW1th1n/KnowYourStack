{"Data":{"Vue":{"Events":[{"Id":"7126069264","Type":"IssuesEvent","CreatedAt":"2018-01-20T05:10:21","Actor":"realcarbonneau","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue/issues/7485","RelatedDescription":"Opened issue \"Multi-type props defined without value gets empty string, should be true [Boolean, String]\" (#7485) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://jsfiddle.net/realcarbonneau/68w22cbo/](https://jsfiddle.net/realcarbonneau/68w22cbo/)\r\n\r\n### Steps to reproduce\r\nDefine a multi-type Boolean and String Prop, call the component by specfying the prop name (wihout a value).\r\n\r\n### What is expected?\r\nProp contrains true (Boolean type)\r\n\r\n### What is actually happening?\r\nProp contrains an empty string\r\n\r\n---\r\nThe sequence do not change the result, both [Boolean, String] and [String, Boolean] give the same result.  The version does not change the result either (vue version 1.0.12, 2.2.1, edge on jsfiddle)\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"},"Router":{"Events":[{"Id":"7122484905","Type":"IssuesEvent","CreatedAt":"2018-01-19T12:00:21","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/2011","RelatedDescription":"Closed issue \"Add a way to catch a route cancel\" (#2011) at vuejs/vue-router","RelatedBody":"There are occasions where a route should be handled everytime it’s considered. For example, I’ve seen it suggested that VueRouter could be used to show a loading indicator by doing the following:\r\n\r\n```\r\nrouter.beforeEach((to, from, next) => {\r\n    LoadIndicator.show();\r\n    next();\r\n});\r\nrouter.afterEach((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\nA route can be cancelled in a component’s `beforeRouteEnter` method with `next(false)`, but `AfterEach` won’t fire since the route never actually loaded and the loading indicatior is stuck.  \r\n\r\nSomething like that would be great: \r\n\r\n```\r\nrouter.cancel((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\n"},{"Id":"7122260276","Type":"IssuesEvent","CreatedAt":"2018-01-19T11:03:46","Actor":"LinusBorg","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1993","RelatedDescription":"Closed issue \"CSS Modules and `router-link` active classes. Add data-attribute flag\" (#1993) at vuejs/vue-router","RelatedBody":"### Version\r\n3.0.1\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/w024ro0695](https://codesandbox.io/s/w024ro0695)\r\n\r\n### Steps to reproduce\r\nThe following styles won't work as ad-hoc classes won't apply styles when parsed:\r\n```\r\n<template>\r\n  <div>\r\n    <router-link :class=\"$style.myLink\" to=\"/foo\">Hello</router-link>\r\n  </div>\r\n</template>\r\n\r\n<style module>\r\n.myLink {\r\n  color: #f00;\r\n}\r\n\r\n// This won't do anything\r\n.myLink.router-link-exact-active {\r\n  color: #0f0;\r\n}\r\n</style>\r\n```\r\n\r\n### What is expected?\r\nThis is to be expected but an alternative to classes would be great\r\n\r\n### What is actually happening?\r\nAs expected, but an alternative to classes (eg. data attributes) would be great\r\n\r\n---\r\nAFAIK it's not possible to reference the classes from within the context of CSS modules.\r\n\r\nIt would be great if there was instead a flag on the router to use data attributes to flag active links so that you can have conditional CSS module states for links. Eg.\r\n\r\n```\r\n// router.js\r\nexport default new Router({\r\n  linkActiveDataAttributes: true\r\n})\r\n```\r\n\r\nWould add the active attributes as data to the router-link's in the application:\r\n\r\n```\r\n<router-link to=\"/\" :class=\"$style.myLink\">Foo</router-link>\r\n\r\n// would convert to\r\n\r\n<a href=\"/\" data-active=\"true\" data-exact=\"true\" :class=\"$style.myLink\">Foo</a>\r\n\r\n// and i can write css modules as\r\n.myLink[data-exact] {\r\n  color: #f00\r\n}\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7122159473","Type":"IssuesEvent","CreatedAt":"2018-01-19T10:48:50","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/vuejs/vue-router/issues/2011","RelatedDescription":"Reopened issue \"Add a way to catch a route cancel\" (#2011) at vuejs/vue-router","RelatedBody":"There are occasions where a route should be handled everytime it’s considered. For example, I’ve seen it suggested that VueRouter could be used to show a loading indicator by doing the following:\r\n\r\n```\r\nrouter.beforeEach((to, from, next) => {\r\n    LoadIndicator.show();\r\n    next();\r\n});\r\nrouter.afterEach((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\nA route can be cancelled in a component’s `beforeRouteEnter` method with `next(false)`, but `AfterEach` won’t fire since the route never actually loaded and the loading indicatior is stuck.  \r\n\r\nSomething like that would be great: \r\n\r\n```\r\nrouter.cancel((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\n"},{"Id":"7122037886","Type":"IssuesEvent","CreatedAt":"2018-01-19T10:20:36","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/2011","RelatedDescription":"Closed issue \"Add a way to catch a route cancel\" (#2011) at vuejs/vue-router","RelatedBody":"There are occasions where a route should be handled everytime it’s considered. For example, I’ve seen it suggested that VueRouter could be used to show a loading indicator by doing the following:\r\n\r\n```\r\nrouter.beforeEach((to, from, next) => {\r\n    LoadIndicator.show();\r\n    next();\r\n});\r\nrouter.afterEach((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\nA route can be cancelled in a component’s `beforeRouteEnter` method with `next(false)`, but `AfterEach` won’t ever since the route never actually loaded and the loading indicatior is stuck.  \r\n\r\nSomething like that would be great: \r\n\r\n```\r\nrouter.cancel((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\n"},{"Id":"7121908425","Type":"IssuesEvent","CreatedAt":"2018-01-19T09:49:35","Actor":"Manidos","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue-router/issues/2011","RelatedDescription":"Opened issue \"Add a way to catch a route cancel\" (#2011) at vuejs/vue-router","RelatedBody":"There are occasions where a route should be handled everytime it’s considered. For example, I’ve seen it suggested that VueRouter could be used to show a loading indicator by doing the following:\r\n\r\n```\r\nrouter.beforeEach((to, from, next) => {\r\n    LoadIndicator.show();\r\n    next();\r\n});\r\nrouter.afterEach((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\nA route can be cancelled in a component’s `beforeRouteEnter` method with `next(false)`, but `AfterEach` won’t ever since the route never actually loaded and the loading indicatior is stuck.  \r\n\r\nSomething like that would be great: \r\n\r\n```\r\nrouter.cancel((to, from) => {\r\n    LoadIndicator.hide();\r\n});\r\n```\r\n"}],"ResultType":"GitHubEvent"},"Vuex":{"Events":[{"Id":"7123508914","Type":"IssuesEvent","CreatedAt":"2018-01-19T15:38:30","Actor":"posva","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vuex/issues/1138","RelatedDescription":"Closed issue \"$store对象中带下划线的函数为什么不能直接调用\" (#1138) at vuejs/vuex","RelatedBody":" #<!--\r\nIMPORTANT: Please use the following link to create a new issue:\r\n\r\n  https://new-issue.vuejs.org/?repo=vuejs/vuex\r\n\r\nIf your issue was not created using the app above, it will be closed immediately.\r\n-->\r\n\r\nthis.$store._actions.getAllProducts;无效\r\nthis.$store.dispatch('getAllProducts')  有用\r\n"},{"Id":"7122174498","Type":"IssuesEvent","CreatedAt":"2018-01-19T10:51:10","Actor":"charlesfleche","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/1139","RelatedDescription":"Opened issue \"Strict mode especially slow on Firefox / Linux\" (#1139) at vuejs/vuex","RelatedBody":"### Version\r\n3.0.1\r\n\r\n### Reproduction link\r\n[https://app.previz.co](https://app.previz.co)\r\n\r\n### Steps to reproduce\r\nRun Firefox / Linux\r\n\r\n### What is expected?\r\nSame order of magnitude of performance degradation on Firefox / Linux than on other OS combination\r\n\r\n### What is actually happening?\r\nVuex strict on Firefox / Linux is much slower than any other browser / OS combination.\r\n\r\n---\r\nOur Vuex stores objects that are facades that drive a direct acyclic graph that itself drives a WebGL scene (THREE.js). When a property of a Vuex object is modified (a parameter is changed, or input event on the canvas triggers a camera move), our render graph is set dirty and we schedule a refresh with requestAnimationFrame. Usually refreshing our DAG takes just a few milliseconds.\r\nWith Vuex in strict mode, performances (3D framerate) is not affected too much most of the time in any OS / browser combination, apart for Firefox (57.0.4 64-bit) on Linux (Ubuntu 17.10). I don't get those kind of performance degradation on Firefox / macOS or Firefox / Windows.\r\nWhy would Vuex strict would have such a performance impact on Firefox / Linux ?\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"}},"RunOn":"2018-01-20T05:30:34.2712176Z","RunDurationInMilliseconds":2195}