{"Data":{"GitHub":{"Issues":[{"Id":"368957195","IsPullRequest":false,"CreatedAt":"2018-10-11T05:22:18","Actor":"mjannet","Number":"1223","RawContent":null,"Title":"Error MSB4019 when adding package Microsoft.ML","State":"open","Body":"### System information\r\n\r\n- **Windows 10**:\r\n- **MS Visual Studio Community 2017 Preview**: \r\n\r\n### error MSB4019: The imported project \"C:\\Users\\Owner\\source\\repos\\machinelearning\\tools\\clean.target\" was not found.\r\n\r\n- **Clone package from github: https://github.com/dotnet/machinelearning.git using Visual Studio Preview\r\n- **From CLI executed: dotnet add package Microsoft.ML**\r\n- **Got the error message referenced above**\r\n- **This is one of my first projects I am trying to download from github, and I am not sure where to find information to be able to download this project correctly.  I appreciate any assistance I could get.  Thank you**\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1223","RelatedDescription":"Open issue \"Error MSB4019 when adding package Microsoft.ML\" (#1223)"},{"Id":"368777115","IsPullRequest":false,"CreatedAt":"2018-10-11T04:05:10","Actor":"wschin","Number":"1211","RawContent":null,"Title":"Export Kmeans to ONNX","State":"closed","Body":"Kmeans is a series of matrix operations in prediction phase, so it's onnxable. Due to Kmeans' popularity, ONNX exporter might want to cover it.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1211","RelatedDescription":"Closed issue \"Export Kmeans to ONNX\" (#1211)"},{"Id":"368779593","IsPullRequest":true,"CreatedAt":"2018-10-11T04:04:58","Actor":"wschin","Number":"1212","RawContent":null,"Title":"Save Kmeans in ONNX ","State":"closed","Body":"Address #1211 .  This PR implements a converter for ML.NET Kmeans predictor. Detailed explanation and a visualization of the conversion code is inlined in the source file.\r\n\r\nHere is a Kmeans in ONNX example (ArgMax should be ArgMin though):\r\n![image](https://user-images.githubusercontent.com/3524474/46757244-74a95480-cc7e-11e8-968a-e0fffa4f93b9.png)","Url":"https://github.com/dotnet/machinelearning/pull/1212","RelatedDescription":"Closed or merged PR \"Save Kmeans in ONNX \" (#1212)"},{"Id":"368772398","IsPullRequest":true,"CreatedAt":"2018-10-10T23:36:04","Actor":"elbruno","Number":"1210","RawContent":null,"Title":"Adding missing parenthesis, line 91","State":"closed","Body":"Adding missing parenthesis in sample code, line 91\r\n\r\nWe are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [ ] There's a descriptive title that will make sense to other developers some time from now. \r\n- [ ] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1210","RelatedDescription":"Closed or merged PR \"Adding missing parenthesis, line 91\" (#1210)"},{"Id":"368894895","IsPullRequest":false,"CreatedAt":"2018-10-10T23:32:58","Actor":"Zruty0","Number":"1222","RawContent":null,"Title":"Debugger views of estimators","State":"open","Body":"We are already committed to improving how our data looks like in the debugger.\r\n\r\nFor instance, #1167 will turn the schema into an 'eagerly computed' object, so you can look at it in the debugger:\r\n![schema](https://user-images.githubusercontent.com/41337831/46771152-2c525c80-cca7-11e8-949e-b728eda5b5b3.PNG)\r\n\r\nNow a different question is: how do we make `Estimators` somehow 'debugger-inspectable'?\r\n\r\nWe cannot really inspect 'the algorithm'. But we can inspect 'how the algorithm will transform data'. In the world of `LearningPipeline`, every pipeline was 'duct-taped' to a specific data file. That was a mistake, of course, but it did allow for nice debugger views of pipeline steps.\r\n\r\nWith the new API, the pipeline is no longer bound to any data. It can be 'fitted' on any data of 'reasonable' shape. But now the debugger view is useless.\r\n\r\nOne possible suggestion is to add an extension method to our estimators, called something along the lines of `Preview`. It would have a signature `IDataView Preview(IDataView data)` in case of a transformer or an estimator, or `IDataView Preview(T source)` in case of an `IDataReader<T>`.\r\n\r\nThis method would return some form 'lazy approximation of `Fit`':\r\n```csharp\r\nIDataView Preview(IDataView data) => Fit(data.Take(100)).Transform(data.Take(100))\r\n```\r\n\r\nThen, at least, we can have the watch window experience more or less palatable: you just add `pipeline.Preview(trainData)` and you can see an approximation of how the pipeline would transform `trainData`.\r\n\r\ncc: @GalOshri @CESARDELATORRE @TomFinley @eerhardt ","Url":"https://github.com/dotnet/machinelearning/issues/1222","RelatedDescription":"Open issue \"Debugger views of estimators\" (#1222)"},{"Id":"368892947","IsPullRequest":false,"CreatedAt":"2018-10-10T23:22:58","Actor":"tannergooding","Number":"1221","RawContent":null,"Title":"Update CI to support building and testing x86","State":"open","Body":"The support for building against x86 was added on https://github.com/dotnet/machinelearning/pull/1008.\r\n\r\nWe still need to update CI to ensure that it is tested on a regular basis and update the `-RunTests` command to pull down the appropriate test host.","Url":"https://github.com/dotnet/machinelearning/issues/1221","RelatedDescription":"Open issue \"Update CI to support building and testing x86\" (#1221)"},{"Id":"368892543","IsPullRequest":false,"CreatedAt":"2018-10-10T23:20:58","Actor":"tannergooding","Number":"1220","RawContent":null,"Title":"Investigate cleaning up `[ConditionalFact(typeof(Environment), nameof(Environment.Is64BitProcess))]`","State":"open","Body":"It was suggested that creating explicit attributes for the various cases (Such as Onnx, TensorFlow, LightGBM, etc) may be a better long term solution to manage these tests across the various platforms.\r\n\r\nSee https://github.com/dotnet/machinelearning/pull/1008#discussion_r221985876 for more details.","Url":"https://github.com/dotnet/machinelearning/issues/1220","RelatedDescription":"Open issue \"Investigate cleaning up `[ConditionalFact(typeof(Environment), nameof(Environment.Is64BitProcess))]`\" (#1220)"},{"Id":"368890071","IsPullRequest":false,"CreatedAt":"2018-10-10T23:08:50","Actor":"codemzs","Number":"1219","RawContent":null,"Title":"Time Series predictors need to be stateful","State":"open","Body":"We need to make components such as SSA spike and changepoint detector stateful so that when we do predictions using them the state is updated with the new observations that are seen at prediction phase.\r\n\r\nMore details on the design to come here.","Url":"https://github.com/dotnet/machinelearning/issues/1219","RelatedDescription":"Open issue \"Time Series predictors need to be stateful\" (#1219)"},{"Id":"368873170","IsPullRequest":true,"CreatedAt":"2018-10-10T22:01:07","Actor":"Anipik","Number":"1218","RawContent":null,"Title":"Common Implemenatation for MatMul and MatMulTran for both aligned and unaligned arrays","State":"open","Body":"For inputs that are not naturally aligned (the alignment is not a multiple of 4), it does exclusively unaligned loads\r\nFor all other inputs, it will do at most two unaligned loads (one each for any leading/trailing unaligned elements) and all other loads will be aligned.\r\n\r\ncc @tannergooding @eerhardt @danmosemsft @TomFinley ","Url":"https://github.com/dotnet/machinelearning/pull/1218","RelatedDescription":"Open PR \"Common Implemenatation for MatMul and MatMulTran for both aligned and unaligned arrays\" (#1218)"},{"Id":"368869162","IsPullRequest":true,"CreatedAt":"2018-10-10T21:48:03","Actor":"artidoro","Number":"1217","RawContent":null,"Title":"Conversion of NAIndicatorTransform to estimator with related pigstensions","State":"open","Body":"Ongoing work on converting the transformers to estimators (#754). This PR converts the NA Indicator transform to estimator and adds the relative pigsty extensions. \r\n","Url":"https://github.com/dotnet/machinelearning/pull/1217","RelatedDescription":"Open PR \"Conversion of NAIndicatorTransform to estimator with related pigstensions\" (#1217)"},{"Id":"368868254","IsPullRequest":false,"CreatedAt":"2018-10-10T21:45:13","Actor":"tannergooding","Number":"1216","RawContent":null,"Title":"Investigate why two predictor tests fail with \"Unknown command: 'train'\" on x86","State":"open","Body":"There are currently two `TestPredictors` tests disabled on x86 due to: `[ConditionalFact(typeof(Environment), nameof(Environment.Is64BitProcess))] // x86 fails with \"Unknown command: 'train'; Format error at (83,3)-(83,4011): Illegal quoting\"`.\r\n\r\nThis issue needs further investigation.","Url":"https://github.com/dotnet/machinelearning/issues/1216","RelatedDescription":"Open issue \"Investigate why two predictor tests fail with \"Unknown command: 'train'\" on x86\" (#1216)"},{"Id":"368867582","IsPullRequest":false,"CreatedAt":"2018-10-10T21:43:04","Actor":"tannergooding","Number":"1215","RawContent":null,"Title":"Investigate and deal with the remaining x86 baseline differences","State":"open","Body":"The x86 build of ML.NET has some remaining baseline differences that need investigation and fixing.\r\n\r\nFrom initial investigation, the remaining differences have fewer than 4 matching significant digits and this may be caused by known bugs in the double parsing code (which have already been fixed or are actively being fixed in .NET Core). Other differences are due to the implementation (between x86 and x64) of some floating-point Math functions that the tests depend on.","Url":"https://github.com/dotnet/machinelearning/issues/1215","RelatedDescription":"Open issue \"Investigate and deal with the remaining x86 baseline differences\" (#1215)"},{"Id":"368855979","IsPullRequest":false,"CreatedAt":"2018-10-10T21:09:25","Actor":"pictos","Number":"1214","RawContent":null,"Title":"Is there a way to train my model with multiple coaches?","State":"open","Body":"### System information\r\nIs there a way to train my model with multiple coaches?\r\n\r\nSo, for example, i want to create a model to calculate a salary based in years of experience. To do this i used Regression, but has more than one trainers. I want to test all of this trainers and compare the results. \r\nI researched a lot, but i don't finded one way to do this with the ML.NET.\r\n\r\n- **What did you do?**\r\nFor did that  I execute one time, change the trainers and execute again... It's not very good.\r\n\r\n- **What did you expect?**\r\n\r\nCreate a way to initialize a array of ILearningPipelineItem and train my model with each one and show the results\r\n\r\n### Source code / logs\r\nI do some experiments using the version 0.3, and I think this could be something native to this api, if it does not already exist.\r\nhttps://github.com/pictos/MLParalel\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1214","RelatedDescription":"Open issue \"Is there a way to train my model with multiple coaches?\" (#1214)"},{"Id":"368803504","IsPullRequest":true,"CreatedAt":"2018-10-10T18:52:16","Actor":"utkarsh-42","Number":"1213","RawContent":null,"Title":"updating_files_with_LinearClassificationTrainer","State":"open","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [ ] There's a descriptive title that will make sense to other developers some time from now. \r\n- [ ] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1213","RelatedDescription":"Open PR \"updating_files_with_LinearClassificationTrainer\" (#1213)"},{"Id":"368762937","IsPullRequest":false,"CreatedAt":"2018-10-10T17:04:18","Actor":"sfilipi","Number":"1209","RawContent":null,"Title":"Documentation samples for the transforms of the new API","State":"open","Body":"We need to add samples on how to use the new transforms, than reference those samples from the XML documentation so that in docs.microsoft.com users can copy/paste the sample and have a head-starts. \r\n\r\nMot of the tests that got added as part of the transformer work are a good start for creating a sample.  \r\n\r\nList of transformers:\r\n\r\n| Transform | Category | Priority | Has entry point | Transformer PR| Sample PR|\r\n| --------- | -------- | -------- | --------------- | ----- | -----|\r\n| Key To Value Transform | Categorical | 0 | 1 | #856 | |\r\n| Concat Transform | Schema manipulation | 0 | 1 | #896 | |\r\n| Term Transform | Categorical | 0 | 1 | #759 | |\r\n| Text Transform | Text processing | 0 | 1 | #801 | |\r\n| Image Greyscale Transform | Image | 0 | 0 | #753 | |\r\n| Image Loader Transform | Image | 0 | 0 | #753 | |\r\n| Image Pixel Extractor Transform | Image | 0 | 0 | #753 | |\r\n| Image Resizer Transform | Image | 0 | 0 | #753 | |\r\n| Tensorflow Scoring Transform | Image | 0 | 1 |#840 #877 | |\r\n| Min-Max Normalizer | Normalizer | 0 | 1 | #797 | |\r\n| NA Handle Transform | Missing values | 1 | 1 | no need | |\r\n| NA Indicator Transform | Missing values | 1 | 1 | | |\r\n| NA Replace Transform | Missing values | 1 | 1 |#917 | |\r\n| Categorical Transform | Categorical | 1 | 1 | #899 | |\r\n| Categorical Hash Transform | Categorical | 1 | 1 | #1033 | |\r\n| Hash Transform | Categorical | 1 | 0 | #944 | |\r\n| Copy Columns Transform | Schema manipulation | 1 | 1 | #706 | |\r\n| Word Embeddings Transform | Text processing | 1 | 1 | #928 | |\r\n| Key To Vector Transform | Categorical | 1 | 0 | #858 | |\r\n| Character Tokenizer Transform | Text processing | 2 | 1 | #931 | |\r\n| Ngram Hash Transform | Text processing | 2 | 0 |#953| |\r\n| Ngram Transform | Text processing | 2 | 1 | #953| |\r\n| Stopwords Remover Transform | Text processing | 2 | 0 | #953| |\r\n| Text Normalizer Transform | Text processing | 2 | 0 |#953| |\r\n| Word Bag Transform | Text processing | 2 | 0 |#953| |\r\n| Word Hash Bag Transform | Text processing | 2 | 0 |#953| |\r\n| Word Tokenizer Transform | Text processing | 2 | 1 | #931 | |\r\n| Convert Transform | Column mapper | 2 | 1 | | |\r\n| Drop Slots Transform | Feature selection | 2 | 0 | no need | |\r\n| LogMeanVar Normalizer | Normalizer | 2 | 1 | #797 | |\r\n| MeanVar Normalizer | Normalizer | 2 | 1 | #797 | |\r\n| Latent Dirichlet Allocation Transform | Projection | 2 | 1 |#972| |\r\n| Tree Ensemble Featurization Transform | Projection | 2 | 1 | | |\r\n| NA Filter | Row manipulation | 2 | 1 | | |\r\n| Count Feature Selection Transform | Feature selection | 2 | 1 |#991 | |\r\n| Mutual Information Feature Selection Transform | Feature selection | 2 | 1 |#991| |\r\n| NA Drop Transform | Missing values | 2 | 1 | | |\r\n| Binning Normalizer | Normalizer | 2 | 1 | #797 | |\r\n| Global Contrast Normalization Transform | Normalizer | 2 | 1 |#961| |\r\n| Principal Component Analysis Transform | Projection | 2 | 1 | | |\r\n| Random Fourier Features Transform | Projection | 2 | 0 |#1122 | |\r\n| Bootstrap Sample Transform | Row manipulation | 2 | 1 | | |\r\n| Shuffle Transform | Row manipulation | 2 | 0 | | |\r\n| Custom Stopwords Remover Transform | Text processing | 2 | 0 | | |\r\n| Learner Feature Selection Transform | Feature selection | 3 | 0 | | |\r\n| Lp-Norm Normalizer | Normalizer | 3 | 1 |#961| |\r\n| Supervised Binning Normalizer | Normalizer | 3 | 1 | | |\r\n| Whitening Transform | Normalizer | 3 | 0 |#961| |\r\n| Choose Columns Transform | Schema manipulation | 3 | 0 | | |\r\n| Drop Columns Transform | Schema manipulation | 3 | 1 | | |\r\n| Generate Number Transform | Schema manipulation | 3 | 1 | | |\r\n| Keep Columns Transform | Schema manipulation | 3 | 0 | | |\r\n| Key To Binary Vector Transform | Categorical | 3 | 0 | #858| |\r\n| Term Lookup Transform | Categorical | 3 | 0 || |\r\n| Label Indicator Transform | Column mapper | 3 | 1 | | |\r\n| Group Transform | Relational operation | 3 | 1 | | |\r\n| Un-group Transform | Relational operation | 3 | 1 | | |\r\n| Range Filter | Row manipulation | 3 | 1 | | |\r\n| Skip Filter | Row manipulation | 3 | 1 | | |\r\n| Skip and Take Filter | Row manipulation | 3 | 1 | | |\r\n| Take Filter | Row manipulation | 3 | 1 | | |\r\n| Evaluate Predictor | Re-evaluate | 4 | 0 | | |\r\n| Hash Join Transform | Re-evaluate | 4 | 1 | | |\r\n| Load Transform | Re-evaluate | 4 | 0 | | |\r\n| Optional Column Transform | Re-evaluate | 4 | 1 | | |\r\n| Score Predictor | Re-evaluate | 4 | 0 | | |\r\n| Sentiment Analyzing Transform | Re-evaluate | 4 | 1 | | |\r\n| Train and Score Predictor | Re-evaluate | 4 | 0 | | |\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1209","RelatedDescription":"Open issue \"Documentation samples for the transforms of the new API\" (#1209)"},{"Id":"368445821","IsPullRequest":false,"CreatedAt":"2018-10-10T13:26:42","Actor":"zeahmed","Number":"1207","RawContent":null,"Title":"FastTreeBinaryClassificationCategoricalSplitTest taking very long to execute...","State":"closed","Body":"The following test is taking 15-25mins (depending on system) alone to execute.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/8ca1c9386587aa4ef77c56f605f8244debefce93/test/Microsoft.ML.Predictor.Tests/TestPredictors.cs#L711\r\n\r\nIs there any policy for test execution time in ML.Net build system?","Url":"https://github.com/dotnet/machinelearning/issues/1207","RelatedDescription":"Closed issue \"FastTreeBinaryClassificationCategoricalSplitTest taking very long to execute...\" (#1207)"},{"Id":"368266865","IsPullRequest":false,"CreatedAt":"2018-10-10T12:58:34","Actor":"adamsitnik","Number":"1196","RawContent":null,"Title":"Improve `AvxIntrinsics.DotSU` performance","State":"closed","Body":"Our profiles show that DotSU which should be faster with AVX is actually slower and takes more time. This can be confirmed running our CpuMathBenchmarks:\r\n\r\n`..\\..\\Tools\\dotnetcli\\dotnet.exe run -c Release-Intrinsics -f netcoreapp3.0 -- -f *.DotSU --join`\r\n\r\n|                   Type | Method |     Mean |     Error |    StdDev | Extra Metric |\r\n|----------------------- |------- |---------:|----------:|----------:|-------------:|\r\n|    AvxPerformanceTests |  DotSU | 2.545 ms | 0.0590 ms | 0.0580 ms |            - |\r\n| NativePerformanceTests |  DotSU | 2.463 ms | 0.0612 ms | 0.0704 ms |            - |\r\n|    SsePerformanceTests |  DotSU | 2.494 ms | 0.0480 ms | 0.0449 ms |            - |\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1196","RelatedDescription":"Closed issue \"Improve `AvxIntrinsics.DotSU` performance\" (#1196)"},{"Id":"368357896","IsPullRequest":true,"CreatedAt":"2018-10-10T11:41:29","Actor":"helloguo","Number":"1200","RawContent":null,"Title":"Update Load8 with GatherVector256 instruction for .NET Core 3","State":"closed","Body":"Update Load8 with GatherVector256 instruction for .NET Core 3. Fix https://github.com/dotnet/machinelearning/issues/1195\r\n\r\nBefore the change:\r\n![before](https://user-images.githubusercontent.com/18431130/46692878-3435d200-cbbd-11e8-9123-86fa62cfc6ab.PNG)\r\n\r\nAfter the change:\r\n![after](https://user-images.githubusercontent.com/18431130/46692901-40ba2a80-cbbd-11e8-9037-c561745bdb3e.PNG)\r\n\r\ncc\\ @adamsitnik @eerhardt\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1200","RelatedDescription":"Closed or merged PR \"Update Load8 with GatherVector256 instruction for .NET Core 3\" (#1200)"},{"Id":"368446866","IsPullRequest":true,"CreatedAt":"2018-10-10T00:18:06","Actor":"zeahmed","Number":"1208","RawContent":null,"Title":"Removed shuffling from TensorFlowTransform.","State":"open","Body":"Removed the shuffling of data that was being done internally in TensorFlowTransform (was commented out due to #1106). The idea is to give user more control over the shuffling by allowing them to use the ShuffleTransform in their pipeline explicit.\r\n\r\nThis also reduces the number of parameters in TensorFlowTransform.Argument class. Please see the modified tests for use-cases. Tests with shuffling are currently disabled due to #1106.","Url":"https://github.com/dotnet/machinelearning/pull/1208","RelatedDescription":"Open PR \"Removed shuffling from TensorFlowTransform.\" (#1208)"},{"Id":"368420526","IsPullRequest":true,"CreatedAt":"2018-10-09T22:17:31","Actor":"sfilipi","Number":"1206","RawContent":null,"Title":"Enabling FFM tests","State":"open","Body":"Addresses part of #404 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/1206","RelatedDescription":"Open PR \"Enabling FFM tests\" (#1206)"},{"Id":"368403656","IsPullRequest":false,"CreatedAt":"2018-10-09T21:22:25","Actor":"yaeldekel","Number":"1205","RawContent":null,"Title":"Logistic Regression doesn't work with training stats","State":"open","Body":"Stats that are being computed at training time aren't passed to the predictor.","Url":"https://github.com/dotnet/machinelearning/issues/1205","RelatedDescription":"Open issue \"Logistic Regression doesn't work with training stats\" (#1205)"},{"Id":"368390657","IsPullRequest":false,"CreatedAt":"2018-10-09T20:47:42","Actor":"CESARDELATORRE","Number":"1204","RawContent":null,"Title":"Classification stratificationColumn not supported for boolean column","State":"open","Body":"For not balanced datasets, with stratified splitting, the data is divided in such a way that a percentage of each target column value is put in both training and test dataset.\r\n\r\nHowever, the following line of code throws an error if the column 'Label' is Boolean, which is very common for binary classification.\r\n\r\n`(trainData, testData) = classification.TrainTestSplit(data, testFraction: 0.2, stratificationColumn: \"Label\");`\r\n\r\nIt would work if the Label column would be float or other types.\r\n\r\nI might be missing something, but why is Boolean not supported for the `stratificationColumn`?\r\nCan we support it since it can be a common scenario for binary classifications?","Url":"https://github.com/dotnet/machinelearning/issues/1204","RelatedDescription":"Open issue \"Classification stratificationColumn not supported for boolean column\" (#1204)"},{"Id":"368367808","IsPullRequest":false,"CreatedAt":"2018-10-09T19:46:38","Actor":"Zruty0","Number":"1203","RawContent":null,"Title":"ML.NET command line tool","State":"open","Body":"I think we should consider making ML.NET command-line tool an actual first-class citizen.\r\n\r\nA bit of insider knowledge: we currently already have a commandline tool, that is a port of `maml.exe`. You can launch it as follows (this shows the 'help' command, or the `?` command).\r\n```\r\ndotnet .\\bin\\AnyCPU.Debug\\Microsoft.ML.Console\\netcoreapp2.1\\MML.dll ?\r\n```\r\n\r\nGenerally, the syntax is `dotnet MML.dll <command> <arguments>`, and the current list of commands include things like `train`, `CV`, `showdata` etc. (full list is available via `dotnet MML.dll ? kind=command`).\r\n\r\nThis command-line tool is actually very powerful (although the language is clunky). \r\n\r\nWe could easily expand the command-line tool to handle common programming sub-tasks, like:\r\n- Generate prediction code from model (actually, we already have `codegen`, but it needs some retouch to work with the new API);\r\n- Inspect the contents of the model (which transformers are there and how they are set up);\r\n- Introspect into the TensorFlow or other external model format (`Microsoft.ML.Tensorflow` could have a commandline interface to list the nodes of the graph;\r\n- etc.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1203","RelatedDescription":"Open issue \"ML.NET command line tool\" (#1203)"},{"Id":"368363826","IsPullRequest":false,"CreatedAt":"2018-10-09T19:35:30","Actor":"Zruty0","Number":"1202","RawContent":null,"Title":"ML.NET to use appsettings.json for seed and concurrency level","State":"open","Body":"When `LocalEnvironment` is created using default constructor, it should look into `appsettings.json` for random seed and concurrency level.\r\n\r\n(Original issue description below)\r\n\r\nIn case an ML.NET model is already trained and persisted, we can still control to some degree the behavior of the model at prediction time. For example, we could:\r\n- limit the model to only one thread or let it run multi-threaded\r\n- use GPU or CPU for math\r\n- specify a location for temporary / transient resources.\r\n\r\netc. \r\nWe could consider having a ML.NET dedicated session in `app.config` for the application to control these, or we could use system environment variables, or we could have a 'ML.NET config' text file that the `MLContext` will initialize with.\r\n\r\nThis came up in the process of the API discussion, so creating the issue for future consideration.","Url":"https://github.com/dotnet/machinelearning/issues/1202","RelatedDescription":"Open issue \"ML.NET to use appsettings.json for seed and concurrency level\" (#1202)"},{"Id":"368362325","IsPullRequest":false,"CreatedAt":"2018-10-09T19:31:14","Actor":"Zruty0","Number":"1201","RawContent":null,"Title":"Is Estimator a good enough name?","State":"open","Body":"As @CESARDELATORRE pointed out, the term `Estimator` means two different things in Spark and in sklearn. \r\n\r\nOur terminology is in line with Spark one: the `Estimator` is a 'factory for a `Transformer`', or 'a components that trains a `Transformer` based on the data.\r\n\r\nHowever, it would be even better if we avoided the naming clash with sklearn. So far, the other alternative names for `Estimator` have been taken from generic .NET architecture: `TransformerBuilder`, `TransformerFactory` etc.\r\n\r\nI am personally not a big fan of either of the above, but they do have the benefit of mapping the behavior to other known .NET concepts. \r\n\r\nIn any case, let's see if there are better suggestions, or if there is strong preference to the existing names.","Url":"https://github.com/dotnet/machinelearning/issues/1201","RelatedDescription":"Open issue \"Is Estimator a good enough name?\" (#1201)"},{"Id":"368345583","IsPullRequest":false,"CreatedAt":"2018-10-09T18:46:11","Actor":"Anipik","Number":"1199","RawContent":null,"Title":"Regex Number Parsing Errors for netcoreapp 3.0","State":"open","Body":"There are two issue that we face while matching the baseline files while running tests for netcoreapp3.0\r\n\r\n- The regex treats -0 and 0 differently. We may need to modify the regex for filtering the numbers to treat -0 and 0 same.\r\n- Some numbers are in written in the baseline file in the form of exponentials eg ```5.011722E-35``` They are not  picked up by the regex. so while matching these numbers we do an exact match rather than a floating number comparison with some buffer which fails for netcoreapp3.0\r\n\r\n\r\ncc @danmosemsft @tannergooding @eerhardt @shauheen @codemzs \r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1199","RelatedDescription":"Open issue \"Regex Number Parsing Errors for netcoreapp 3.0\" (#1199)"},{"Id":"368313620","IsPullRequest":false,"CreatedAt":"2018-10-09T17:18:54","Actor":"justinormont","Number":"1198","RawContent":null,"Title":"Mapping U4 datatype to Int64 in ONNX","State":"open","Body":"Currently, for ONNX, we are mapping a `U4` datatype (an unsigned 32-bit integer) to an `Int64`.\r\n\r\nShould we be instead mapping the `U4` datatype to `Uint32` in ONNX? Or is there no support for a `Uint32`, and we're storing in an `Int64`?\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/96439752cbaad099093ca0e8c770576bf3a53ad4/src/Microsoft.ML.Onnx/OnnxUtils.cs#L329-L331\r\n\r\nIn the [above code](https://github.com/dotnet/machinelearning/blob/96439752cbaad099093ca0e8c770576bf3a53ad4/src/Microsoft.ML.Onnx/OnnxUtils.cs#L329-L331), you'll notice the mapping is currently:\r\n* `BL` to `Float` \r\n* `TX` to `String`\r\n* `I1` to `Int8`\r\n* `U1` to `Uint8`\r\n* `I2` to `Int16`\r\n* `U2` to `Uint16`\r\n* `I4` to `Int32`\r\n* `U4` to `Int64`   <- **This one is odd**\r\n* `I8` to `Int64`\r\n* `U8` to `Uint64`\r\n* `R4` to `Float`\r\n* `R8` to `Double`\r\n\r\nThe `BL` to `Float` & `U4` to `Int64` seem odd.\r\n\r\n@wschin noted we have been mapping `U4` to `Int64` for the last two releases of WinML: https://github.com/dotnet/machinelearning/pull/947#discussion_r223443413 ","Url":"https://github.com/dotnet/machinelearning/issues/1198","RelatedDescription":"Open issue \"Mapping U4 datatype to Int64 in ONNX\" (#1198)"},{"Id":"368311945","IsPullRequest":false,"CreatedAt":"2018-10-09T17:14:02","Actor":"ganik","Number":"1197","RawContent":null,"Title":"Fix duplicate params in entrypoints","State":"open","Body":"Following entrypoints have duplicate param names:\r\nData.DataViewReference \r\nModels.CrossValidator\r\nModels.CrossValidationResultsCombiner\r\nModels.PipelineSweeper\r\nModels.PipelineSweeper\r\nModels.SweepResultExtractor\r\nModels.TrainTestEvaluator\r\nTransforms.TwoHeterogeneousModelCombiner\r\nTransforms.ManyHeterogeneousModelCombiner\r\n\r\nThis is not a bug per se. This is about how to make entrypoint API easy to use by 3rd parties/clients. Since I have been implementing such a client, I can share my experience. We have viewed \"entrypoint\" as a function, sort of RPC that you can call. All the parameters for \"entrypoint\" are parameters of such a function. \r\nOn example of TensorFlowScorer (fixed by #1169 ) : even though Model is set as \"Output\" param, its actually required to set this param to a filepath so ML.NET can output zipped model there. Therefore entrypoint needs 2 model params: one to specify filepath for input model, another one to specify path for output model. I am not sure if I know any programming language where function can accept parameters with the same name.\r\nOf course its possible to view \"entrypoint\" not as a method but some sort of class, or break up params into separate Input and Output structs and populate separately, but in the end, on a highest level, what is going to surface to user is a function with params to specify input and output model paths. It would be easier to avoid intermediates and being able to have that high level function built right on top of manifest.json specs.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1197","RelatedDescription":"Open issue \"Fix duplicate params in entrypoints\" (#1197)"},{"Id":"368263066","IsPullRequest":false,"CreatedAt":"2018-10-09T15:15:31","Actor":"adamsitnik","Number":"1195","RawContent":null,"Title":"Remove the `AddScaleSU` performance regression for AVX","State":"open","Body":"Our profiles show that `AddScaleSU` which should be faster with AVX is actually slower and takes more time. This can be confirmed running our CpuMathBenchmarks:\r\n\r\n`..\\..\\Tools\\dotnetcli\\dotnet.exe run -c Release-Intrinsics -- -f *.AddScaleSU --join`\r\n\r\n|                   Type |     Method |     Mean |\r\n|----------------------- |----------- |---------:|\r\n|    AvxPerformanceTests | AddScaleSU | 4.012 ms |\r\n| NativePerformanceTests | AddScaleSU | 2.966 ms |\r\n|    SsePerformanceTests | AddScaleSU | 2.916 ms |\r\n\r\nThis issue has been spotted by @eerhardt in August https://github.com/dotnet/machinelearning/pull/691#issuecomment-414364378\r\n\r\n@helloguo suggested https://github.com/dotnet/machinelearning/pull/691#issuecomment-414375034 that `GatherVector256` intrinsic should be used","Url":"https://github.com/dotnet/machinelearning/issues/1195","RelatedDescription":"Open issue \"Remove the `AddScaleSU` performance regression for AVX\" (#1195)"},{"Id":"368255541","IsPullRequest":false,"CreatedAt":"2018-10-09T14:59:46","Actor":"adamsitnik","Number":"1194","RawContent":null,"Title":"Benchmark results analysis for .NET Core 2.1 vs 3.0","State":"open","Body":"I took all of our benchmarks and run them for:\r\n\r\n1.  .NET Core 2.1 using **native** `CpuMathNative` which uses **SSE**\r\n2. .NET Core 3.0 using new **managed** Hardware Intrinsics API which uses **AVX** with Tiered compilation **enabled**\r\n3. .NET Core 3.0 using new **managed** Hardware Intrinsics API which uses **AVX** with Tiered compilation **disabled**\r\n\r\nI will add a separate comment for every benchmark in this issue with some analysis.\r\n\r\nEnvironment info (updated):\r\n\r\n```\r\nBenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4)\r\nIntel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores\r\nFrequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC\r\n.NET Core SDK=2.2.100-preview2-009404\r\n  [Host]             : .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT\r\n  Core 2.1           : .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT\r\n  Core 3.0 NonTiered : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT\r\n```","Url":"https://github.com/dotnet/machinelearning/issues/1194","RelatedDescription":"Open issue \"Benchmark results analysis for .NET Core 2.1 vs 3.0\" (#1194)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-10-11T05:30:33.3735875Z","RunDurationInMilliseconds":1092}