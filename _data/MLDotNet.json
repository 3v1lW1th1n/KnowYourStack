{"Data":{"GitHub":{"Issues":[{"Id":"377689131","IsPullRequest":false,"CreatedAt":"2018-11-06T04:33:22","Actor":"TomFinley","Number":"1542","RawContent":null,"Title":"TensorFlow transform would throw on non-vector input","State":"open","Body":"In the process of working on #1533, I found the following code in the tensorflow transform.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/73762a8d8f23d27f3c15b4382c0bc374934ccad5/src/Microsoft.ML.TensorFlow/TensorflowTransform.cs#L834-L844\r\n\r\nConsider the above code. We have at line 834 this assignment to a boolean value depending on whether the input is of type vector, or not. This strongly suggests that the transform can accomodate non-vector types. However at lines 841 and 844, we have this `type.AsVector.DimCount`. Now, `AsVector` will be `null` in the case where the type is not a vector of course, so this would throw a null reference exception if we were to ever feed this transform a non-vector value.\r\n\r\nSo, there's something wrong here. Unfortunately the intent of what the author *meant* to write is somewhat hidden from me, so perhaps whoever wrote this code could check this out. Maybe even write a test to test this condition.","Url":"https://github.com/dotnet/machinelearning/issues/1542","RelatedDescription":"Open issue \"TensorFlow transform would throw on non-vector input\" (#1542)"},{"Id":"377674673","IsPullRequest":false,"CreatedAt":"2018-11-06T03:11:08","Actor":"AceHack","Number":"1541","RawContent":null,"Title":"Please support autodifferentiation","State":"open","Body":"This would be a great feature to have.","Url":"https://github.com/dotnet/machinelearning/issues/1541","RelatedDescription":"Open issue \"Please support autodifferentiation\" (#1541)"},{"Id":"377674070","IsPullRequest":false,"CreatedAt":"2018-11-06T03:07:51","Actor":"TomFinley","Number":"1540","RawContent":null,"Title":"IDataView Cleanup: KeyType Simplification","State":"open","Body":"We have by now multiple years of experience with `KeyType`. In the documentation of the `IDatView` type system, [key types](https://github.com/dotnet/machinelearning/blob/master/docs/code/IDataViewTypeSystem.md#key-types) are described as having the following properties:\r\n\r\nAll of our current transformers produce key-types that are (1) known size and (2) have a minimum value of `0`, and are (3) contiguous, with absolutely no exceptions. Also if we consider how key-types are actually used (always, even in the hash transformer, considered enumerations into a set), then there is no particular rason for this. I therefore suggest that we simplify the key types by removing the properties describing this, and just make it a rule.\r\n\r\nThis does represent a loss of capability, but it is a capability that AFAIK has never been exercised beyond unit tests and small toy demonstrations to clarify to new developers, \"by the way, our key-types have this really, really weird capability...\"\r\n\r\nOn the flip side, I feel like having a *count* have the maximum of `int.MaxValue` is arguably too limiting. The reason for this is that it was anticipated that the only real usage of key values would be to project into a vector, but this is not true. I would like to replace it with a `ulong` maximum value instead.","Url":"https://github.com/dotnet/machinelearning/issues/1540","RelatedDescription":"Open issue \"IDataView Cleanup: KeyType Simplification\" (#1540)"},{"Id":"377662091","IsPullRequest":false,"CreatedAt":"2018-11-06T02:04:52","Actor":"AceHack","Number":"1539","RawContent":null,"Title":"Please support XGBoost i.e. gradient boosting machines","State":"open","Body":"This is the 2nd most popular model on Kaggle.\r\n\r\nThanks.","Url":"https://github.com/dotnet/machinelearning/issues/1539","RelatedDescription":"Open issue \"Please support XGBoost i.e. gradient boosting machines\" (#1539)"},{"Id":"377649240","IsPullRequest":true,"CreatedAt":"2018-11-06T01:00:57","Actor":"shmoradims","Number":"1538","RawContent":null,"Title":"Added dynamic API snippets to cookbook","State":"open","Body":"Added the dynamic API equivalent for all the snippets that were using static API, except for the snippet that uses onFit, which is not supported by dynamic API yet.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1538","RelatedDescription":"Open PR \"Added dynamic API snippets to cookbook\" (#1538)"},{"Id":"377647196","IsPullRequest":false,"CreatedAt":"2018-11-06T00:51:40","Actor":"abgoswam","Number":"1537","RawContent":null,"Title":"Invalid arguments provided when using Iris dataset with TextLoader ","State":"open","Body":"There are two versions of the Iris data set in the ML.NET repo.\r\n- [iris.data](https://github.com/dotnet/machinelearning/blob/master/test/data/iris.data)\r\n- [iris.txt](https://github.com/dotnet/machinelearning/blob/master/test/data/iris.txt)\r\n\r\nBoth of these datasets do not have a header.  As such, when using these datasets with Textloader, the `HasHeader` field in the `TextLoader.Arguments` class should be `false` . \r\n\r\nInstead, we see several places (e.g. [here](https://github.com/dotnet/machinelearning/blob/453eb57f0cd94d6412b1f8dee76c00c686e2e06e/test/Microsoft.ML.Tests/TrainerEstimators/TrainerEstimators.cs#L178) ) where we have set `HasHeader=true`  while working with the above two datasets. \r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1537","RelatedDescription":"Open issue \"Invalid arguments provided when using Iris dataset with TextLoader \" (#1537)"},{"Id":"377642246","IsPullRequest":true,"CreatedAt":"2018-11-06T00:30:45","Actor":"eerhardt","Number":"1536","RawContent":null,"Title":"Introduce VBuffer GetValues and GetIndices","State":"open","Body":"Use the new methods in place of Count and Values/Indices in as many readonly situations as possible.\r\n\r\nWorking towards #608 \r\n\r\nSee proposed change (4) in https://github.com/dotnet/machinelearning/issues/608#issuecomment-433185895\r\n\r\nEventually, `Count`, `Values` and `Indices` will be hidden/private on VBuffer and `GetValues()` and `GetIndices()` will be the only way to read these values.","Url":"https://github.com/dotnet/machinelearning/pull/1536","RelatedDescription":"Open PR \"Introduce VBuffer GetValues and GetIndices\" (#1536)"},{"Id":"377615479","IsPullRequest":true,"CreatedAt":"2018-11-05T22:45:36","Actor":"abgoswam","Number":"1535","RawContent":null,"Title":"Fix TextLoader.Argument (HasHeader=true) for Iris dataset","State":"open","Body":"Fixes #1537 \r\n\r\nDropped `HasHeader=true` from  `GetMultiClassPipeline` and `MakeIrisTextLoaderArgs`\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1535","RelatedDescription":"Open PR \"Fix TextLoader.Argument (HasHeader=true) for Iris dataset\" (#1535)"},{"Id":"377606569","IsPullRequest":false,"CreatedAt":"2018-11-05T22:17:19","Actor":"TomFinley","Number":"1534","RawContent":null,"Title":"IDataView Cleanup: Rename `UInt128`","State":"open","Body":"The row cursor IDs serve a purpose as described here.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/master/src/Microsoft.ML.Core/Data/ICursor.md#getidgetter\r\n\r\nThese IDs are represented as 128-bit numbers. Correspondingly, I named them `UInt128` back in the long vanished past. However, this is a troubling name: this first of all conflicts with any name .NET would use in the future to represent 128-bit unsigned integers (assuming they ever did so), which is reason enough not to use it. But even without this reason, this type just doesn't *quite* act like a number.\r\n\r\nOn the other hand, I am not certain what a good name would be. Something like `RowId`, `RecordId`, or something like that?\r\n\r\n/cc @Zruty0 @shauheen @terrajobst ","Url":"https://github.com/dotnet/machinelearning/issues/1534","RelatedDescription":"Open issue \"IDataView Cleanup: Rename `UInt128`\" (#1534)"},{"Id":"377592001","IsPullRequest":false,"CreatedAt":"2018-11-05T21:33:58","Actor":"TomFinley","Number":"1533","RawContent":null,"Title":"IDataView Cleanup: ColumnType cleanup","State":"open","Body":"The `IDataView` type system is extensible (as we see with [`ImageType`](https://github.com/dotnet/machinelearning/blob/f9202628fbfac9e599e8c63dc5ed26eae77afbee/src/Microsoft.ML.ImageAnalytics/ImageType.cs#L12)).\r\n\r\nThis is fine, but there is something confusing about `ColumnType` as well, since there are lots of methods and properties on the base class `ColumnType` that are specific for derived types. For example, `.IsVector`, `.KeyCount`, and other such things, that are only really relevant if the type *is* either vector, key, or whatever.\r\n\r\n## Why clean up?\r\n\r\nThere are lots of things on `ColumnType` that are unappealing. There are things like `AsVector` and `IsVector` which, as the documentation states, are equivalent to `as VectorType` and `is VectorType`. I mean, *why*? You save a few characters here and there, but at the cost of complicating one of the most central classes in the API.\r\n\r\nSome things are just plain old silly. Why `IsTimeSpan`? How useful is that, really? Some things are like this.\r\n\r\nThere's also `DataKind`. This is so strange. This has already caused a fair amount of confusion among some people: they see this, and they think, \"oh the types are just from this `enum`.\" No, they're not.\r\n\r\nThe reality is, these things are *conveniences*, but they're conveniences I think that confuse people (multiple smart people have thought their presence meant the type system was *not* extensible), so maybe we ought not to expose them, at least, not in their current form.\r\n\r\n## Why not clean up?\r\n\r\nIn a sense, forming an analogue between the IDV and .NET type systems, there is some precedent for this sort of thing: if we consider `System.Type`. This has the property `IsArray`, with the methods `GetArrayRank`, which is only sensible to use. However in *our* case, `ColumnType` is an abstract class, and while `System.Type` is abstract, its inheritance structure does not capture specific types of values in this sense. If, hypothetically, `.GetType` of an `int[]` returned some type `System.ArrayType` that descended from `System.Type`, then we might equally hypothetically imagine that the method to get the array rank would be on that derived `ArrayType`, rather than on `Type` directly.\r\n\r\nThere is also a practical consideration. The reality though is that some types are definitely more important and more heavily used than others.\r\n\r\nLet's imagine that we kept the `ColumnType` inheritance structure as it is now, but removed any properties relevant only to any derived type, specifically. What would hypothetically happen? I picked this usage more or less randomly from our codebase.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/f9202628fbfac9e599e8c63dc5ed26eae77afbee/src/Microsoft.ML.Data/Evaluators/ClusteringEvaluator.cs#L799-L801\r\n\r\nNow then, let's imagine that we have *none* of the \"specialty\" properties on `ColumnType` used above, but instead have a `IsKnownSize` and `ItemType` on `VectorType` *specifically*, that is, not on the root class, and you must rephrase this thing as a `VectorType` if you wished to access these. The most clear way I can imagine to deliver equivalent logic to the linked condition is this:\r\n\r\n```csharp\r\nif (!(type is VectorType vecType && vecType.IsKnownSize && vecType.ItemType == NumberType.Float))\r\n```\r\nThat's not *so* bad really... the condition went from 60 to 92 characters, which while not great, is hardly ridiculous.\r\n\r\nIt's even conceivable that had we had pattern matching at the time this code is written, we would have done this. Prior to C# 7.0 (and this code is *way* prior to C# 7.0), there was no such things as this pattern matching, as we see used here in the `type is VectorType vecType` expression. So the equivalent in the pre-pattern match days would have been considerably more obnoxious and verbose.\r\n\r\nLet's talk about `DataKind`. Unquestionably it is confusing, but if you take a look at it, it is also really, really helpful to have, for the common builtin types, an `enum`.\r\n\r\n## Proposed balance\r\n\r\nI think it's possible to sort of have our cake and eat it too. Now that we have #1520, we can sort of make our public surface as sparse as possible, while allowing the conveniences we currently enjoy for the internal implementation to remain more or less unmolested.\r\n\r\n* Let us mark these questionable things as `internal`, but with `BestFriend` attributes on them. The internal code can retain is sparsity, \r\n* Let us add to the public surface the same information that we get from the types on the specific relevant types themselves. (E.g., the vector size would just be *publicly* part of `VectorSize` itself.)\r\n* In any event, some of the properties have no reason to exist in *any* world. For example, a property like `IsTimeSpan` exists just because someone misunderstood what was going on, and thought, \"gee I'm adding a new class, I see we have tests for things like vector and text, let me just add this.\" Nope, we just have those special things as conveniences.\r\n\r\nWe could then, if we *like* either (1) make the conveniences public or (2) remove them altogether, at our own pace, without jeopardizing the public surface of the API at all.\r\n\r\n/cc @Zruty0 @shauheen @terrajobst \r\n","Url":"https://github.com/dotnet/machinelearning/issues/1533","RelatedDescription":"Open issue \"IDataView Cleanup: ColumnType cleanup\" (#1533)"},{"Id":"377565010","IsPullRequest":false,"CreatedAt":"2018-11-05T20:16:47","Actor":"TomFinley","Number":"1532","RawContent":null,"Title":"IDataView Cleanup: Clear cutting the `IRowCursor` interface jungle","State":"open","Body":"Right now we have a fairly elaborate set of interfaces surrounding `IRowCursor`. These include `ISchematized`, `ICounted`, `IRow`.\r\n\r\nWhile `IRowCursor` and `IRow` are quite useful, it is not clear if separating out `ICursor` and `ICounted` as separate interfaces is actually helpful, and we think we ought to get rid of `ISchematized` anyway (see #1502). The goal would be to refactor this jungle so that there are, relating to row cursors, two types, both abstract ***classes***, corresponding to `IRow` and `IRowCursor`, but of course not named that since they won't be interfaces. (What would be a good name is up for debate. `RowCursor` seems probably fine, but just `Row` does not seem like a good name.)\r\n\r\nIt may be that we have the name `Row` for now until we imagine a better name, and treat that renaming as a separate issue from this issue which mostly treats on the proper refactoring of the code.\r\n\r\n`ICursor` does have some implementations that are not also `IRowCursor`, but it is unclear whether this *has* to be this way, or if it is just that way just because it was there.\r\n\r\nThe collapse of `ICounted` into these hypothetical `Row` and `RowCursor` classes would be mostly into `Row`.\r\n\r\n## While we are at it...\r\n\r\nWhile refactoring this code it would be advantageous to at the same time deal with the refactorings of other things methods in cursors, as we will be restructuring them anyway.\r\n\r\n* The utility of `State` on cursors has proven to not be terribly useful. People create and use cursors more or less like they do enumerators -- they create them, move-next over them, then when they stop the thing is disposed. It is valuable for the sake of assert checking, but otherwise I am not aware of any use. Certainly `IEnumerator` gets along just fine without this...\r\n\r\n* The `MoveMany` method *seems* attractive. In many cases, you can in fact move faster than just an exhaustive `MoveNext` to get to where you want to go. The trouble is the utility for such a mechanism has proven to be limited -- sure, a `Skip` filter could be more performant, but beyond that usages are few. We may as well remove it.\r\n\r\n* `GetRootCursor`'s performs an essential job (bypass nested move-next so that nested cursors, which is to say *most* cursors, have a fast `MoveNext`). By moving this to an abstract class, we can see if this \"bypass\" mechanism can be achieved in a less obnoxious (possibly internal) way to cursors.\r\n\r\n* Possibly not to be done here, it would be nice if instead of `IRowCursor` (or rather, its abstract class descendant) being disposable, that the `IRow` is disposable. This is desirable but may require additional considerations, and might be best achieved in a separate issue.\r\n\r\n* The utility of the `IsActiveColumn` is not immediately clear. Can we get away with simply not providing it? It may be though that we decide to keep it.\r\n\r\n/cc @Zruty0 @shauheen @terrajobst ","Url":"https://github.com/dotnet/machinelearning/issues/1532","RelatedDescription":"Open issue \"IDataView Cleanup: Clear cutting the `IRowCursor` interface jungle\" (#1532)"},{"Id":"377563947","IsPullRequest":false,"CreatedAt":"2018-11-05T20:14:01","Actor":"TomFinley","Number":"1531","RawContent":null,"Title":"IDataView Cleanup: Remove `lazy` parameter from get row count","State":"open","Body":"How do you tell the number of rows in a data view?\r\n\r\nThere is this very interesting method here.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/f9202628fbfac9e599e8c63dc5ed26eae77afbee/src/Microsoft.ML.Core/Data/IDataView.cs#L95\r\n\r\nThe semantics of this are somewhat odd (though logical, in their way), and basically boil down to: under the default value of `lazy=true`, only return the row count if it is basically an O(1) operation. But what if this returns `null`? Then you have the `lazy=false` operation! This is a hint that we ought to possibly expend *more* effort, but only if doing so entails less work than just iterating over every row and counting directly.\r\n\r\nIndeed, this is what this utility function does:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/f9202628fbfac9e599e8c63dc5ed26eae77afbee/src/Microsoft.ML.Data/Data/DataViewUtils.cs#L78\r\n\r\nFirst it asks (with `lazy=false`!) for the row count, and failing that will actually open a cursors (with no rows active) and directly count the number.\r\n\r\nThis is all fairly logical. However, as a practical matter, no one *ever* bothered to implement a `lazy=false` different code path as far as I am aware. This is not to say they couldn't have -- you might imagine some text-loader that without trying to parse anything merely counts the number of newline characters in a file, which would be much faster than an iteration -- but again, as a practical matter, no one *did*.\r\n\r\nThis suggests removing this `lazy` parameter to simplify the interface. It would still have the same semantics, just without all the complication of explaining `lazy`. (Though we'd still need to make clear to people that they *should* be lazy in the implementation notes.)\r\n\r\n/cc @Zruty0 @shauheen @terrajobst ","Url":"https://github.com/dotnet/machinelearning/issues/1531","RelatedDescription":"Open issue \"IDataView Cleanup: Remove `lazy` parameter from get row count\" (#1531)"},{"Id":"377554293","IsPullRequest":true,"CreatedAt":"2018-11-05T19:46:29","Actor":"artidoro","Number":"1530","RawContent":null,"Title":"Make whitening tests work on hosted macs","State":"open","Body":"Fixes #1506.\r\n\r\nThis PR fixes the error encountered when running tests on hosted macs.\r\n\r\nIt turns out that the problem was due to a mismatch in the parameters sizes and values that were passed  to the MKL gemm function during training. In particular, as part of the test, the transform is trained on empty data. An empty array of data was then passed to the MKL gemm function, while the parameters specifying the size of the data were were non 0. This situation was apparently handled for other OS and processors versions, but not on the hosted macs, and was therefore giving an error. \r\n\r\nThe fix that I propose is to initialize zero matrices of the right size instead of training when provided empty data as an input.\r\n\r\nThis PR also deletes a command in the build.proj that was still downloading the wine dataset (found by @vaeksare) when building.","Url":"https://github.com/dotnet/machinelearning/pull/1530","RelatedDescription":"Open PR \"Make whitening tests work on hosted macs\" (#1530)"},{"Id":"377550767","IsPullRequest":false,"CreatedAt":"2018-11-05T19:36:48","Actor":"TomFinley","Number":"1529","RawContent":null,"Title":"IDataView Cleanup: Predicates from int to Column","State":"open","Body":"As seen in #1500, schema is being changed so that schemas contain columns.\r\n\r\nFor various reasons it may be easiest once `IDataView` is a class.\r\n\r\nLet us consider the use of predicates in the `IDataView` system, e.g., when getting a cursor:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/f9202628fbfac9e599e8c63dc5ed26eae77afbee/src/Microsoft.ML.Core/Data/IDataView.cs#L103\r\n\r\nor elsewhere when forming a mapper, and getting dependencies:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/f9202628fbfac9e599e8c63dc5ed26eae77afbee/src/Microsoft.ML.Core/Data/ISchemaBindableMapper.cs#L77\r\n\r\nThe use of integer indices here has sometimes led to confusion or even bugs. With the change of #1500 under consideration, this suggests a possibly better way.\r\n\r\nIt may be worth considering whether the columns in the new scheme suggested in #1500 should have a backref to the original schema (even as an internal field that is checked by the data-view abstract class), so as to enable an easy way to check.\r\n\r\nWe could also consider this dependency be expressed not as a *delegate*, but instead just some sort of collection of columns, since that would also make this easier to explain.\r\n\r\nNote that while this makes the *interface* to `IDataView` easier, it makes the *implementation* harder, at least, if we suppose that all dataviews are possible for handling these inputs correctly and verifying that there aren't any shenaningans going on with input columns being from a different schema (which we can and so almost certainly should do under this new scheme). This suggests a change to `IDataView`, possibly done once `IDataView` is a class, so that the utility mapping from these column objects back down to indices (which must still happen internally) is handled by common code. It would also enable if these column objects have some sort of internal backreference to the schema, the ability to check that the input schemas are in fact correct. (This we obviously cannot do today with indices!)\r\n\r\n/cc @Zruty0 @shauheen @terrajobst ","Url":"https://github.com/dotnet/machinelearning/issues/1529","RelatedDescription":"Open issue \"IDataView Cleanup: Predicates from int to Column\" (#1529)"},{"Id":"377550205","IsPullRequest":false,"CreatedAt":"2018-11-05T19:35:16","Actor":"TomFinley","Number":"1528","RawContent":null,"Title":"IDataView Cleanup: IDataView as an abstract class, not interface","State":"open","Body":"Let us not have `IDataView` as an interface, but instead just an abstract base class `DataView`. Then instead of implementing this interface, we descend from the base class. This is in line with .NET guidelines preferring abstract classes to interfaces where possible and reasonable.\r\n\r\nAt least internal to ML.NET things that are `IDataView` are primarily that (or some subcase of that).\r\n\r\nFor various reason this *may* have to wait until the `IDataTransform` conversion into the `IEstimator`/`ITransformer` idioms is complete, but we can investigate doing it now, or even temporarily making *that* itself a base class. Nonetheless it woudl be easiest done once `IDataTransform` is disentangled from many of the existing `IDataView` implementations.\r\n\r\n/cc @Zruty0 @shauheen @terrajobst ","Url":"https://github.com/dotnet/machinelearning/issues/1528","RelatedDescription":"Open issue \"IDataView Cleanup: IDataView as an abstract class, not interface\" (#1528)"},{"Id":"377546563","IsPullRequest":true,"CreatedAt":"2018-11-05T19:25:10","Actor":"montebhoover","Number":"1527","RawContent":null,"Title":"Publish build logs in Azure DevOps CI.","State":"open","Body":"Fixes #1473 by publishing logs from the build as artifacts in the Azure DevOps pipeline:\r\n\r\n![image](https://user-images.githubusercontent.com/37886197/48021283-045ee900-e0ed-11e8-84a6-63b68ed2f48a.png)\r\n\r\nPublishes the following files:\r\n- msbuild.log\r\n- msbuild.err\r\n- msbuild.wrn\r\n- binclash.log\r\n- init-tools.log\r\n- Microsoft.ML.Predictor.Tests/../TestOutput/*\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1527","RelatedDescription":"Open PR \"Publish build logs in Azure DevOps CI.\" (#1527)"},{"Id":"377037690","IsPullRequest":true,"CreatedAt":"2018-11-05T18:20:17","Actor":"TomFinley","Number":"1520","RawContent":null,"Title":"Add the `BestFriend` attribute for restricting cross-assembly internal access","State":"closed","Body":"Fixes #1519 .","Url":"https://github.com/dotnet/machinelearning/pull/1520","RelatedDescription":"Closed or merged PR \"Add the `BestFriend` attribute for restricting cross-assembly internal access\" (#1520)"},{"Id":"377037386","IsPullRequest":false,"CreatedAt":"2018-11-05T18:20:17","Actor":"TomFinley","Number":"1519","RawContent":null,"Title":"Best friends to limit friend access","State":"closed","Body":"While we stabilize the API, it is best if we keep hidden as much as possible, since once v1.0 the barrier to changing the public types on a publicly released library will be high. For that reason the thinking is to keep the scope of what we publicly release as limited as possible. If we suppose that *usage* of the library vs. *component authorship* inside the library, one obvious way to reduce the surface area is to ideally hide (or, in the worst case, render useless) all the items related to component authorship.\r\n\r\nThe problem is, over the years we have accumulated have a fairly huge library, so there are a tremendous number of types, and a fair amount of infrastructure. We cannot make that infrastructure internal simply and put everything in one big assembly, because some components or their dependencies are quite large, so we want to keep them in separate nugets, which means separate assemblies. But, that means public classes.\r\n\r\nWe could make the core infrastructure assemblies friends of all leaf assemblies via the `InternalsVisibleTo` attribute, but that would render *all* internal classes usable from the leaf assemblies, which again is not what we want from a code maintainability perspective.\r\n\r\nWe really want to have a mechanism that distinguishes internal to the assembly, and internal to the library. There is no concept in .NET, and based on conversations with the .NET folks there seems to be little belief such a thing might be useful in any other situation, so we'll roll our own.\r\n\r\nThe best idea we have settled on so far is that we set things to be friends as described above, make things internal, *but* for these internal items we want to share, make sure that there is an attribute (provisionally called `BestFriend`) on the item, and if not, the code analyzer we have internal to ML.NET will complain.\r\n\r\nSo, e.g.:\r\n\r\n```csharp\r\ninternal sealed class Foo { }\r\n\r\n[BestFriend]\r\ninternal sealed class Bar\r\n{\r\n    [BestFriend]\r\n    internal int A { get; }\r\n    internal int B { get; }\r\n}\r\n\r\npublic abstract class Biz\r\n{\r\n    [BestFriend]\r\n    private internal Biz() { }\r\n}\r\n```\r\n\r\nIn this scenario, if we consider some hypothetical other project code trying to access this, access to `Foo` and `Bar.B` would be restricted (despite being friends!), but access to `Bar`, `Bar.A`, and a class inheriting from `Biz` would be possible in.\r\n\r\nNote here, `Biz` itself is still public since we very often have user-accessible classes descend from some class we would like to be \"internal,\" but kind of can't, at least, not without introducing a significant absurd amount of wrapping. This level of \"visible but unusable\" though we should try to keep to a minimum.\r\n\r\nYou could imagine this attribute being an opt-out rather than opt-in, but opt-in seems a bit more reasonable since we want to treat these cross-assembly sharings as being somehow special, and it would be nice if in PRs it becomes obvious when there's something like this going on.\r\n\r\nThe work then is:\r\n\r\n1. Introduce two attributes, one this `BestFriend` attribute, the other an assembly level attribute whereby an assembly can indicate it wants to be subject to these best-friend controls. (Some assemblies like `CpuMath` that are purely intended for component authors would perhaps share everything without the need for this attribute.)\r\n\r\n2. Write an analyzer that complains when there is a cross-assembly friend access, when the item does not contain this attribute.\r\n\r\nObviously one of these is slightly harder than the other. 😄 Note that this work merely covers the *creation* of the infrastructure, not the *use* of the infrastructure. That later work will be considerably more involved and spread across many files, and so will certainly be structured across many PRs.\r\n\r\n/cc @danmosemsft @eerhardt @Zruty0 ","Url":"https://github.com/dotnet/machinelearning/issues/1519","RelatedDescription":"Closed issue \"Best friends to limit friend access\" (#1519)"},{"Id":"377084661","IsPullRequest":false,"CreatedAt":"2018-11-05T18:07:15","Actor":"CESARDELATORRE","Number":"1522","RawContent":null,"Title":"Simplify API: dataPipeline.Fit(data).Transform(data);","State":"closed","Body":"For the code on [\"How do I look at the intermediate data?\"](https://github.com/dotnet/machinelearning/blob/453eb57f0cd94d6412b1f8dee76c00c686e2e06e/docs/code/MlNetCookBook.md#how-do-i-look-at-the-intermediate-data) as explained in the CookBook, it looks weird to have to pass the same DataView object twice in the following code line:\r\n(Scroll down a bit and you'll see)\r\n```\r\n// Fit our data pipeline and transform data with it.\r\nvar transformedData = dataPipeline.Fit(data).Transform(data);\r\n```\r\n\r\nThat line of code initially looks like a [\"Code smell\"](https://en.wikipedia.org/wiki/Code_smell).. \r\n\r\nSince the DataView object is provided to the parent object (pipeline) through the `Fit(data)` method, could it be possible to get/use the DataView from the parent object without having to provide again the DataView object to the Transform(data) method? - Something like:\r\n\r\n`var transformedData = pipeline.Fit(dataView).Transform();`\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1522","RelatedDescription":"Closed issue \"Simplify API: dataPipeline.Fit(data).Transform(data);\" (#1522)"},{"Id":"377478618","IsPullRequest":true,"CreatedAt":"2018-11-05T16:29:26","Actor":"codemzs","Number":"1526","RawContent":null,"Title":"WIP stateful prediction engine for TS.","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/pull/1526","RelatedDescription":"Open PR \"WIP stateful prediction engine for TS.\" (#1526)"},{"Id":"377263917","IsPullRequest":false,"CreatedAt":"2018-11-05T06:16:24","Actor":"CESARDELATORRE","Number":"1525","RawContent":null,"Title":"Minor consistency issue: MLContext.MulticlassClassification has first \"c\" letter as lowercase, but MultiClassClassifierEvaluator.Result has it as uppercase","State":"open","Body":"Minor consistency issue, this class has first \"c\" as lowercase:\r\nMLContext.Multi**c**lassClassification.Evaluate()\r\n\r\nThen, the Evaluate method returns the following type which has the first \"C\" as uppercase:\r\n\r\nMulti**C**lassClassifierEvaluator.Result ","Url":"https://github.com/dotnet/machinelearning/issues/1525","RelatedDescription":"Open issue \"Minor consistency issue: MLContext.MulticlassClassification has first \"c\" letter as lowercase, but MultiClassClassifierEvaluator.Result has it as uppercase\" (#1525)"},{"Id":"377169341","IsPullRequest":true,"CreatedAt":"2018-11-04T16:29:48","Actor":"sfilipi","Number":"1524","RawContent":null,"Title":"More trainer extensions, bug fixes and consistency across trainer extensions","State":"open","Body":"Gam trainers placed in the right context, and removing arguments they weren't using from their signatures. \r\nFixes #1521 making the order of the parameters consistent. \r\nAddresses part of #1318 by adding the FastForest extensions. \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1524","RelatedDescription":"Open PR \"More trainer extensions, bug fixes and consistency across trainer extensions\" (#1524)"},{"Id":"377128824","IsPullRequest":false,"CreatedAt":"2018-11-04T07:28:03","Actor":"shauheen","Number":"1523","RawContent":null,"Title":"Test issue - disregard","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**:\r\n- **.NET Version (eg., dotnet --info)**: \r\n\r\n### Issue\r\n\r\n- **What did you do?**\r\n- **What happened?**\r\n- **What did you expect?**\r\n\r\n### Source code / logs\r\n\r\nPlease paste or attach the code or logs or traces that would be helpful to diagnose the issue you are reporting.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1523","RelatedDescription":"Open issue \"Test issue - disregard\" (#1523)"},{"Id":"377080492","IsPullRequest":false,"CreatedAt":"2018-11-03T18:24:39","Actor":"CESARDELATORRE","Number":"1521","RawContent":null,"Title":"Need to make consistent the parameters across the API","State":"open","Body":"**Issue: Similar classes/estimators methods have different parameters' order for the same concepts.** \r\n\r\nIt looks like a \"silly\" error, but not straightforward to catch because the column's name provided as parameters are not typed (just strings, logically, since column names could vary) you get an error in execution time but in addition to that because the pipeline works as lazy loading, you find the error later on when fitting the model, so you initially don't know what API is incorrectly configured making it hard to find these kind of \"silly\" errors which are prone to happen because of different parameter's order in similar APIs (such as Estimators and Transformers). \r\n\r\nFor instance, when migrating to the estimator by using mlContext, the following \"silly\" case happened to me:\r\n\r\n```\r\n// This line works\r\nvar trainer = new SdcaMultiClassTrainer(mlContext, \"Features\", \"Label\");\r\n// This line doesn't work, but you'll find out later on when Fitting the model\r\nvar trainer = mlContext.MulticlassClassification.Trainers.StochasticDualCoordinateAscent(\"Features\", \"Label\");\r\n```\r\n\r\nError you get when fitting:\r\n```\r\nSystem.ArgumentOutOfRangeException\r\n  HResult=0x80131502\r\n  **Message=Training label column 'Features' type is not valid for multi-class: Vec<R4, 69981>. Type must be R4 or R8.**\r\n  Source=Microsoft.ML.Data\r\n```\r\n\r\n```\r\n//This line DOES work when changing to the right order of parameters accepted by the new API:\r\nvar trainer = mlContext.MulticlassClassification.Trainers.StochasticDualCoordinateAscent(\"Label\", \"Features\");\r\n```\r\nBut you can see that is not consistent in order with this very similar line, the same trainer:\r\n```\r\n// This line works\r\nvar trainer = new SdcaMultiClassTrainer(mlContext, \"Features\", \"Label\");\r\n```\r\n\r\nI initially thought that the trainer in the mlcontext catalog was not working for any reason as a very similar API was working by directly creating the class.. But it was simply because the order is vice-versa in the case of the new trainer surfaced on the mlContext. ;)\r\n\r\n**Improvement**\r\n\r\n1. Obvious and already \"work in progress\": It will help if we are consistent in the order of the parameters across all the APIs. \"Label\" first, \"Features\" later, or vice-versa, but consistent.\r\n\r\n2. Not sure if somehow we could use strongly-typed types for the column names or some kind of check/control.. like if for the column names we were able to use the fields in the schema classes and the \"Label\" field was \"marked\" as \"Label\" with an attribute, that could also help, I mean something like the following:\r\n\r\n```\r\nvar trainer = mlContext.MulticlassClassification.Trainers.StochasticDualCoordinateAscentnameof(\r\n                                                        nameof(MyObservation.MyLabel), \r\n                                                        \"Features\");\r\n```\r\n\r\nThen, the Label field is \"marked\" as Label:\r\n```\r\n    public class MyObservation\r\n    {\r\n        [Column(ordinal: \"0\")]\r\n        public string ID;\r\n\r\n        [Label]\r\n        [Column(ordinal: \"1\")]\r\n        public string MyLabel; // This is an issue label, for example \"area-System.Threading\"\r\n\r\n        [Column(ordinal: \"2\")]\r\n        public string Title;\r\n\r\n        [Column(ordinal: \"3\")]\r\n        public string Description;\r\n    }\r\n```\r\n\r\nNot sure though..., this last approach might be too contrived and not realistic because in almost all the cases the Label is also a generated/Dictionarized field, as well as the \"Features\" column, both created/generated as new columns out of the original observation schema class, so this last attempt might not be feasible...\r\n\r\nAny other possible check/control so errors when using strings for the column names could be less prone to happen?... \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1521","RelatedDescription":"Open issue \"Need to make consistent the parameters across the API\" (#1521)"},{"Id":"376905168","IsPullRequest":true,"CreatedAt":"2018-11-02T22:42:34","Actor":"wschin","Number":"1513","RawContent":null,"Title":"Better explanation of Score's initial value","State":"closed","Body":"Fixes #1489 so that the example becomes compatible with older C# versions. \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1513","RelatedDescription":"Closed or merged PR \"Better explanation of Score's initial value\" (#1513)"},{"Id":"376976979","IsPullRequest":true,"CreatedAt":"2018-11-02T21:42:44","Actor":"Zruty0","Number":"1518","RawContent":null,"Title":"Debugger preview for data, schema, metadata, VBuffer","State":"open","Body":"Fixes #1242 . Adds debugger previews for data, schema, metadata, VBuffer","Url":"https://github.com/dotnet/machinelearning/pull/1518","RelatedDescription":"Open PR \"Debugger preview for data, schema, metadata, VBuffer\" (#1518)"},{"Id":"376957184","IsPullRequest":true,"CreatedAt":"2018-11-02T20:29:04","Actor":"GalOshri","Number":"1517","RawContent":null,"Title":"Add release notes for ML.NET 0.7","State":"open","Body":"This adds release notes for ML.NET 0.7","Url":"https://github.com/dotnet/machinelearning/pull/1517","RelatedDescription":"Open PR \"Add release notes for ML.NET 0.7\" (#1517)"},{"Id":"376955258","IsPullRequest":true,"CreatedAt":"2018-11-02T20:22:35","Actor":"ganik","Number":"1516","RawContent":null,"Title":"Examples for Timeseries","State":"open","Body":"Added example docs\r\nFix doc strings\r\nfixes #1483 \r\nfixes #1479 ","Url":"https://github.com/dotnet/machinelearning/pull/1516","RelatedDescription":"Open PR \"Examples for Timeseries\" (#1516)"},{"Id":"376923494","IsPullRequest":false,"CreatedAt":"2018-11-02T18:34:50","Actor":"CESARDELATORRE","Number":"1515","RawContent":null,"Title":"Be able to create a reader by just specifying an schema class instead of all the columns","State":"open","Body":"In current version (v0.6 and v0.7) when creating a TextLoader we need to provide all the columns explicetely like the following:\r\n\r\n_loader = mlContext.Data.TextReader(new TextLoader.Arguments()\r\n                                                {\r\n                                                    Separator = \",\",\r\n                                                    HasHeader = true,\r\n                                                    Column = new[]\r\n                                                                {\r\n                                                                new TextLoader.Column(\"Season\", DataKind.R4, 2),\r\n                                                                new TextLoader.Column(\"Year\", DataKind.R4, 3),\r\n                                                                new TextLoader.Column(\"Month\", DataKind.R4, 4),\r\n                                                                new TextLoader.Column(\"Hour\", DataKind.R4, 5),\r\n                                                                new TextLoader.Column(\"Holiday\", DataKind.R4, 6),\r\n                                                                new TextLoader.Column(\"Weekday\", DataKind.R4, 7),\r\n                                                                new TextLoader.Column(\"WorkingDay\", DataKind.R4, 8),\r\n                                                                new TextLoader.Column(\"Weather\", DataKind.R4, 9),\r\n                                                                new TextLoader.Column(\"Temperature\", DataKind.R4, 10),\r\n                                                                new TextLoader.Column(\"NormalizedTemperature\", DataKind.R4, 11),\r\n                                                                new TextLoader.Column(\"Humidity\", DataKind.R4, 12),\r\n                                                                new TextLoader.Column(\"Windspeed\", DataKind.R4, 13),\r\n                                                                new TextLoader.Column(\"Count\", DataKind.R4, 16)\r\n                                                                }\r\n                                                }\r\n\r\nSince you usually also have a schema class for the observations, like the following:\r\n\r\n    public class DemandObservation\r\n    {\r\n        public float Season;\r\n        public float Year;\r\n        public float Month;\r\n        public float Hour;\r\n        public float Holiday;\r\n        public float Weekday;\r\n        public float WorkingDay;\r\n        public float Weather;\r\n        public float Temperature;\r\n        public float NormalizedTemperature;\r\n        public float Humidity;\r\n        public float Windspeed;\r\n        public float Count;   // This is the observed count, to be used a \"label\" to predict\r\n    }\r\n\r\nIt would be very convenient to be able to create a TextReader by just providing the class, like this:\r\n\r\nmlContext.Data.TextReader(DemandObservation);\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1515","RelatedDescription":"Open issue \"Be able to create a reader by just specifying an schema class instead of all the columns\" (#1515)"},{"Id":"376906064","IsPullRequest":false,"CreatedAt":"2018-11-02T17:42:05","Actor":"CESARDELATORRE","Number":"1514","RawContent":null,"Title":"ONNX dlls appearing in VS at the project's root folder","State":"open","Body":"Right after compiling a sample which is scoring with an ONNX model, a bunch of \"low level\" DLLs related to ONNX appear in VS at the project's root folder.\r\n\r\nIs there a way not to show all these .DLLs here?\r\n(Ignore the list of image files, of course..)\r\n\r\n![image](https://user-images.githubusercontent.com/1712635/47931063-fc077380-de8a-11e8-8c2b-d1a02b5e8d09.png)\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1514","RelatedDescription":"Open issue \"ONNX dlls appearing in VS at the project's root folder\" (#1514)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-11-06T05:30:38.5068329Z","RunDurationInMilliseconds":1287}