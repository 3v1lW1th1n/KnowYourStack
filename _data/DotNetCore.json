{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":26,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":38,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7896820874","Type":"IssuesEvent","CreatedAt":"2018-06-29T09:52:53","Actor":"tomkerkhove","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/104","RelatedDescription":"Opened issue \"About still mentions CodePlex\" (#104) at dotnet/home","RelatedBody":"About still mentions CodePlex which is now in archive mode.\r\n\r\n![image](https://user-images.githubusercontent.com/4345663/42086259-e0b7d008-7b92-11e8-96c9-02ee61ddc457.png)\r\n\r\nIs this something that I can PR?"},{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7920834422","Type":"PullRequestEvent","CreatedAt":"2018-07-05T03:48:43","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18784","RelatedDescription":"Opened pull request \"Add missing FlushInstructionCache to CommitGCStressInstructionUpdate\" (#18784) at dotnet/coreclr","RelatedBody":"It's my understanding that missing `FlushInstructionCache` in `Thread::CommitGCStressInstructionUpdate` was the reason of the assertion failures we observed in https://github.com/dotnet/coreclr/issues/17570#issuecomment-382913069. \r\n\r\nI have done proper testing of this change with threading tests (running them 10000 times in a loop) previous failing under `GCStress=0xC` and the issue is not reproducible anymore.\r\n\r\nFixes #17570"},{"Id":"7920545980","Type":"PullRequestEvent","CreatedAt":"2018-07-05T01:38:06","Actor":"stephentoub","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18771","RelatedDescription":"Merged pull request \"Improve DateTime{Offset}.ParseExact{Multiple} performance for RFC1123 (\"r\")\" (#18771) at dotnet/coreclr","RelatedBody":"Significantly improves the performance of `DateTime.ParseExact(..., \"r\", ...)` by porting and adapting the `Utf8Parser` code from corefx, for a **15-20x** throughput increase (and also saving three string allocations totaling ~80bytes... which more generally we should subsequently look at getting rid of for other formats).  This optimizes for the (default) case of a `DateTimeStyles.None`; specifying any other style falls back to the normal parsing support, as that requires handling things such as arbitrary whitespace anywhere in the string.\r\n\r\nBenchmark:\r\n```C#\r\nusing System;\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Attributes.Jobs;\r\nusing BenchmarkDotNet.Running;\r\n\r\n[MemoryDiagnoser]\r\n[InProcess]\r\npublic class Benchmark\r\n{\r\n    private static void Main() => BenchmarkRunner.Run<Benchmark>();\r\n\r\n    [Benchmark] public DateTime DT_ParseExactR() => DateTime.ParseExact(\"Wed, 15 Aug 1906 07:24:05 GMT\", \"r\", null);\r\n    [Benchmark] public DateTimeOffset DTO_ParseExactR() => DateTimeOffset.ParseExact(\"Wed, 15 Aug 1906 07:24:05 GMT\", \"r\", null);\r\n\r\n    private static readonly string[] s_formats = new string[] { \"R\" };\r\n    [Benchmark] public DateTime DT_ParseExactMultipleR() => DateTime.ParseExact(\"Wed, 15 Aug 1906 07:24:05 GMT\", s_formats, null);\r\n    [Benchmark] public DateTimeOffset DTO_ParseExactMultipleR() => DateTimeOffset.ParseExact(\"Wed, 15 Aug 1906 07:24:05 GMT\", s_formats, null);\r\n}\r\n```\r\n\r\nBefore:\r\n```\r\n                  Method |     Mean |     Error |    StdDev |  Gen 0 | Allocated |\r\n------------------------ |---------:|----------:|----------:|-------:|----------:|\r\n          DT_ParseExactR | 1.922 us | 0.0377 us | 0.0888 us | 0.0172 |      80 B |\r\n         DTO_ParseExactR | 1.948 us | 0.0374 us | 0.0511 us | 0.0153 |      80 B |\r\n  DT_ParseExactMultipleR | 1.922 us | 0.0265 us | 0.0221 us | 0.0172 |      80 B |\r\n DTO_ParseExactMultipleR | 1.934 us | 0.0349 us | 0.0292 us | 0.0153 |      80 B |\r\n```\r\n\r\nAfter:\r\n```\r\n                  Method |      Mean |     Error |    StdDev | Allocated |\r\n------------------------ |----------:|----------:|----------:|----------:|\r\n          DT_ParseExactR |  98.38 ns | 0.9119 ns | 0.7119 ns |       0 B |\r\n         DTO_ParseExactR | 123.87 ns | 0.4554 ns | 0.3012 ns |       0 B |\r\n  DT_ParseExactMultipleR | 112.05 ns | 2.3175 ns | 4.6284 ns |       0 B |\r\n DTO_ParseExactMultipleR | 120.27 ns | 1.3823 ns | 1.2930 ns |       0 B |\r\n```\r\n\r\ncc: @ahsonkhan, @jkotas, @pjanotti, @joperezr \r\nContributes to https://github.com/dotnet/corefx/issues/30612"},{"Id":"7920019682","Type":"PullRequestEvent","CreatedAt":"2018-07-04T20:33:38","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18724","RelatedDescription":"Merged pull request \"Re-enable jit regression test DevDiv_590771\" (#18724) at dotnet/coreclr","RelatedBody":"The issue the test was hitting was worked around in #18292.\r\n\r\nFixes #17967.\r\n\r\nAlso add GitHub_18522_8 to the arm/arm64 lists (from #18708)."},{"Id":"7920019669","Type":"IssuesEvent","CreatedAt":"2018-07-04T20:33:38","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17967","RelatedDescription":"Closed issue \"[arm64/RyuJit] assert(!\"We should never encounter a reference to a lclVar that has a zero refCnt.\");\" (#17967) at dotnet/coreclr","RelatedBody":"It was found in our internal test runs, I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590771/DevDiv_590771.il  (#17759)\r\n\r\nTo repro crossgen this test with altjit_arm64 or on arm64 itself.\r\n\r\nOnce it fixed delete change `tests/arm64/Tests.lst` to enable the test."},{"Id":"7919930575","Type":"PullRequestEvent","CreatedAt":"2018-07-04T19:56:59","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18783","RelatedDescription":"Opened pull request \"Delete dead code\" (#18783) at dotnet/coreclr","RelatedBody":"- Leftover from unobserved exception desktop quirk\r\n- Unnecessary calls to AppDomain.IsFinalizingForUnload(). They were actually never required even with AppDomain support because of Environment.HasShutdownStarted returns true during AppDomain unload."},{"Id":"7919780503","Type":"PullRequestEvent","CreatedAt":"2018-07-04T18:56:26","Actor":"ViktorHofer","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18652","RelatedDescription":"Merged pull request \"Add LastIndexOf compareoptions overload\" (#18652) at dotnet/coreclr","RelatedBody":"Relates to https://github.com/dotnet/corefx/issues/30649\r\n\r\nI mostly copied the existing implementations and changed to FIND_FROMEND. Please let me know if something is missing here."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7916191014","Type":"IssuesEvent","CreatedAt":"2018-07-04T04:36:15","Actor":"ramsubbaraoc","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/792","RelatedDescription":"Closed issue \"vs2017 csproj don't have <ItemGroup> <Compile/> tag\" (#792) at dotnet/standard","RelatedBody":"This is not an issue.Just for information\r\nWhen i create a netstandard project in VS2017, the csproj file doesn't contain the list of cs files which are part of the solution/project. \r\nOld csproj(which have been created using older VS version) contain the list of files and using that for command-line wasn't a problem\r\n\r\n If i have to use csproj/sln file(created with VS2017) to compile the code from command-line how do i do it?"},{"Id":"7911966456","Type":"IssuesEvent","CreatedAt":"2018-07-03T11:33:03","Actor":"ramsubbaraoc","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/792","RelatedDescription":"Opened issue \"vs2017 csproj don't have <ItemGroup> <Compile/> tag\" (#792) at dotnet/standard","RelatedBody":"This is not an issue.Just for information\r\nWhen i create a netstandard project in VS2017, the csproj file doesn't contain the list of cs files which are part of the solution/project. \r\nOld csproj(which have been created using older VS version) contain the list of files and using that for command-line wasn't a problem\r\n\r\n If i have to use csproj/sln file(created with VS2017) to compile the code from command-line how do i do it?"},{"Id":"7910306192","Type":"IssuesEvent","CreatedAt":"2018-07-03T05:19:07","Actor":"EEVblog","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/791","RelatedDescription":"Opened issue \"When Building a UWP app with .netstandard 2.0 and Compile With Native Tool Chain, Build Hangs forever\" (#791) at dotnet/standard","RelatedBody":"I have a project that I have released into the windows app store and have an update which included porting from xamarin forms project to a .net standard project.\r\n\r\nAfter porting the project I have found that any time I build the app with the:\r\n\r\n\"Compile with .NET Native tool chain\" checked the build hangs forever. It will hang on any platform when this item is checked.\r\n\r\nI have tried the following flags in an attempt to fix it in my project build settings:\r\n\r\n<ShortcutGenericAnalysis>true</ShortcutGenericAnalysis>\r\n<SingleThreadNUTC>true</SingleThreadNUTC>\r\n<Use64BitCompiler>true</Use64BitCompiler>\r\n\r\nI have tried deleting obj and bin folders, no success.\r\nI have all of the latest VS updates and the latest package updates. "},{"Id":"7909110492","Type":"IssuesEvent","CreatedAt":"2018-07-02T21:47:15","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/787","RelatedDescription":"Closed issue \"nsboard GitHub team is not public\" (#787) at dotnet/standard","RelatedBody":"> There is also a (public) GitHub team [nsboard](https://github.com/orgs/dotnet/teams/nsboard) you can\r\nuse when you want the board to take a look at a particular issue\r\n\r\nActually nsboard team is not public. Following the above link leads to:\r\n\r\n\r\n![nsboard](https://user-images.githubusercontent.com/801959/42095457-f63bf5a6-7bb2-11e8-8e98-dff65911b038.png)\r\n\r\n\r\n\r\n"},{"Id":"7909102076","Type":"IssuesEvent","CreatedAt":"2018-07-02T21:45:00","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/682","RelatedDescription":"Closed issue \".Net Standard 2.1?\" (#682) at dotnet/standard","RelatedBody":"_From @jherby2k on March 7, 2018 19:35_\n\nI can't find any information about a .net standard 2.1.\r\n\r\nI really want to use the new Span-ified methods like Stream.Read in my class libraries, but it looks like that stuff isn't in System.Memory but rather the .net core 2.1 SDK. Any other way to get these APIs, or do I have to wait for .net standard 2.1. And is there any ETA on that?\n\n_Copied from original issue: dotnet/coreclr#16806_"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7920655597","Type":"PullRequestEvent","CreatedAt":"2018-07-05T02:28:54","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30841","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#30841) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @stephentoub"},{"Id":"7920551030","Type":"PullRequestEvent","CreatedAt":"2018-07-05T01:40:39","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30841","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#30841) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7920388411","Type":"PullRequestEvent","CreatedAt":"2018-07-04T23:59:54","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30838","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#30838) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @ViktorHofer"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7920874889","Type":"PullRequestEvent","CreatedAt":"2018-07-05T04:08:06","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6054","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6054) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @stephentoub"},{"Id":"7920551269","Type":"PullRequestEvent","CreatedAt":"2018-07-05T01:40:45","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6054","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6054) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7920393965","Type":"PullRequestEvent","CreatedAt":"2018-07-05T00:03:28","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6053","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6053) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @ViktorHofer"},{"Id":"7919800939","Type":"PullRequestEvent","CreatedAt":"2018-07-04T19:04:25","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6053","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6053) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7919657671","Type":"PullRequestEvent","CreatedAt":"2018-07-04T18:09:03","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6047","RelatedDescription":"Merged pull request \"[Linux] Fix build for new clang versions\" (#6047) at dotnet/corert","RelatedBody":"@dotnet/arm32-corert-contrib please review"},{"Id":"7919581532","Type":"PullRequestEvent","CreatedAt":"2018-07-04T17:40:42","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6051","RelatedDescription":"Merged pull request \"Fix handling of StdCall intrinsic\" (#6051) at dotnet/corert","RelatedBody":"The Project N compiler only needs the prefix to match, so matching the behavior here. dotnet/csharplang#1685 can't come soon enough.\r\n\r\nhttps://github.com/dotnet/corert/blob/7246a7a5f32f44dc12b8a538383a4bbc7cc26d91/src/System.Private.Interop/src/Shared/McgIntrinsics.cs#L59-L67\r\n\r\nFixes #6042."},{"Id":"7919581519","Type":"IssuesEvent","CreatedAt":"2018-07-04T17:40:42","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/6042","RelatedDescription":"Closed issue \"Strange null ref in COM call\" (#6042) at dotnet/corert","RelatedBody":"After #5587 was fixed, I'm able to get much further with my project. Most everything works, but there's still some issues calling into SharpDX (or so it seems). I get a crash with this stack:\r\n\r\n```\r\nUnhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.\r\n   at Veldrid.D3D11.D3D11Swapchain..ctor(Device, SwapchainDescription&) + 0x342\r\n   at Veldrid.D3D11.D3D11GraphicsDevice..ctor(GraphicsDeviceOptions, Nullable`1) + 0x1e3\r\n   at Veldrid.GraphicsDevice.CreateD3D11(GraphicsDeviceOptions, IntPtr, UInt32, UInt32) + 0xfb\r\n   at Veldrid.StartupUtilities.VeldridStartup.CreateDefaultD3D11GraphicsDevice(GraphicsDeviceOptions, Sdl2Window) + 0x6e\r\n   at Veldrid.StartupUtilities.VeldridStartup.CreateGraphicsDevice(Sdl2Window, GraphicsDeviceOptions, GraphicsBackend) + 0x86\r\n   at SampleBase.VeldridStartupWindow.Run() + 0x9c\r\n   at Instancing.Program.Main(String[]) + 0x6d\r\n   at Instancing.Desktop!<BaseAddress>+0x4ad77a\r\n   at Instancing.Desktop!<BaseAddress>+0x4ad807\r\n```\r\n\r\nI believe that it's hitting a null ref [on this line](https://github.com/mellinoe/veldrid/blob/master/src/Veldrid/D3D11/D3D11Swapchain.cs#L88). `dxgiDevice` is null when it shouldn't be, and isn't when using CoreCLR. That query function shouldn't return null (it should throw instead), as far as I know.\r\n\r\nThe problem can be reprod by checking out the `corert-crash` branch of https://github.com/mellinoe/veldrid-samples/tree/corert-crash.\r\n\r\n`dotnet publish -r win-x64 src\\Instancing\\Desktop\\Instancing.Desktop.csproj`"},{"Id":"7918993434","Type":"IssuesEvent","CreatedAt":"2018-07-04T15:03:57","Actor":"benaadams","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/6052","RelatedDescription":"Opened issue \"Npgsql causes compilation to fail or infinite loop\" (#6052) at dotnet/corert","RelatedBody":"Npgsql 4.0.1 https://www.nuget.org/packages/Npgsql/ and using the `NpgsqlFactory.Instance` property causes compilation to fail\r\n\r\nSeems to be some type recursion?\r\n\r\n```\r\nEXEC : error : [TEMPORARY EXCEPTION MESSAGE] ClassLoadValueClassTooLarge:\r\nNpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<\r\n NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<\r\n NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<\r\n NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<\r\n NpgsqlTypes.NpgsqlRange`1<System.String>>>>>>>>>>>>>\r\n, Npgsql, Version=4.0.1.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7 [C:\\GitHub\\FrameworkBenchmarks\\frameworks\\CSharp\\aspnetcore-corert\\PlatformBenchmarks\\PlatformBenchmarks.csproj]\r\n  Internal.TypeSystem.TypeSystemException+TypeLoadException: [TEMPORARY EXCEPTION MESSAGE] ClassLoadValueClassTooLarge: NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<NpgsqlTypes.NpgsqlRange`1<System.String>>>>>>>>>>>>>, Npgsql, Version=4.0.1.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7\r\n     at Internal.TypeSystem.ThrowHelper.ThrowTypeLoadException(ExceptionStringID id, String typeName, String assemblyName)\r\n     at ILCompiler.DependencyAnalysis.EETypeNode.CheckCanGenerateEEType(NodeFactory factory, TypeDesc type)\r\n     at ILCompiler.DependencyAnalysis.NodeFactory.<CreateNodeCaches>b__36_1(TypeDesc type)\r\n     at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n     at ILCompiler.DependencyAnalysis.ReadyToRunGenericHelperNode.InstantiateDependencies(NodeFactory factory, Instantiation typeInstantiation, Instantiation methodInstantiation)\r\n     at ILCompiler.DependencyAnalysis.ShadowConcreteMethodNode.GetStaticDependencies(NodeFactory factory)\r\n     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.GetStaticDependenciesImpl(DependencyNodeCore`1 node)\r\n     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes()\r\n     at ILCompiler.ILScanner.ILCompiler.IILScanner.Scan()\r\n     at ILCompiler.Program.Run(String[] args)\r\n     at ILCompiler.Program.Main(String[] args)\r\n```\r\nIncluding it in the rd.xml\r\n```\r\n<Assembly Name=\"Npgsql\" Dynamic=\"Required All\" />\r\n```\r\nInstead seems like it infinite loops the compiler causing ever growing memory usage (killed it when if hit 5GB)"},{"Id":"7917658443","Type":"PullRequestEvent","CreatedAt":"2018-07-04T10:34:07","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6024","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#6024) at dotnet/corert","RelatedBody":""},{"Id":"7917632444","Type":"PullRequestEvent","CreatedAt":"2018-07-04T10:28:45","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6051","RelatedDescription":"Opened pull request \"Fix handling of StdCall intrinsic\" (#6051) at dotnet/corert","RelatedBody":"The Project N compiler only needs the prefix to match, so matching the behavior here. dotnet/csharplang#1685 can't come soon enough.\r\n\r\nhttps://github.com/dotnet/corert/blob/7246a7a5f32f44dc12b8a538383a4bbc7cc26d91/src/System.Private.Interop/src/Shared/McgIntrinsics.cs#L59-L67\r\n\r\nFixes #6042."},{"Id":"7917278728","Type":"PullRequestEvent","CreatedAt":"2018-07-04T09:20:52","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6050","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6050) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7917271437","Type":"PullRequestEvent","CreatedAt":"2018-07-04T09:19:34","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6050","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6050) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1013052742326280192","CreatedAt":"2018-06-30T13:32:50+00:00","UserScreenname":"dotnet","Text":"Tune in for Jeff's Saturday show, learn how to use C# and @ASPNET Core.  Always a good time https://t.co/KJoRPYHnHt","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":31,"FavoriteCount":8,"RawContent":null}]}},"RunOn":"2018-07-05T05:30:32.4024139Z","RunDurationInMilliseconds":6843}