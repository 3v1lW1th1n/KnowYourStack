{"Data":{"Blog":{"FeedItems":[{"Title":"Deprecating TLS 1.0 and 1.1 on NuGet.org","PublishedOn":"2019-11-15T18:58:33+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"co-authored by Scott Bommarito\nAt Microsoft, using the latest and secure encryption techniques is very important to us to ensure the security and privacy of our customers. TLS 1.0 and TLS 1.1,...","Href":"https://devblogs.microsoft.com/nuget/deprecating-tls-1-0-and-1-1-on-nuget-org/","RawContent":null},{"Title":"Deprecating packages on nuget.org","PublishedOn":"2019-09-30T18:29:23+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"We are excited to announce that nuget.org now supports package deprecation. This has been a long standing ask that will help the ecosystem use supported packages. As a package publisher on nuget.org,...","Href":"https://devblogs.microsoft.com/nuget/deprecating-packages-on-nuget-org/","RawContent":null},{"Title":"New and improved NuGet Search is here!","PublishedOn":"2019-08-23T03:31:26+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Itâ€™s been a long time coming, and today we are excited to announce the new and improved search on NuGet.org leveraging Azure Search. We want to start this post with a huge thanks to you, the NuGet...","Href":"https://devblogs.microsoft.com/nuget/new-and-improved-nuget-search/","RawContent":null},{"Title":"Surfacing GitHub Usage for packages on NuGet.org","PublishedOn":"2019-07-17T20:00:23+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"There are several criteria you can use today to evaluate NuGet packages. We received feedback that you would like even more information to help choose the right packages. We&#8217;re excited to...","Href":"https://devblogs.microsoft.com/nuget/surfacing-github-usage-for-packages-on-nuget-org/","RawContent":null},{"Title":"NuGet Spring 2019 Roadmap","PublishedOn":"2019-04-10T07:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"We published our last NuGet roadmap in June last year. Many of the features announced were major additions to NuGet and we have been hard at work to implement those over the last few months. In this...","Href":"https://devblogs.microsoft.com/nuget/nuget-spring-2019-roadmap/","RawContent":null},{"Title":"Enable repeatable package restores using a lock file","PublishedOn":"2018-12-17T08:00:00+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"With PackageReference, NuGet always tries to produce the same closure of package dependencies if the input package reference list has not changed. However, there are a few scenarios where it may not...","Href":"https://devblogs.microsoft.com/nuget/enable-repeatable-package-restores-using-a-lock-file/","RawContent":null},{"Title":"Lock down your dependencies using configurable trust policies","PublishedOn":"2018-12-05T08:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"For the past several months we have focused on various features to improve package security and trust. Around a year back, we had announced our plans on various signing functionalities that we have...","Href":"https://devblogs.microsoft.com/nuget/lock-down-your-dependencies-using-configurable-trust-policies/","RawContent":null},{"Title":"Improved package debugging experience with the NuGet.org symbol server","PublishedOn":"2018-11-16T08:00:00+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Starting today, you can publish symbol packages to the NuGet.org symbol server. With NuGet.org as a single service provider for libraries and symbols, package authors and consumers will have a...","Href":"https://devblogs.microsoft.com/nuget/improved-package-debugging-experience-with-the-nuget-org-symbol-server/","RawContent":null},{"Title":"Introducing Source Code Link for NuGet packages","PublishedOn":"2018-08-27T07:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"NuGet.org now supports surfacing source code repository link for NuGet packages. This will enable package authors to surface both the project&#8217;s website and the source repository using the...","Href":"https://devblogs.microsoft.com/nuget/introducing-source-code-link-for-nuget-packages/","RawContent":null},{"Title":"NuGet.org starts repo-signing packages","PublishedOn":"2018-08-10T07:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"In May, we implemented Stage 1 and enabled support for any NuGet.org user to submit signed packages to NuGet.org. Today, we are announcing Stage 2 of our NuGet package signing journey &#8211; tamper...","Href":"https://devblogs.microsoft.com/nuget/introducing-repository-signatures/","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"11102317477","Type":"IssuesEvent","CreatedAt":"2019-12-16T23:38:38","Actor":"agr","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7774","RelatedDescription":"Opened issue \"Gallery feedback button shifts all the content to the right\" (#7774) at NuGet/NuGetGallery","RelatedBody":"1. Go to https://dev.nugettest.org\r\n2. Click on the feedback button.\r\n\r\nNotice the content shifts right as the feedback dialog appears.\r\nAt the same time the feedback button gets partially obscured by the scrollbar:\r\n![image](https://user-images.githubusercontent.com/102933/70952086-1b734880-201a-11ea-964e-57f42fb9430a.png)\r\n"},{"Id":"11101943993","Type":"IssuesEvent","CreatedAt":"2019-12-16T22:34:26","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7773","RelatedDescription":"Opened issue \"dev branch of NuGetGallery is not emitting request or dependency telemetry in AI\" (#7773) at NuGet/NuGetGallery","RelatedBody":"customMetrics\r\n| where timestamp > ago(7d)\r\n| extend cloudDeploymentId = tostring(customDimensions.CloudDeploymentId)\r\n| where isnotempty(cloudDeploymentId)\r\n| summarize count() by bin(timestamp, 3h), cloudDeploymentId\r\n| render columnchart \r\n\r\n## requests\r\n\r\n![image](https://user-images.githubusercontent.com/94054/70948780-1067ea80-2011-11ea-98e5-5f7210427723.png)\r\n\r\n## dependencies\r\n\r\n![image](https://user-images.githubusercontent.com/94054/70948796-1b227f80-2011-11ea-8f01-59d2668cb9a2.png)\r\n\r\n## traces\r\n\r\n![image](https://user-images.githubusercontent.com/94054/70948811-207fca00-2011-11ea-8a5e-694240189135.png)\r\n\r\n## customMetrics\r\n\r\n![image](https://user-images.githubusercontent.com/94054/70948822-25447e00-2011-11ea-9179-45bb19bd21e6.png)\r\n\r\n"},{"Id":"11101607443","Type":"IssuesEvent","CreatedAt":"2019-12-16T21:49:04","Actor":"dannyvv","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7751","RelatedDescription":"Reopened issue \"[Proposal] Add api endpoint to retreive the list of files that are in each .nupkg archive\" (#7751) at NuGet/NuGetGallery","RelatedBody":"# Add api endpoint to retrieve the file list of a NuGet package\r\n\r\nThis is a proposal to expose the list of files (and their file sizes) on the NuGet server api.\r\n\r\n## Motivation\r\nThere are various use cases for having the list of files in a NuGet package. This proposal lists them in detail [below](#UsecasesofthisApi). This proposal is currently made to satisfy the need to optimize the build to avoid downloading all the packages before the build and have the build engine be the NuGet client that only download packages that are used by the build and the download happens interleaved during the build.\r\n\r\nThis might benefit other clients as well since if the list of files is exposed, one can create an implementation of [NuGet.Packaging.PackageReaderBase](https://github.com/NuGet/NuGet.Client/blob/48f67796ff38e98e3dfe4ab55fce000577b74fea/src/NuGet.Core/NuGet.Packaging/PackageReaderBase.cs) that doesn't need to download the whole .nupk file. It just needs to use this proposed api and the existing exposed [.nuspec](https://github.com/NuGet/docs.microsoft.com-nuget/blob/master/docs/api/package-base-address-resource.md#download-package-manifest-nuspec) file.\r\n\r\n## Spec\r\n\r\nThis will add a new endpoint on the [Package Content](https://docs.microsoft.com/en-us/nuget/api/package-base-address-resource) family of endpoints. \r\nThe spec already defines downloading of the [`.nupkg` file](https://docs.microsoft.com/en-us/nuget/api/package-base-address-resource#download-package-manifest-nuspec) and the [`.nuspec` file](https://docs.microsoft.com/en-us/nuget/api/package-base-address-resource#download-package-manifest-nuspec)\r\nThere also have been extensions proposed on this api for icons and licenses\r\n> Please correct me if I'm wrong on the extra ones...\r\n\r\nSo an extra entry here for a new JSON document with the following Package Content based URL:\r\n\r\n    GET {@id}/{LOWER_ID}/{LOWER_VERSION}/packageContents.json\r\n\r\nThis will return a json document which contains a property called `packageEntries`.\r\nThe `packageEntries` element is a JSON array of JSON objects, each object representing a `packageEntry`.\r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\npackageEntries          | array of object            | yes      | Each entry is a 'packageEntry'\r\n\r\nThe `packageEntry` leaf element is a JSON object with the following properties:\r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\nfullName                | string                     | yes      | The full relative path in the package.\r\nlength                  | integer                    | yes      | The size of the file in bytes |\r\n\r\nThe contents of `fullName` must use `/` as a path separator to match the paths for [IPackageCoreReader](https://github.com/NuGet/NuGet.Client/blob/f7e4a189c85fc6cfcc2d3f6b3d94079125adfe91/src/NuGet.Core/NuGet.Packaging/Core/IPackageCoreReader.cs)\r\n\r\nThe `fullName` must also match the final extracted layed out on disk format. NuGet uses custom path encoding in the zip files. The paths here should be unencoded i.e. the api should return: `lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.dll`, not `lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.dll` as it is in the zip file.\r\n\r\n> I chose to use the names currently exposed on nuget.org. As in this [sample](https://api.nuget.org/v3/catalog0/data/2018.10.15.01.11.37/newtonsoft.json.3.5.8.json). I have no preference for any naming scheme here.\r\n\r\n> The zip archive stores extra fields. The current nuget.org [packageEntries field](https://api.nuget.org/v3/catalog0/data/2018.10.15.01.11.37/newtonsoft.json.3.5.8.json) exposes these extra fields as well. They are not strictly necesary for the use cases below, but they might be useful. I have left them off for now to make it easier for implementors.\r\n\r\n\r\n\r\n> This option hopefully should not add too much of a burden to existing service implementation as sibling field  `dependencyGroups` is exposed here which is only available in the 'nuspec' file, which has to be extracted from the full zip file that is uploaded.\r\n\r\n## Sample request\r\n\r\n    GET https://api.nuget.org/v3-flatcontainer/newtonsoft.json/6.0.4/packageContents.json\r\n\r\n```json\r\n{\r\n  \"count\": 19,\r\n  \"packageEntries\": [\r\n    {\r\n      \"fullName\": \"_rels/.rels\",\r\n      \"length\": 500\r\n    },\r\n    {\r\n      \"fullName\": \"Newtonsoft.Json.nuspec\",\r\n      \"length\": 682\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net20/Newtonsoft.Json.dll\",\r\n      \"length\": 493056\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net20/Newtonsoft.Json.xml\",\r\n      \"length\": 516034\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net35/Newtonsoft.Json.dll\",\r\n      \"length\": 430080\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net35/Newtonsoft.Json.xml\",\r\n      \"length\": 459802\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net40/Newtonsoft.Json.dll\",\r\n      \"length\": 493056\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net40/Newtonsoft.Json.xml\",\r\n      \"length\": 478726\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net45/Newtonsoft.Json.dll\",\r\n      \"length\": 502272\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net45/Newtonsoft.Json.xml\",\r\n      \"length\": 478726\r\n    },\r\n    {\r\n      \"fullName\": \"lib/netcore45/Newtonsoft.Json.dll\",\r\n      \"length\": 446976\r\n    },\r\n    {\r\n      \"fullName\": \"lib/netcore45/Newtonsoft.Json.xml\",\r\n      \"length\": 448530\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.dll\",\r\n      \"length\": 387072\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.xml\",\r\n      \"length\": 425586\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net45+wp80+win8+wpa81/Newtonsoft.Json.dll\",\r\n      \"length\": 444928\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net45+wp80+win8+wpa81/Newtonsoft.Json.xml\",\r\n      \"length\": 448549\r\n    },\r\n    {\r\n      \"fullName\": \"tools/install.ps1\",\r\n      \"length\": 3229\r\n    },\r\n    {\r\n      \"fullName\": \"package/services/metadata/core-properties/87a0a4e28d50417ea282e20f81bc6477.psmdcp\",\r\n      \"length\": 735\r\n    },\r\n    {\r\n      \"fullName\": \"[Content_Types].xml\",\r\n      \"length\": 566\r\n    },\r\n    {\r\n      \"fullName\": \".signature.p7s\",\r\n      \"length\": 9463\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n> ### Alternative way to expose the data:\r\n> Expose the `packageContents` leaf element on the [package details catalog items](https://docs.microsoft.com/en-us/> nuget/api/catalog-resource#item-types). Since this is a new introduction it would have to be an > optional element, if we ref.\r\n> > This option hopefully should not add too much of a burden to existing service implementation as\r\n> > sibling property `dependencyGroups` is exposed here which is only available in the 'nuspec' file, which > has to be extracted from the full zip file that is uploaded.\r\n\r\n\r\n## Use cases of this Api\r\n### Build engines with fine grained dependency management\r\nBuild engines with fine grained dependency management like [BuildXL](https://github.com/microsoft/buildxl) and [Bazel](bazel.io) and static graphs can benefit from having detailed file information from a NuGet package without downloading the package. \r\n\r\nFor these kind of build engines if during graph construction they can only download the metadata from the package to obtain its semantics (i.e. for NuGet this is encoded in the nuspec and the folder structure on disk inside the NuGet ) \r\n*without* fully downloading the zip file. These build engines can highly optimize the download and extraction of the consumed packages. \r\n\r\nFrequently one doesn't build the entire tree and pass a 'filter expression' to the build. By either building only certain projects and their downstream dependents and/or upstream dependencies. Filter by a particular aspect like: codegen, compile, build, test, packaging. etc. Or for particular platforms or configurations. This allows the engine to optimize and not download any packages that are not needed by the current build. \r\n\r\nSince these engines work with fine grained file dependencies they can ensure the packages are downloaded 'just in time' when the dependents actually need them. For example usually the first unittest starts somewhere half way during the build since they need to wait until some of their code dependencies are compiled, the engine can delay downloading of the packages needed to run the unittests until there are resources available or they are really needed to make build progress.\r\n\r\nThese engines have highly optimized schedulers that try to maximize the machine utilization but not overload it. They are great at mixing CPU heavy jobs with IO heavy operations to reduce overall build times. Package restore is usually pretty IO heavy, so the engine can interleave CPU heavy tasks like C++ compilation with the downloading of the packages.\r\n\r\nThese engines also tend to work distributed. I.e. the build is spread over more than one computer (workers). Currently if the restore has to happen before the build, the restore typically happens on every computer that is part of a distributed build. This can be up to 25 machines for large builds. This causes packages that are only used by one project to be downloaded on every worker machine, where they are only consumed on a single machine where that one job that needs it is run. \r\nHaving the engine control the download of the package allows the engine to optimize this and only download the packages as needed on machines and can even optimize the distribution which jobs run on which machines to optimize \r\n\r\n### Virtual file system package client\r\nVirtual File System implementations are getting traction across various platforms: \r\n* [ProjFs](https://github.com/microsoft/ProjFS-Managed-API)\r\n* [FUSE](https://github.com/libfuse/libfuse)\r\n\r\nVarious dev experiences have been built on top of these virtual file systems. These vary from complete dev environments being virtualized for source, packages intermediates and outputs. To just certain components like just the source files. For example [VfsForGit](https://github.com/Microsoft/VFSForGit). \r\n\r\nOne can envision a similar implementation for NuGet packages as well. Where the client on restore would lay out virtual entry points for the expanded packages on disk without downloading the full archive. When any of the files for a given package would be accessed by any client the virtual filesystem implementation could only then download that particular nupkg archive and extract it and place it on disk.\r\nThis would reduce the number of downloads\r\n\r\n### Reverse file lookup helpers\r\nOne can envision a search tool that tries to find files in NuGet packages. For example to answer the question: Which packages have: `System.Net.Http.dll` embedded? Hint: There are many :)\r\nToday that search operation would have to pull all .nupkg files from the server.\r\n\r\n## Workarounds\r\nThe workaround for not having this api is to partially download the zip file and extract the file list from there. This would be pretty easy to do if the zip file had the file header at the start of the file, but the [zip file format](https://en.wikipedia.org/wiki/Zip_(file_format)) has the file manifest at the end of the file. Therefore one has to use [HTTP range](https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.12) queries. This is all doable like it is done in [MiniZip](https://github.com/joelverhagen/MiniZip) but one has to either redo all the authentication logic and throttling logic that is implemented in [Nuget.Packaging](https://github.com/NuGet/NuGet.Client/tree/dev/src/NuGet.Core/NuGet.Packaging) or extend Nuget.Packaging to support this.\r\nOne can also assume that there might be extra server load as one needs to download more chunks from the zip file that strictly is encoded in the file table and the server implementation might not be as efficient as downloading a single resource and the range operations likely will bypass any caching layers on the HTTP stack.\r\n\r\n## Potential Future extensions\r\n### Include file hash\r\n> Note: this is not a request, and I realize this can be expensive. Merely hypothesizing for future use cases\r\n\r\nIf in the future the each file in the returned file list could also carry an optional content hash (which algo tbd). \r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\nfileHash                | string                     | no       | The hash of the file, encoding using [standard base 64](https://tools.ietf.org/html/rfc4648#section-4)\r\nfileHashAlgorithm       | string                     | no       |\r\n\r\n> Potentially the fileHashAlgorithm can be a property of `packageContents` to not have to replicate it so many times.\r\n\r\nThis can help build engines with reliable cache implementations to perform cache lookups without having to download the nupkg as well. This will allow them to check if they have the results in the cache. \r\nFor example if a NuGet package contains 'system.xyz.dll' with hash 'hXYZ' and it takes file 'a.cs' with hash 'hACS'. A  build engine with a cache can check to see if the local cache (or the remote shared cache) already contains the output file 'a.dll' further reducing NuGet downloads.\r\n\r\n### Individual file download\r\n> Note: this is not a request, and I realize this can be expensive. Merely hypothesizing for future use cases\r\n\r\nOften only a few files are needed from a package. Build engines (or NuGet clients) could decide to optimize their workflow by either downloading an individual file(s), or the whole archive.\r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\ndownloadUrl             | string                     | no       | The url where this file can be downloaded from\r\n"},{"Id":"11101606070","Type":"IssuesEvent","CreatedAt":"2019-12-16T21:48:52","Actor":"dannyvv","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7751","RelatedDescription":"Closed issue \"[Proposal] Add api endpoint to retreive the list of files that are in each .nupkg archive\" (#7751) at NuGet/NuGetGallery","RelatedBody":"# Add api endpoint to retrieve the file list of a NuGet package\r\n\r\nThis is a proposal to expose the list of files (and their file sizes) on the NuGet server api.\r\n\r\n## Motivation\r\nThere are various use cases for having the list of files in a NuGet package. This proposal lists them in detail [below](#UsecasesofthisApi). This proposal is currently made to satisfy the need to optimize the build to avoid downloading all the packages before the build and have the build engine be the NuGet client that only download packages that are used by the build and the download happens interleaved during the build.\r\n\r\nThis might benefit other clients as well since if the list of files is exposed, one can create an implementation of [NuGet.Packaging.PackageReaderBase](https://github.com/NuGet/NuGet.Client/blob/48f67796ff38e98e3dfe4ab55fce000577b74fea/src/NuGet.Core/NuGet.Packaging/PackageReaderBase.cs) that doesn't need to download the whole .nupk file. It just needs to use this proposed api and the existing exposed [.nuspec](https://github.com/NuGet/docs.microsoft.com-nuget/blob/master/docs/api/package-base-address-resource.md#download-package-manifest-nuspec) file.\r\n\r\n## Spec\r\n\r\nThis will add a new endpoint on the [Package Content](https://docs.microsoft.com/en-us/nuget/api/package-base-address-resource) family of endpoints. \r\nThe spec already defines downloading of the [`.nupkg` file](https://docs.microsoft.com/en-us/nuget/api/package-base-address-resource#download-package-manifest-nuspec) and the [`.nuspec` file](https://docs.microsoft.com/en-us/nuget/api/package-base-address-resource#download-package-manifest-nuspec)\r\nThere also have been extensions proposed on this api for icons and licenses\r\n> Please correct me if I'm wrong on the extra ones...\r\n\r\nSo an extra entry here for a new JSON document with the following Package Content based URL:\r\n\r\n    GET {@id}/{LOWER_ID}/{LOWER_VERSION}/packageContents.json\r\n\r\nThis will return a json document which contains a property called `packageEntries`.\r\nThe `packageEntries` element is a JSON array of JSON objects, each object representing a `packageEntry`.\r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\npackageEntries          | array of object            | yes      | Each entry is a 'packageEntry'\r\n\r\nThe `packageEntry` leaf element is a JSON object with the following properties:\r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\nfullName                | string                     | yes      | The full relative path in the package.\r\nlength                  | integer                    | yes      | The size of the file in bytes |\r\n\r\nThe contents of `fullName` must use `/` as a path separator to match the paths for [IPackageCoreReader](https://github.com/NuGet/NuGet.Client/blob/f7e4a189c85fc6cfcc2d3f6b3d94079125adfe91/src/NuGet.Core/NuGet.Packaging/Core/IPackageCoreReader.cs)\r\n\r\nThe `fullName` must also match the final extracted layed out on disk format. NuGet uses custom path encoding in the zip files. The paths here should be unencoded i.e. the api should return: `lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.dll`, not `lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.dll` as it is in the zip file.\r\n\r\n> I chose to use the names currently exposed on nuget.org. As in this [sample](https://api.nuget.org/v3/catalog0/data/2018.10.15.01.11.37/newtonsoft.json.3.5.8.json). I have no preference for any naming scheme here.\r\n\r\n> The zip archive stores extra fields. The current nuget.org [packageEntries field](https://api.nuget.org/v3/catalog0/data/2018.10.15.01.11.37/newtonsoft.json.3.5.8.json) exposes these extra fields as well. They are not strictly necesary for the use cases below, but they might be useful. I have left them off for now to make it easier for implementors.\r\n\r\n\r\n\r\n> This option hopefully should not add too much of a burden to existing service implementation as sibling field  `dependencyGroups` is exposed here which is only available in the 'nuspec' file, which has to be extracted from the full zip file that is uploaded.\r\n\r\n## Sample request\r\n\r\n    GET https://api.nuget.org/v3-flatcontainer/newtonsoft.json/6.0.4/packageContents.json\r\n\r\n```json\r\n{\r\n  \"count\": 19,\r\n  \"packageEntries\": [\r\n    {\r\n      \"fullName\": \"_rels/.rels\",\r\n      \"length\": 500\r\n    },\r\n    {\r\n      \"fullName\": \"Newtonsoft.Json.nuspec\",\r\n      \"length\": 682\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net20/Newtonsoft.Json.dll\",\r\n      \"length\": 493056\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net20/Newtonsoft.Json.xml\",\r\n      \"length\": 516034\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net35/Newtonsoft.Json.dll\",\r\n      \"length\": 430080\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net35/Newtonsoft.Json.xml\",\r\n      \"length\": 459802\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net40/Newtonsoft.Json.dll\",\r\n      \"length\": 493056\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net40/Newtonsoft.Json.xml\",\r\n      \"length\": 478726\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net45/Newtonsoft.Json.dll\",\r\n      \"length\": 502272\r\n    },\r\n    {\r\n      \"fullName\": \"lib/net45/Newtonsoft.Json.xml\",\r\n      \"length\": 478726\r\n    },\r\n    {\r\n      \"fullName\": \"lib/netcore45/Newtonsoft.Json.dll\",\r\n      \"length\": 446976\r\n    },\r\n    {\r\n      \"fullName\": \"lib/netcore45/Newtonsoft.Json.xml\",\r\n      \"length\": 448530\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.dll\",\r\n      \"length\": 387072\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net40+sl5+wp80+win8+wpa81/Newtonsoft.Json.xml\",\r\n      \"length\": 425586\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net45+wp80+win8+wpa81/Newtonsoft.Json.dll\",\r\n      \"length\": 444928\r\n    },\r\n    {\r\n      \"fullName\": \"lib/portable-net45+wp80+win8+wpa81/Newtonsoft.Json.xml\",\r\n      \"length\": 448549\r\n    },\r\n    {\r\n      \"fullName\": \"tools/install.ps1\",\r\n      \"length\": 3229\r\n    },\r\n    {\r\n      \"fullName\": \"package/services/metadata/core-properties/87a0a4e28d50417ea282e20f81bc6477.psmdcp\",\r\n      \"length\": 735\r\n    },\r\n    {\r\n      \"fullName\": \"[Content_Types].xml\",\r\n      \"length\": 566\r\n    },\r\n    {\r\n      \"fullName\": \".signature.p7s\",\r\n      \"length\": 9463\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n> ### Alternative way to expose the data:\r\n> Expose the `packageContents` leaf element on the [package details catalog items](https://docs.microsoft.com/en-us/> nuget/api/catalog-resource#item-types). Since this is a new introduction it would have to be an > optional element, if we ref.\r\n> > This option hopefully should not add too much of a burden to existing service implementation as\r\n> > sibling property `dependencyGroups` is exposed here which is only available in the 'nuspec' file, which > has to be extracted from the full zip file that is uploaded.\r\n\r\n\r\n## Use cases of this Api\r\n### Build engines with fine grained dependency management\r\nBuild engines with fine grained dependency management like [BuildXL](https://github.com/microsoft/buildxl) and [Bazel](bazel.io) and static graphs can benefit from having detailed file information from a NuGet package without downloading the package. \r\n\r\nFor these kind of build engines if during graph construction they can only download the metadata from the package to obtain its semantics (i.e. for NuGet this is encoded in the nuspec and the folder structure on disk inside the NuGet ) \r\n*without* fully downloading the zip file. These build engines can highly optimize the download and extraction of the consumed packages. \r\n\r\nFrequently one doesn't build the entire tree and pass a 'filter expression' to the build. By either building only certain projects and their downstream dependents and/or upstream dependencies. Filter by a particular aspect like: codegen, compile, build, test, packaging. etc. Or for particular platforms or configurations. This allows the engine to optimize and not download any packages that are not needed by the current build. \r\n\r\nSince these engines work with fine grained file dependencies they can ensure the packages are downloaded 'just in time' when the dependents actually need them. For example usually the first unittest starts somewhere half way during the build since they need to wait until some of their code dependencies are compiled, the engine can delay downloading of the packages needed to run the unittests until there are resources available or they are really needed to make build progress.\r\n\r\nThese engines have highly optimized schedulers that try to maximize the machine utilization but not overload it. They are great at mixing CPU heavy jobs with IO heavy operations to reduce overall build times. Package restore is usually pretty IO heavy, so the engine can interleave CPU heavy tasks like C++ compilation with the downloading of the packages.\r\n\r\nThese engines also tend to work distributed. I.e. the build is spread over more than one computer (workers). Currently if the restore has to happen before the build, the restore typically happens on every computer that is part of a distributed build. This can be up to 25 machines for large builds. This causes packages that are only used by one project to be downloaded on every worker machine, where they are only consumed on a single machine where that one job that needs it is run. \r\nHaving the engine control the download of the package allows the engine to optimize this and only download the packages as needed on machines and can even optimize the distribution which jobs run on which machines to optimize \r\n\r\n### Virtual file system package client\r\nVirtual File System implementations are getting traction across various platforms: \r\n* [ProjFs](https://github.com/microsoft/ProjFS-Managed-API)\r\n* [FUSE](https://github.com/libfuse/libfuse)\r\n\r\nVarious dev experiences have been built on top of these virtual file systems. These vary from complete dev environments being virtualized for source, packages intermediates and outputs. To just certain components like just the source files. For example [VfsForGit](https://github.com/Microsoft/VFSForGit). \r\n\r\nOne can envision a similar implementation for NuGet packages as well. Where the client on restore would lay out virtual entry points for the expanded packages on disk without downloading the full archive. When any of the files for a given package would be accessed by any client the virtual filesystem implementation could only then download that particular nupkg archive and extract it and place it on disk.\r\nThis would reduce the number of downloads\r\n\r\n### Reverse file lookup helpers\r\nOne can envision a search tool that tries to find files in NuGet packages. For example to answer the question: Which packages have: `System.Net.Http.dll` embedded? Hint: There are many :)\r\nToday that search operation would have to pull all .nupkg files from the server.\r\n\r\n## Workarounds\r\nThe workaround for not having this api is to partially download the zip file and extract the file list from there. This would be pretty easy to do if the zip file had the file header at the start of the file, but the [zip file format](https://en.wikipedia.org/wiki/Zip_(file_format)) has the file manifest at the end of the file. Therefore one has to use [HTTP range](https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.12) queries. This is all doable like it is done in [MiniZip](https://github.com/joelverhagen/MiniZip) but one has to either redo all the authentication logic and throttling logic that is implemented in [Nuget.Packaging](https://github.com/NuGet/NuGet.Client/tree/dev/src/NuGet.Core/NuGet.Packaging) or extend Nuget.Packaging to support this.\r\nOne can also assume that there might be extra server load as one needs to download more chunks from the zip file that strictly is encoded in the file table and the server implementation might not be as efficient as downloading a single resource and the range operations likely will bypass any caching layers on the HTTP stack.\r\n\r\n## Potential Future extensions\r\n### Include file hash\r\n> Note: this is not a request, and I realize this can be expensive. Merely hypothesizing for future use cases\r\n\r\nIf in the future the each file in the returned file list could also carry an optional content hash (which algo tbd). \r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\nfileHash                | string                     | no       | The hash of the file, encoding using [standard base 64](https://tools.ietf.org/html/rfc4648#section-4)\r\nfileHashAlgorithm       | string                     | no       |\r\n\r\n> Potentially the fileHashAlgorithm can be a property of `packageContents` to not have to replicate it so many times.\r\n\r\nThis can help build engines with reliable cache implementations to perform cache lookups without having to download the nupkg as well. This will allow them to check if they have the results in the cache. \r\nFor example if a NuGet package contains 'system.xyz.dll' with hash 'hXYZ' and it takes file 'a.cs' with hash 'hACS'. A  build engine with a cache can check to see if the local cache (or the remote shared cache) already contains the output file 'a.dll' further reducing NuGet downloads.\r\n\r\n### Individual file download\r\n> Note: this is not a request, and I realize this can be expensive. Merely hypothesizing for future use cases\r\n\r\nOften only a few files are needed from a package. Build engines (or NuGet clients) could decide to optimize their workflow by either downloading an individual file(s), or the whole archive.\r\n\r\nName                    | Type                       | Required | Notes\r\n----------------------- | -------------------------- | -------- | -----\r\ndownloadUrl             | string                     | no       | The url where this file can be downloaded from\r\n"},{"Id":"11100566045","Type":"IssuesEvent","CreatedAt":"2019-12-16T19:29:26","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7717","RelatedDescription":"Closed issue \"[Deployment] Week of 2019-12-09\" (#7717) at NuGet/NuGetGallery","RelatedBody":"# Catalog2icon\r\n\r\nRelease: [525397](https://devdiv.visualstudio.com/DevDiv/_releaseProgress?_a=release-pipeline-progress&releaseId=525397)\r\n\r\n- [x] DEV\r\n- [x] Merge dev -> master\r\n  - https://github.com/NuGet/NuGet.Services.Metadata/pull/698\r\n- [x] INT\r\n- [x] PROD\r\n\r\n# NuGetGallery\r\n\r\n(Run migration against DB to apply \"201911160032363_AddCredentialRevocationSourceKeyColumn\" )\r\n\r\nGallery service build: [3311390](https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=3311390&view=logs&j=fd490c07-0b22-5182-fac9-6d67fe1e939b&t=70b92200-87db-50c8-35f9-975ba5f9e5b7)\r\nGallery job build: [3311389](https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=3311389&view=results)\r\n\r\nMigration release: [530849](https://devdiv.visualstudio.com/DevDiv/_releaseProgress?_a=release-pipeline-progress&releaseId=530849)\r\nGallery release: [530856](https://devdiv.visualstudio.com/DevDiv/_releaseProgress?_a=release-pipeline-progress&releaseId=530856)\r\n\r\n- [x] DEV\r\n- [x] Merge dev -> master\r\n  - https://github.com/NuGet/NuGetGallery/pull/7722\r\n  - Hotfix: https://github.com/NuGet/NuGetGallery/pull/7731\r\n  - Hotfix: https://github.com/NuGet/NuGetGallery/pull/7750\r\n- [x] INT\r\n- [x] PROD\r\n\r\n# Azure Search Service\r\n\r\nBuild: [3310662](https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=3310662)\r\nRelease: [530599](https://devdiv.visualstudio.com/DevDiv/_releaseProgress?_a=release-pipeline-progress&releaseId=530599)\r\n\r\n- [x] DEV\r\n- [x] INT\r\n- [x] PROD"},{"Id":"11096179031","Type":"PullRequestEvent","CreatedAt":"2019-12-16T10:36:29","Actor":"SimonCropp","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/7772","RelatedDescription":"Opened pull request \"WIP: Remove semver2 warning\" (#7772) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"11087795232","Type":"IssuesEvent","CreatedAt":"2019-12-14T05:16:13","Actor":"skofman1","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7748","RelatedDescription":"Closed issue \"I Can't delete a new create package\" (#7748) at NuGet/NuGetGallery","RelatedBody":"@LuGuangguang commented on [Tue Nov 26 2019](https://github.com/NuGet/Home/issues/8859)\n\nI learn to how to create a package.When I had public a package,I want to delete this. But I can't by the URL \"https://docs.microsoft.com/zh-cn/nuget/quickstart/create-and-publish-a-package-using-visual-studio-net-framework\".This is no the delete button.\r\n \r\nthis doc\r\n![PHZE(IIAT (%RF51${(RNDR](https://user-images.githubusercontent.com/34500722/69702479-47da2a00-112a-11ea-916c-46b7e5464878.jpg)\r\n\r\nthis my project\r\n![L9%FP{ AT56MX)A80PD@3EV](https://user-images.githubusercontent.com/34500722/69702619-98ea1e00-112a-11ea-910e-246141aae206.png)\r\n\r\nThank you!\r\n\r\n\r\n\r\n\n\n"},{"Id":"11087754622","Type":"IssuesEvent","CreatedAt":"2019-12-14T04:52:33","Actor":"skofman1","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7759","RelatedDescription":"Closed issue \"The package does not pass validation\" (#7759) at NuGet/NuGetGallery","RelatedBody":"### Describe the bug\r\nThe project has been published many times and is stuck in the Validating step. I don't know why. This is just a small class library\r\n\r\n\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\n1. The source address\r\n\r\nhttps://github.com/zhenlei520/System.Extension.Core/tree/release/features-2.0\r\n\r\n2. Release package details\r\n\r\nhttps://www.nuget.org/packages/EInfrastructure.Core.ServiceDiscovery.Consul.AspNetCore/\r\nhttps://www.nuget.org/packages/EInfrastructure.Core.Config.IdentificationExtensions/\r\n\r\n![image](https://user-images.githubusercontent.com/9740886/70515068-ac0bdd80-1b6f-11ea-848a-fd67fec02f46.png)\r\n![image](https://user-images.githubusercontent.com/9740886/70515110-bd54ea00-1b6f-11ea-96d6-310e90e17f19.png)\r\n\r\n\r\n"},{"Id":"11087752936","Type":"IssuesEvent","CreatedAt":"2019-12-14T04:51:36","Actor":"skofman1","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/7760","RelatedDescription":"Closed issue \"Show license from README.md file\" (#7760) at NuGet/NuGetGallery","RelatedBody":"### Is your feature request related to a problem? Please describe.\r\nThere is a package where NuGet doesn't show license https://www.nuget.org/packages/DNS/.\r\n[README.md](https://github.com/kapetan/dns/blob/master/README.md#license) has the license inside.\r\n\r\n### Describe the solution you'd like\r\nShow license in NuGet gallery\r\n\r\n### Additional context\r\n![image](https://user-images.githubusercontent.com/580536/70518186-97fdb700-1b42-11ea-8ea8-773ea6f177e2.png)\r\n![image](https://user-images.githubusercontent.com/580536/70518204-a0ee8880-1b42-11ea-8968-ddf97dc3f525.png)\r\n"},{"Id":"11087663010","Type":"PullRequestEvent","CreatedAt":"2019-12-14T03:58:48","Actor":"zhhyu","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/7771","RelatedDescription":"Opened pull request \"[Token Scanning-Phase 1] Robust UI\" (#7771) at NuGet/NuGetGallery","RelatedBody":"The PR is to fix the following issues:\r\n1. Break the word\r\n![image](https://user-images.githubusercontent.com/41028779/70843124-f4323680-1de1-11ea-950b-f257f8b397c8.png)\r\n\r\n2. Clicking the 'Verify' button should clean up the last action message. \r\n"},{"Id":"11087550088","Type":"PullRequestEvent","CreatedAt":"2019-12-14T02:57:46","Actor":"agr","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/7770","RelatedDescription":"Opened pull request \"Build extensions targets file for build pipelines\" (#7770) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/Engineering/issues/2883\r\n\r\nThis adds an optional point to insert targets file during the build."}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"11102926489","Type":"PullRequestEvent","CreatedAt":"2019-12-17T01:53:01","Actor":"cristinamanum","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/pull/8950","RelatedDescription":"Opened pull request \"Move the spec from Client.Engineering PR: https://github.com/NuGet/Clâ€¦\" (#8950) at NuGet/Home","RelatedBody":"Move the spec from the  Client.Engineering\r\nPR: https://github.com/NuGet/Client.Engineering/pull/112"},{"Id":"11102738451","Type":"IssuesEvent","CreatedAt":"2019-12-17T01:10:23","Actor":"donnie-msft","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8949","RelatedDescription":"Opened issue \"Linux FuncTests should run against dotnet 3.1 not 2.2\" (#8949) at NuGet/Home","RelatedBody":"Recent temporary workaround resulted in dotnet 3.1 not running against our Functional Tests on Linux. dotnet 2.2 is currently being used."},{"Id":"11102437519","Type":"IssuesEvent","CreatedAt":"2019-12-17T00:03:08","Actor":"Liturgist","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8948","RelatedDescription":"Opened issue \"Github as a PSRepository?\" (#8948) at NuGet/Home","RelatedBody":"We have a local Enterprise GitHub instance. We would like to make use of standard installation tools for both PowerShell and Python code. We want to install only what is needed and not replicate the entire project repository onto every machine that will run the code.\r\n\r\nIt appears that we could create a local Enterprise NuGet server. Is that needed?\r\n\r\nWhere can I find information on publishing a GitHub project to NuGet?\r\n\r\nCan GitHub act as a PSRepository which would make PowerShellGet commands see it as a PSRepository?\r\n\r\nWe need to do the same thing for Python applications and modules? Can a NuGet server act as a repository for Python installations? Or, is there a way to publish a GitHub project to PyPI?"},{"Id":"11101596034","Type":"IssuesEvent","CreatedAt":"2019-12-16T21:47:31","Actor":"rrelyea","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/8945","RelatedDescription":"Closed issue \"Update dashboards to 15.9-16.3-16.4\" (#8945) at NuGet/Home","RelatedBody":"PR: https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_git/VSTelemetryDashboards/pullrequest/219038?_a=overview"},{"Id":"11100535436","Type":"IssuesEvent","CreatedAt":"2019-12-16T19:25:20","Actor":"nkolev92","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8947","RelatedDescription":"Opened issue \"Port the dev guide to GitHub\" (#8947) at NuGet/Home","RelatedBody":"Right now it's a One Note. \r\nIt's more useful in the repo in some sort of a doc. "},{"Id":"11100523189","Type":"IssuesEvent","CreatedAt":"2019-12-16T19:23:41","Actor":"rrelyea","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8946","RelatedDescription":"Opened issue \"Improve NU1105\" (#8946) at NuGet/Home","RelatedBody":"Looking at newest telemetry, @nkolev92 noticed that NU1105 has dropped in frequency since the 16.0 feature supporting Solution Filters and unloaded projects. I've improved the doc page here so people know about the new feature and how to get out of this problem.\n\nPR to fix docs: https://github.com/NuGet/docs.microsoft.com-nuget/pull/1815"},{"Id":"11100509718","Type":"IssuesEvent","CreatedAt":"2019-12-16T19:21:53","Actor":"heng-liu","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/8835","RelatedDescription":"Closed issue \"retarget signing/verification project to netcoreapp5.0\" (#8835) at NuGet/Home","RelatedBody":"retarget to netcoreapp5.0  and fix all broken tests."},{"Id":"11100121320","Type":"IssuesEvent","CreatedAt":"2019-12-16T18:29:14","Actor":"rrelyea","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8945","RelatedDescription":"Opened issue \"Update dashboards to 15.9-16.3-16.4\" (#8945) at NuGet/Home","RelatedBody":"PR: https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_git/VSTelemetryDashboards/pullrequest/219038?_a=overview"},{"Id":"11099047877","Type":"IssuesEvent","CreatedAt":"2019-12-16T16:16:59","Actor":"kesso1","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8944","RelatedDescription":"Opened issue \"Visual Studio 2019: Error Installing Nuget Packages\" (#8944) at NuGet/Home","RelatedBody":"I receive the following error when trying to download new nuget packages in Visual Studio 2019:\r\n\r\nSeverity\tCode\tDescription\tProject\tFile\tLine\tSuppression State\r\nError\tNU3000\tSigned package validation failed with multiple errors:\r\nNU3018: Package 'Microsoft.CSharp 4.7.0' from source 'https://api.nuget.org/v3/index.json': The author primary signature found a chain building issue: A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.\r\nNU3018: Package 'Microsoft.CSharp 4.7.0' from source 'https://api.nuget.org/v3/index.json': The repository countersignature found a chain building issue: A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.\t\t\t\t\r\n\r\nDoes anyone experienced this Problem?"},{"Id":"11097623352","Type":"IssuesEvent","CreatedAt":"2019-12-16T13:44:06","Actor":"onovotny","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/8943","RelatedDescription":"Opened issue \"Incorrect NU5131 error with MSAL\" (#8943) at NuGet/Home","RelatedBody":"Please read the following information before posting the issue.\r\n\r\n## Details about Problem\r\n\r\nmsbuild /t:pack\r\n\r\n\r\ndotnet.exe --version (if appropriate): 3.1.100\r\n\r\nVS version (if appropriate): VS 16.5\r\n\r\n\r\nWorked before? If so, with which NuGet version: dotnet sdk 2.2\r\n\r\n## Detailed repro steps so we can see the same problem\r\n\r\nIt appears that the validation rule added in https://github.com/NuGet/Home/issues/8296 isn't correctly validating packages created by the SDK Extras. We see \r\n\r\n```\r\nC:\\Program Files\\dotnet\\sdk\\3.1.100\\Sdks\\NuGet.Build.Tasks.Pack\\buildCrossTargeting\\NuGet.Build.Tasks.Pack.targets(198,5): error NU5131: References were found in the nuspec, but some reference assemblies were not found in both the nuspec and ref folder. Add the following reference assemblies:\r\n- Add Microsoft.Identity.Client.dll to the monoandroid90 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the monoandroid90 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.dll to the net45 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the net45 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.dll to the netcoreapp2.1 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the netcoreapp2.1 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.dll to the netstandard1.3 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the netstandard1.3 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.dll to the uap10.0 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the uap10.0 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.dll to the xamarinios10 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the xamarinios10 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.dll to the xamarinmac20 reference group in the nuspec\r\n- Add Microsoft.Identity.Client.xml to the xamarinmac20 reference group in the nuspec\r\n [D:\\dev\\microsoft-authentication-library-for-dotnet\\src\\client\\Microsoft.Identity.Client\\Microsoft.Identity.Client.csproj]\r\n```\r\nComing from PackTask, but when we look at the generated `nupkg`, it appears to be correct. Thus the validation rule is failing and causing the build to fail.\r\n\r\nThis is captured here: https://github.com/novotnyllc/MSBuildSdkExtras/issues/191\r\n\r\nRepro:\r\n1.  clone https://github.com/AzureAD/microsoft-authentication-library-for-dotnet\r\n2.  cd src\\client\\Microsoft.Identity.Client\r\n3.  msbuild /restore /t:pack\r\n\r\n/cc @bgavrilMS \r\n\r\n"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"10740159942","Type":"IssuesEvent","CreatedAt":"2019-10-29T17:39:29","Actor":"anangaur","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/39","RelatedDescription":"Opened issue \"Flag vulnerable packages\" (#39) at NuGet/Announcements","RelatedBody":"The spec for 'Flagging vulnerable packages' is ready for **review**:\r\n\r\n|Spec wiki|Discussion issue|\r\n|----------|------------------|\r\n|[Flag vulnerable packages](https://github.com/NuGet/Home/wiki/Flag-vulnerable-packages) | https://github.com/nuget/home/issues/8087|"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1204812404573392897","CreatedAt":"2019-12-11T17:17:16+00:00","UserScreenname":"nuget","Text":"We are currently experiencing CDN issues in a few geographies.  https://t.co/F9kiKfdOWi services like package restoâ€¦ https://t.co/0ZVMeF11CW","Source":"<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>","RetweetCount":9,"FavoriteCount":8,"RawContent":null},{"Id":"1190360390980395008","CreatedAt":"2019-11-01T20:10:07+00:00","UserScreenname":"nuget","Text":"The issue with the publishing pipeline has been resolved and packages are now being published normally. https://t.co/NdK8mVk7UF","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":3,"FavoriteCount":0,"RawContent":null},{"Id":"1190331936293572608","CreatedAt":"2019-11-01T18:17:03+00:00","UserScreenname":"nuget","Text":"We are experiencing an issue with our publishing pipeline causing a delay in the publishing of new packages. We areâ€¦ https://t.co/gM91QcE1Zc","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":5,"FavoriteCount":3,"RawContent":null}]}},"RunOn":"2019-12-17T05:30:47.6428381Z","RunDurationInMilliseconds":2543}