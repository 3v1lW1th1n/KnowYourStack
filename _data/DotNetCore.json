{"Data":{"Blog":{"FeedItems":[{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":69,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803)","PublishedOn":"2018-05-24T01:49:57+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/23/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-april-2018-update-version-1803/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update)","PublishedOn":"2018-05-21T22:44:05+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/21/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-1709-fall-creators-update/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10","PublishedOn":"2018-05-17T17:20:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1703 (Creators Update) and Windows 10 1607 (Anniversary Update). Quality and Reliability This release contains the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/17/net-framework-may-2018-preview-of-quality-rollup-for-windows-10/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup","PublishedOn":"2018-05-15T18:10:24+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup. Quality and Reliability This release contains the following quality and reliability improvements. CLR Resolves an issue in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/15/net-framework-may-2018-preview-of-quality-rollup/","RawContent":null},{"Title":".NET Core May 2018 Update","PublishedOn":"2018-05-08T22:31:30+00:00","CommentsCount":15,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core May 2018 Update. This update includes .NET Core 2.1.200 SDK and ASP.NET Core 2.0.8. Security Microsoft is releasing this security advisory to provide information...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-core-may-2018-update/","RawContent":null},{"Title":".NET Framework May 2018 Security and Quality Rollup","PublishedOn":"2018-05-08T21:18:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Security and Quality Rollup. Security CVE-2018-1039 – Windows Security Feature Bypass Vulnerability A security feature bypass vulnerability exists in Windows which...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/08/net-framework-may-2018-security-and-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""},{"Id":"7697516495","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:04:23","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/101","RelatedDescription":"Merged pull request \"Create mlnet.md\" (#101) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7794612979","Type":"IssuesEvent","CreatedAt":"2018-06-08T03:46:21","Actor":"NMSAzulX","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18369","RelatedDescription":"Opened issue \"Support weaving.\" (#18369) at dotnet/coreclr","RelatedBody":"We can add more function for the method. \r\n(Maybe like Mono.cecil, profiling, IL Inject etc)\r\nWhen I encapsulated some library, I need lots of below operations:\r\nIt can make our library more intelligent and greatly improve the efficiency of developers.\r\nI hope this:\r\n\r\nStatic weaving / Dynamic weaving API:\r\n```C#\r\n    MethodInfo info = type.GetMethod(\"xxx\");\r\n    Weaving weav=info.GetWeaving(WeavFlag.Static / Dynamic );\r\n    weav.Head(  ilBytes / methodInfo );\r\n    weav.Body(  ilBytes / methodInfo );\r\n    weav.Tail(  ilBytes / methodInfo );\r\n    weav.Compile();\r\n```\r\n\r\n\r\nUse:\r\n```C#\r\npublic void ShowA(){\r\n    Console.WriteLine(\"A\");\r\n}\r\npublic void ShowB(){\r\n    Console.WriteLine(\"B\");\r\n}\r\n\r\npublic void Run(){\r\n\r\n    ShowA();\r\n    //Output:\"A\"\r\n\r\n    MethodInfo a from ShowA;\r\n    MethodInfo b from ShowB;\r\n\r\n    //Connect MethodA and MethodB\r\n    a.Tail(b)\r\n    ShowA();\r\n    //Output: \"A\"\\r\\n\"B\"\r\n\r\n    //Rewrite MethodA by using MethodB\r\n    a.Replace(b);\r\n    ShowA();\r\n     //Output:\"B\"   \r\n}\r\n\r\n```\r\n\r\nInsert in head:\r\n```C#\r\npublic static void Append(this MethodInfo old, MethodInfo new)\r\n{\r\n    Weaving weav=old.GetWeaving(WeavFlag.Static);\r\n    weav.Head(new);\r\n    weav.Compile();\r\n}\r\n```\r\nReplace body:\r\n```C#\r\npublic static void Append(this MethodInfo old, MethodInfo new)\r\n{\r\n    Weaving weav=old.GetWeaving(WeavFlag.Static);\r\n    weav.Body(new);\r\n    weav.Compile();\r\n}\r\n```\r\n\r\nAppend in tail:\r\n```C#\r\npublic static void Append(this MethodInfo old, MethodInfo new)\r\n{\r\n    Weaving weav=old.GetWeaving(WeavFlag.Static);\r\n    weav.Tail(new);\r\n    weav.Compile();\r\n}\r\n```\r\n\r\n"},{"Id":"7794503253","Type":"IssuesEvent","CreatedAt":"2018-06-08T03:02:27","Actor":"NMSAzulX","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18368","RelatedDescription":"Opened issue \"Attribute support Generic Types.\" (#18368) at dotnet/coreclr","RelatedBody":"For example:\r\n```c#\r\ndefine:\r\n     public class TestAttribute<T>:Attribute\r\n\r\nuse:\r\n     [Test<User>]\r\n     public class  Run{}\r\n```"},{"Id":"7794291853","Type":"IssuesEvent","CreatedAt":"2018-06-08T01:42:17","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18367","RelatedDescription":"Opened issue \"[Regression] Assertion failed 'mask != RBM_NONE'\" (#18367) at dotnet/coreclr","RelatedBody":"`jit\\regset.cpp (120) - Assertion failed 'mask != RBM_NONE'`\r\nThe regression was introduced by #18230.\r\n\r\ncc @dotnet/jit-contrib "},{"Id":"7794229123","Type":"PullRequestEvent","CreatedAt":"2018-06-08T01:17:20","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18366","RelatedDescription":"Opened pull request \"[WIP] Cross-bitness in static and non-static fields placement and CORINFO structs\" (#18366) at dotnet/coreclr","RelatedBody":"This PR is add cross-bitness support to\r\n1. Static fields placement - same approach utilized in #18245 #18329 - introducing target-specific constants (such as `OFFSETOF__DomainLocalModule__m_pDataBlob`) and replacing corresponding `offsetof`-expressions since they could not be properly computed in a cross-bitness scenario\r\n\r\n2. Non-static fields placement in `MethodTableBuilder` by introducing `IN_TARGET_32BIT` `IN_TARGET_64BIT` macros and replacing some `IN_WIN32` `IN_WIN64` macros (which depends on `_WIN64` definition)\r\n\r\n3. `CORINFO` structures that are fundamental part of EE-JIT interactions. It is not clear for me how this part should be implemented. I made several changes to `CORINFO` structures. First, I replaced `_WIN64` with `_TARGET_64BIT_` and this is a safe change for current scenarios. Second, I created *\"mocking\"* structures under `CROSS_COMPILE`, so expression `offsetof(CORINFO_X, Y)` would return target-specific value. We can do same approach with hardcoding constants here and using them everywhere instead of `offsetof(CORINFO_X,Y)` in coreclr but I am not sure if this is a right way to go.\r\n\r\n@jkotas PTAL"},{"Id":"7794157963","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:48:54","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18251","RelatedDescription":"Closed pull request \"Fix issue #2944, rounding errors in decimal.GetHashCode.\" (#18251) at dotnet/coreclr","RelatedBody":"Simplify VarR8FromDec in decimal.GetHashCode in order to reduce rounding error caused by division big double by big power of 10 for decimal with big scale.\r\nFix issue #2944\r\n\r\nUnfortunately I had to add `VarHashFromDec` to `oleauto.h` header file because I need constants `DECMAX` and `ds2to64` for hash computation. I know that's not a good way to do it, thus I'm open to suggestions how to reorganize these code changes if they are necessary.\r\n"},{"Id":"7794155279","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:47:45","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18288","RelatedDescription":"Merged pull request \"Fixed and optimized Decimal.GetHashCode\" (#18288) at dotnet/coreclr","RelatedBody":"This fixes #2944, tests are in https://github.com/dotnet/corefx/pull/30116 and the same change for CoreRT is in https://github.com/dotnet/corert/pull/5886 (benchmarks also there)."},{"Id":"7794153466","Type":"IssuesEvent","CreatedAt":"2018-06-08T00:46:57","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/2944","RelatedDescription":"Closed issue \"Decimal.GetHashCode shouldn't generate different values for numbers with different scale\" (#2944) at dotnet/coreclr","RelatedBody":"See https://connect.microsoft.com/VisualStudio/feedback/details/776203/\nhttp://stackoverflow.com/questions/8533449/\n\nMarking connect issue as won't fix without any comment is not nice. This issue makes decimal completely useless as a key in collections, that rely on GetHashCode result, like Dictionary or HashSet.\n"},{"Id":"7794134822","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:39:21","Actor":"brianrob","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18359","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/corefx\" (#18359) at dotnet/coreclr","RelatedBody":"This PR contains mirrored changes from dotnet/corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7794094186","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:23:09","Actor":"AaronRobinsonMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18310","RelatedDescription":"Merged pull request \"Interop Copy tests now all return 101 during fail rather than crash\" (#18310) at dotnet/coreclr","RelatedBody":"Currently taking stock of Interop tests and decided to make all the Copy tests consistent as a way to get familiar with building and running the tests."},{"Id":"7794057783","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:08:52","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18293","RelatedDescription":"Closed pull request \"Moved PinnableBufferCache.cs  and PinnableBufferCacheEventSource.cs  to shared\" (#18293) at dotnet/coreclr","RelatedBody":"Related to https://github.com/dotnet/corert/pull/5897"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7793338058","Type":"PullRequestEvent","CreatedAt":"2018-06-07T20:51:23","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/762","RelatedDescription":"Merged pull request \"Update BuildTools to preview1-02902-01 (master)\" (#762) at dotnet/standard","RelatedBody":""},{"Id":"7792868560","Type":"IssuesEvent","CreatedAt":"2018-06-07T19:15:38","Actor":"jnm2","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/767","RelatedDescription":"Closed issue \"Trimming intermittently fails with InvalidCastException\" (#767) at dotnet/standard","RelatedBody":"Sometimes when building from the command line, I'll get `error MSB4018: The \"TrimFiles\" task failed unexpectedly.`:\r\n\r\n```\r\n\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\15.0\\Bin\\amd64\\MSBuild.exe\" /v:minimal /p:Configuration=\"Release\" /target:Build /restore \"path\\to.sln\"\r\n```\r\n\r\n> C:\\Users\\jmusser\\.nuget\\packages\\microsoft.packaging.tools.trimming\\1.1.0-preview1-26322-01\\build\\Microsoft.Packaging.Tools.Trimming.targets(71,5): error MSB4018: System.InvalidCastException: [A]NuGet.ProjectModel.LockFile cannot be cast to [B]NuGet.ProjectModel.LockFile. Type A originates from 'NuGet.ProjectModel, Version=4.7.0.5, Culture=neutral, PublicKeyToken=31bf3856ad364e35' in the context 'LoadFrom' at location 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\Common7\\IDE\\CommonExtensions\\Microsoft\\NuGet\\NuGet.ProjectModel.dll'. Type B originates from 'NuGet.ProjectModel, Version=4.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35' in the context 'LoadFrom' at location 'C:\\Users\\jmusser\\.nuget\\packages\\microsoft.packaging.tools.trimming\\1.1.0-preview1-26322-01\\build\\desktop\\NuGet.ProjectModel.dll'.\r\n\r\nI don't remember getting this before installing the targeting pack for .NET Framework 4.7.2, but it might not be related.\r\n\r\nI haven't figured out yet if it's related to having the same solution open in VS. It may begin working when I close the solution or close VS.\r\n\r\nAlso, I upgraded to the latest preview and it continued with the same failure.\r\n\r\ncc: @ericstj "},{"Id":"7792455679","Type":"IssuesEvent","CreatedAt":"2018-06-07T17:53:39","Actor":"jnm2","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/767","RelatedDescription":"Opened issue \"Trimming intermittently fails with InvalidCastException\" (#767) at dotnet/standard","RelatedBody":"Sometimes when building from the command line, I'll get error MSB4018: The \"TrimFiles\" task failed unexpectedly.\r\n\r\n```\r\n\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\15.0\\Bin\\amd64\\MSBuild.exe\" /v:minimal /p:Configuration=\"Release\" /target:Build /restore \"path\\to.sln\"\r\n```\r\n\r\n> C:\\Users\\jmusser\\.nuget\\packages\\microsoft.packaging.tools.trimming\\1.1.0-preview1-26322-01\\build\\Microsoft.Packaging.Tools.Trimming.targets(71,5): error MSB4018: System.InvalidCastException: [A]NuGet.ProjectModel.LockFile cannot be cast to [B]NuGet.ProjectModel.LockFile. Type A originates from 'NuGet.ProjectModel, Version=4.7.0.5, Culture=neutral, PublicKeyToken=31bf3856ad364e35' in the context 'LoadFrom' at location 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\Common7\\IDE\\CommonExtensions\\Microsoft\\NuGet\\NuGet.ProjectModel.dll'. Type B originates from 'NuGet.ProjectModel, Version=4.6.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35' in the context 'LoadFrom' at location 'C:\\Users\\jmusser\\.nuget\\packages\\microsoft.packaging.tools.trimming\\1.1.0-preview1-26322-01\\build\\desktop\\NuGet.ProjectModel.dll'.\r\n\r\nI don't remember getting this before installing the targeting pack for .NET Framework 4.7.2, but it might not be related.\r\n\r\nI haven't figured out yet if it's related to having the same solution open in VS. It may begin working when I close the solution or close VS.\r\n\r\ncc: @ericstj "},{"Id":"7792358255","Type":"PullRequestEvent","CreatedAt":"2018-06-07T17:34:19","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/766","RelatedDescription":"Opened pull request \"Fix typo in FileNode 'Polulate'\" (#766) at dotnet/standard","RelatedBody":"/cc @nil4"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7794151140","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:46:05","Actor":"luqunl","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/30205","RelatedDescription":"Closed pull request \"Use reflection to call AsyncCausalityTracer and Task internal methods\" (#30205) at dotnet/corefx","RelatedBody":"Use reflection instead of InternalsVisibleTo to access internal methods inside System.Private.Corelib.\r\n"},{"Id":"7794137903","Type":"IssuesEvent","CreatedAt":"2018-06-08T00:40:33","Actor":"karelz","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/29941","RelatedDescription":"Closed issue \"SPNEGO logon fails from linux client against windows server\" (#29941) at dotnet/corefx","RelatedBody":"Attaching  client and server application compiled in netcoreapp2.0 . Authentication is successful from windows client and failed from linux client. The server is windows . In the client code I used impersonation level as System.Security.Principal.TokenImpersonationLevel.Identification for linux as this is only supported. From windows I used System.Security.Principal.TokenImpersonationLevel.Impersponation\r\n\r\nFrom linux client , I see the below error\r\n[root@sdl17146 publish]# dotnet krbclient.dll\r\n\r\n```\r\nUnhandled Exception: System.Security.Authentication.AuthenticationException: A call to SSPI failed, see inner exception. ---> System.ComponentModel.Win32Exception: GSSAPI operation failed with error - An invalid status code was supplied (Message stream modified).\r\n   --- End of inner exception stack trace ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Net.Security.NegoState.StartSendAuthResetSignal(LazyAsyncResult lazyResult, Byte[] message, Exception exception)\r\n   at System.Net.Security.NegoState.StartSendBlob(Byte[] message, LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegoState.CheckCompletionBeforeNextSend(Byte[] message, LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegoState.ProcessReceivedBlob(Byte[] message, LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegoState.StartReceiveBlob(LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegoState.CheckCompletionBeforeNextReceive(LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegoState.StartSendBlob(Byte[] message, LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegoState.ProcessAuthentication(LazyAsyncResult lazyResult)\r\n   at System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, String targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)\r\n   at System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential credential, String targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)\r\n   at krbclient.ASynchronousAuthenticatingTcpClient.Main(String[] args)\r\nAborted (core dumped)\r\n```\r\n\r\nFrom windows client:\r\n-------------------------\r\nC:\\Users\\rl151007.ESROOTDOM\\aarthi>krbclient.exe\r\nClient waiting for authentication...\r\nIsAuthenticated: True\r\nIsMutuallyAuthenticated: False\r\nIsEncrypted: True\r\nIsSigned: True\r\nIsServer: False\r\nSent 22 bytes.\r\nClient closed.\r\nkrbclient.cs\r\n\r\n```c#\r\nusing System;\r\nusing System.IO;\r\nusing System.Net;\r\nusing System.Net.Security;\r\nusing System.Net.Sockets;\r\nusing System.Text;\r\n\r\nnamespace krbclient\r\n{\r\n    public class ASynchronousAuthenticatingTcpClient\r\n    {\r\n        static TcpClient client = null;\r\n\r\n        public static void Main(String[] args)\r\n        {\r\n            // Establish the remote endpoint for the socket.\r\n            // For this example, use the local machine.\r\n            //IPHostEntry ipHostInfo = Dns.GetHostEntry(\"localhost\");\r\n            //IPAddress ipAddress = ipHostInfo.AddressList[0];\r\n            // Client and server use port 11000. \r\n            //IPEndPoint remoteEP = new IPEndPoint(ipAddress, 11000);\r\n            // Create a TCP/IP socket.\r\n            client = new TcpClient();\r\n            // Connect the socket to the remote endpoint.\r\n            client.Connect(\"esroot\", 9999);\r\n            //Console.WriteLine(\"Client connected to {0}.\", remoteEP.ToString());\r\n            // Ensure the client does not close when there is \r\n            // still data to be sent to the server.\r\n            client.LingerState = (new LingerOption(true, 0));\r\n\r\n            System.Security.Principal.TokenImpersonationLevel impLevel = System.Security.Principal.TokenImpersonationLevel.Identification;\r\n                \r\n             // Request authentication.\r\n             NetworkStream clientStream = client.GetStream();\r\n            NegotiateStream authStream = new NegotiateStream(clientStream, false);\r\n            // Pass the NegotiateStream as the AsyncState object \r\n            // so that it is available to the callback delegate.\r\n            /*  IAsyncResult ar = authStream.BeginAuthenticateAsClient(\r\n                  new AsyncCallback(EndAuthenticateCallback),\r\n                  authStream\r\n                  );*/\r\n            //NetworkCredential cred = new NetworkCredential(\"au185009\", \"@Thirukami9876\");\r\n            authStream.AuthenticateAsClient(CredentialCache.DefaultNetworkCredentials, \"HOST/ESROOT\",\r\n       ProtectionLevel.EncryptAndSign,\r\n       impLevel);\r\n\r\n            StreamWriter writer = new StreamWriter(authStream);\r\n            Console.WriteLine(\"Client waiting for authentication...\");\r\n            // Wait until the result is available.\r\n            //ar.AsyncWaitHandle.WaitOne();\r\n            // Display the properties of the authenticated stream.\r\n            AuthenticatedStreamReporter.DisplayProperties(authStream);\r\n            // Send a message to the server.\r\n            // Encode the test data into a byte array.\r\n            byte[] message = Encoding.UTF8.GetBytes(\"Hello from the client.\");\r\n            //ar = authStream.BeginWrite(message, 0, message.Length,\r\n              //  new AsyncCallback(EndWriteCallback),\r\n              //  authStream);\r\n            //ar.AsyncWaitHandle.WaitOne();\r\n            authStream.Write(message, 0, message.Length);\r\n\r\n\r\n            Console.WriteLine(\"Sent {0} bytes.\", message.Length);\r\n            // Close the client connection.\r\n            authStream.Close();\r\n            Console.WriteLine(\"Client closed.\");\r\n        }\r\n        // The following method is called when the authentication completes.\r\n        public static void EndAuthenticateCallback(IAsyncResult ar)\r\n        {\r\n            Console.WriteLine(\"Client ending authentication...\");\r\n            NegotiateStream authStream = (NegotiateStream)ar.AsyncState;\r\n            Console.WriteLine(\"ImpersonationLevel: {0}\", authStream.ImpersonationLevel);\r\n\r\n            // End the asynchronous operation.\r\n            authStream.EndAuthenticateAsClient(ar);\r\n        }\r\n        // The following method is called when the write operation completes.\r\n        public static void EndWriteCallback(IAsyncResult ar)\r\n        {\r\n            Console.WriteLine(\"Client ending write operation...\");\r\n            NegotiateStream authStream = (NegotiateStream)ar.AsyncState;\r\n\r\n            // End the asynchronous operation.\r\n            authStream.EndWrite(ar);\r\n        }\r\n    }\r\n\r\n    // The following class displays the properties of an authenticatedStream.\r\n    public class AuthenticatedStreamReporter\r\n    {\r\n        public static void DisplayProperties(AuthenticatedStream stream)\r\n        {\r\n            Console.WriteLine(\"IsAuthenticated: {0}\", stream.IsAuthenticated);\r\n            Console.WriteLine(\"IsMutuallyAuthenticated: {0}\", stream.IsMutuallyAuthenticated);\r\n            Console.WriteLine(\"IsEncrypted: {0}\", stream.IsEncrypted);\r\n            Console.WriteLine(\"IsSigned: {0}\", stream.IsSigned);\r\n            Console.WriteLine(\"IsServer: {0}\", stream.IsServer);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nkrbserver.cs\r\n\r\n```c#\r\nusing System;\r\nusing System.Net;\r\nusing System.Net.Security;\r\nusing System.Net.Sockets;\r\nusing System.Security.Authentication;\r\nusing System.Security.Principal;\r\nusing System.Text;\r\nusing System.Threading;\r\n\r\nnamespace krbserver\r\n{\r\n\r\n        public class Program\r\n        {\r\n            public static void Main()\r\n            {\r\n                // Create an IPv4 TCP/IP socket. \r\n                TcpListener listener = new TcpListener(IPAddress.Any, 9999);\r\n                // Listen for incoming connections.\r\n                listener.Start();\r\n                while (true)\r\n                {\r\n                    TcpClient clientRequest = null;\r\n                    // Application blocks while waiting for an incoming connection.\r\n                    // Type CNTL-C to terminate the server.\r\n                    clientRequest = listener.AcceptTcpClient();\r\n                    Console.WriteLine(\"Client connected.\");\r\n                    // A client has connected. \r\n                    try\r\n                    {\r\n                        AuthenticateClient(clientRequest);\r\n                    }\r\n                    catch (Exception e)\r\n                    {\r\n                        Console.WriteLine(e);\r\n                        continue;\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n            public static void AuthenticateClient(TcpClient clientRequest)\r\n            {\r\n                NetworkStream stream = clientRequest.GetStream();\r\n                // Create the NegotiateStream.\r\n                NegotiateStream authStream = new NegotiateStream(stream, false);\r\n                // Save the current client and NegotiateStream instance \r\n                // in a ClientState object.\r\n                ClientState cState = new ClientState(authStream, clientRequest);\r\n                /* Listen for the client authentication request.\r\n                authStream.BeginAuthenticateAsServer(\r\n                    new AsyncCallback(EndAuthenticateCallback),\r\n                    cState\r\n                    );*/\r\n\r\n            authStream.AuthenticateAsServer(CredentialCache.DefaultNetworkCredentials,\r\n      ProtectionLevel.EncryptAndSign,\r\n      TokenImpersonationLevel.Impersonation);\r\n\r\n            Console.WriteLine(\"Client Identity\", authStream.ToString());\r\n            // Wait until the authentication completes.\r\n            cState.Waiter.WaitOne();\r\n                cState.Waiter.Reset();\r\n                authStream.BeginRead(cState.Buffer, 0, cState.Buffer.Length,\r\n                       new AsyncCallback(EndReadCallback),\r\n                       cState);\r\n                cState.Waiter.WaitOne();\r\n                // Finished with the current client.\r\n                authStream.Close();\r\n                clientRequest.Close();\r\n            }\r\n            // The following method is invoked by the\r\n            // BeginAuthenticateAsServer callback delegate.\r\n\r\n            public static void EndAuthenticateCallback(IAsyncResult ar)\r\n            {\r\n                // Get the saved data.\r\n                ClientState cState = (ClientState)ar.AsyncState;\r\n                TcpClient clientRequest = cState.Client;\r\n                NegotiateStream authStream = (NegotiateStream)cState.AuthenticatedStream;\r\n                Console.WriteLine(\"Ending authentication.\");\r\n                // Any exceptions that occurred during authentication are\r\n                // thrown by the EndAuthenticateAsServer method.\r\n                try\r\n                {\r\n                    // This call blocks until the authentication is complete.\r\n                    authStream.EndAuthenticateAsServer(ar);\r\n                }\r\n                catch (AuthenticationException e)\r\n                {\r\n                    Console.WriteLine(e);\r\n                    Console.WriteLine(\"Authentication failed - closing connection.\");\r\n                    cState.Waiter.Set();\r\n                    return;\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Console.WriteLine(e);\r\n                    Console.WriteLine(\"Closing connection.\");\r\n                    cState.Waiter.Set();\r\n                    return;\r\n                }\r\n                // Display properties of the authenticated client.\r\n                IIdentity id = authStream.RemoteIdentity;\r\n                Console.WriteLine(\"{0} was authenticated using {1}.\",\r\n                    id.Name,\r\n                    id.AuthenticationType\r\n                    );\r\n                cState.Waiter.Set();\r\n\r\n            }\r\n            public static void EndReadCallback(IAsyncResult ar)\r\n            {\r\n                // Get the saved data.\r\n                ClientState cState = (ClientState)ar.AsyncState;\r\n                TcpClient clientRequest = cState.Client;\r\n                NegotiateStream authStream = (NegotiateStream)cState.AuthenticatedStream;\r\n                // Get the buffer that stores the message sent by the client.\r\n                int bytes = -1;\r\n                // Read the client message.\r\n                try\r\n                {\r\n                    bytes = authStream.EndRead(ar);\r\n                    cState.Message.Append(Encoding.UTF8.GetChars(cState.Buffer, 0, bytes));\r\n                    if (bytes != 0)\r\n                    {\r\n                        authStream.BeginRead(cState.Buffer, 0, cState.Buffer.Length,\r\n                              new AsyncCallback(EndReadCallback),\r\n                              cState);\r\n                        return;\r\n                    }\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    // A real application should do something\r\n                    // useful here, such as logging the failure.\r\n                    Console.WriteLine(\"Client message exception:\");\r\n                    Console.WriteLine(e);\r\n                    cState.Waiter.Set();\r\n                    return;\r\n                }\r\n                IIdentity id = authStream.RemoteIdentity;\r\n                Console.WriteLine(\"{0} says {1}\", id.Name, cState.Message.ToString());\r\n                cState.Waiter.Set();\r\n            }\r\n        }\r\n        // ClientState is the AsyncState object.\r\n        internal class ClientState\r\n        {\r\n            private AuthenticatedStream authStream = null;\r\n            private TcpClient client = null;\r\n            byte[] buffer = new byte[2048];\r\n            StringBuilder message = null;\r\n            ManualResetEvent waiter = new ManualResetEvent(false);\r\n            internal ClientState(AuthenticatedStream a, TcpClient theClient)\r\n            {\r\n                authStream = a;\r\n                client = theClient;\r\n            }\r\n            internal TcpClient Client\r\n            {\r\n                get { return client; }\r\n            }\r\n            internal AuthenticatedStream AuthenticatedStream\r\n            {\r\n                get { return authStream; }\r\n            }\r\n            internal byte[] Buffer\r\n            {\r\n                get { return buffer; }\r\n            }\r\n            internal StringBuilder Message\r\n            {\r\n                get\r\n                {\r\n                    if (message == null)\r\n                        message = new StringBuilder();\r\n                    return message;\r\n                }\r\n            }\r\n            internal ManualResetEvent Waiter\r\n            {\r\n                get\r\n                {\r\n                    return waiter;\r\n                }\r\n            }\r\n        }\r\n    \r\n}\r\n```\r\n\r\n[EDIT] Fixing code and exception formatting by @karelz"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7794814354","Type":"PullRequestEvent","CreatedAt":"2018-06-08T05:11:13","Actor":"AlekseyTs","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/27604","RelatedDescription":"Merged pull request \"Refine input validation for GetLocalFunctionControlFlowGraph/GetAnonymousFunctionControlFlowGraph APIs\" (#27604) at dotnet/roslyn","RelatedBody":""}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7794812508","Type":"PullRequestEvent","CreatedAt":"2018-06-08T05:10:31","Actor":"benaadams","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5912","RelatedDescription":"Opened pull request \"Update WebApi sample to 2.1\" (#5912) at dotnet/corert","RelatedBody":"Will fail with\r\n```\r\n\r\n  Restore completed in 62.94 ms for C:\\GitHub\\corert\\samples\\WebApi\\SampleWebApi.csproj.\r\n  SampleWebApi -> C:\\GitHub\\corert\\samples\\WebApi\\bin\\Release\\netcoreapp2.1\\win-x64\\SampleWebApi.dll\r\n  Generating native code\r\nEXEC : warning : RD.XML processing will change before release (https://github.com/dotnet/corert/issues/5001) [C:\\GitHub\\corert\\samples\\WebApi\\SampleWebApi.csproj]\r\nEXEC : error : [TEMPORARY EXCEPTION MESSAGE] \r\nClassLoadGeneral: System.Reflection.Emit.ILGenerator, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a [C:\\GitHub\\corert\\samples\\WebApi\\SampleWebApi.csproj]\r\n  Internal.TypeSystem.TypeSystemException+TypeLoadException: [TEMPORARY EXCEPTION MESSAGE] ClassLoadGeneral: System.Reflection.Emit.ILGenerator, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\r\n     at Internal.TypeSystem.ThrowHelper.ThrowTypeLoadException(ExceptionStringID id, String typeName, String assemblyName)\r\n     at Internal.TypeSystem.Ecma.EcmaModule.GetType(String nameSpace, String name, Boolean throwIfNotFound)\r\n     at Internal.TypeSystem.Ecma.EcmaModule.GetType(String nameSpace, String name, Boolean throwIfNotFound)\r\n     at Internal.TypeSystem.Ecma.EcmaModule.ResolveTypeReference(TypeReferenceHandle handle)\r\n     at Internal.TypeSystem.Ecma.EcmaModule.EcmaObjectLookupHashtable.CreateValueFromKey(EntityHandle handle)\r\n     at Internal.TypeSystem.LockFreeReaderHashtable`2.CreateValueAndEnsureValueIsInTable(TKey key)\r\n     at Internal.TypeSystem.Ecma.EcmaModule.GetObject(EntityHandle handle)\r\n     at Internal.TypeSystem.Ecma.EcmaModule.GetType(EntityHandle handle)\r\n     at Internal.TypeSystem.Ecma.EcmaSignatureParser.ParseType(SignatureTypeCode typeCode)\r\n     at Internal.TypeSystem.Ecma.EcmaSignatureParser.ParseFieldSignature()\r\n     at Internal.TypeSystem.Ecma.EcmaField.InitializeFieldType()\r\n     at Internal.TypeSystem.MetadataFieldLayoutAlgorithm.ComputeInstanceLayout(DefType defType, InstanceLayoutKind layoutKind)\r\n     at Internal.TypeSystem.DefType.ComputeInstanceLayout(InstanceLayoutKind layoutKind)\r\n     at ILCompiler.DependencyAnalysis.EETypeNode.CheckCanGenerateEEType(NodeFactory factory, TypeDesc type)\r\n     at ILCompiler.DependencyAnalysis.NodeFactory.<CreateNodeCaches>b__36_1(TypeDesc type)\r\n     at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n     at ILCompiler.Compilation.RootingServiceProvider.AddCompilationRoot(TypeDesc type, String reason)\r\n     at ILCompiler.RdXmlRootProvider.RootType(IRootingServiceProvider rootProvider, TypeDesc type)\r\n     at ILCompiler.RdXmlRootProvider.ProcessAssemblyDirective(IRootingServiceProvider rootProvider, XElement assemblyElement)\r\n     at ILCompiler.RdXmlRootProvider.AddCompilationRoots(IRootingServiceProvider rootProvider)\r\n     at ILCompiler.Compilation..ctor(DependencyAnalyzerBase`1 dependencyGraph, NodeFactory nodeFactory, IEnumerable`1 compilationRoots, DebugInformationProvider debugInformationProvider, DevirtualizationManager devirtualizationManager, Logger logger)\r\n     at ILCompiler.ILScannerBuilder.ToILScanner()\r\n     at ILCompiler.Program.Run(String[] args)\r\n     at ILCompiler.Program.Main(String[] args)\r\nC:\\Users\\thund\\.nuget\\packages\\microsoft.dotnet.ilcompiler\\1.0.0-alpha-26529-02\\build\\Microsoft.NETCore.Native.targets(183,5): error MSB3073: The command \"\"C:\\Users\\thund\\.nuget\\packages\\runtime.win-x64.microsoft.dotnet.ilcompiler\\1.0.0-alpha-26529-02\\tools\\ilc\" @\"obj\\Release\\netcoreapp2.1\\win-x64\\native\\SampleWebApi.ilc.rsp\"\" exited with code 1. [C:\\GitHub\\corert\\samples\\WebApi\\SampleWebApi.csproj\r\n```"},{"Id":"7794153471","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:46:57","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5886","RelatedDescription":"Merged pull request \"Fixed and optimized Decimal.GetHashCode\" (#5886) at dotnet/corert","RelatedBody":"This fixes https://github.com/dotnet/coreclr/issues/2944 and contributes to https://github.com/dotnet/coreclr/issues/18249.\r\nI'll add tests to CoreFX that break the current imprecise implementation.\r\nI'm not sure if `HashCode.Combine` should be used here instead of a simple xor - it would be twice as slow.\r\nAnd this also raises a question about decimal to double conversion - ideally, it should be normalized before conversion, but from a compatibility perspective it's not that clear.\r\n\r\n_Updated benchmark with different input data sets:_\r\n#### x64 (mostly normalized)\r\n|  Method |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 5.365 ns | 0.0127 ns | 0.0033 ns |   1.00 |\r\n| CoreRT2 | 2.706 ns | 0.0103 ns | 0.0037 ns |   0.51 |\r\n\r\n#### x64 (denormalized)\r\n|  Method |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 5.575 ns | 0.0275 ns | 0.0098 ns |   1.00 |\r\n| CoreRT2 | 4.750 ns | 0.0243 ns | 0.0087 ns |   0.85 |\r\n\r\n#### x64 (heavily denormalized)\r\n|  Method |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 6.162 ns | 0.0159 ns | 0.0057 ns |   1.00 |\r\n| CoreRT2 | 6.482 ns | 0.0128 ns | 0.0046 ns |   1.05 |\r\n\r\n#### x86 (mostly normalized)\r\n|  Method |      Mean |     Error |    StdDev | Scaled |\r\n|-------- |----------:|----------:|----------:|-------:|\r\n|  Native |  7.706 ns | 0.1061 ns | 0.0378 ns |   1.00 |\r\n| CoreRT2 |  4.093 ns | 0.0345 ns | 0.0123 ns |   0.54 |\r\n\r\n#### x86 (denormalized)\r\n|  Method |      Mean |     Error |    StdDev | Scaled |\r\n|-------- |----------:|----------:|----------:|-------:|\r\n|  Native |  7.870 ns | 0.0355 ns | 0.0127 ns |   1.00 |\r\n| CoreRT2 | 14.292 ns | 0.0621 ns | 0.0222 ns |   1.82 |\r\n\r\n#### x86 (heavily denormalized)\r\n|  Method |      Mean |     Error |    StdDev | Scaled |\r\n|-------- |----------:|----------:|----------:|-------:|\r\n|  Native |  8.408 ns | 0.0426 ns | 0.0152 ns |   1.00 |\r\n| CoreRT2 | 26.775 ns | 0.1536 ns | 0.0548 ns |   3.18 |\r\n\r\n## x86 DIV\r\n|  Method |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 116.6 ns | 0.1997 ns | 0.0712 ns |   1.00 |\r\n|  CoreRT | 235.5 ns | 1.0579 ns | 0.3773 ns |   2.02 |\r\n| CoreRT2 | 113.9 ns | 0.2593 ns | 0.0674 ns |   0.98 |\r\n"},{"Id":"7794149800","Type":"PullRequestEvent","CreatedAt":"2018-06-08T00:45:31","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5911","RelatedDescription":"Merged pull request \"Enable Alpine ARM/ARM64 cross build\" (#5911) at dotnet/corert","RelatedBody":"Also unify the cross build related files with coreclr and\r\nfix a bug in the build-native.sh\r\n"},{"Id":"7793941086","Type":"PullRequestEvent","CreatedAt":"2018-06-07T23:26:22","Actor":"janvorli","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5911","RelatedDescription":"Opened pull request \"Enable Alpine ARM/ARM64 cross build\" (#5911) at dotnet/corert","RelatedBody":"Also unify the cross build related files with coreclr and\r\nfix a bug in the build-native.sh\r\n"},{"Id":"7793852548","Type":"PullRequestEvent","CreatedAt":"2018-06-07T22:57:40","Actor":"maryamariyan","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5910","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5910) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7793253150","Type":"PullRequestEvent","CreatedAt":"2018-06-07T20:34:13","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5906","RelatedDescription":"Closed pull request \"[JustForView] Moves CurrentSystemTimeZone, ICastable, and some Registry classes to shared\" (#5906) at dotnet/corert","RelatedBody":"cc: @jkotas \r\n\r\nRelated to https://github.com/dotnet/coreclr/pull/18337"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1004145068381331456","CreatedAt":"2018-06-05T23:36:55+00:00","UserScreenname":"dotnet","Text":"Cool retro game built with #dotnet #monogame. Clone the repo, play the game, and you could win some serious money!… https://t.co/iHu2MQ1bME","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":66,"FavoriteCount":17,"RawContent":null},{"Id":"1001877224096649216","CreatedAt":"2018-05-30T17:25:18+00:00","UserScreenname":"dotnet","Text":"Announcing .NET Core 2.1 https://t.co/HyKnPLqfwy","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":1294,"FavoriteCount":902,"RawContent":null}]}},"RunOn":"2018-06-08T05:30:34.1968762Z","RunDurationInMilliseconds":8268}