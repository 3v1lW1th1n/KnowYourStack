{"Data":{"GitHub":{"Issues":[{"Id":"383669020","IsPullRequest":false,"CreatedAt":"2018-11-22T22:55:28","Actor":"abgoswam","Number":"1715","RawContent":null,"Title":"Microsoft.ML.Samples does not have a TensorFlowTransform example","State":"open","Body":"Creating an issue to make the following updates to the TF Transform:\r\n\r\n- add mlcontext extension\r\n- add example to Microsoft.ML.Samples","Url":"https://github.com/dotnet/machinelearning/issues/1715","RelatedDescription":"Open issue \"Microsoft.ML.Samples does not have a TensorFlowTransform example\" (#1715)"},{"Id":"383667772","IsPullRequest":true,"CreatedAt":"2018-11-22T22:43:33","Actor":"abgoswam","Number":"1714","RawContent":null,"Title":"WIP : TensorFlowTransform unit tests should not use Legacy API","State":"open","Body":"TensorFlowTransform unit tests should not use Legacy API\r\n\r\nThis PR has the following changes:\r\n- Updated couple of TensorFlow tests to use new API. \r\n- Fix bug in ImagePixelExtractingEstimator.\r\n- Deleted one test where model is not available.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1714","RelatedDescription":"Open PR \"WIP : TensorFlowTransform unit tests should not use Legacy API\" (#1714)"},{"Id":"383529757","IsPullRequest":false,"CreatedAt":"2018-11-22T13:11:20","Actor":"Vijay27anand","Number":"1713","RawContent":null,"Title":"How to use Feature selection ","State":"open","Body":"I want to use FeatureSelectorByMutualInformation feature selection, can you please provide me a sample code snippet how to use it with a dataset,  i could not able find in the samples provided. ","Url":"https://github.com/dotnet/machinelearning/issues/1713","RelatedDescription":"Open issue \"How to use Feature selection \" (#1713)"},{"Id":"383391405","IsPullRequest":false,"CreatedAt":"2018-11-22T06:00:59","Actor":"sharpwood","Number":"1712","RawContent":null,"Title":"Does ML.Net support KNN?","State":"open","Body":"https://github.com/markdregan/K-Nearest-Neighbors-with-Dynamic-Time-Warping\r\n\r\nI suggest adding the algorithm of this article to the function of time series.","Url":"https://github.com/dotnet/machinelearning/issues/1712","RelatedDescription":"Open issue \"Does ML.Net support KNN?\" (#1712)"},{"Id":"382907770","IsPullRequest":true,"CreatedAt":"2018-11-22T01:14:04","Actor":"rogancarr","Number":"1691","RawContent":null,"Title":"Extend GAM models with methods to return model parameters","State":"closed","Body":"This PR updates `GamPredictorBase` to allow all GAM predictors to return the intercept and copies of the bin and weight arrays.\r\n\r\nFixes #1679","Url":"https://github.com/dotnet/machinelearning/pull/1691","RelatedDescription":"Closed or merged PR \"Extend GAM models with methods to return model parameters\" (#1691)"},{"Id":"383333802","IsPullRequest":false,"CreatedAt":"2018-11-22T00:05:56","Actor":"Anipik","Number":"1711","RawContent":null,"Title":"Adding a new ci leg for netcoreapp 3.0","State":"open","Body":"Lately some of our commits are breaking stuff for our netcoreapp3.0\r\nwith the new ci leg up, we wont have to test the changes locally for netcoreapp3.0\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1711","RelatedDescription":"Open issue \"Adding a new ci leg for netcoreapp 3.0\" (#1711)"},{"Id":"383320545","IsPullRequest":true,"CreatedAt":"2018-11-21T22:58:33","Actor":"singlis","Number":"1710","RawContent":null,"Title":"[WIP] Addition of the ValueMappingEstimator and ValueMappingTransform.","State":"open","Body":"This will be replacing the TermLookupTransform and provide a way to\r\nspecify the mapping betweeen two values (note this is specified and not\r\ntrained). A user can specify the mapping by providing a keys list and\r\nvalues list that must be equal in size. The Estimator will then generate\r\na 1-1 mapping based on the two lists.\r\n\r\nThe PR references #754 which covers the conversion of Transformer to use\r\nthe new Estimator API.","Url":"https://github.com/dotnet/machinelearning/pull/1710","RelatedDescription":"Open PR \"[WIP] Addition of the ValueMappingEstimator and ValueMappingTransform.\" (#1710)"},{"Id":"383315262","IsPullRequest":true,"CreatedAt":"2018-11-21T22:35:33","Actor":"Ivanidzo4ka","Number":"1709","RawContent":null,"Title":"Provide methods to train with validation context and initial predictor","State":"open","Body":"Tests incoming...\r\nFix #752 ","Url":"https://github.com/dotnet/machinelearning/pull/1709","RelatedDescription":"Open PR \"Provide methods to train with validation context and initial predictor\" (#1709)"},{"Id":"383299766","IsPullRequest":false,"CreatedAt":"2018-11-21T21:34:15","Actor":"Zruty0","Number":"1708","RawContent":null,"Title":"Add MLContext.Data extensions for schema comprehension","State":"open","Body":"- Move `AsEnumerable<T>` to `Microsoft.ML`. \r\n- Move `AsCursorable<T>` to `Microsoft.ML.Data`: I'm not sure if it's ever useful, so let's at least get it out of people's faces. Maybe `internal-best-friend` it.\r\n- Add `MLContext.Data.ReadFromCollection<T>` (instead of `env.CreateDataView` and `env.CreateStreamingDataView`).\r\n- Add `MLContext.Model.MakePredictionFunction` as an alternative to `model.MakePredictionFunction`. Maybe still turn it into `Create`? @TomFinley ?\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1708","RelatedDescription":"Open issue \"Add MLContext.Data extensions for schema comprehension\" (#1708)"},{"Id":"383297403","IsPullRequest":false,"CreatedAt":"2018-11-21T21:26:20","Actor":"Zruty0","Number":"1707","RawContent":null,"Title":"Merge API assembly into Data","State":"open","Body":"Go over `Microsoft.ML.Api` in the following fashion:\r\n\r\n- For all code that is currently used by our code or tests, move it to `Microsoft.ML.Data`.\r\n  - This, I assume, will include all schema propagation, `PredictionEngine` (but not Batch), and `CustomMappingEstimator` and probably the `StatefulFilter` for the time series.\r\n- For all code that is needed by TLC, move back to TLC.\r\n  - I'm not aware of any such code at the moment.\r\n- For code that is not used by either, remove.\r\n\r\nAfter this, remove `Microsoft.ML.Api`\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1707","RelatedDescription":"Open issue \"Merge API assembly into Data\" (#1707)"},{"Id":"383296195","IsPullRequest":false,"CreatedAt":"2018-11-21T21:21:44","Actor":"Zruty0","Number":"1706","RawContent":null,"Title":"Final interface of SchemaShape","State":"open","Body":"1. Move to `Microsoft.ML.Data`\r\n2. `internal-best-friend` all methods that are not accessing columns.\r\n3. Make `SchemaShape` be a `IReadOnlyList<SchemaShape.Column>`\r\n4. Add an accessor by name, and `GetColumnOrNull`, like `Schema` has.\r\n5. Make `SchemaShape.Column` a `struct`.\r\n6. Remove `SchemaException`.","Url":"https://github.com/dotnet/machinelearning/issues/1706","RelatedDescription":"Open issue \"Final interface of SchemaShape\" (#1706)"},{"Id":"383293825","IsPullRequest":false,"CreatedAt":"2018-11-21T21:12:49","Actor":"Zruty0","Number":"1705","RawContent":null,"Title":"Make members of leaf assemblies internal","State":"open","Body":"Similar to #1602, let's make as many members of these assemblies internal as possible.\r\n\r\nThis applies to all assemblies other than `Core`, `Data` and `Transforms`.","Url":"https://github.com/dotnet/machinelearning/issues/1705","RelatedDescription":"Open issue \"Make members of leaf assemblies internal\" (#1705)"},{"Id":"383293627","IsPullRequest":false,"CreatedAt":"2018-11-21T21:12:07","Actor":"Zruty0","Number":"1704","RawContent":null,"Title":"Make members of Data and Transforms assemblies internal","State":"open","Body":"Similar to #1602, let's make as many members of these assemblies internal as possible","Url":"https://github.com/dotnet/machinelearning/issues/1704","RelatedDescription":"Open issue \"Make members of Data and Transforms assemblies internal\" (#1704)"},{"Id":"383293224","IsPullRequest":false,"CreatedAt":"2018-11-21T21:10:35","Actor":"Zruty0","Number":"1703","RawContent":null,"Title":"Final public API for remaining learners","State":"open","Body":"Part of #1698 \r\n\r\nLet's make good public classes for trained artifacts of:\r\n- `FFM`\r\n- `Naive Bayes`\r\n- `PCAAnomaly`\r\n- `MF`\r\n- Any other trainers not covered in sub-issues of #1698 \r\n\r\n- Move to an appropriate namespace inside `Microsoft.ML`\r\n- Reduce the public surface\r\n- Add public constructor\r\n- Add a sample","Url":"https://github.com/dotnet/machinelearning/issues/1703","RelatedDescription":"Open issue \"Final public API for remaining learners\" (#1703)"},{"Id":"383292843","IsPullRequest":false,"CreatedAt":"2018-11-21T21:09:06","Actor":"Zruty0","Number":"1702","RawContent":null,"Title":"Final public API for linear learners","State":"open","Body":"Part of #1698 \r\n\r\nLet's make `LinearModelParameters` a good public class for Linear models' trained artifacts.\r\nThis applies to all linear models (SDCA, LR, SymSgd, OLS etc.)\r\n\r\n- Move to `Microsoft.ML.StandardLearners` or an appropriate namespace\r\n- Reduce the public surface\r\n- Add public constructor\r\n- Add a sample","Url":"https://github.com/dotnet/machinelearning/issues/1702","RelatedDescription":"Open issue \"Final public API for linear learners\" (#1702)"},{"Id":"383292425","IsPullRequest":false,"CreatedAt":"2018-11-21T21:07:33","Actor":"Zruty0","Number":"1701","RawContent":null,"Title":"Final public API for Tree predictors","State":"open","Body":"Part of #1698 \r\n\r\nLet's make `TreeEnsembleModelParameters` a good public class for our tree learners' trained artifacts.\r\nThis applies to all descendants of `FastTreePredictionWrapper`.\r\n\r\n- Move to `Microsoft.ML.FastTree` or an appropriate namespace\r\n- Reduce the public surface\r\n- Add public constructor\r\n- Add a sample","Url":"https://github.com/dotnet/machinelearning/issues/1701","RelatedDescription":"Open issue \"Final public API for Tree predictors\" (#1701)"},{"Id":"383292423","IsPullRequest":true,"CreatedAt":"2018-11-21T21:07:33","Actor":"Anipik","Number":"1700","RawContent":null,"Title":"Adding a new CI leg for netcoreapp 3.0","State":"open","Body":"Fixes https://github.com/dotnet/machinelearning/issues/1711\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1700","RelatedDescription":"Open PR \"Adding a new CI leg for netcoreapp 3.0\" (#1700)"},{"Id":"383291823","IsPullRequest":false,"CreatedAt":"2018-11-21T21:05:13","Actor":"Zruty0","Number":"1699","RawContent":null,"Title":"Final public API for KMeans predictor","State":"open","Body":"Part of #1698 \r\n\r\nLet's make `KMeansModelParameters` a good public class for KMeans trained artifacts.\r\n\r\n- Move to `Microsoft.ML.KMeansClustering` or an appropriate namespace\r\n- Reduce the public surface\r\n- Add public constructor\r\n- Add a sample","Url":"https://github.com/dotnet/machinelearning/issues/1699","RelatedDescription":"Open issue \"Final public API for KMeans predictor\" (#1699)"},{"Id":"383291130","IsPullRequest":false,"CreatedAt":"2018-11-21T21:02:37","Actor":"Zruty0","Number":"1698","RawContent":null,"Title":"Final public API for predictor classes","State":"open","Body":"1. All predictor classes should be named `SoAndSoModelParameters` (like `KMeansModelParameters`, `LinearBinaryModelParameters` etc. \r\n\r\n2. Strive to remove unnecessary interfaces from the public API: thinks like `IPredictor`, `IPredictorProducing<float>` etc. should not be public. \r\n\r\n3. Review the public surface of `ModelParameters` to enable ONLY parameter introspection. For example:\r\n  - `KMeans` should only expose centroid coordinates.\r\n  - `Linear` should only expose weights/biases.\r\n\r\n4. If possible, try to add public constructors. For example:\r\n  - Make it possible to create `KMeansModelParameters` from centroid coordinates\r\n  - Make it possible to create `LinearBinaryModelParameters` from weights and biases\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1698","RelatedDescription":"Open issue \"Final public API for predictor classes\" (#1698)"},{"Id":"383289386","IsPullRequest":false,"CreatedAt":"2018-11-21T20:56:21","Actor":"Zruty0","Number":"1697","RawContent":null,"Title":"Remove references to Runtime namespaces from all samples","State":"open","Body":"As part of the grand rename of namespaces, let's finalize the set of namespaces of public-facing components.\r\n\r\nIn this issue, let's perform a simple test:\r\n- For each of the `API Scenarios` tests, make sure that there is no need to reference any `Runtime` namespace.\r\n  - This will of course mean that we'll have to move things out of `Runtime`, like `IDataView` `AsEnumerable` etc.\r\n\r\nNamespaces should be:\r\n\r\n| Test | Namespaces |\r\n| ---  | --- |\r\n| CrossValidation.cs | `Microsoft.ML` only |\r\n| DecomposableTrainAndPredict.cs |  `Microsoft.ML` only |\r\n| Evaluation.cs | `Microsoft.ML` only |\r\n| Extensibility.cs | `Microsoft.ML` only |\r\n| FileBasedSavingOfData.cs | `Microsoft.ML` only |\r\n| IntrospectiveTraining.cs | `Microsoft.ML` and an appropriate trainer namespace | \r\n| Metacomponents.cs | `Microsoft.ML` only |\r\n| MultithreadedPrediction.cs | `Microsoft.ML` only |\r\n| ReconfigurablePrediction.cs | `Microsoft.ML` and the namespace for prediction transformer | \r\n| SimpleTrainAndPredict.cs | `Microsoft.ML` only |\r\n| TrainSaveModelAndPredict.cs | `Microsoft.ML` only |\r\n| TrainWithInitialPredictor.cs | `Microsoft.ML` only |\r\n| TrainWithValidationSet.cs | `Microsoft.ML` only |\r\n| Visibility.cs | `Microsoft.ML` only |","Url":"https://github.com/dotnet/machinelearning/issues/1697","RelatedDescription":"Open issue \"Remove references to Runtime namespaces from all samples\" (#1697)"},{"Id":"383288462","IsPullRequest":false,"CreatedAt":"2018-11-21T20:53:05","Actor":"dubansal","Number":"1696","RawContent":null,"Title":"(Azure Stream Analytics) Multivariate support for time series anomaly detection","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**:  All\r\n- **.NET Version (eg., dotnet --info)**: All\r\n\r\n### Issue\r\n- **What did you do?** Azure Stream Analytics is currently running a private preview of built-in Anomaly Detection ML models. \r\n\r\n- **What happened?** In our discussions with several customers in private preview, lack of support for multi-variate A/D is coming up as a blocker to have them fully operationalize their hot path pipelines with this core feature. The list of customers include: \r\n1) Azure IoT Central (IoT SaaS solution) which uses Stream Analytics under the covers and are expected to grow to supporting '000s of IoT deployment by mid 2019. They require support for upto 4 variables.\r\n2) Stanley Black and Decker\r\n3) ATOS - European SI's IoT practice that works with many customers to build end to end IoT solutions. \r\n\r\n- **What did you expect?** N/A\r\n\r\n### Source code / logs N/A\r\n\r\nPlease paste or attach the code or logs or traces that would be helpful to diagnose the issue you are reporting.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1696","RelatedDescription":"Open issue \"(Azure Stream Analytics) Multivariate support for time series anomaly detection\" (#1696)"},{"Id":"383247595","IsPullRequest":false,"CreatedAt":"2018-11-21T18:37:06","Actor":"artidoro","Number":"1695","RawContent":null,"Title":"Separate assembly for statically typed API extensions","State":"open","Body":"There should be a greater separation between the statically typed API and the dynamic API, so that users are more aware of which one they are using. Ideally the statically typed extensions should live in a separate assembly, but they should at least be in a separate namespace.\r\n\r\nCurrently some extensions for the statically typed API are not under the StaticPipe namespace. From preliminary search the following estimators seem to have extensions that are not under Microsoft.ML.StaticPipe:\r\nhttps://github.com/dotnet/machinelearning/blob/dd46276cc257e20fe09239aeedb2f25c4bded6dd/src/Microsoft.ML.Transforms/MissingValueIndicatorTransformer.cs\r\nhttps://github.com/dotnet/machinelearning/blob/dd46276cc257e20fe09239aeedb2f25c4bded6dd/src/Microsoft.ML.Data/Transforms/KeyToValue.cs\r\nhttps://github.com/dotnet/machinelearning/blob/dd46276cc257e20fe09239aeedb2f25c4bded6dd/src/Microsoft.ML.Transforms/KeyToVectorMapping.cs\r\nhttps://github.com/dotnet/machinelearning/blob/e74bc65524430a1e0ed06912bdb5c6c21ef8d158/src/Microsoft.ML.Transforms/Text/TextFeaturizingEstimator.cs\r\nhttps://github.com/dotnet/machinelearning/blob/dd46276cc257e20fe09239aeedb2f25c4bded6dd/src/Microsoft.ML.Transforms/MissingValueReplacing.cs\r\nhttps://github.com/dotnet/machinelearning/blob/dd46276cc257e20fe09239aeedb2f25c4bded6dd/src/Microsoft.ML.Data/Transforms/KeyToVector.cs","Url":"https://github.com/dotnet/machinelearning/issues/1695","RelatedDescription":"Open issue \"Separate assembly for statically typed API extensions\" (#1695)"},{"Id":"382940051","IsPullRequest":true,"CreatedAt":"2018-11-21T03:28:08","Actor":"jignparm","Number":"1694","RawContent":null,"Title":"WIP: Upgrade to ML.Scoring v 1.2.0, with bug fixes and GPU/CUDA  support","State":"open","Body":"Fixes #1514 \r\nFixes #1228 \r\n\r\nUpgraded runtime to Onnx 1.3, with isNan operator.\r\n\r\nBetter exception handling -- clear error messages instead of generic SEH exception.\r\n\r\nGPU support via CUDA 9.2","Url":"https://github.com/dotnet/machinelearning/pull/1694","RelatedDescription":"Open PR \"WIP: Upgrade to ML.Scoring v 1.2.0, with bug fixes and GPU/CUDA  support\" (#1694)"},{"Id":"382919304","IsPullRequest":false,"CreatedAt":"2018-11-21T01:41:01","Actor":"CESARDELATORRE","Number":"1693","RawContent":null,"Title":"QUESTION: The \"pipeline\" is immutable; sometimes a chain of Estimators, sometimes a single Estimator. Easy to understand?","State":"open","Body":"This is just an observation of a possible risk. I'm not saying that my hypothetical proposal below is better, since it is probably less flexible. I just would like to get feedback from the community about our current approach to double-check we're on the right path.\r\n\r\nThe fact that a \"pipeline\" sometimes is a \"chain of estimators\", but sometimes \"it can be\" a single estimator could be confusing for developers. For instance:\r\n\r\nIn this case \"dataProcessPipeline\" is a single Estimator of type `TextFeaturizingEstimator`:\r\n\r\n`var dataProcessPipeline = mlContext.Transforms.Categorical.MapValueToKey(\"Area\", \"Label\")\r\n;`\r\n\r\nIn this other case below, \"dataProcessPipeline\" is a chain of estimators of type `EstimatorChain<TTrans>`, as soon as you call the first `Append()`:\r\n\r\n```\r\nvar dataProcessPipeline = mlContext.Transforms.Categorical.MapValueToKey(\"Area\", \"Label\")\r\n                .Append(mlContext.Transforms.Text.FeaturizeText(\"Title\", \"TitleFeaturized\"))\r\n                .Append(mlContext.Transforms.Text.FeaturizeText(\"Description\", \"DescriptionFeaturized\"))\r\n                .Append(mlContext.Transforms.Concatenate(\"Features\", \"TitleFeaturized\", \"DescriptionFeaturized\"));\r\n```\r\n\r\nAlso, the fact that an EstimatorChain pipeline is created from its first element might also be confusing?\r\n\r\nSimplifying and in comparison, when you create a List or collection in C# you first create the List (the box) then add things/elements  into it. You usually don't create a collection of items from the first item but you create the \"box\" first, then add items. But that is for mutable collections. Not the same! :)\r\n\r\nIn the case of our current EstimatorChain it is using a more advanced pattern based on fluent API and immutable objects. Since each estimator and estimator-chain is immutable, when you append another estimator in reality you are creating a new estimator-chain and returning that new pipeline (estimator-chain).\r\n\r\n**QUESTION: Is this pattern clear or confusing for you?**\r\n\r\nA different approach based on a typical **mutable** collection could be something like the following (This is NOT how ML.NET currently works and might require different types):\r\n\r\n```\r\n//DataView with dataset\r\nIDataView trainingDataView = textLoader.Read(TrainDataPath);\r\n\t\t\r\n// Create an \"empty\" EstimatorChain, the \"box\", which would be mutable, as it'll be growing with items:\r\nvar dataProcessPipeline = MLContext.CreateEstimatorChain();\r\n\r\n// Add Estimators to the same chain/pipeline\r\ndataProcessPipeline.Append(mlContext.Transforms.CopyColumns(\"FareAmount\", \"Label\");\r\ndataProcessPipeline.Append(mlContext.Transforms.Categorical.OneHotEncoding(\"VendorId\", \"VendorIdEncoded\"));\r\ndataProcessPipeline.Append(mlContext.Transforms.Normalize(inputName: \"TripTime\", mode: NormalizerMode.MeanVariance));\r\ndataProcessPipeline.Append(mlContext.Transforms.Concatenate(\"Features\", \"VendorIdEncoded\", \"TripTime\"));\r\n\r\n//... Peek data into the DataView, etc. if you want\r\n\r\n//Optional - Clone the pipeline with data transformations in case you want to reuse the dataProcessPipeline for parallel executions of additional trainers\r\nvar trainingPipeline = dataProcessPipeline.Clone();\r\n\r\n//Add trainer to the training pipeline\r\nvar sdcaTrainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent(label: \"Label\", features: \"Features\");\r\ntrainingPipeline.Append(sdcaTrainer);\r\n\r\n//Train the model fitting to the dataSet\r\nvar trainedModel = trainingPipeline.Fit(trainingDataView);\r\n```\r\nIn this last code, when you execute dataProcessPipeline.Append(estimator) it is really appending an estimator into that current pipeline. \r\n\r\nIn comparison and shown below, with our current API, when adding a trainer, you have to \"catch\" the returned pipeline, as the estimator/trainer was added only to the returned new pipeline, not to the pipeline owning the method Append() you run.\r\n\r\n```\r\n//Add trainer to the training pipeline\r\nvar sdcaTrainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent(label: \"Label\", features: \"Features\");\r\nvar trainingPipeline = dataProcessPipeline.Append(sdcaTrainer);\r\n\r\n//Train the model fitting to the dataSet\r\nvar trainedModel = trainingPipeline.Fit(trainingDataView);\r\n```\r\nThat's also why you don't need to clone the pipeline if you want to \"fork\" it, since every time you call Append() you are creating a new pipeline, so you could \"fork\" whenever you call .Append().\r\n\r\nAs summary, in our current API, .Append() is not appending anything into the current pipeline, but creating and returning a new pipeline (EstimatorChain) with that new estimator appended.\r\n\r\nOur current approach is probably more flexible based on immutable EstimatorChains but I'd like to double check if our current approach is clear for anyone learning the API.\r\n\r\n What are your thoughts about it?\r\nCan you provide your feedback? 👍 \r\nThanks, \r\n \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1693","RelatedDescription":"Open issue \"QUESTION: The \"pipeline\" is immutable; sometimes a chain of Estimators, sometimes a single Estimator. Easy to understand?\" (#1693)"},{"Id":"382908812","IsPullRequest":true,"CreatedAt":"2018-11-21T00:49:04","Actor":"rogancarr","Number":"1692","RawContent":null,"Title":"WIP: Adding documentation for GAM","State":"open","Body":"This PR adds documentation for using the GAM in the Microsoft.ML.Samples project.\r\n\r\nFixes #1645 \r\n\r\nAwaiting PR #1691 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/1692","RelatedDescription":"Open PR \"WIP: Adding documentation for GAM\" (#1692)"},{"Id":"382906847","IsPullRequest":false,"CreatedAt":"2018-11-21T00:39:54","Actor":"CESARDELATORRE","Number":"1690","RawContent":null,"Title":"Rename mlContext.Data.TextReader() to mlContext.Data.CreateTextLoader()","State":"open","Body":"Since the object being created is a \"TextLoader\", I'd recommend the method's name to say so, instead of \"TextReader\" which looks like a different type. \r\n\r\nI mean code like the following feels confusing:\r\n\r\n```\r\n            TextLoader textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()\r\n                                                    {\r\n                                                        Separator = \"tab\",\r\n                                                        HasHeader = true,\r\n                                                        Column = new[]\r\n                                                                    {\r\n                                                                    new TextLoader.Column(\"Label\", DataKind.Bool, 0),\r\n                                                                    new TextLoader.Column(\"Text\", DataKind.Text, 1)\r\n                                                                    }\r\n                                                    });\r\n```\r\n\r\nIn addition to that, methods should have a verb as part of the name, so if what it is doing is to create a TextReader, let's say so, as:\r\n\r\nmlContext.Data.CreateTextLoader()\r\n\r\nWe're not being consistent now when having some methods with a verb but other methods just a noun:\r\n\r\n![image](https://user-images.githubusercontent.com/1712635/48811328-18f0d300-ece2-11e8-8d31-2e2fad81ab60.png)\r\n\r\nIt is also against C# conventions (and most languages). A method's name should have a verb describing the action being performed by that method:\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-type-members#names-of-methods","Url":"https://github.com/dotnet/machinelearning/issues/1690","RelatedDescription":"Open issue \"Rename mlContext.Data.TextReader() to mlContext.Data.CreateTextLoader()\" (#1690)"},{"Id":"382904365","IsPullRequest":false,"CreatedAt":"2018-11-21T00:27:24","Actor":"CESARDELATORRE","Number":"1689","RawContent":null,"Title":"Include the \"save file\" action (.ZIP file) as part of model.SaveFile()","State":"open","Body":"Currently, whenever we are saving a .ZIP model file, you always need to handle the code for the File stream class.\r\n\r\nI think that is repetitive code that could be included in the API.\r\nInstead of:\r\n\r\n```\r\nusing (var fs = new FileStream(ModelPath, FileMode.Create, FileAccess.Write, FileShare.Write))\r\n                mlContext.Model.Save(trainedModel, fs);\r\n```\r\n\r\nWe could have an overridden method so I could simply do the following:\r\n\r\n`mlContext.Model.Save(trainedModel, modelPath);`\r\n\r\nOr even the following, if those methods were part of the model class itself instead of a utility class in the MLContext:\r\n\r\n`model.Save(modelPath);`\r\n\r\nCurrently, this kind of line using the file stream class is something you need to repeat over and over in every/most training app (even when the constructor can be simplified):\r\n\r\n`using (var fs = new FileStream(ModelPath, FileMode.Create, FileAccess.Write, FileShare.Write))`\r\n\r\nHandling a FileStream object might should not be mandatory for the user **but optional**:\r\n\r\nOf course, I would also maintain the current methods because in some cases you might want to just provide an existing stream object, but as opt-in.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1689","RelatedDescription":"Open issue \"Include the \"save file\" action (.ZIP file) as part of model.SaveFile()\" (#1689)"},{"Id":"382878508","IsPullRequest":false,"CreatedAt":"2018-11-20T22:42:46","Actor":"eerhardt","Number":"1688","RawContent":null,"Title":"CpuMath has a bad project reference to ML.Core","State":"open","Body":"See https://github.com/dotnet/machinelearning/pull/1659#discussion_r235195505\r\n\r\nWe recently made CpuMath depend on ML.Core, but this is broken.\r\n\r\nThe `Microsoft.ML` nuget package depends on the `Microsoft.ML.CpuMath` NuGet package.  So having the CpuMath.dll depend on `Microsoft.ML.Core` is backwards.\r\n\r\nSee https://github.com/dotnet/machinelearning/pull/542 for the reasoning why this was done that way.","Url":"https://github.com/dotnet/machinelearning/issues/1688","RelatedDescription":"Open issue \"CpuMath has a bad project reference to ML.Core\" (#1688)"},{"Id":"382820511","IsPullRequest":true,"CreatedAt":"2018-11-20T19:43:56","Actor":"yaeldekel","Number":"1687","RawContent":null,"Title":"Remove adult.train and adult.test and modify all unit tests","State":"open","Body":"\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1687","RelatedDescription":"Open PR \"Remove adult.train and adult.test and modify all unit tests\" (#1687)"},{"Id":"382795373","IsPullRequest":true,"CreatedAt":"2018-11-20T18:32:16","Actor":"wschin","Number":"1686","RawContent":null,"Title":"Obsolete API","State":"open","Body":"We are planning removing classical APIs defined in Microsoft.ML.Legacy. The commits are organized so please read them one-by-one.\r\n\r\nFixes #1684.","Url":"https://github.com/dotnet/machinelearning/pull/1686","RelatedDescription":"Open PR \"Obsolete API\" (#1686)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-11-23T05:30:32.1120969Z","RunDurationInMilliseconds":1257}