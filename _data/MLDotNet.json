{"Data":{"GitHub":{"Issues":[{"Id":"395743777","IsPullRequest":true,"CreatedAt":"2019-01-06T05:30:09","Actor":"wschin","Number":"2013","RawContent":null,"Title":"New ONNX converter interface and some tests","State":"closed","Body":"This PR create a ONNX converter targeting ITransformer. A full example is added as a test; we train a pipeline (normalize + SDCA) using new APIs, convert the trained model, and call ONNXRuntime to evaluate it. In addition, we recreate existing ONNX conversion tests using new APIs to ensure at least identical test coverage after removing ONNX tests using legacy APIs.\r\n\r\nWorking item summary:\r\n1. Create new ONNX converter interface which is able to handle ITransformer.\r\n2. Remove OnnxTest.cs\r\n3. Recreate ONNX conversions in OnnxTest.cs using new APIs.\r\n4. Add extra end-to-end tests. We train ML.NET model, convert it to ONNX format, and call ONNX runtime to execute it. The results produced by ONNX runtime and ML.NET's original model are checked.","Url":"https://github.com/dotnet/machinelearning/pull/2013","RelatedDescription":"Closed or merged PR \"New ONNX converter interface and some tests\" (#2013)"},{"Id":"396229213","IsPullRequest":false,"CreatedAt":"2019-01-06T05:18:40","Actor":"TomFinley","Number":"2041","RawContent":null,"Title":"TextLoader Separator/SeparatorChars","State":"open","Body":"Consider these two settings:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/496e185fdaf8969ffd856c65c42dd259368a242d/src/Microsoft.ML.Data/DataLoadSave/Text/TextLoader.cs#L356-L360\r\n\r\nThey both exist for the same purpose but serve very different endpoints. One exists for the benefit of the command line, one for the benefit of the API. The API one (currently named `SeparatorChars`) should instead become `Separators` (plural pursuant to #2040). The other, currently named `Separator`, can remain named that, but should be invisible to API users since it exists purely for the benefit of the command line users. So, it should become `internal`.\r\n\r\n/cc @stephentoub ","Url":"https://github.com/dotnet/machinelearning/issues/2041","RelatedDescription":"Open issue \"TextLoader Separator/SeparatorChars\" (#2041)"},{"Id":"396227082","IsPullRequest":false,"CreatedAt":"2019-01-06T04:31:28","Actor":"TomFinley","Number":"2040","RawContent":null,"Title":"Pluralize names of settings/arguments field values to plural when array","State":"open","Body":"Consider this content of concatentating transformer's `Argument`'s class:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/496e185fdaf8969ffd856c65c42dd259368a242d/src/Microsoft.ML.Data/Transforms/ColumnConcatenatingTransformer.cs#L116-L117\r\n\r\nOr this similar entry:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/496e185fdaf8969ffd856c65c42dd259368a242d/src/Microsoft.ML.Data/Transforms/ColumnConcatenatingTransformer.cs#L122-L123\r\n\r\nYou will notice something curious. This is an array of `Column[]`, yet is named `Column`, not `Columns`. The reason for this is somewhat odd: this settings object *originally* arose out of the need to provide a command line settable object back when this code was supporting a tool (and not an API!). And, the presence of an array indicate that this setting can be set multiple times... so one could say, for instance, `column=Foo column=Bar column=Biz`, and so wind up with this field populated with 3 items. In this setting the name \"column\" is the most natural name.\r\n\r\nNow we are trying to ship an API. What we did for the convenience of the command line now causes confusion for an API user, because they see an array (which can clearly handle multiple items), yet it has a singular name!\r\n\r\nFortunately, we can have our cake and eat it too: the `ArgumentAttribute` has something called `Name`, to allow the field name to be distinguished from the command line name. So, this:\r\n\r\n```csharp\r\n[Argument(ArgumentType.Multiple | ArgumentType.Required,\r\n    HelpText = \"New column definition(s) (optional form: name:srcs)\",\r\n    ShortName = \"col\", SortOrder = 1)]\r\npublic Column[] Column;\r\n```\r\n\r\ncould become this:\r\n\r\n```csharp\r\n[Argument(ArgumentType.Multiple | ArgumentType.Required,\r\n    HelpText = \"New column definition(s) (optional form: name:srcs)\",\r\n    Name = \"Column\", ShortName = \"col\", SortOrder = 1)]\r\npublic Column[] Columns;\r\n```\r\n\r\nand remain equivalent from the command line perspective, while not being confusing from the API perspective.\r\n\r\nAs a general rule any field with an `ArgumentAttribute` attribute on it that is also an array, we have often not made plural, for the aforementioned reasons. If it is singular:\r\n\r\n1. Make the field name itself plural and\r\n\r\n2. Retain the old singular command line as this `Name` parameter, so as to retain the benefit of why we named it this way in the first place.\r\n\r\nHowever, please, not thoughtlessly! Think about whether that change makes sense *in context*.\r\n\r\n/cc @stephentoub ","Url":"https://github.com/dotnet/machinelearning/issues/2040","RelatedDescription":"Open issue \"Pluralize names of settings/arguments field values to plural when array\" (#2040)"},{"Id":"396224973","IsPullRequest":false,"CreatedAt":"2019-01-06T03:45:02","Actor":"daholste","Number":"2039","RawContent":null,"Title":"Code in Documentation Not Working","State":"open","Body":"### Issue\r\n\r\n- **What did you do?**\r\nNavigated to https://github.com/dotnet/machinelearning/blob/80f5720438d544b1c9cf019a889479d8e67d5837/docs/code/SchemaComprehension.md\r\n\r\nNoticed that the code uses Microsoft.ML.Data.TlcEnvironment that no longer exists\r\n\r\n@justinormont had a great suggestion -- perhaps wrap each documentation code sample in a unit test to prevent breakage?","Url":"https://github.com/dotnet/machinelearning/issues/2039","RelatedDescription":"Open issue \"Code in Documentation Not Working\" (#2039)"},{"Id":"396144986","IsPullRequest":false,"CreatedAt":"2019-01-05T08:14:48","Actor":"wschin","Number":"2038","RawContent":null,"Title":"ReplaceMissingValues' input argument type","State":"open","Body":"Most transforms use string as column names but in the function below, users need to create `ColumnInfo` first.\r\n```\r\n        public static MissingValueReplacingEstimator ReplaceMissingValues(this TransformsCatalog catalog, params MissingValueReplacingTransformer.ColumnInfo[] columns)\r\n```\r\nIs it appropriate to use\r\n```\r\n        public static MissingValueReplacingEstimator ReplaceMissingValues(this TransformsCatalog catalog, string[] inputs, string[] outputs)\r\n```\r\nor\r\n```\r\n        public static MissingValueReplacingEstimator ReplaceMissingValues(this TransformsCatalog catalog, params (string, string) inputOutputColumnPairs)\r\n```\r\n?","Url":"https://github.com/dotnet/machinelearning/issues/2038","RelatedDescription":"Open issue \"ReplaceMissingValues' input argument type\" (#2038)"},{"Id":"396117788","IsPullRequest":true,"CreatedAt":"2019-01-05T03:42:26","Actor":"artidoro","Number":"2033","RawContent":null,"Title":"Remove legacy dependency from TextLoaderTests.cs","State":"closed","Body":"Part of the effort described in #1971.\r\n\r\nThis PR removes references to the legacy API from the TextLoaderTests.cs file.\r\nPart of the tests just required substituting to the new textloader, others were substituted by an equivalent json entrypoint graph that was used to run the same pipeline defined in the old api.","Url":"https://github.com/dotnet/machinelearning/pull/2033","RelatedDescription":"Closed or merged PR \"Remove legacy dependency from TextLoaderTests.cs\" (#2033)"},{"Id":"396125056","IsPullRequest":false,"CreatedAt":"2019-01-05T02:36:32","Actor":"artidoro","Number":"2037","RawContent":null,"Title":"Need better exception for TextLoader when column attribute is not present","State":"open","Body":"In PR #2033 we converted all uses of the legacy TextLoader to the new TextLoader.\r\n\r\nIt emerged that when reading from a file providing the schema, if there is no column attribute, then there are two different exceptions thrown depending on whether it is a debug or release build.\r\n\r\nWe need a single exception for both debug and release, and we need the name to be more informative. We also need a single message for both exceptions.\r\n\r\nThis is the test that exerts these exceptions: ThrowsExceptionWithPropertyName in TextLoaderTests.cs","Url":"https://github.com/dotnet/machinelearning/issues/2037","RelatedDescription":"Open issue \"Need better exception for TextLoader when column attribute is not present\" (#2037)"},{"Id":"395768044","IsPullRequest":true,"CreatedAt":"2019-01-05T02:08:37","Actor":"codemzs","Number":"2015","RawContent":null,"Title":"Remove legacy API test that already have coverage and refactor code.","State":"closed","Body":"Deleted all tests under test/Microsoft.ML.Tests/Scenarios/PipelineApi and removed SentimentPredictionTests.cs from test/Microsoft.ML.Tests/ScenariosWithDirectInstantiation because these tests already have equivalent tests that use new api under test/Microsoft.ML.Tests/Scenarios/Api/Estimators. \r\n\r\nVerified the code coverage wasn't affected too much, its now at **68.94% vs 68.97%** the difference is in the below dlls:\r\nmicrosoft.ml.data.dll - 0.05%\r\nmicrosoft.ml.entrypoints.dll - 0.18% (expected since legacy api calls into core entrypoints API)\r\nmicrosoft.ml.fasttree.dll - 0.04%\r\nmicrosoft.ml.hallearners.dll - 0.99% (This drop is coming from the removal of SymSGD test, will add one in another PR)\r\nmicrosoft.ml.transforms.dll - 0.06%\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2015","RelatedDescription":"Closed or merged PR \"Remove legacy API test that already have coverage and refactor code.\" (#2015)"},{"Id":"396122210","IsPullRequest":true,"CreatedAt":"2019-01-05T02:00:16","Actor":"yaeldekel","Number":"2036","RawContent":null,"Title":"Expose internal APIs to components that use them in an internal repo","State":"open","Body":"Fixes #2035.","Url":"https://github.com/dotnet/machinelearning/pull/2036","RelatedDescription":"Open PR \"Expose internal APIs to components that use them in an internal repo\" (#2036)"},{"Id":"396122184","IsPullRequest":false,"CreatedAt":"2019-01-05T01:59:57","Actor":"yaeldekel","Number":"2035","RawContent":null,"Title":"APIs that were made internal need to be exposed for use in an internal repo","State":"open","Body":"We need to add the InternalsVisibleTo attribute to a few of the ML.NET projects so that components in the internal repo can use their internal APIs.","Url":"https://github.com/dotnet/machinelearning/issues/2035","RelatedDescription":"Open issue \"APIs that were made internal need to be exposed for use in an internal repo\" (#2035)"},{"Id":"396079964","IsPullRequest":true,"CreatedAt":"2019-01-05T01:47:31","Actor":"najeeb-kazmi","Number":"2027","RawContent":null,"Title":"Remove Legacy dependency from Microsoft.ML.Benchmarks","State":"closed","Body":"Part of the work in PR #1971 \r\n\r\nThis PR removes dependency on Legacy code from Microsoft.ML.Benchmarks.\r\n\r\n`LegacyPredictionEngineBench.cs` was written to mimic `PredictionEngineBench.cs` using Legacy API after the fact, so just deleting it here.\r\n\r\n`StochasticDualCoordinateAscentClassifierBench.cs` is rewritten to use new API and remove all Legacy code.","Url":"https://github.com/dotnet/machinelearning/pull/2027","RelatedDescription":"Closed or merged PR \"Remove Legacy dependency from Microsoft.ML.Benchmarks\" (#2027)"},{"Id":"396113560","IsPullRequest":true,"CreatedAt":"2019-01-05T01:36:13","Actor":"codemzs","Number":"2032","RawContent":null,"Title":"Remove collectionsdatasource tests.","State":"closed","Body":"CollectionsDataSource part of legacy api uses StreamingIDataView under the hood which already has coverage from other tests based on code coverage analysis. Remove CollectionsDataSource tests as they use legacy API.","Url":"https://github.com/dotnet/machinelearning/pull/2032","RelatedDescription":"Closed or merged PR \"Remove collectionsdatasource tests.\" (#2032)"},{"Id":"396096290","IsPullRequest":true,"CreatedAt":"2019-01-05T01:31:38","Actor":"jignparm","Number":"2029","RawContent":null,"Title":"Added more documentation and extra CPU path test","State":"closed","Body":"Updated XML docs for public estimator methods.\r\nUpdate XML to point to new GPU package\r\nAdded tests for extra CPU paths (gpuDeviceId=null, fallBackToCPU=true)\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2029","RelatedDescription":"Closed or merged PR \"Added more documentation and extra CPU path test\" (#2029)"},{"Id":"396118100","IsPullRequest":false,"CreatedAt":"2019-01-05T01:28:19","Actor":"mikaelm12","Number":"2034","RawContent":null,"Title":"When in debug loading ML model fails with \"Unknown file type\"","State":"open","Body":"When in debug, I get an exception, \"Unknown file type\", when I try to load an already trained ML model. The weird thing is that this only happens in debug. Any idea as to why this is failing? Thanks","Url":"https://github.com/dotnet/machinelearning/issues/2034","RelatedDescription":"Open issue \"When in debug loading ML model fails with \"Unknown file type\"\" (#2034)"},{"Id":"396112677","IsPullRequest":true,"CreatedAt":"2019-01-05T00:38:10","Actor":"Ivanidzo4ka","Number":"2031","RawContent":null,"Title":"Hide IDataTransform Create methods","State":"open","Body":"Step towards https://github.com/dotnet/machinelearning/issues/1995.\r\nAlso add proper comments for Image transforms.\r\nRemove Create methods in Onnx and Tensorflow (replace them with proper constructors).","Url":"https://github.com/dotnet/machinelearning/pull/2031","RelatedDescription":"Open PR \"Hide IDataTransform Create methods\" (#2031)"},{"Id":"396099432","IsPullRequest":true,"CreatedAt":"2019-01-05T00:01:07","Actor":"abgoswam","Number":"2030","RawContent":null,"Title":"Fix build break","State":"closed","Body":"Fix to mitigate the build break.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2030","RelatedDescription":"Closed or merged PR \"Fix build break\" (#2030)"},{"Id":"396003756","IsPullRequest":true,"CreatedAt":"2019-01-04T23:55:47","Actor":"eerhardt","Number":"2023","RawContent":null,"Title":"Remove ColumnType \"Is\" properties (except IsKey and IsVector)","State":"closed","Body":"Remove the following properties from ColumnType:\r\n\r\n- IsPrimitive\r\n- IsNumber\r\n- IsText\r\n- IsBool\r\n\r\nAnd move `IsStandardScalar` to an extension method, so it can be left in ML.NET when ColumnType is extracted with IDataView to a separate package.\r\n\r\nI plan on removing `IsKey` and `IsVector` each in their own PR along with the rest of the \"Key\" and \"Vector\" members on ColumnType.\r\n\r\nPart of the work necessary for #1860 ","Url":"https://github.com/dotnet/machinelearning/pull/2023","RelatedDescription":"Closed or merged PR \"Remove ColumnType \"Is\" properties (except IsKey and IsVector)\" (#2023)"},{"Id":"395955105","IsPullRequest":true,"CreatedAt":"2019-01-04T22:06:33","Actor":"artidoro","Number":"2021","RawContent":null,"Title":"Remove Legacy dependency in ML.FSharp.Tests","State":"closed","Body":"Part of the effort described in #1971.\r\n\r\nThis PR removes Legacy code in ML.TestFramework and ML.FSharp.Tests, and replaces it with the new Estimator, Transformer API. Specifically, it changes tests that were using ModelHelper.cs (although those tests were skipped anyway as the dataset is missing). It also changes the F# code in the F# smoke tests to use the new API.  \r\n\r\nI checked the code coverage effect of this PR, and it increases the coverage by 0.02% (possibly for deleting test utility code that was not used).\r\n\r\n\r\nEDIT:\r\nWe decided to remove the tests relying on the housing dataset in PR #2024. I am therefore reverting my changes on those tests and letting that PR remove all references to Legacy in the TestFramework DLL.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2021","RelatedDescription":"Closed or merged PR \"Remove Legacy dependency in ML.FSharp.Tests\" (#2021)"},{"Id":"395853507","IsPullRequest":true,"CreatedAt":"2019-01-04T22:04:40","Actor":"codemzs","Number":"2020","RawContent":null,"Title":"Convert CSharpAPI based tests to EntryPoint based test.","State":"closed","Body":"Converts [CSharpAPI tests](https://github.com/dotnet/machinelearning/blob/master/test/Microsoft.ML.Core.Tests/UnitTests/TestCSharpApi.cs) to entrypoints based test. CSharpAPI converts the pipeline to a json graph which is converted by entrypoint infrastructure to MLNET pipeline via entrypoints. This change converts the CSharp based pipeline to Json graph and invokes the graph runner, hence preserving code coverage of entry points infrastructure and ML.NET transforms/trainers, etc.\r\n\r\nCode coverage seems to drop by 0.09%, bulk of it seems to be coming from microsoft.ml.core.tests.dll - 0.55% where TestCSharpAPI.cs file was deleted, followed by microsoft.ml.core.dll - 0.24%, microsoft.ml.maml.dll - 0.13%, microsoft.ml.transforms.dll - 0.02%.\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2020","RelatedDescription":"Closed or merged PR \"Convert CSharpAPI based tests to EntryPoint based test.\" (#2020)"},{"Id":"396022011","IsPullRequest":true,"CreatedAt":"2019-01-04T22:02:00","Actor":"abgoswam","Number":"2024","RawContent":null,"Title":"Updating tests in Microsoft.ML.Tests/Scenarios to new API","State":"closed","Body":"1. Updated the `ClusteringPrediction` test to use new API\r\n\r\n2. Deleted the following 3 Legacy tests, which were being skipped because of missing data set files \r\n\r\n- `PredictHousePriceModelTest`\r\n- `TrainAndPredictHousePriceModelTest`\r\n- `ReadStrongTypeModelFromStream`\r\n\r\n3. Deleted `test\\Microsoft.ML.TestFramework\\ModelHelper.cs` which had some helper utils for (2)  above\r\n\r\n4. Remove Legacy references from Microsoft.ML.TestFramework.csproj and EnvironmentExtensions.cs\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2024","RelatedDescription":"Closed or merged PR \"Updating tests in Microsoft.ML.Tests/Scenarios to new API\" (#2024)"},{"Id":"396082082","IsPullRequest":false,"CreatedAt":"2019-01-04T22:00:18","Actor":"TomFinley","Number":"2028","RawContent":null,"Title":"Internalization of CacheDataView and IRowSeekable","State":"open","Body":"One thing we may want to consider is that, while having caching is nice and necessary, and we should expose some ability to *perform* caching if we want (as we do with the, exposing `AppendCacheCheckpoint`, as seen here:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/5c00980abeae594161d0b9ee748d7d0b959962b5/src/Microsoft.ML.Data/DataLoadSave/EstimatorChain.cs#L99\r\n\r\nThis itself *uses* `CacheDataView`, but does not expose it. I am somewhat uncomfortable exposing the cache data view as part of our public API in a way that makes it a first class citizen of the API, at least, in v1.0 of the API. Its particular interface is a bit odd (possibly for good reasons, but odd nonetheless), and most of the reasons for its oddness have to do with how components might want to behave \"specially\" with it, and component authoring scenarios are not a target for v1.0. So hiding it, and `IRowSeekable` (which is a useful but, again, somewhat odd interface), might be good.","Url":"https://github.com/dotnet/machinelearning/issues/2028","RelatedDescription":"Open issue \"Internalization of CacheDataView and IRowSeekable\" (#2028)"},{"Id":"396068456","IsPullRequest":false,"CreatedAt":"2019-01-04T21:09:41","Actor":"Ivanidzo4ka","Number":"2026","RawContent":null,"Title":"TextFeaturizingEstimator shouldn't use Argument class as main way of setting itself.","State":"open","Body":"https://github.com/dotnet/machinelearning/blob/5c00980abeae594161d0b9ee748d7d0b959962b5/src/Microsoft.ML.Transforms/Text/TextFeaturizingEstimator.cs#L141\r\n\r\nCurrently if I want to play with Word extractor and Char extractor I need to do that via \r\nhttps://github.com/dotnet/machinelearning/blob/5c00980abeae594161d0b9ee748d7d0b959962b5/src/Microsoft.ML.Transforms/Text/TextFeaturizingEstimator.cs#L497\r\n\r\nwhich stops me from hiding IDataTransform interface.\r\nWe should have proper way to set it up via Setting object.\r\n\r\nRelated to https://github.com/dotnet/machinelearning/issues/1995","Url":"https://github.com/dotnet/machinelearning/issues/2026","RelatedDescription":"Open issue \"TextFeaturizingEstimator shouldn't use Argument class as main way of setting itself.\" (#2026)"},{"Id":"396049815","IsPullRequest":false,"CreatedAt":"2019-01-04T20:01:43","Actor":"yaeldekel","Number":"2025","RawContent":null,"Title":"Add a method in DataOperationsCatalog that creates an IDataView from an IEnumerable<T>","State":"open","Body":"Currently we have an extension method CreateStreamingDataView in ComponentCreation that operates over IHostEnvironment. We should add an extension over DataOperations instead, and consider making the current one internal.\r\nRelated to #1993 .","Url":"https://github.com/dotnet/machinelearning/issues/2025","RelatedDescription":"Open issue \"Add a method in DataOperationsCatalog that creates an IDataView from an IEnumerable<T>\" (#2025)"},{"Id":"395741170","IsPullRequest":true,"CreatedAt":"2019-01-04T17:37:26","Actor":"zeahmed","Number":"2012","RawContent":null,"Title":"Fixing typo in FeatureContributionCalculation sample.","State":"closed","Body":"Fixing typos in FeatureContributionCalculation sample.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2012","RelatedDescription":"Closed or merged PR \"Fixing typo in FeatureContributionCalculation sample.\" (#2012)"},{"Id":"395956164","IsPullRequest":false,"CreatedAt":"2019-01-04T15:03:28","Actor":"mareklinka","Number":"2022","RawContent":null,"Title":"Convolutional net gives different results under ML.NET and Keras/TensorFlow","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10 1809\r\n- **.NET Version (eg., dotnet --info)**: \r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.2.100\r\n Commit:    b9f2fa0ca8\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17763\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.2.100\\\r\n\r\nHost (useful for support):\r\n  Version: 2.2.0\r\n  Commit:  1249f08fed\r\n\r\n.NET Core SDKs installed:\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.500 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.502 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.100 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\n### Issue\r\n\r\nI'm facing an issue while trying to score my Keras-trained, TensorFlow-backed model using ML.NET 0.8.\r\n\r\n#### The ML task\r\nThis is a rather small convolutional neural net that inputs an image and attempts to identify two areas of interest in the image. We are attempting to read some data off a hardware device.\r\n\r\n#### The model\r\n\r\nWe have a trained Keras model (.5h) and we converted it into a frozen TensorFlow model (.pb). The net contains 4 convolutional layers, 1 dense layer (the output), and uses ReLU activations. The output of the model is an array of 8 numbers: [X1_1, Y1_1, X2_1, Y2_1, X2_1, Y2_1, X2_2, Y2_2]. These are the top-left and bottom-right corners of the two areas of interest.\r\n\r\nNetron diagram:\r\n\r\n![current_model_best](https://user-images.githubusercontent.com/7479226/50692919-bfe0c280-1035-11e9-8e21-d32da1006a4a.png)\r\n\r\nThis model works very well for our use case when we execute it using Keras.\r\n\r\n#### the ML.NET scoring setup\r\n\r\nSince our main application is written in C#, I tried to use ML.NET to access the predictions from C# code. The pipeline is setup like this:\r\n\r\n\r\n``` csharp\r\nvar pipeline =\r\n    new ImageLoadingEstimator(env, imagePath, (nameof(AreaInput.Path), \"ImageData\"))\r\n    .Append(new ImageResizingEstimator(env, \"ImageData\", \"ImageResized\", Areas.ImageWidth,\r\n        Areas.ImageHeight))\r\n    .Append(new ImagePixelExtractingEstimator(env,\r\n        new ImagePixelExtractorTransform.ColumnInfo(\r\n            \"ImageResized\", Areas.InputLayerName,\r\n            ImagePixelExtractorTransform.ColorBits.Rgb, interleave: true,\r\n            scale: 1 / 255f)))\r\n    .Append(new TensorFlowEstimator(env, modelPath, new[] {Areas.InputLayerName},\r\n        new[] {Areas.OutputLayerName}));\r\n```\r\n\r\nOn the surface, we do the same thing as with Keras:\r\n1. Load an image from the file system\r\n2. Resize the image to 400x400 (the model's expected input size)\r\n3. Convert the image to a vector (dimmensions of (batch_size, 400, 400, 3) - we are using RGB mode)\r\n4. Feed this vector into the TF model\r\n\r\nThen we make a predictor function from this pipeline and use that to score examples.\r\n\r\n#### The issue\r\n\r\nThere are actually two issues with this. One is a problem with interoperability - the `ImageResizingEstimator` is doing something very different than Keras' `load_img`:\r\n\r\n* `load_img(x, target_size=(400,400), color_mode=\"rgb\")` loads the image in RGB and resizes it to 400x400. The image ends up \"squeezed\" into a square\r\n* `ImageResizingEstimator to 400x400` either pads or crops the source image to be 400x400. The result of this operation is therefore very different.\r\n* Resizing the source images to 400x400 BEFORE feeding them into the ImageResizingEstimator actually leads to an `ArgumentException` - the resulting bitmap is invalid when it gets to the `ImagePixelExtractingEstimator` stage.\r\n\r\nThis is mainly an issue with documentation, I guess - it would be very helpful to declare this behavior explicitly, especially for interoperability scenarios such as this. At any rate, while realizing this, we went and resized our training images to 401x401 (to bypass the third bullet point issue) and retrained the model. \r\n\r\nOur theory was that will both allow the resizer to do its job without exception and will avoid the difference in behavior of the resize behavior - since resizing from 401x401 to 400x400 does not change the bitmap too much. So the expectation was that feeding the same 401x401 image to Keras and ML.NET should produce the same predictions.\r\n\r\nThis did not happen. The ML.NET code seems to be working and produces predictions, however these predictions are way off of the Keras results (the Keras/TF results are actually correct which we proved by drawing the resulting coordinates on the images).\r\n\r\nSo the problem here is: is our TF setup wrong? Or is this some underlying difference in behavior which we can't see? I'm attaching a repro code as well. The ML.NET part is a .NET Core 2.2 project. To run the Keras part, you'll need the whole Keras stack installed (Keras + Tensorflow). The models and some sample images are included as well.\r\n\r\nSample output demonstrating the issue:\r\n\r\nML.NET predictions for three images:\r\n78,151,124,196,157,152,208,195\r\n83,160,131,208,167,162,220,207\r\n82,161,136,212,174,163,229,211\r\n\r\nKeras output for the same three images:\r\n[96, 182, 166, 247, 218, 179, 291, 247]\r\n[97, 186, 169, 253, 222, 182, 297, 252]\r\n[99, 252, 172, 314, 225, 249, 294, 311]\r\n\r\nSome additional details:\r\nWe tested this both against TensorFlow and Tensorflow-GPU, the issue persists. Therefore it's not a problem of running on GPU vs CPU. One possible explanation would be that I simply froze the TF graph wrong by specifying an incorrect final node, but I'm pretty sure TensorBoard is telling me that `final_layer/BiasAdd` is my final node:\r\n![image](https://user-images.githubusercontent.com/7479226/50694338-e86abb80-1039-11e9-98b4-59688a076450.png)\r\n\r\nAny help with tracing this down would be greatly appreciated - operationalizing a TF model directly from C# is an awesome capability to have.\r\n\r\n#### Source\r\n[MLNetConvNetRepro.zip](https://github.com/dotnet/machinelearning/files/2727391/MLNetConvNetRepro.zip)\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2022","RelatedDescription":"Open issue \"Convolutional net gives different results under ML.NET and Keras/TensorFlow\" (#2022)"},{"Id":"395808852","IsPullRequest":false,"CreatedAt":"2019-01-04T04:52:09","Actor":"yaeldekel","Number":"2019","RawContent":null,"Title":"FastTree learning rate in advanced settings does not override the default value ","State":"open","Body":"These lines in the BoostingFastTreeTrainerBase ctor reset it to the value specified directly (or the default value):\r\n\r\n            if (Args.LearningRates != learningRate)\r\n            {\r\n                using (var ch = Host.Start($\"Setting learning rate to: {learningRate} as supplied in the direct arguments.\"))\r\n                    Args.LearningRates = learningRate;\r\n            }\r\n\r\n(Reported in #1983 .)\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2019","RelatedDescription":"Open issue \"FastTree learning rate in advanced settings does not override the default value \" (#2019)"},{"Id":"395779222","IsPullRequest":true,"CreatedAt":"2019-01-04T01:11:47","Actor":"Anipik","Number":"2018","RawContent":null,"Title":"Adding a new CI leg for netframework","State":"open","Body":"We are currently not running or building our tests on netframework.\r\nHowever we are going to support netframework when we release 1.0 , so just adding a new ci leg to consistently build and test stuff on netframework\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2018","RelatedDescription":"Open PR \"Adding a new CI leg for netframework\" (#2018)"},{"Id":"395773557","IsPullRequest":true,"CreatedAt":"2019-01-04T00:35:39","Actor":"Ivanidzo4ka","Number":"2017","RawContent":null,"Title":"Fix CategoricalHashTransform to handle OutputKind \"Key\"","State":"open","Body":"fixes #1939.\r\nDuplicate of https://github.com/dotnet/machinelearning/pull/1941, but since Gani is out, I want to finish it.","Url":"https://github.com/dotnet/machinelearning/pull/2017","RelatedDescription":"Open PR \"Fix CategoricalHashTransform to handle OutputKind \"Key\"\" (#2017)"},{"Id":"395770903","IsPullRequest":false,"CreatedAt":"2019-01-04T00:19:53","Actor":"glebuk","Number":"2016","RawContent":null,"Title":"Feature Contribution Calculation Top/Bottom arguments are confusing","State":"open","Body":"### Issue\r\nThe current API for Feature Contribution are confusing.  They have the following parameters:\r\n` FeatureContributionCalculation(... int top = 10, int bottom = 10..);`\r\nthose arg names are confusing.  From naming it is unclear if bottom means max negative or min abs() contribution.  \r\nLet's rename them params to `topPositive and topNegative`\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2016","RelatedDescription":"Open issue \"Feature Contribution Calculation Top/Bottom arguments are confusing\" (#2016)"},{"Id":"395757961","IsPullRequest":false,"CreatedAt":"2019-01-03T23:51:46","Actor":"zeahmed","Number":"2014","RawContent":null,"Title":"Recommendation as a method on MLContext object","State":"closed","Body":"\r\nRegression, BinaryClassification and MulticlassClassifcation context appear as properties on MLContext object while Recommendation context appear as method. Also tooltip is showing incorrect help.\r\n\r\n![image](https://user-images.githubusercontent.com/38438266/50666493-d15c9880-0f69-11e9-8c58-fcc593e477ec.png)\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2014","RelatedDescription":"Closed issue \"Recommendation as a method on MLContext object\" (#2014)"}],"ResultType":"GitHubIssue"}},"RunOn":"2019-01-06T05:30:42.3400697Z","RunDurationInMilliseconds":890}