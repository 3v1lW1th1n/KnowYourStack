{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018","PublishedOn":"2017-10-23T16:41:13+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"This post was written by Varun Venkatesan, Li Tian, and Juan Rodriguez, engineers at Intel. They are excited to share .NET Core-specific enhancements that Intel has made to VTune Amplifier 2018. We&#8217;re excited to have a new tool to use to help make .NET Core faster on Intel chips. Intel has been a strong partner in the development... <a aria-label=\"read more about .NET Core Performance Profiling with Intel® VTune™ Amplifier 2018\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/","RawContent":null},{"Title":"Experiment with Azure for FREE!","PublishedOn":"2017-10-19T14:00:11+00:00","CommentsCount":35,"FacebookCount":0,"Summary":"What is Azure? What can it do for me? Do I need it? How do I find out? How do I use it? Will it help my business? Can it help my career? With all the things Azure can do, it&#8217;s hard to know where to start answering these important questions. But there&#8217;s a really... <a aria-label=\"read more about Experiment with Azure for FREE!\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/","RawContent":null},{"Title":"Announcing the .NET Framework 4.7.1","PublishedOn":"2017-10-17T21:26:30+00:00","CommentsCount":29,"FacebookCount":0,"Summary":"Today, we are announcing the release of the .NET Framework 4.7.1. It’s included in the Windows 10 Fall Creators Update. .NET Framework 4.7.1 is also available on Windows 7+ and Windows Server 2008 R2+.  We’ve added support for targeting the .NET Framework 4.7.1 in Visual Studio 2017 15.5. The .NET Framework 4.7.1 includes improvements in several areas: Accessibility improvements... <a aria-label=\"read more about Announcing the .NET Framework 4.7.1\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/","RawContent":null},{"Title":".NET Framework October 2017 Preview of Quality Rollup","PublishedOn":"2017-10-17T20:56:56+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Preview of Quality Rollup. This type of rollup is intended for businesses that want to the preview or use quality improvements as soon as they are available. Quality and Reliability This release contains the following quality and reliability improvements. CLR Code optimization bug for x64 C# code targeting... <a aria-label=\"read more about .NET Framework October 2017 Preview of Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/","RawContent":null},{"Title":"RyuJIT Just-in-Time Compiler Optimization Enhancements","PublishedOn":"2017-10-17T05:16:50+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"I&#8217;d like to tell you about some of the recent changes we&#8217;ve made as part of our ongoing work to extend the optimization capabilities of RyuJIT, the MSIL-to-native code generator used by .NET Core and .NET Framework. I hope it will make for an interesting read, and offer some insight into the sorts of optimization opportunities we have... <a aria-label=\"read more about RyuJIT Just-in-Time Compiler Optimization Enhancements\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/","RawContent":null},{"Title":".NET Framework October 2017 Security and Quality Rollup","PublishedOn":"2017-10-11T06:02:21+00:00","CommentsCount":16,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Security and Quality Rollup. The update applies to all supported Windows versions. It includes a known issue for Windows 10 1507 (see below). Security This release contains no new security updates. Quality and Reliability This release contains the following quality and reliability improvements. WPF WPF fails to load... <a aria-label=\"read more about .NET Framework October 2017 Security and Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/net-framework-october-2017-security-and-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/net-framework-october-2017-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing UWP Support for .NET Standard 2.0","PublishedOn":"2017-10-10T22:57:46+00:00","CommentsCount":104,"FacebookCount":0,"Summary":"This post was mostly written by Rich Lander with contributions from Immo Landwerth. Today, we are releasing huge updates to UWP for .NET developers. The really big improvement is adding support for .NET Standard 2.0. UWP developers now have access to ~ 20k more APIs. This release brings UWP to partity with the other .NET implementations... <a aria-label=\"read more about Announcing UWP Support for .NET Standard 2.0\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/announcing-uwp-support-for-net-standard-2-0/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/announcing-uwp-support-for-net-standard-2-0/","RawContent":null},{"Title":".NET Framework 4.7.1 Runtime and Compiler Features","PublishedOn":"2017-09-28T23:56:59+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"This post describes the new Runtime, Compiler and Base Class Library (BCL) improvements in the .NET Framework 4.7.1. You can try out these features by downloading the Developer Pack, described in the Welcome to the .NET Framework 4.7.1 Early Access blog post.  BCL &#8211; .NET Standard 2.0 Support .NET Framework 4.7.1 has built-in support for .NET Standard 2.0. .NET Framework 4.7.1... <a aria-label=\"read more about .NET Framework 4.7.1 Runtime and Compiler Features\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/28/net-framework-4-7-1-runtime-and-compiler-features/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/28/net-framework-4-7-1-runtime-and-compiler-features/","RawContent":null},{"Title":"Build a web service with F# and .NET Core 2.0","PublishedOn":"2017-09-26T16:39:23+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Earlier this year, I wrote about an update to the roadmap for F# and .NET Core. I had mentioned that there were a number of things you could build with F# and .NET Core today, such as web services. In this post, I&#8217;ll walk through building a web service with F# and .NET Core 2.0... <a aria-label=\"read more about Build a web service with F# and .NET Core 2.0\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/","RawContent":null},{"Title":".NET Framework September 2017 Preview of Quality Rollup","PublishedOn":"2017-09-25T19:57:18+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are releasing the September 2017 Preview of Quality Rollup. This type of rollup is intended for businesses that want to the preview or use quality improvements as soon as they are available. This update applies to Windows 10 Update 1607 (Anniversary Update) and to Windows Server 2016. FYI: The KBs for Windows Server 2016... <a aria-label=\"read more about .NET Framework September 2017 Preview of Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/25/net-framework-september-2017-preview-of-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/25/net-framework-september-2017-preview-of-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6650451504","Type":"IssuesEvent","CreatedAt":"2017-09-28T16:22:10","Actor":"hughbe","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/87","RelatedDescription":"Opened issue \"PRs to repos outside of dotnet/* pattern should not always thank for signing the CLA\" (#87) at dotnet/home","RelatedBody":"For example: https://github.com/mono/libgdiplus/pull/109\r\n\r\nI have already signed the CLI. On the dotnet/corefx etc. projects, I don't get the extra message:\r\n\r\n```\r\n@hughbe,\r\nThanks for having already signed the Contribution License Agreement. Your agreement was validated by .NET Foundation. We will now review your pull request.\r\nThanks,\r\n.NET Foundation Pull Request Bot\r\n```\r\n\r\nJust a small gripe, as I get an email each time I do this. I've seen this in Mono and Xunit.\r\n\r\n/cc @karelz I know this is unrelated to corefx but maybe you know the right person/repo to route this to :D\r\n"},{"Id":"6515896963","Type":"PullRequestEvent","CreatedAt":"2017-08-26T22:20:18","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/85","RelatedDescription":"Merged pull request \"Create telerik-ui-for-uwp.md\" (#85) at dotnet/home","RelatedBody":"Submission of Telerik UI for UWP"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6766996801","Type":"IssuesEvent","CreatedAt":"2017-10-26T00:24:01","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/36","RelatedDescription":"Opened issue \"microsoft/dotnet-framework images now support Windows Server 1709\" (#36) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework images now support Windows Server 1709\r\n\r\n[Windows Server Version 1709](https://blogs.technet.microsoft.com/windowsserver/2017/10/17/windows-server-version-1709-available-for-download/) was released earlier this month. [microsoft/windowsservercore](https://hub.docker.com/r/microsoft/windowsservercore/) images have been updated to support [Windows Server 1709](https://docs.microsoft.com/en-us/windows-server/get-started/whats-new-in-windows-server-1709). These images can be identified with the `1709` [tag](https://hub.docker.com/r/microsoft/windowsservercore/tags/).\r\n\r\nThe following repos have been updated:\r\n\r\n* [microsoft/aspnet](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #35](https://github.com/Microsoft/dotnet-framework-docker/issues/35)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #31](https://github.com/Microsoft/dotnet-framework-docker/pull/31)\r\n* [microsoft/dotnet-framework-docker #34](https://github.com/Microsoft/dotnet-framework-docker/pull/34)\r\n* [microsoft/dotnet-framework-docker #32](https://github.com/Microsoft/dotnet-framework-docker/issues/32)\r\n\r\n.NET Framework Docker images now support Windows Server 1709, the latest version of Windows Server.\r\n\r\n.NET Framework 3.5 and 4.7.1 images are available for Windows Server 1709. Windows Server 1709 includes the .NET Framework 4.7.1. .NET Framework 4.6.2 and .NET Framework 4.7 images are only available with Windows Server 2016 images. You can see an example of 1709-based images in the following example.\r\n\r\n![.NET Framework Windows 1709 images](https://user-images.githubusercontent.com/2608468/32028249-6684a82c-b9a2-11e7-8afa-1b1abf89eb3b.png)\r\n\r\nYou can identify Windows Server 1709-based .NET Framework images with the tag substring `windowsservercore-1709` and Windows Server 2016 images with the tag substring `windowsservercore-10.0.14393`. You will likely notice that the 1709-based images are easier to identify than the Windows Server 2016 ones. \r\n\r\nChanges have been made in Windows Server 1709 that affect the [compatibility of Windows container images](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility). The practical impact is that Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creative Update hosts cannot load Windows Server 1709 images. Windows 10 Fall Creative Update and Windows Server 1709 can load both original Windows Server 2016 and Windows Server 1709 images. Windows Server 1709 requires Hyper-V isolation (`docker run --isolation=hyperv`) in order to load Windows Server 2016 images.\r\n\r\nGiven the compatibility differences with Windows container images, .NET Framework images will adopt [manifest lists](https://github.com/Microsoft/dotnet-framework-docker/issues/32) so that a single logical tag, like `4.7.1`, can be used on both older and newer Windows 10 and Windows Server versions. `docker pull microsoft/dotnet-framework:4.7.1` will pull a Windows Server 2016 image on Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creators Update machines. The same command will pull a Windows Server 1709 based image on Windows Server 1709 and Windows 10 Fall Creators Update machines. The same rules apply to FROM lines. [.NET Core](https://hub.docker.com/r/microsoft/dotnet) Docker images use this same feature to support Linux and Windows hosts and AMD64 and ARM32 hosts with the same logical tag, like `2.0-runtime`.\r\n\r\nThe following tags will be updated to use manifest lists:\r\n\r\n- `latest`\r\n- `4.7.1`\r\n- `3.5`\r\n\r\nYou need [Docker 17.10](https://docs.docker.com/release-notes/docker-ce/#17100-ce-2017-10-17) or later to use Windows-version-specific manifest list tags. The following change from the Docker 17.10 release notes is the one that enables this functionality.\r\n\r\n* Add support for Windows version filtering on pull [moby/moby#35090](https://github.com/moby/moby/pull/35090)\r\n\r\nYou are only recommended to use manifest tags if you want flexibility for development and deployment environments. That's what manifest tags deliver. In general, you should select the most specific tag you can. The more specific the tag, the more predictable the result of each `docker pull` and `docker build` will be."},{"Id":"6761784781","Type":"IssuesEvent","CreatedAt":"2017-10-25T04:03:38","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/35","RelatedDescription":"Opened issue \"microsoft/dotnet-framework latest tag updated to 4.7.1\" (#35) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework latest tag updated to 4.7.1\r\n\r\nThe [.NET Framework 4.7.1](https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/) was released earlier this month. The [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework) `latest` [tag](https://hub.docker.com/r/microsoft/dotnet-framework/tags/) was also updated.\r\n\r\nThe .NET Framework 4.7.1 is represented by the `microsoft/dotnet-framework:4.7.1` tag.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #33](https://github.com/Microsoft/dotnet-framework-docker/issues/33)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #28](https://github.com/Microsoft/dotnet-framework-docker/pull/28)\r\n* [microsoft/dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework 4.7.1 image is now available as a Docker image. The `latest` tag points to the same image.\r\n\r\nThe following repos were updated:\r\n\r\n* [microsoft/asp](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\nThe [microsoft/dotnet-framework-samples](https://hub.docker.com/r/microsoft/dotnet-framework-samples) repo has not yet been updated.\r\n\r\nWe recommend that you use version-specific tags for production apps. For experimentation or while an application is in development, using the `latest` tag is a fine practice.\r\n\r\nWe recently found a [significant performance issue with .NET Framework Docker images](https://github.com/dotnet/announcements/issues/33). The .NET Framework 4.7.1 image includes the fix for that problem.\r\n"},{"Id":"6729762964","Type":"IssuesEvent","CreatedAt":"2017-10-17T21:21:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/34","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2017-8585 : Malformed Culture can cause application crash\" (#34) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-8585 \r\n## Malformed Culture can cause application to crash\r\n### Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed string request could cause an application to crash and lead to a denial of service.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.7 and 1.1.4. Developers are advised to update their .NET Core SDK to version 1.1.4.\r\n\r\n### Discussion\r\n\r\nUse https://github.com/dotnet/corefx/issues/24703 for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n\r\n.NET Core 2.0 is not affected by this issue.\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.6 or lower versions, or 1.1.2 or lower versions is affected. The latest version of the .NET core runtime you have installed in your computer can be listed by running `dotnet --info`. Running that command produces an output similar to the following:\r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\nAs this command only displays the latest version of the runtime installed (or the version set in the *global.json* file), it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location          |\r\n|------------------|-------------------|\r\n| Windows          | C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\ |\r\n| macOS            | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n| [Supported Linux platforms](https://docs.microsoft.com/dotnet/core/linux-prerequisites#supported-linux-versions) | /usr/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.7 and 1.1.4, then any applications targeting 1.0 or 1.1 of .NET Core are vulnerable.\r\n\r\nAlso, even if you have a directory for 1.0.7 and 1.1.4 present in your system, if you've deployed [self-contained applications](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd) targeting the impacted versions, these applications are also vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). .NET Core 1.1.4 SDK installs both versions 1.0.7 and 1.1.4 of the .NET Core runtime.\r\n\r\nIf you've built a [self-contained application](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd), you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [*application.runtime.config*](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application. Set the framework version to the desired version and the `rollForward` property to `false`. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the *application.runtime.config* file is an optional file, you may need to create one for each application and add it alongside the executable."},{"Id":"6725652001","Type":"IssuesEvent","CreatedAt":"2017-10-17T06:48:14","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/33","RelatedDescription":"Opened issue \".NET Framework Docker Performance Issue Resolved\" (#33) at dotnet/announcements","RelatedBody":"# .NET Framework Docker Performance Issue Resolved\r\n\r\nMultiple people have [reported](https://github.com/Microsoft/dotnet-framework-docker/issues/25) that [.NET Framework performance in Docker images is poor](https://github.com/moby/moby/issues/33096). In the cases reported, performance was an order of magnitude slower than expected.\r\n\r\nThis issue has now been resolved for [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) images. It was due to incorrectly generated NGEN images. They are now correctly generated and expected performance has been restored.\r\n\r\n## Discussion \r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet-framework-docker #29](https://github.com/Microsoft/dotnet-framework-docker/pull/29)\r\n\r\n## Details\r\n\r\n* [dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework uses [NGEN](https://docs.microsoft.com/dotnet/framework/tools/ngen-exe-native-image-generator) as a primary mechanism for startup performance. .NET Framework assemblies are compiled to native code with the NGEN tool as part of the .NET Framework setup process. The benefit of these files is that they can be loaded and executed without any additional significant extra work required by the Common Language Runtime (CLR). The lack of  additional work means that performance is very good.\r\n\r\nNGEN image generation interacts with a Windows subsystem that is not correctly supported in Windows containers. NGEN images are generated in Windows containers, but they are not valid. Fortunately, the CLR can still run in the presence of invalid images, but code execution is much slower.\r\n\r\nWe are in the process of fixing Windows containers so that NGEN will work correctly. In the interim, we have updated the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) images to correctly generate NGEN images. The [microsoft/windowsservercore/](https://hub.docker.com/r/microsoft/windowsservercore/) images still have the performance problem that was initially reported. We are working on updating Windows containers so that NGEN works as expected. You are recommended to use the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) base image if you can, so that you can get better performance.\r\n\r\nOne of the developers that reported the performance issue shared basic performance results. The first two rows are the before state. The last row is the dotnet-framework image after the fix. The improvement is quite significant.\r\n\r\n> Runing `powershell -command (measure-command { powershell -command exit }).TotalSeconds` in various images on our CI server produced this table of timings:\r\n \r\n| time (s) | image |\r\n|----------|--------|\r\n|10.7212372| microsoft/windowsservercore |\r\n|8.3278793  | microsoft/dotnet-framework:4.7|\r\n|0.6426073  | microsoft/dotnet-framework:4.7 (after fix)|\r\n"},{"Id":"6645912196","Type":"IssuesEvent","CreatedAt":"2017-09-27T19:47:08","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/32","RelatedDescription":"Opened issue \".NET Framework 4.7.1 provides built-in support for .NET Standard 2.0\" (#32) at dotnet/announcements","RelatedBody":"## Summary\r\n\r\n.NET Framework 4.7.1 will have built-in support for .NET Standard 2.0. This means that you don't have to deploy any additional files or use binding redirects to use .NET Standard 2.0 libraries.\r\n\r\nFor a demo, check out [this video][video].\r\n\r\n## Details\r\n\r\nWhile libraries targeting [.NET Standard 2.0][ns20post] are can be consumed by applications and libraries [targeting .NET Framework 4.6.1][nstable] and higher, not all files that are required for .NET Standard libraries were part of .NET Framework 4.6.1. In fact, .NET Framework 4.6.1 was shipped before .NET Standard 2.0 was even designed. That's why building an application targeting .NET Framework 4.6.1 (as well as 4.6.2 and 4.7) will have to deploy additional files.\r\n\r\n* If you use **Visual Studio 2017 15.3** or higher, these files are automatically copied to the application's output folder.\r\n\r\n* If you use **Visual Studio 2015 and [use NuGet 3.6][nuget36]**, we'll prompt you to install a [support package][vs2015support] which will handle copying the files to the output directory.\r\n\r\nStarting with .NET Framework 4.7.1 these files no longer have to be deployed with the application -- they are built right into the .NET Framework itself.\r\n\r\n.NET Framework 4.7.1 also adds[about 200 missing APIs][missingapis] that were part of .NET Standard 2.0 but not actually implemented by .NET Framework 4.6.1, 4.6.2 or 4.7.\r\n\r\nThis also removes the need for [binding redirects][netfx-issues] when using .NET Standard libraries on .NET Framework because the CLR automatically unifies version numbers of assemblies that are part of the platform.\r\n\r\nLearn more [by reading the .NET Standard FAQ](http://aka.ms/netstandardfaq).\r\n\r\n## Discussion\r\n\r\nDiscussion\r\n\r\nFor a discussion, please go to dotnet/standard#514.\r\n\r\n[ns20post]: https://blogs.msdn.microsoft.com/dotnet/2017/08/14/announcing-net-standard-2-0/\r\n[nstable]: https://docs.microsoft.com/en-us/dotnet/standard/net-standard\r\n[nuget36]: https://dist.nuget.org/visualstudio-2015-vsix/v3.6.0/NuGet.Tools.vsix\r\n[vs2015support]: https://aka.ms/netstandard-build-support-netfx\r\n[missingapis]: https://github.com/dotnet/standard/blob/master/netstandard/src/ApiCompatBaseline.net461.txt\r\n[netfx-issues]: https://github.com/dotnet/standard/issues/481\r\n[video]: https://www.youtube.com/watch?v=u67Eu_IgEMs\r\n\r\nhttps://github.com/dotnet/standard/issues/514"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6767232589","Type":"PullRequestEvent","CreatedAt":"2017-10-26T01:59:04","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14704","RelatedDescription":"Opened pull request \"Update CoreClr to preview1-25826-01 (master)\" (#14704) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"6767048118","Type":"PullRequestEvent","CreatedAt":"2017-10-26T00:45:11","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14702","RelatedDescription":"Closed pull request \"[Do not merge] Test commit\" (#14702) at dotnet/coreclr","RelatedBody":"Can we have GT_LONG nodes after the decomposition?"},{"Id":"6767000915","Type":"PullRequestEvent","CreatedAt":"2017-10-26T00:25:41","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14703","RelatedDescription":"Opened pull request \"Delete dead code\" (#14703) at dotnet/coreclr","RelatedBody":""},{"Id":"6766961833","Type":"PullRequestEvent","CreatedAt":"2017-10-26T00:10:01","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14702","RelatedDescription":"Opened pull request \"[Do not merge] Test commit\" (#14702) at dotnet/coreclr","RelatedBody":"Can we have GT_LONG nodes after the decomposition?"},{"Id":"6766858997","Type":"PullRequestEvent","CreatedAt":"2017-10-25T23:31:44","Actor":"mikem8361","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14696","RelatedDescription":"Merged pull request \"Fix source/line info on Windows for Windows PDBs.\" (#14696) at dotnet/coreclr","RelatedBody":"Now attempts to load the diasymreader from the coreclr module path.\r\n\r\nIssue #21079"},{"Id":"6766857725","Type":"IssuesEvent","CreatedAt":"2017-10-25T23:31:17","Actor":"swgillespie","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/14701","RelatedDescription":"Opened issue \"[Local GC] Compile without FEATURE_REDHAWK\" (#14701) at dotnet/coreclr","RelatedBody":"Accomplishing this will produce a GC largely equivalent to the one that is linked-in to `coreclr.dll` by default. Today, `clrgc.dll` compiles with `FEATURE_REDHAWK` to paper over some problems, namely:\r\n\r\n* Use of `_ASSERTE`\r\n* Use of `nativeoverlapped.h` in the handle table for Overlapped I/O\r\n* Use of `S_SIZE_T`\r\n* Ref_InitializeHandleTableBucket` making use of `NewHolder`\r\n\r\nFinal milestone of https://github.com/dotnet/coreclr/issues/11518.\r\n\r\ncc @Maoni0 @sergiy-k @jkotas"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6766841091","Type":"PullRequestEvent","CreatedAt":"2017-10-25T23:25:27","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/7903","RelatedDescription":"Closed pull request \"insert new bits of testplatform of version 15.5.0-preview-20171025-01\" (#7903) at dotnet/cli","RelatedBody":"\r\n"},{"Id":"6766838382","Type":"PullRequestEvent","CreatedAt":"2017-10-25T23:24:30","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7906","RelatedDescription":"Merged pull request \"Update CoreSetup to preview1-25825-07 (master)\" (#7906) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6766719040","Type":"IssuesEvent","CreatedAt":"2017-10-25T22:44:53","Actor":"evil-shrike","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7909","RelatedDescription":"Opened issue \"cli-tool: running a cil-tool via dotnet produces unmanaged unhandler exception\" (#7909) at dotnet/cli","RelatedBody":"I have a netcoreapp2.0 console project with output \"dotnet-xxx\" assembly (Exe) for a tool. The tool can run fine (`dotnet dotnet-xxx.dll`). Now I want to use it as CliTool in other projects.\r\n\r\nI packed the tool in nuget package with `<packageType name=\"DotnetCliTool\" />` then installed it in a project via DotNetCliToolReference  reference:\r\n\r\n    <DotNetCliToolReference Include=\"Croc.XFW3.DotnetCliTool\" Version=\"3.0.0\" />\r\n\r\nBut when I try to run it via dotnet I'm getting an unmanaged unhandled exception:\r\n\r\nUnhandled Exception:\r\n   Cannot print exception string because Exception.ToString() failed.\r\n\r\nWindows debug dialog pops up, inside debugger (VS) I only can see this:\r\n\r\nUnhandled exception at 0x00007FFB9AE13FB8 (KernelBase.dll) in dotnet.exe: 0xE0434352 (parameters: 0xFFFFFFFF80131534, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x00007FFB3E430000).\r\n\r\nNot much.\r\n\r\nHow can I diagnose what's wrong?\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n\r\n\r\n\r\n"},{"Id":"6766039569","Type":"IssuesEvent","CreatedAt":"2017-10-25T20:02:50","Actor":"dcarl1","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7908","RelatedDescription":"Opened issue \"Debugging very slow build times\" (#7908) at dotnet/cli","RelatedBody":"I apologize that this isn't really a bug report I just didn't know where else to go...\r\n\r\nWe have a solution of about ~35 projects that is seeing build times in the 3-5 minute range. This is using ASP.Net Core 2.0 targeting net46. Incremental builds seem to be non existent.\r\n\r\nI've been following the few performance related issued on here, however now I think it may be something inside our solution.\r\n\r\nDoes anyone have a general starting point or any advice on how to dig into this? Or maybe this is normal? I've tried a verbose build however the log file is hundreds of megabytes which is not really human parse-able. \r\n\r\nThanks."},{"Id":"6766014530","Type":"IssuesEvent","CreatedAt":"2017-10-25T19:57:28","Actor":"tmat","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7907","RelatedDescription":"Opened issue \"ItRestoresLibToSpecificDirectory failed in CI\" (#7907) at dotnet/cli","RelatedBody":"https://ci.dot.net/job/dotnet_cli/job/master/job/debug_centos7.1_x64_prtest/1626/testReport/junit/(root)/(empty)/Microsoft_DotNet_Restore_Tests_GivenThatIWantToRestoreApp_ItRestoresLibToSpecificDirectory/\r\n\r\n```\r\n  MESSAGE:\r\n                                        Expected command to pass but it did not.\r\nFile Name: /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/bin/2/linux-x64/dotnet/dotnet\r\nArguments: restore  --configfile /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/NuGet.Config --packages \"pkgs\" --disable-parallel\r\nWorkingDir:: /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/bin/3/linux-x64/test/dotnet-restore.Tests/ItRestoresLibToSpecificDirectory/temp\r\nExit Code: 134\r\nStdOut:\r\n  Restoring packages for /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/bin/3/linux-x64/test/dotnet-restore.Tests/ItRestoresLibToSpecificDirectory/temp/temp.csproj...\r\n  Installing NETStandard.Library 2.0.1.\r\n  Installing Microsoft.NETCore.Platforms 1.1.0.\r\n  Generating MSBuild file /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/bin/3/linux-x64/test/dotnet-restore.Tests/ItRestoresLibToSpecificDirectory/temp/obj/temp.csproj.nuget.g.props.\r\n  Generating MSBuild file /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/bin/3/linux-x64/test/dotnet-restore.Tests/ItRestoresLibToSpecificDirectory/temp/obj/temp.csproj.nuget.g.targets.\r\n  Restore completed in 1.3 sec for /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/bin/3/linux-x64/test/dotnet-restore.Tests/ItRestoresLibToSpecificDirectory/temp/temp.csproj.\r\nStdErr:\r\n\r\n\r\n                                        +++++++++++++++++++\r\n                                        STACK TRACE:\r\n                                           at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)\r\n   at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)\r\n   at Microsoft.DotNet.Tools.Test.Utilities.CommandResultAssertions.Pass() in /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/test/Microsoft.DotNet.Tools.Tests.Utilities/Assertions/CommandResultAssertions.cs:line 30\r\n   at Microsoft.DotNet.Restore.Tests.GivenThatIWantToRestoreApp.ItRestoresLibToSpecificDirectory() in /mnt/resource/j/workspace/dotnet_cli/master/debug_centos7.1_x64_prtest/test/dotnet-restore.Tests/GivenThatIWantToRestoreApp.cs:line 62\r\n```"},{"Id":"6765559510","Type":"PullRequestEvent","CreatedAt":"2017-10-25T18:20:43","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/7906","RelatedDescription":"Opened pull request \"Update CoreSetup to preview1-25825-04 (master)\" (#7906) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6765394242","Type":"PullRequestEvent","CreatedAt":"2017-10-25T17:46:44","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/7894","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to dev/release/2.0\" (#7894) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into dev/release/2.0.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-dev/release/2.0-20171024-070027\ngit reset --hard upstream/dev/release/2.0\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-dev/release/2.0-20171024-070027 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6765346521","Type":"IssuesEvent","CreatedAt":"2017-10-25T17:36:42","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/5607","RelatedDescription":"Closed issue \"Cannot use dotnet build with implicit project arg and disable console log summary\" (#5607) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\n* Make a project with a deliberate compilation error \r\n* dotnet build /clp:NoSummary\r\n\r\n## Expected  behavior\r\n\r\nError is only printed once\r\n\r\n## Actual behavior\r\n\r\nError is printed once when it occurs and again in the summary I tried to disable\r\n\r\n## Environment data\r\n```\r\n.NET Command Line Tools (1.0.0-rc4-004769)\r\n\r\nProduct Information:\r\n Version:            1.0.0-rc4-004769\r\n Commit SHA-1 hash:  9cf4e9d1d0\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.14393\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\1.0.0-rc4-004769\r\n```\r\n\r\n\r\n"},{"Id":"6765345501","Type":"PullRequestEvent","CreatedAt":"2017-10-25T17:36:29","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7897","RelatedDescription":"Merged pull request \"Stop producing core sdk from CLI repo\" (#7897) at dotnet/cli","RelatedBody":"We are now producing the toolset.\r\n\r\nThe next step will be to make the CLI produce just CLI verbs + MSBuild Props/targets and then move the toolset piece to the toolset repo.\r\n\r\n@nguerrera \r\n"},{"Id":"6764034578","Type":"IssuesEvent","CreatedAt":"2017-10-25T13:39:49","Actor":"atrauzzi","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7905","RelatedDescription":"Opened issue \"Allow for a way to map nuget packages to local projects\" (#7905) at dotnet/cli","RelatedBody":"When I'm working on NPM packages, it has a neat feature where I can map a package to a local directory.  That way, rather than downloading a version that has to be built, I can use a WIP version of a package before publishing it.\r\n\r\nWould love to be able to do this with .net."},{"Id":"6763947904","Type":"IssuesEvent","CreatedAt":"2017-10-25T13:24:13","Actor":"pankajdmishra","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7904","RelatedDescription":"Opened issue \"'dotnet' is not recognized as an internal or external command, operable program or batch file.\" (#7904) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nI am trying to create a Angular 2 spa template using cmd in Visual studio 2015 update 3\r\n\r\nI am trying to run \"dotnet new --install Microsoft.AspNetCore.SpaTemplate::*\"\r\nBut it gives 'dotnet' is not recognized as an internal or external command, operable program or batch file.\r\n\r\nI also installed DotNet core (dotnet-sdk-2.0.0-win-gs-x64)\r\n\r\n## Expected  behavior\r\nIt should run the command successfully and install SPA template\r\n\r\n## Actual behavior\r\n'dotnet' is not recognized as an internal or external command, operable program or batch file.\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n\r\n\r\n\r\n\r\n\r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6766575893","Type":"PullRequestEvent","CreatedAt":"2017-10-25T22:04:34","Actor":"chcosta","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/553","RelatedDescription":"Opened pull request \"Add transport feed as a source\" (#553) at dotnet/standard","RelatedBody":""},{"Id":"6765775944","Type":"IssuesEvent","CreatedAt":"2017-10-25T19:04:59","Actor":"malylemire1","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/552","RelatedDescription":"Opened issue \".NET Framework 4.7.1 class library with .NET Standard 2.0 nuget package.\" (#552) at dotnet/standard","RelatedBody":"Hi, \r\n\r\nI have a problem with a 4.7.1 Class Library (.Net Framework) referencing Microsoft.AspNetCore (Or any other .net standard nuget package.) using PackageReference.\r\n\r\nTo reproduce the problem : \r\n\r\n- Create a new Class Library (.Net Framework) that target framework 4.7.1\r\n- Add Microsoft.AspNetCore nuget package using PackageReference.\r\n- Call any method from the nuget package.\r\n- You can try using simple equals \r\n\r\n`namespace ClassLibrary1\r\n{\r\n    public class Class1\r\n    {\r\n        public Class1()\r\n        {\r\n            WebHost.Equals(0);\r\n        }\r\n    }\r\n}`\r\n\r\nYou will get error :\r\n\r\nError CS0012 The type 'Object' is defined in an assembly that is not referenced. You must add a reference to assembly 'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.\r\n\r\nSeems like 4.7.1 is not resolved as a .net standard 2.0 compatible version of the .net framework.\r\n\r\nThanks\r\n"},{"Id":"6765224943","Type":"PullRequestEvent","CreatedAt":"2017-10-25T17:11:01","Actor":"chcosta","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/551","RelatedDescription":"Opened pull request \"Add properties required for maestro\" (#551) at dotnet/standard","RelatedBody":"Add properties required for wiring up to maestro\r\n\r\n@dagood \r\n\r\n/cc @weshaggard \r\n"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6767704179","Type":"PullRequestEvent","CreatedAt":"2017-10-26T05:19:34","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24890","RelatedDescription":"Opened pull request \"Make ServicePointManager tests run out of proc\" (#24890) at dotnet/corefx","RelatedBody":"Fixes https://github.com/dotnet/corefx/issues/24875\r\n\r\nI'll throw up a matching change for buildtools\\src\\xunit.runner.uap\\RunnerRemoteExecutionServiceUAP\\RunnerRemoteExecutionServiceUAP.cs\r\n\r\n"},{"Id":"6767701665","Type":"PullRequestEvent","CreatedAt":"2017-10-26T05:18:26","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24889","RelatedDescription":"Opened pull request \"Update ProjectNTfs, ProjectNTfsTestILC to beta-25826-00, beta-25826-00, respectively (master)\" (#24889) at dotnet/corefx","RelatedBody":""},{"Id":"6767660530","Type":"IssuesEvent","CreatedAt":"2017-10-26T04:59:49","Actor":"wfurt","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/23535","RelatedDescription":"Closed issue \"flaky Sockets tests in System.Net.Sockets.Tests.DualModeConnectionlessReceiveFrom\" (#23535) at dotnet/corefx","RelatedBody":"I've seen this one fail with \"connection timed out\".  Other similar tests may have a similar timeout issue.\r\n\r\nReceiveFromV6BoundToSpecificV6_Success"},{"Id":"6767653545","Type":"PullRequestEvent","CreatedAt":"2017-10-26T04:56:38","Actor":"wfurt","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24615","RelatedDescription":"Merged pull request \"add some code to make sure we sent datagram before we try to receive it\" (#24615) at dotnet/corefx","RelatedBody":"This has been long outstanding problem. I was able to reproduce this locally on old Ubuntu 14 and running ALL tests in loop. This did non repro while running only single test or running them in sequence. \r\n\r\nI was able to collect traces suggesting that in some cases send() is called after recv failed. \r\nI added Task.Wait() to increase changes that sent is actually done when we try to receive. \r\nWith this change I was able to run the test for a day  where it would fail in about one hour before. \r\n\r\nMy original change had 1s wait. However after one day, it failed again with new debug message that the sending task did not complete in 1s time. This is Azure VM instance where it is not clear what else is happening at the same time. I feel it would be better to be more liberal and possibly wait longer than have random failures. I bumped wait() timeout to 3s and receive timeout to 1s. \r\nThis is still best guess but the tests are still running right now. When I get 3-5 days without failure I'll update this PR. I just wanted to get it out so people can comment on it.\r\n\r\n\r\nfixes  #17681"},{"Id":"6767653541","Type":"IssuesEvent","CreatedAt":"2017-10-26T04:56:38","Actor":"wfurt","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/17681","RelatedDescription":"Closed issue \"Test failure: System.Net.Sockets.Tests.DualModeConnectionlessReceiveFrom/ReceiveFromV6BoundToAnyV6_Success\" (#17681) at dotnet/corefx","RelatedBody":"Opened on behalf of @Jiayili1\n\nThe test `System.Net.Sockets.Tests.DualModeConnectionlessReceiveFrom/ReceiveFromV6BoundToAnyV6_Success` has failed.\n\nSystem.Net.Sockets.SocketException : Connection timed out\n\n        Stack Trace:\n\n           at System.Net.Sockets.Socket.ReceiveFrom(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags, EndPoint& remoteEP) in /root/corefx/src/System.Net.Sockets/src/System/Net/Sockets/Socket.cs:line 1725\n       at System.Net.Sockets.Tests.DualModeBase.ReceiveFrom_Helper(IPAddress listenOn, IPAddress connectTo) in /root/corefx/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 2753\nBuild : Master - 20170330.01 (Core Tests)\nFailing configurations:\n- Redhat.72.Amd64\n  - x64-Release\n\nDetail: https://mc.dot.net/#/product/netcore/master/source/official~2Fcorefx~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20170330.01/workItem/System.Net.Sockets.Tests/analysis/xunit/System.Net.Sockets.Tests.DualModeConnectionlessReceiveFrom~2FReceiveFromV6BoundToAnyV6_Success"},{"Id":"6767607449","Type":"PullRequestEvent","CreatedAt":"2017-10-26T04:35:42","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24888","RelatedDescription":"Opened pull request \"Add Span<T> Base64 conversion APIs that support UTF-8\" (#24888) at dotnet/corefx","RelatedBody":"Fixes https://github.com/dotnet/corefx/issues/24568 (part of https://github.com/dotnet/corefx/issues/24174).\r\n\r\n```C#\r\nnamespace System.Buffers.Text {\r\n    public static class Base64 {\r\n        public static OperationStatus DecodeFromUtf8(ReadOnlySpan<byte> utf8, Span<byte> bytes, out int consumed, out int written, bool isFinalBlock=true);\r\n        public static OperationStatus DecodeFromUtf8InPlace(Span<byte> buffer, out int written);\r\n        public static OperationStatus EncodeToUtf8(ReadOnlySpan<byte> bytes, Span<byte> utf8, out int consumed, out int written, bool isFinalBlock=true);\r\n        public static OperationStatus EncodeToUtf8InPlace(Span<byte> buffer, int dataLength, out int written);\r\n        public static int GetMaxDecodedFromUtf8Length(int length);\r\n        public static int GetMaxEncodedToUtf8Length(int length);\r\n    }\r\n}\r\n\r\nnamespace System.Buffers {\r\n    public enum OperationStatus {\r\n        DestinationTooSmall = 1,\r\n        Done = 0,\r\n        InvalidData = 3,\r\n        NeedMoreData = 2,\r\n    }\r\n}\r\n```\r\n\r\n**Note:**\r\nOperationStatus (previously TransformationStatus) can be updated base on API review and doesn't need to block this PR (https://github.com/dotnet/corefx/issues/22412).\r\n\r\n**Code Coverage:**\r\n100% line and branch coverage\r\n![image](https://user-images.githubusercontent.com/6527137/32033468-901c1002-b9c1-11e7-90d7-c1cacb24c8cc.png)\r\n\r\n**Performance Test Results (duration):**\r\n\r\nTest   Name | AVERAGE\r\n-- | --\r\nBase64Decode(numberOfBytes: 10) | 0.018\r\nBase64Decode(numberOfBytes: 100) | 0.113\r\nBase64Decode(numberOfBytes: 1000) | 1.005\r\nBase64Decode(numberOfBytes: 1000000) | 1011.903\r\nBase64DecodeBaseline(numberOfBytes: 10) | 0.083\r\nBase64DecodeBaseline(numberOfBytes: 100) | 0.452\r\nBase64DecodeBaseline(numberOfBytes: 1000) | 4.077\r\nBase64DecodeBaseline(numberOfBytes:   1000000) | 8977.842\r\nBase64DecodeInPlace(numberOfBytes: 10) | 0.022\r\nBase64DecodeInPlace(numberOfBytes: 100) | 0.114\r\nBase64DecodeInPlace(numberOfBytes: 1000) | 0.983\r\nBase64DecodeInPlace(numberOfBytes:   1000000) | 1055.159\r\nBase64DecodeInPlaceOnce(numberOfBytes:   1000000) | 0.985\r\nBase64Encode(numberOfBytes: 10) | 0.024\r\nBase64Encode(numberOfBytes: 100) | 0.171\r\nBase64Encode(numberOfBytes: 1000) | 1.631\r\nBase64Encode(numberOfBytes: 1000000) | 1659.814\r\nBase64EncodeBaseline(numberOfBytes: 10) | 0.034\r\nBase64EncodeBaseline(numberOfBytes: 100) | 0.149\r\nBase64EncodeBaseline(numberOfBytes: 1000) | 1.342\r\nBase64EncodeBaseline(numberOfBytes:   1000000) | 1340.315\r\nBase64EncodeInPlace(numberOfBytes: 10) | 0.068\r\nBase64EncodeInPlace(numberOfBytes: 100) | 0.406\r\nBase64EncodeInPlace(numberOfBytes: 1000) | 3.782\r\nBase64EncodeInPlace(numberOfBytes:   1000000) | 3983.673\r\nBase64EncodeInPlaceOnce(numberOfBytes:   1000000) | 3.854\r\n\r\nEncode is about 20% slower (for input larger than 100 bytes). Decode is at least 4x faster. This is mainly because the Convert.FromBase64CharArray allocates (approximately n bytes, where n is input size + ~24 byte overhead).\r\n\r\ncc @KrzysztofCwalina, @stephentoub, @GrabYourPitchforks, @jkotas, @dotnet/corefxlab-contrib "},{"Id":"6767528478","Type":"PullRequestEvent","CreatedAt":"2017-10-26T03:59:00","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24816","RelatedDescription":"Merged pull request \"Remove dead code from System.Net.Security\" (#24816) at dotnet/corefx","RelatedBody":"PR addresses issue #17905, project **System.Net.Security**."},{"Id":"6767525875","Type":"PullRequestEvent","CreatedAt":"2017-10-26T03:57:50","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24864","RelatedDescription":"Merged pull request \"Update CoreClr, CoreFx, CoreSetup, ProjectNTfs, ProjectNTfsTestILC, Standard to preview1-25826-01, preview1-25825-08, preview1-25825-07, beta-25825-00, beta-25825-00, preview1-25825-02, respectively (master)\" (#24864) at dotnet/corefx","RelatedBody":""}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6767198737","Type":"IssuesEvent","CreatedAt":"2017-10-26T01:45:49","Actor":"VSadov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22858","RelatedDescription":"Opened issue \"Implicit reference conversions to array types should emit \"castclass\" for verifiability\" (#22858) at dotnet/roslyn","RelatedBody":"The following results in unverifiable code:\r\n\r\n```C#\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Test(ref ((object[])new string[] { \"hi\", \"hello\" })[0]);\r\n        }\r\n\r\n        static void Test(ref object r)\r\n        {\r\n            System.Console.WriteLine(r);\r\n        }\r\n    }\r\n```\r\n\r\nIt looks like Roslyn had this bug since V1, while native compiler emits verifiable code.\r\n\r\nThe reason is that arrays of reference types are assignment-compatible when element types are assignment-compatible. However while instance of `Derived` can act as instance of `Base`, it is not true for arrays per verification rules. It is not permitted to get an element address of type `Base[]` from an array of type `Derived[]`. \r\n\r\nThe purpose of such restriction is unknown to me. Indeed - you can simply assign instance of `Derived[]` to a variable of `Base[]` type and then taking the reference is ok, - go figure... We should consider relaxing this when/if we have a chance - since there is a dynamic type check anyways, the rule is redundant.\r\n\r\nAnyways. Based on the above, when emitting verifiable code implicit reference conversions should emit `castclass`. \r\n\r\nWe do not need to do this when not in peverify-compat mode.\r\n"},{"Id":"6767040964","Type":"IssuesEvent","CreatedAt":"2017-10-26T00:42:15","Actor":"benaadams","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22857","RelatedDescription":"Opened issue \"[Discussion] Method linking\" (#22857) at dotnet/roslyn","RelatedBody":"## Background\r\n\r\nFor async and iterator statemachines the source method can be linked back from the running method using the StateMachineAttribute and knowledge that the statemachine is defined in a type at the same level as the source method https://github.com/dotnet/coreclr/pull/14655\r\n\r\n![Match back](https://aoa.blob.core.windows.net/aspnet/matching.png)\r\n\r\nHowever; this is an implementation detail of the current output of the roslyn compiler.\r\n\r\n## Aims\r\n\r\nIt would be desirable if there was a way in the type system to link back that did not rely on the layout.\r\n\r\nIt would also be desirable if there was a mechanism that worked for lambdas and local functions.\r\n\r\n## Use Case\r\n\r\nAn example use case for this is output in stack traces.\r\n\r\n## Discussion Starter\r\n\r\nOne approach would be to add new attributes for the source and generated method/types so the two could be matched.\r\n```csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsageAttribute(AttributeTargets.All, Inherited = true)]\r\n    public class CompilerGeneratedTypeAttribute: Attribute\r\n    {\r\n        public Type BuilderType { get; }\r\n        public string BuilderMethodName { get; }\r\n    }\r\n\r\n    [AttributeUsageAttribute(AttributeTargets.All, Inherited = true)]\r\n    public class CompilerGeneratedMethodAttribute: Attribute\r\n    {\r\n        public Type BuilderType { get; }\r\n        public string BuilderMethodName { get; }\r\n    }\r\n\r\n    [AttributeUsageAttribute(AttributeTargets.All, Inherited = true)]\r\n    public class BuilderMethodAttribute : Attribute\r\n    {\r\n        public Type GeneratedType { get; }\r\n        public string GeneratedMethodName { get; }\r\n        public string DisplayMethodName { get; }\r\n    }\r\n}\r\n```\r\nAsync and iterators both already have a contract via `IAsyncStateMachine` and `IEnumerator` and match can be confirmed via `StateMachineAttribute` on the source method; so they would only need the `CompilerGeneratedTypeAttribute` to tell the runtime where to look for the source method\r\n```csharp\r\nclass System.Linq.Enumerable\r\n{\r\n    [CompilerGeneratedType(builderType: = typeof(Enumerable), \r\n                           builderMethodName:= \"SkipWhileIterator\")]\r\n    class <SkipWhileIterator>d__177`1 : IEnumerator\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\nLocal functions would require both; with the `DisplayMethodName` referring to the original local function name:\r\n```csharp\r\nclass Program\r\n{\r\n    public void Foo(int arg)\r\n    {\r\n        PrintTheArg();\r\n        return;\r\n        void PrintTheArg()\r\n        {\r\n            Console.WriteLine(arg);\r\n        }\r\n    }\r\n}\r\n```\r\nCreating\r\n```csharp\r\nclass Program\r\n{\r\n    internal struct c__DisplayClass0_0\r\n    {\r\n        public int arg;\r\n    }\r\n    \r\n    [BuilderMethod(generatedType: = typeof(Program), \r\n                   generatedMethodName:= \"Foo_g__PrintTheArg0_0\", \r\n                   displayMethodName := \"PrintTheArg\")]\r\n    public void Foo(int arg)\r\n    {\r\n        var c__DisplayClass0_ = new c__DisplayClass0_0() { arg = arg };\r\n        Foo_g__PrintTheArg0_0(ref c__DisplayClass0_);\r\n    }\r\n\r\n    [CompilerGeneratedType(builderType: = typeof(Program), \r\n                           builderMethodName:= \"Foo\")]\r\n    internal static void Foo_g__PrintTheArg0_0(ref c__DisplayClass0_0 ptr)\r\n    {\r\n        Console.WriteLine(ptr.arg);\r\n    }\r\n}\r\n```\r\n\r\nLambdas' `DisplayMethodName` could be sequential for the containing function e.g. `Lambda1`,`Lambda2` and capturing ones could perhaps be differentiated `Closure3`, `Closure4`"},{"Id":"6767034418","Type":"PullRequestEvent","CreatedAt":"2017-10-26T00:39:34","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22839","RelatedDescription":"Closed pull request \"Fix type argument ambiguity in indexer initializers\" (#22839) at dotnet/roslyn","RelatedBody":"Fixes #22830"},{"Id":"6767028025","Type":"PullRequestEvent","CreatedAt":"2017-10-26T00:36:52","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22856","RelatedDescription":"Opened pull request \"Fix scanning type arguments - they cannot contain attributes\" (#22856) at dotnet/roslyn","RelatedBody":"**Customer scenario**\r\n\r\nWhen an object initializer contains an initializer for one item that is a less-than expression (`<`), and a second item that is an index initializer, then the parser incorrectly interprets the `<` as the start of a type argument list. For example, the following produces a syntax error:\r\n\r\n``` c#\r\nvar x = new C { [0] = op1 < op2, [1] = true };\r\n```\r\n\r\n**Bugs this fixes:**\r\n\r\nhttps://github.com/dotnet/roslyn/issues/22830\r\n\r\n**Workarounds, if any**\r\n\r\nThis bug can be worked around by parenthesizing the comparison expression.\r\n\r\n**Risk**\r\n\r\nLow. The change is tiny and focused on the scenario.\r\n\r\n**Performance impact**\r\n\r\nTiny, possibly improving performance in scenarios of erroneous code.\r\n\r\n**Is this a regression from a previous update?**\r\n\r\nYes, this fixes a recently introduced regression.\r\n\r\n**Root cause analysis:**\r\n\r\nThis is an old bug exposed by changes in the disambiguation of type arguments.\r\n\r\n**How was the bug found?**\r\n\r\nCustomer reported.\r\n\r\n**Test documentation updated?**\r\n\r\nN/A\r\n"},{"Id":"6766962250","Type":"IssuesEvent","CreatedAt":"2017-10-26T00:10:12","Actor":"333fred","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22855","RelatedDescription":"Opened issue \"Missing array bounds for certain VB initializers.\" (#22855) at dotnet/roslyn","RelatedBody":"See https://github.com/dotnet/roslyn/pull/22842#issuecomment-339467500."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6767528331","Type":"PullRequestEvent","CreatedAt":"2017-10-26T03:58:56","Actor":"hippiehunter","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4808","RelatedDescription":"Opened pull request \"implemented newobj using malloc\" (#4808) at dotnet/corert","RelatedBody":"@morganbr \r\nAlso added evaluation stack spillage and cut down on unneeded llvm casts. \r\nThe relationship between ILImporter and StackEntry doesn't feel 100% to me. Do you see a better way to do this without mixing functionality between ILImporter and StackEntry?\r\nSpillage, I'm not reusing slots at all here do I need to?\r\n\r\n"},{"Id":"6767415252","Type":"PullRequestEvent","CreatedAt":"2017-10-26T03:11:15","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4807","RelatedDescription":"Merged pull request \"Merge master to nmirror\" (#4807) at dotnet/corert","RelatedBody":""},{"Id":"6767414760","Type":"PullRequestEvent","CreatedAt":"2017-10-26T03:11:03","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4807","RelatedDescription":"Opened pull request \"Merge master to nmirror\" (#4807) at dotnet/corert","RelatedBody":""},{"Id":"6767186025","Type":"PullRequestEvent","CreatedAt":"2017-10-26T01:40:34","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4805","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#4805) at dotnet/corert","RelatedBody":""},{"Id":"6766998195","Type":"PullRequestEvent","CreatedAt":"2017-10-26T00:24:35","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4806","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4806) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6766778856","Type":"PullRequestEvent","CreatedAt":"2017-10-25T23:03:51","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4806","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4806) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6766701891","Type":"PullRequestEvent","CreatedAt":"2017-10-25T22:39:43","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4805","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#4805) at dotnet/corert","RelatedBody":""},{"Id":"6766394674","Type":"PullRequestEvent","CreatedAt":"2017-10-25T21:20:05","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4804","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4804) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6766279683","Type":"PullRequestEvent","CreatedAt":"2017-10-25T20:54:24","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4804","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4804) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6766088909","Type":"PullRequestEvent","CreatedAt":"2017-10-25T20:13:34","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4799","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#4799) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6766084381","Type":"PullRequestEvent","CreatedAt":"2017-10-25T20:12:35","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4803","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4803) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6766049309","Type":"PullRequestEvent","CreatedAt":"2017-10-25T20:04:58","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4803","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4803) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6765943492","Type":"PullRequestEvent","CreatedAt":"2017-10-25T19:41:56","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4802","RelatedDescription":"Opened pull request \"Fix standalone run of init-tools.sh\" (#4802) at dotnet/corert","RelatedBody":"Running all of buildvars-setup.sh seems like an overkill, but it does the job of setting a `HostArch`, which is all we care about, really."},{"Id":"6765261638","Type":"PullRequestEvent","CreatedAt":"2017-10-25T17:18:36","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4801","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4801) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6765260229","Type":"PullRequestEvent","CreatedAt":"2017-10-25T17:18:18","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4798","RelatedDescription":"Merged pull request \"Enable debug info in Release builds of the runtime\" (#4798) at dotnet/corert","RelatedBody":"Matches what we do in CoreCLR. The crashes on release build are impossible to debug without this."},{"Id":"6765236232","Type":"PullRequestEvent","CreatedAt":"2017-10-25T17:13:13","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4801","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4801) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"923344981602942977","CreatedAt":"2017-10-26T00:26:13+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework images now support Windows Server 1709 https://t.co/enC2cjj2ds /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":19,"FavoriteCount":11,"RawContent":null},{"Id":"923037554265296896","CreatedAt":"2017-10-25T04:04:36+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework latest tag updated to 4.7.1 https://t.co/NuV11juPrm /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":40,"FavoriteCount":20,"RawContent":null},{"Id":"922503653402882049","CreatedAt":"2017-10-23T16:43:04+00:00","UserScreenname":"dotnet","Text":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018  https://t.co/TPKfGvwNLH /cc @intel","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":95,"FavoriteCount":55,"RawContent":null},{"Id":"921143443912474624","CreatedAt":"2017-10-19T22:38:05+00:00","UserScreenname":"dotnet","Text":"New .NET Rocks podcast with @coolcsh on understanding #dotnet standard &amp; future of #dotnetcore… https://t.co/b8BCeZKEqz","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":41,"FavoriteCount":20,"RawContent":null},{"Id":"920400974321147904","CreatedAt":"2017-10-17T21:27:47+00:00","UserScreenname":"dotnet","Text":"Announcing the .NET Framework 4.7.1 https://t.co/Vu3bilF8bZ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":380,"FavoriteCount":344,"RawContent":null},{"Id":"920393493557555205","CreatedAt":"2017-10-17T20:58:03+00:00","UserScreenname":"dotnet","Text":".NET Framework October 2017 Preview of Quality Rollup https://t.co/oVqxMXye74","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":16,"FavoriteCount":16,"RawContent":null},{"Id":"920179824576028673","CreatedAt":"2017-10-17T06:49:00+00:00","UserScreenname":"dotnet","Text":".NET Framework Docker Performance Issue Resolved https://t.co/FST3EfcLtS","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":55,"FavoriteCount":29,"RawContent":null},{"Id":"920157146309730305","CreatedAt":"2017-10-17T05:18:54+00:00","UserScreenname":"dotnet","Text":"RyuJIT Just-in-Time Compiler Optimization Enhancements https://t.co/dhO8rAqiSI","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":132,"FavoriteCount":79,"RawContent":null},{"Id":"918494723425406976","CreatedAt":"2017-10-12T15:13:01+00:00","UserScreenname":"dotnet","Text":"So many fantastic #dotnetconf sessions this year! Check them out on-demand on @ch9 https://t.co/aFDC9i36Lu https://t.co/diQ3nfOU5p","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":108,"FavoriteCount":70,"RawContent":null}]}},"RunOn":"2017-10-26T05:30:20.0274497Z","RunDurationInMilliseconds":7160}