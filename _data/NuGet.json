{"Data":{"Blog":{"FeedItems":[{"Title":"NuGet Package Signing","PublishedOn":"2017-09-14T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In our <a href=\"https://blog.nuget.org/20170809/NuGet-Fall-2017-Roadmap.html\">NuGet Fall 2017 Roadmap</a>, we highlighted security as the main area of investment over the next few months. This blog post describes a major part of that roadmap in greater detail – package signing.</p>\n\n<p>We started talking about supporting signed packages on NuGet.org a while ago. For example, in 2015 we published a post on <a href=\"https://blog.nuget.org/20150203/package-signing.html\">Package Signing</a> as well as a related <a href=\"https://github.com/aspnet/Signing/blob/dev/Spec.md\">specification</a> from the ASP.NET team, and more recently we described package signing as a part of our future plans in the post on <a href=\"https://blog.nuget.org/20170417/Package-identity-and-trust.html\">NuGet Package Identity and Trust</a>.  We´ve received some great feedback from our various discussions with you (such as the ones in the comments on the GitHub issues <a href=\"https://github.com/NuGet/Home/issues/5260\">here</a>, <a href=\"https://github.com/NuGet/Home/issues/1882\">here</a> and <a href=\"https://github.com/NuGet/Home/issues/2577\">here</a>), and we think we are ready to act on it.</p>\n\n<p>To get further feedback from our community before we start implementation, we are publishing this post as a refreshed set of goals and design principles. As we continue to refine our design, we will publish additional technical details in the form of technical specifications that will be announced via our newly setup <a href=\"https://github.com/NuGet/Announcements\">announcement repo</a>.</p>\n\n<p>We are committed to bringing these various experiences to you in a way that minimizes disruptions to your development or package authoring workflows, and at the same time balances the goal of making NuGet.org a trustworthy destination for all .NET developers to share and acquire packages.</p>\n\n<h3 id=\"package-signing-goals\">Package Signing Goals</h3>\n<p>We have two primary goals we would like to accomplish with package signing:</p>\n\n<p><strong>Package Integrity</strong>: We want to ensure the package contents have not been modified from the time the package was authored to when a developer downloads it for use in their projects. We also recognize that users copy packages from NuGet.org to multiple locations (such as setting up mirrors or copying them locally) and we want to ensure that such packages have not been modified before consumption.</p>\n\n<p><strong>Package Authenticity</strong>: We’ve heard from the community that it is often difficult to determine the origin of a package. In a previous <a href=\"https://blog.nuget.org/20170417/Package-identity-and-trust.html\">blog post</a>, we proposed some resolutions to the problem such as the ability for users to reserve package ID prefixes on NuGet.org. As we called out in that blog post, the next logical step is to address package signing. This will strengthen our package identity solution to provide authenticity on packages across multiple feeds.</p>\n\n<h3 id=\"design-principles\">Design Principles</h3>\n<p>We recognize that NuGet has a very well-established ecosystem of packages that won’t all move overnight, and various NuGet consumers will have differing requirements around the levels of conformance they want to abide by. Hence, we have set up a set of principles that we will use to test any solution with:</p>\n\n<ul>\n  <li>Changes in the NuGet protocol or its implementation on NuGet.org will ensure <strong>backwards compatibility</strong>. Existing NuGet clients will be able to consume signed or unsigned packages and we should not impact their current workflows around package authoring and consumption.</li>\n  <li>We should not require authors to <strong>resubmit</strong> existing packages. We acknowledge that not every package on NuGet.org is in active development, and not all of them will be signed and resubmitted.</li>\n  <li>We should <strong>minimize the performance impact</strong> on install and restore operations.</li>\n  <li>We should enable <strong>cross platform support</strong> - Windows, Mac and Linux - using the same protocols and workflows.</li>\n  <li>We should enable <strong>3rd party servers and clients</strong>. All changes we are proposing to NuGet.org can be implemented by any other NuGet server or client, using well-documented protocol changes.</li>\n  <li>We need to help users make <strong>informed decisions</strong> about which packages/owners to trust.</li>\n  <li>We should make use of <strong>well-known crypto</strong> algorithms.</li>\n  <li>We should enable a <strong>seamless and incremental rollout</strong> of the various experiences, not requiring all the tools or packages to be updated at the same time.</li>\n  <li>Packages should be <strong>immutable</strong> once they are signed. We should not depend on workflows that require changes to packages once they have been submitted to NuGet.org.</li>\n  <li>We should be able to support various <strong>automation</strong> scenarios (i.e. CI/CD workflows). Authors and consumers should be able to integrate the new processes and tools in their existing automation pipelines with minimal changes.</li>\n</ul>\n\n<h3 id=\"solution\">Solution</h3>\n<p>This section describes the solution and its impact from the perspective of each of the use cases in the NuGet ecosystem (package authors, package consumers and server administrators). We describe the solution using the following stages to describe how the various experiences will be enabled over time, and how they will impact each use case.</p>\n\n<h4 id=\"stage-1-enable-package-authors-to-sign-their-packages\">Stage 1: Enable package authors to sign their packages</h4>\n<p>Today, it’s not easy to know if a given package has been modified from the time it was created, to the time it is consumed. To address this, we will use <a href=\"https://en.wikipedia.org/wiki/Digital_signature\">digital signatures</a>. These are cryptographic artifacts that enable package verification in terms of integrity and authenticity from authors to consumers.</p>\n\n<p>The <a href=\"https://github.com/NuGet/Home/wiki/Author-Package-Signing\">Author Package Signing specification</a> describes the author workflow for signing packages, as well as the signed package consumption workflow in Visual Studio in greater detail. We are finalizing the technical details of the standards we will use and these will be available soon in the <a href=\"https://github.com/NuGet/Home/wiki/Package-Signatures-Technical-Details\">Package Signatures Technical specification</a>.</p>\n\n<h5 id=\"package-authors\">Package authors</h5>\n<p>For authors who want to sign their packages, the first step in this process is to obtain an X.509 code signing certificate. We recommend the use of certificates issued by public Certification Authorities, but certificates issued by enterprise CAs will also work in enterprise environments. NuGet.org will not prevent submissions of packages that are unsigned, but they will lack certain visual indicators described later.</p>\n\n<p>We will provide command line tools for Windows to enable signing existing NuGet packages, and verify signature validity prior to package submission (support for Mac and Linux will be added in Stage 3).</p>\n\n<h5 id=\"package-consumers\">Package consumers</h5>\n<p>Visual Studio will provide a visual indicator for packages submitted to NuGet.org that have been signed with a trusted CA issued certificate, including displaying details of the package signer. Once the user has selected to download a package, Visual Studio (or NuGet.exe) will validate the package during the install operation. If the signature validation fails, the consumer will be informed that the contents of the package have been tampered with. For this stage, and for all future stages, older Visual Studio clients will simply continue to work without changes though they will not light up signature validation.</p>\n\n<h5 id=\"nuget-package-sources-other-than-nugetorg\">NuGet Package Sources other than NuGet.org</h5>\n<p>At the completion of this stage, there will be no impact visible to the end user when they consume packages from sources other than NuGet.org, including packages located on their file system. Such packages will just install irrespective of the status of their contents.</p>\n\n<h4 id=\"stage-2-tamper-proofing-entire-package-dependency-graphs\">Stage 2: Tamper proofing entire package dependency graphs</h4>\n<p>Stage 1 establishes the foundation for authors to sign new packages, but it does not address the fact that packages are only trustworthy from an end users’ perspective if the entire dependency graph can be trusted by them. For packages that have not been signed by their authors, existing or new, we want to provide a mechanism to verify the integrity of the package contents once the package has been received by a server such as NuGet.org. To enable this scenario, the package source can add a <strong>secure checksum</strong> that will guarantee the package integrity from the time the package was received on the server to when it is consumed by end users, no matter where the package is physically located.</p>\n\n<p>This secure checksum will improve the consumer experience in two areas:</p>\n\n<ul>\n  <li>When a signed package has a dependency on an unsigned package from a package source that implements secure checksums, the NuGet client will be able to verify the integrity of the complete dependency graph.</li>\n  <li>For scenarios where multiple package sources are used (such as NuGet mirrors), we will help the user identify (and block) packages that were modified after the package was submitted to a trusted source, such as NuGet.org.</li>\n</ul>\n\n<blockquote>\n  <p>Note: We will publish more details on server checksums soon. You can find an index with all related specs <a href=\"https://github.com/NuGet/Home/wiki/Package-signing\">here</a>.</p>\n</blockquote>\n\n<h5 id=\"package-authors-1\">Package authors</h5>\n<p>There will be no impact to package authors, since all packages submitted to NuGet.org, signed and unsigned, existing and new, will automatically be processed to include the checksum without user interaction.</p>\n\n<h5 id=\"package-consumers-1\">Package consumers</h5>\n<p>Consumers will be able to see a visual indicator on all packages that contain the NuGet.org checksum, making it easier to identify packages that were once submitted to NuGet.org even if they are found in different sources.</p>\n\n<p>If the package has been modified since its original submission to NuGet.org, the NuGet client will block the installation.</p>\n\n<h5 id=\"nuget-package-sources-other-than-nugetorg-1\">NuGet Package Sources other than NuGet.org</h5>\n<p>NuGet servers are not required to produce checksums, or to validate other server checksums, although we recommend that they check the checksum to avoid potential tampering while mirroring packages from NuGet.org.</p>\n\n<p>Existing package sources that already have a copy of NuGet packages without the checksum make it impossible to enforce package content validation on their clients. We will recommend these sources to refresh their NuGet.org package copies to include the checksum by downloading them again from NuGet.org (in preparation for Stage 3, where such packages will simply fail to install for many user policy settings).</p>\n\n<p>NuGet Server administrators interested in implementing this feature will get the detailed protocol changes and a reference implementation from our NuGet gallery source code. They can then choose if they would like to add their own checksums to new and existing packages submitted to their service.</p>\n\n<h4 id=\"stage-3-configurable-policies-to-enable-locked-down-developer-environments\">Stage 3: Configurable policies to enable locked down developer environments</h4>\n<p>At this point in our journey, we will have all the pieces we need to tailor custom experiences that will serve most of our use cases: from hobbyist developers where security is not a huge constraint, to demanding enterprise scenarios that require full control on how packages will be authored and consumed.</p>\n\n<p>NuGet server admins will be able to define server policies to require specific characteristics for packages before being submitted to a specific account. An example policy might be to require all new packages from the ASP.NET team to be signed.</p>\n\n<h5 id=\"package-authors-2\">Package authors</h5>\n<p>We will release package signing tools that can be used across platforms (Mac and Linux) so you no longer are restricted to using Windows for signing packages.</p>\n\n<p>NuGet.org will have configurable policies that will allow us to enforce submission restrictions such as a Microsoft-owned packages and their dependencies to be signed with CA-issued certificates before they can be ingested into NuGet.org. Similarly, enterprises can choose to download unsigned packages and sign them with their own certificates, so they can enforce policies around what their users end up consuming in their projects.</p>\n\n<h5 id=\"package-consumers-2\">Package consumers</h5>\n<p>Clients can configure themselves to not only accept, but more importantly <strong>require</strong> specific security constraints, like the ability to block unsigned packages or define a list of signed authors they trust. We will introduce a set of client policies to define the secure requirements per package source. In the table below, you can see a possible example that explains the client behaviors for different package types based on three different policies:</p>\n\n<style type=\"text/css\">\ntable.posttable {\t\t\n\tborder-width: 1px;\n\tborder-color: #004880;\n\tborder-collapse: collapse;    \n}\ntable.posttable th {\n\tborder-width: 1px;\n\tpadding: 8px;\n\tborder-style: solid;\n\tborder-color:white;\n\tbackground-color: #004880;    \n    color:white;\n    text-align: left;\n}\ntable.posttable td {\n\tborder-width: 1px;\n\tpadding: 8px;\n\tborder-style: solid;\n\tborder-color: #004880;\n\tbackground-color: #ffffff;\n    vertical-align: top\n}\n</style>\n\n<table class=\"posttable\">\n  <thead>\n    <tr>\n      <th>Package Type</th>\n      <th>Developer Mode</th>\n      <th>Default Mode</th>\n      <th>Secure Mode</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><strong>Unsigned</strong></td>\n      <td>Allow</td>\n      <td>Warn</td>\n      <td>Block</td>\n    </tr>\n    <tr>\n      <td><strong>Checksum</strong></td>\n      <td>Allow</td>\n      <td>Allow</td>\n      <td>Block</td>\n    </tr>\n    <tr>\n      <td><strong>Signed</strong></td>\n      <td>Allow</td>\n      <td>Allow</td>\n      <td>Prompt</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>Allow</strong>: The package will be installed without any error or warning.</li>\n  <li><strong>Warn</strong>: The client will show a warning indicating there are packages in the dependency graph that does not satisfy policy constraints.</li>\n  <li><strong>Prompt</strong>: Only packages added to a trust list will be allowed, and users can modify this list using Visual Studio user experiences.</li>\n  <li><strong>Block</strong>: The package will not be installed, and we will show an error message.</li>\n</ul>\n\n<h5 id=\"nuget-package-sources\">NuGet Package Sources</h5>\n<p>Servers will be able to define policies to be applied during the package ingestion process, typically on per-account basis, and can define validation rules for signed packages.</p>\n\n<blockquote>\n  <p>Note: We will publish more details on client and server policies soon. You can find an index with all related specs <a href=\"https://github.com/NuGet/Home/wiki/Package-signing\">here</a>.</p>\n</blockquote>\n\n<h3 id=\"roadmap\">Roadmap</h3>\n<p>The table below summarizes our current thinking around how we can introduce this experience in compliance with the design principles we laid out before. Once we iterate on the design with you and finalize our approach, we will propose dates for each of these stages:</p>\n\n<table class=\"posttable\">\n    <thead>\n        <tr>\n            <th width=\"10%\"></th>\n            <th width=\"30%\">Stage 1</th>\n            <th width=\"30%\">Stage 2</th>\n            <th width=\"30%\">Stage 3</th>            \n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><b>Authors</b></td>\n            <td>Command Line tools to enable Sign and Verify packages.</td>\n            <td></td>\n            <td>Cross platform support.</td>\n        </tr>\n        <tr>\n            <td><b>Servers</b></td>\n            <td>Validate Signed Packages on submission.</td>\n            <td>Generate source checksums.</td>\n            <td>Configure server policies.</td>\n        </tr>\n        <tr>\n            <td><b>Consumers</b></td>\n            <td>\n                Visual indicator in Visual Studio NuGet Package Manager for signed and verified packages on NuGet.org.\n                <p>Validate author signatures when obtaining packages (install, restore or update) from CLI or IDE tools.</p>    \n            </td>\n            <td>\n                Validate complete dependency graph for signed packages.\n                <p>Validate source checksums. <br /> Identify NuGet.org packages in multi-source environments.</p>\n            </td>\n            <td>\n                Package Source Settings UI to specify client policy by source.\n                <p>\n                    Trusted author dialog UI.\n                </p>\n            </td>\n        </tr>  \n    </tbody>  \n</table>\n\n<h3 id=\"related-specifications\">Related Specifications</h3>\n<p>You can find a list of the relevant specifications <a href=\"https://github.com/NuGet/Home/wiki/Package-signing\">here</a>. Some of these specifications are further along than others, but more details will be added shortly.</p>\n\n<ul>\n  <li><strong>Package Signing</strong>: This is the master specification of the feature that can be used as an index with links to various related specs.  <a href=\"https://github.com/NuGet/Home/wiki/Package-Signing\">Package Signing</a></li>\n  <li><strong>Package Author Signing</strong> : Describes the user experience for producing and consuming signed packages. <a href=\"https://github.com/NuGet/Home/wiki/Author-Package-Signing\">Author Package Signing</a></li>\n  <li><strong>Package Signatures Technical Details</strong>: Contains the signature format technical details <a href=\"https://github.com/NuGet/Home/wiki/Package-Signatures-Technical-Details\">Package Signatures Technical Details</a></li>\n</ul>\n\n<h3 id=\"call-to-action\">Call to Action</h3>\n<p>I would like to again reiterate that we want to bring this experience in a way that allows everyone in the NuGet ecosystem to participate incrementally, and at the same time, allows the NuGet team to quickly iterate on delivering this experience which will greatly improve the trustworthiness of our ecosystem. We would love to hear your feedback on any of these experiences. You can share your feedback using this <a href=\"https://github.com/NuGet/Home/issues/2577\">GitHub issue</a>, or by dropping me an <a href=\"mailto:rmpablos@microsoft.com?subject=[Feedback]NuGetPackageSigning\">e-mail</a>. Because of the large-scale nature of this experience, we have found that phone conversations are often a good way of working through design issues – let me know if you would like to chat over the phone as well.</p>\n\n<p>I would like to thank many of you who have provided ideas and suggestions on this proposal over the last month with a special call out to Oren Novotny, Kevin Jones and some folks on the .NET team. Their feedback has been invaluable so far.</p>\n\n","Href":"http://blog.nuget.org/20170914/NuGet-Package-Signing.html","RawContent":null},{"Title":"Changes to NuGet.org service management, and performance improvements in China","PublishedOn":"2017-09-07T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>NuGet.org, the package manager for .NET, was purpose-built as a global service with high scale performance regardless of the developer’s location. We are finding that this is not always the case, particularly for developers accessing the service from China, which is the second largest region for .NET developers. They frequently face higher download times resulting in poor restore performance and service outages.</p>\n\n<p>We have been actively investigating solutions to this problem. Based on our tests, developers in China should see up to 30x improvement in package download times and on average, a 10x improvement in overall package restore time. The solution requires us to co-locate our blob storage in China and use a local CDN provider to serve package requests. As a result, in order to implement this solution and better serve the global .NET community, the .NET Foundation will transfer ownership of the NuGet.org <strong>service</strong> to Microsoft.</p>\n\n<p>The .NET Foundation’s mission is to support open source .NET projects, and will continue to do so. However, as the NuGet service grows, Microsoft is in a better position to run such global services from an infrastructure and business perspective. Microsoft’s current footprint allows us to run the service in China – something that we cannot do under the .NET Foundation’s current charter. This will allow the .NET Foundation to focus its efforts on its core mission; supporting .NET open source projects.</p>\n\n<p>We remain fully committed developing NuGet in the open, and the NuGet code base will remain a .NET Foundation project. This will enable us to continue to provide an agile and reliable global service, at the same time as ensuring a healthy ecosystem.</p>\n\n<h4 id=\"q-what-does-this-mean-for-me-as-a-nugetorg-package-author-or-consumer\">Q. What does this mean for me, as a NuGet.org package author or consumer?</h4>\n<p>There are no changes to the way you publish and consume packages from NuGet.org. The Terms of Service and Privacy Statement will be updated to reflect the change in ownership, how Microsoft will process the data collected, and manage copyright and trademark infringement notices.</p>\n\n<h4 id=\"q-what-about-the-nuget-project-on-github-does-the-move-mean-that-nuget-is-no-longer-open-source\">Q. What about the NuGet project on GitHub? Does the move mean that NuGet is no longer open source?</h4>\n<p>The NuGet open source codebase (both the NuGet gallery and the NuGet client) will remain open source and continue as .NET Foundation supported projects under the same terms as before. We remain fully committed to ensuring a healthy and open ecosystem around NuGet. The NuGet.org service is an implementation of the NuGet gallery open source codebase and only this piece is moving to be owned by Microsoft.</p>\n\n<h4 id=\"q-did-the-nuget-team-explore-other-alternatives\">Q. Did the NuGet team explore other alternatives?</h4>\n<p>We explored several options, including a parallel instance of the NuGet.org feed with a different URL (i.e., a mirror of NuGet.org). However, this option would not work for developers in China. Additionally, it does not provide a seamless experience, requiring developers to re-configure IDE, build machines, etc. depending upon location, to publish and consume packages from NuGet.org.</p>\n\n<p>The .NET Foundation and Microsoft want NuGet to meet the evolving needs of our community. If we can do anything to improve your NuGet experience, please send us an email at <a href=\"mailto:feedback@nuget.org&amp;subject=Feedback%20on%20changes%20to%20Nuget.org%20service%20management\">feedback@nuget.org</a>.</p>\n\n","Href":"http://blog.nuget.org/20170907/Changes-to-NuGet-dot-org-service-management-and-performance-improvements-in-China.html","RawContent":null},{"Title":"What's Nu in NuGet with Visual Studio 2017 version 15.3?","PublishedOn":"2017-08-15T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We are happy to announce an update to the NuGet client that comes bundled with Visual Studio 2017 version 15.3 RTW and .NET Core 2.0 SDK. This release introduces support for new scenarios such as .NET Core 2.0/.NET Standard 2.0, some new features, a series of bug fixes and performance improvements. You can see more details, known issues and workarounds associated with this release in our <a href=\"https://docs.microsoft.com/en-us/nuget/release-notes/nuget-4.3-rtm\">release notes</a>.</p>\n\n<p>Here are some links to get started with using the latest NuGet functionality:</p>\n<ul>\n  <li><a href=\"https://www.visualstudio.com/downloads\">Visual Studio 2017 version 15.3</a></li>\n  <li><a href=\"https://www.microsoft.com/net/download/core\">.NET Core 2.0</a></li>\n  <li><a href=\"https://nuget.org/downloads\">NuGet.exe</a></li>\n  <li><a href=\"https://nuget.org/downloads\">Visual Studio 2015 – NuGet Package Manager update (v3.6.0)</a></li>\n</ul>\n\n<h2 id=\"tldr\">TL;DR</h2>\n\n<p>Our major focus for this release was adding support for .NET Core 2.0. In addition, we made some other improvements:</p>\n<ul>\n  <li><a href=\"#support-for-new-tfms\">Support for new TFMs</a></li>\n  <li><a href=\"#msbuild-integration-of-nuget-warnings-and-errors\">MSBuild integration of NuGet warnings and errors</a></li>\n  <li><a href=\"#support-for-semantic-versioning-200\">Support for Semantic Versioning 2.0.0</a></li>\n</ul>\n\n<p>For Visual Studio 2015, you can now start using .NET Standard 2.0 packages by installing the latest <a href=\"#update-to-the-nuget-client-in-visual-studio-2015\">NuGet client (v3.6.0) for Visual Studio 2015</a>.</p>\n\n<p>We are also happy to announce that we have integrated the NuGet.org facelift we had previously previewed back into the NuGet.org site, and results in the following improvements available to all NuGet.org users:</p>\n<ul>\n  <li><a href=\"#an-accessible-nugetorg-site\">An accessible NuGet.org site</a></li>\n  <li><a href=\"#prominent-package-details\">Prominent package details page</a></li>\n  <li><a href=\"#streamlined-account-settings\">Streamlined account settings</a></li>\n</ul>\n\n<h2 id=\"support-for-new-tfms\">Support for new TFMs</h2>\n<p>We have added support for the following TFMs - <code class=\"highlighter-rouge\">netcoreapp2.0</code> and <code class=\"highlighter-rouge\">netstandard2.0</code>. We also enabled <code class=\"highlighter-rouge\">Tizen</code> as a supported TFM that helps integration of Tizen .NET libraries with Xamarin Forms. The complete list of supported TFMs is reflected in this <a href=\"https://docs.microsoft.com/en-us/nuget/schema/target-frameworks#supported-frameworks\">documentation</a>.</p>\n\n<h2 id=\"msbuild-integration-of-nuget-warnings-and-errors\">MSBuild integration of NuGet warnings and errors</h2>\n<p>We have integrated NuGet warnings and errors with MSBuild so you can use existing MSBuild properties to suppress certain warnings or elevate them to errors. In addition, we have also improved warnings and errors to output relevant information and thereby making them more actionable. All NuGet warnings/errors now have a unique number associated with them as documented <a href=\"https://docs.microsoft.com/en-us/nuget/reference/errors-and-warnings\">here</a>.</p>\n\n<p><strong>Note</strong>: These improvements are only available to project systems that support expressing NuGet dependencies using <a href=\"https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files\">PackageReference</a>.</p>\n\n<h3 id=\"how-does-it-work\">How does it work?</h3>\n<p>As an example, when you install a .NET Framework package (say RestSharp) into a .NET Core 2.0 project, you will see the following <a href=\"https://docs.microsoft.com/en-us/nuget/reference/errors-and-warnings#nu1701\">NU1701</a> warning:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Warning\tNU1701\tPackage 'RestSharp 105.2.3' was restored using '.NETFramework,Version=v4.6.1' instead of the project target framework '.NETCoreApp,Version=v2.0'. This package may not be fully compatible with your project.\n</code></pre></div></div>\n<p>If you are okay with the risk as stated by the warning and do not want to see it in future restores/builds, you can do one of the following:</p>\n<h4 id=\"suppress-the-warning-in-the-project-on-a-packagereference-basis\">Suppress the warning in the project on a PackageReference basis</h4>\n<p>To suppress the warning, you can go to the package properties window and add <a href=\"https://docs.microsoft.com/en-us/nuget/reference/errors-and-warnings#nu1701\">NU1701</a> to the NoWarn property:\n<img src=\"/images/2017-08-15-Whats-nu-in-NuGet-with-VS2017-15-3/SuppressWarningPerPackage.PNG\" alt=\"Suppress warning for package reference\" />\nThis results in the following entry being created in the project file:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    &lt;PackageReference Include=\"RestSharp\" Version=\"105.2.3\"&gt;\n      &lt;NoWarn&gt;NU1701&lt;/NoWarn&gt;\n    &lt;/PackageReference&gt;\n</code></pre></div></div>\n\n<h4 id=\"suppress-the-warning-at-a-project-level\">Suppress the warning at a project level</h4>\n<p>If you do not want to see the warning at all in the project irrespective of the package reference that introduces it, you can suppress it in the project’s build properties: \n<img src=\"/images/2017-08-15-Whats-nu-in-NuGet-with-VS2017-15-3/SuppressWarningPerProject.PNG\" alt=\"Suppress warning at a project level\" />\nThis results in the following entry being created in the project file:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    &lt;PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|AnyCPU'\"&gt;\n      &lt;NoWarn&gt;NU1701&lt;/NoWarn&gt;\n    &lt;/PropertyGroup&gt;\n</code></pre></div></div>\n\n<h4 id=\"elevate-a-warning-to-an-error\">Elevate a warning to an error</h4>\n<p>In case you want to elevate a specific warning to an error, you can do so by specifying the same in the Build properties:\n<img src=\"/images/2017-08-15-Whats-nu-in-NuGet-with-VS2017-15-3/ElevateWarningAsError.PNG\" alt=\"Elevate warning to error\" />\nThis results in the following entry being created in the project file:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    &lt;PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|AnyCPU'\"&gt;\n      &lt;WarningsAsErrors&gt;NU1605&lt;/WarningsAsErrors&gt;\n    &lt;/PropertyGroup&gt;\n</code></pre></div></div>\n<h4 id=\"a-word-of-caution\">A word of caution!</h4>\n<p>If you have set your project’s build property to treat all warnings as errors, you may start to see your builds fail because of the NuGet warnings now being flagged as errors. You can choose to either fix these warnings and/or suppress them using one of the mechanisms specified above.</p>\n\n<h2 id=\"support-for-semantic-versioning-200\">Support for Semantic Versioning 2.0.0</h2>\n<p><a href=\"http://semver.org/#semantic-versioning-200\">Semantic Versioning 2.0.0</a> specification has been out for a long time and we have gotten multiple requests to support it. We have been listening to your requests and <a href=\"https://github.com/NuGet/Home/issues/3610\">feedback</a> and are happy to announce SemVer 2.0.0 support for NuGet starting with our latest client releases including NuGet 4.3.0, Visual Studio 2017 version 15.3 and dotnet.exe 2.0.0. We are also making this support available for Visual Studio 2015 as a separate <a href=\"https://nuget.org/downloads\">download</a>.</p>\n\n<h3 id=\"a-word-of-caution-1\">A word of caution!</h3>\n<p>If your package version contains one of the following, they will not be visible from the older clients (NuGet clients before 4.3.0 or Visual Studio before 2017 version 15.3):</p>\n<ol>\n  <li>The pre-release label is dot-separated, e.g. 1.0.0-alpha.1</li>\n  <li>The version has build-metadata, e.g. 1.0.0+githash</li>\n</ol>\n\n<p>We recommend you consider this to be a beta-feature until a significant majority of our users are on these latest clients that understand Semantic Versioning 2.0.0. Read more on Semantic Versioning 2.0.0 NuGet support, <a href=\"https://docs.microsoft.com/en-us/nuget/reference/package-versioning#semantic-versioning-200\">here</a>.</p>\n\n<h2 id=\"update-to-the-nuget-client-in-visual-studio-2015\">Update to the NuGet client in Visual Studio 2015</h2>\n<p>We wanted to ensure that developers using Visual Studio 2015 can use packages targeting .NET Standard 2.0, and have created an <a href=\"https://nuget.org/downloads\">update</a> to the NuGet client in Visual Studio 2015 that adds the following improvements:</p>\n<ul>\n  <li>Support for consuming .NET Standard 2.0 packages into the compatible projects</li>\n  <li>Support for Semantic Versioning 2.0.0 packages</li>\n  <li>Fix for UI hang bug as described in NuGet <a href=\"https://github.com/NuGet/Home/issues/4976\">#4976</a></li>\n</ul>\n\n<h2 id=\"the-facelift-to-nugetorg-site-is-live\">The facelift to NuGet.org site is live!</h2>\n<p>A month ago, we had announced a significant redesign of the NuGet.org site. We got a ton of great feedback, and for that, we are always grateful. We were able to address a majority of that feedback as listed below (See full list of issues <a href=\"https://github.com/NuGet/NuGetGallery/issues?q=label%3A&quot;Redesign%20Feedback&quot;%20\">here</a>):</p>\n\n<h3 id=\"condensed-list-for-manage-packages-4431\">Condensed list for ‘Manage Packages’ <a href=\"https://github.com/NuGet/NuGetGallery/issues/4431\">#4431</a></h3>\n\n<p>We have improved the author’s view of packages they own to make it more manageable – sorted and compact: \n<img src=\"/images/2017-08-15-Whats-nu-in-NuGet-with-VS2017-15-3/CondensedManagePackagesList.PNG\" alt=\"Condensed Manage packages list\" /></p>\n\n<h3 id=\"search-results-consistency-with-visual-studio-3791-4493\">Search results consistency with Visual Studio <a href=\"https://github.com/NuGet/NuGetGallery/issues/3791\">#3791</a>, <a href=\"https://github.com/nuget/nugetgallery/issues/4493\">#4493</a></h3>\n<p>We have made the package ID to be the consistent identifier (header) for the packages that shows up on NuGet.org or Visual Studio:\n<img src=\"/images/2017-08-15-Whats-nu-in-NuGet-with-VS2017-15-3/PackageTitleAndIDConsistency.PNG\" alt=\"Condensed Manage packages list\" /></p>\n\n<p>The NuGet.org package search has a new filter for prelease packages so that search results would be consistent with this existing functionality on Visual Studio:\n<img src=\"/images/2017-08-15-Whats-nu-in-NuGet-with-VS2017-15-3/IncludePrereleaseFilter.PNG\" alt=\"Include pre release filter\" /></p>\n\n<p>In addition, we have made some improvements to package search results to fit more items by reducing the package ID font size and by removing the unnecessary separator line. We will continue to explore more ways to improve this page.</p>\n\n<p>In case you missed the improvements we made to NuGet.org, here is a quick summary of our previous <a href=\"http://blog.nuget.org/20170718/NuGet-Gallery-Gets-A-Facelift.html\">blog post</a>:</p>\n\n<h3 id=\"an-accessible-nugetorg-site\">An accessible NuGet.org site</h3>\n<p>We are committed to making sure that NuGet.org is fully accessible to all users. We addressed many accessibility issues for this preview in accordance with <a href=\"https://www.section508.gov/content/learn/laws-and-policies\">Section 508 Laws</a> and <a href=\"https://www.w3.org/TR/WCAG20/\">Web Content Accessibility Guidelines (WCAG 2.0 AA)</a>. If you find any accessibility issues, please let us know by <a href=\"https://github.com/NuGet/NuGetGallery\">filing an issue on GitHub</a>.</p>\n\n<p>Some of the changes we’ve made include:</p>\n<ul>\n  <li>Updating tab ordering on all pages to ensure proper keyboard navigation</li>\n  <li>Setting ARIA attributes on elements to make sure screen-reader technologies work on the website</li>\n  <li>Ensuring all interactive elements have visual feedback for when they are focused by the keyboard</li>\n  <li>Setting text colors to properly contrast with backgrounds with a minimum ratio of 4.5:1</li>\n</ul>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-Accessibility-Focus.gif\" alt=\"Accessibility Demo\" /></p>\n\n<h3 id=\"prominent-package-details\">Prominent package details</h3>\n<p>During our discussions, we heard from you what information is important when determining the viability of a package. The importance of various aspects like freshness, download count, license type, access to a project site, and many more influenced the design of a more streamlined package details page.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-PackageInfo-Overview.png\" alt=\"Package Details Page\" /></p>\n\n<p>We created sections to divide package details to make it easier to parse through all the information to get a better understanding of a package. All the vital information is placed at the top of the page to be seen first when navigating to the page. Additionally, the project site now displays as the full URL (if it is under a certain number of characters), publish date is more readable, and license type is made more prominent.</p>\n\n<p>Now that NuGet is supported by a variety of consoles, we wanted to support the many ways users can add packages to their projects. We’ve made it easier to copy the command to install a package, and added a new tab for the command to install using the .NET CLI.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-PackageInfo-CLI.gif\" alt=\"CLI Support Demo\" /></p>\n\n<h3 id=\"streamlined-account-settings\">Streamlined account settings</h3>\n<p>We’ve made it easier for users to access their account settings, moving away from a centralized account page that combined unrelated settings together. Now, API keys and package management controls can be accessed from any page with the account dropdown. It’s much easier for authors to manage their packages.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-AccountSettings.gif\" alt=\"New Account Settings Menu\" /></p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n<p>We want NuGet to meet the evolving needs of our community. In case you missed it, we recently published a <a href=\"https://blog.nuget.org/20170809/NuGet-Fall-2017-Roadmap.html\">post</a> that describes some of the experiences we are working in the near future. Share your thoughts with us at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, open an issue on GitHub: <a href=\"https://github.com/NuGet/Home/issues\">NuGet client issues</a>, <a href=\"https://github.com/NuGet/NuGetGallery/issues\">NuGet server issues</a></p>\n","Href":"http://blog.nuget.org/20170815/Whats-nu-in-NuGet-with-VS2017-15-3.html","RawContent":null},{"Title":"NuGet Fall 2017 Roadmap","PublishedOn":"2017-08-09T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Over the past 6 months, the NuGet team has been working hard to ensure the growth of the .NET ecosystem. NuGet has grown significantly during this timeframe: NuGet.org is closing in on 4 billion packages served (up from <a href=\"http://blog.nuget.org/20160510/The-1st-Billion.1.html\">a billion packages</a> just a year ago), we have enabled new .NET scenarios such as .NET Standard 2.0, and have improved the overall user experience of package authors and consumers using the service. Yet, a lot more remains to be done.</p>\n\n<p>Along the way, we made some mistakes that our community has rightfully called us out on. We made changes to the client and the server that took some users by surprise. We also realized that we did not have a set of principles we would follow when it comes to nurturing the community around NuGet. While we still don’t have the answers to some of the questions asked of us, one thing is very clear – we need to significantly increase the transparency in what we do and when we do it, and we will start with this post.</p>\n\n<h2 id=\"our-roadmap\">Our roadmap</h2>\n<p>Our top priorities over the next few months will be to improve security, performance, and some user experiences as called out below. For each of these experiences, we will be posting detailed specifications, including a call to action to the community to offer us feedback before we begin implementation. For now, we have created placeholders for the specifications as well as an issue to discuss the feature once the draft spec has been published.</p>\n\n<h2 id=\"security\">Security</h2>\n<p><a href=\"https://nuget.org/\">NuGet.org</a> usage is growing fast, which is great, but it means our security profile is getting bigger – enough to attract malicious users. Many of the changes required to enforce security can be potentially destabilizing – significant changes to the protocol, increased friction in the submission process, disruption to automation and so on. Ensuring the NuGet experience remains trustworthy and secure must be a top priority, and you’ll find that will be reflected in our near-term roadmap. While we work through these changes, we are committed to minimizing disruption to the NuGet community by being transparent with our plans and design changes, as well as providing enough of a notice before any functionality gets enforced.</p>\n\n<h2 id=\"package-signing\">Package signing</h2>\n<p>The NuGet team, and the broader community, has been debating the idea of enforcing signing requirements on packages authors and consumers. The package signing feature will enable consumers to verify the identity of the author and the integrity of the contents of the package. While we are heavily leaning towards the use of X.509 certificates for signing packages, we will also consider alternatives such as blockchains. We understand that acquiring and managing certificates can be both expensive and cumbersome to the various NuGet workflows, and we are evaluating various options to smoothen this process. We are currently in the process of collating all the good discussions that have been happening, as well as our own thoughts, and will post an initial design proposal on this topic soon at the following link. [<a href=\"https://aka.ms/nuget-pkgsigning\">Feature specification</a>]</p>\n\n<h2 id=\"two-factor-authentication-for-nugetorg-access\">Two-factor authentication for NuGet.org access</h2>\n<p>NuGet.org currently supports a home-grown authentication mechanism, which is not sustainable in the long term. We want to transition the NuGet.org authors to more robust and scalable solutions such as Microsoft Account (MSA) or Azure Active Directory (AAD). We will require users to enable Two-factor authentication (2FA) before they can access NuGet.org to publish new packages or new versions of existing packages (the experience for downloading packages will remain unchanged). We will also consider additional ways to securely push packages via the command line tools that are more resilient to unintentional disclosure of API keys. [<a href=\"https://aka.ms/nuget-2fa\">Feature specification</a>]</p>\n\n<h2 id=\"package-id-prefix-reservation\">Package ID prefix reservation</h2>\n<p>There are currently several identifying properties for NuGet packages originating from NuGet.org, including package title, package ID, package owner, and package author. There are several cases throughout NuGet.org where identifying properties of a package can be misaligned (e.g. author is listed as “Microsoft”, but no owners of the package are from Microsoft). To provide NuGet package authors with an ability to protect their IP, and to empower NuGet package consumers with more information, we are implementing a feature for package owners to reserve a package ID prefix. Packages that meet the right criteria will have a visual indicator to tell package consumers that the package is authentic. [<a href=\"https://aka.ms/nuget-pkg-id-reservation\">Feature specification</a>]</p>\n\n<h2 id=\"improving-search\">Improving search</h2>\n<p>When a user searches for a package either in a NuGet client or on NuGet.org, we list packages that are often not relevant in the context of the user project. We want to improve our search results and project applicability information, so you always know what to expect out a package before you install it. [<a href=\"https://aka.ms/nuget-contextualsearch\">Feature specification</a>]</p>\n\n<h2 id=\"repeatable-builds\">Repeatable builds</h2>\n<p>When users define floating package dependencies in their projects, consecutive builds (restores) may have different package versions if new package versions get uploaded to a NuGet feed in between these builds. We will ensure that package restore graph information is preserved across multiple builds of a project, or even across multiple projects in a repository, thereby giving users control on the restore outcomes and increasing predictability of builds. [<a href=\"https://aka.ms/nuget-rptbuilds\">Feature specification</a>]</p>\n\n<h2 id=\"a-vibrant-nuget-ecosystem\">A vibrant NuGet ecosystem</h2>\n<p>Over the past 6 months, the NuGet team (and me personally) have learnt a great deal about working more effectively with the OSS community. Whether it was the way we started the conversation around <a href=\"https://github.com/NuGet/Home/issues/5307\">reserving package prefixes</a> or the way we handled the <a href=\"https://github.com/NuGet/NuGetGallery/pull/4437\">Paket pull request</a>, we should have done a lot better. We remain fully committed to growing the NuGet ecosystem, and over the next few weeks, will work with the community to articulate an approach that balances our extensibility and our agility to deliver some of the experiences mentioned above.</p>\n\n<p>The publication of this roadmap is just a first step in our journey. Please expect to see a lot more details on each of the items over the next few weeks. If you have feedback on any of these items, we recommend that you use the GitHub issue linked to the item, or create a new one.</p>\n\n","Href":"http://blog.nuget.org/20170809/NuGet-Fall-2017-Roadmap.html","RawContent":null},{"Title":"NuGet.org Gets a Facelift","PublishedOn":"2017-07-18T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>It’s been a long time coming, and today we are excited to announce some big changes coming to NuGet.org. With almost 3 million monthly page views, NuGet.org is the gateway for .NET developers to find packages that accelerate their projects. However, as a package management website, so much more can be done.</p>\n\n<p>We decided to give NuGet.org a redesign and use it as a platform to build out new functionality. We’ve already begun to pull in a couple of new features, and have a bunch in the pipeline or planned for the future.</p>\n\n<p>In this post, we’ll discuss 3 things:</p>\n<ol>\n  <li>The motivations for the redesign and how your feedback guided our decisions</li>\n  <li>An overview of what we’ve changed and added to the website</li>\n  <li>A sneak peak of some other features that are currently being worked on</li>\n</ol>\n\n<p>We encourage you to try out the <a href=\"https://preview.nuget.org\">NuGet.org Preview site</a> today!</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-Home-New.png\" alt=\"New NuGet.org\" /></p>\n\n<h2 id=\"feedback-and-inspiration\">Feedback and inspiration</h2>\n<p>Over the past couple of months, we’ve been talking to you, and hearing your feedback on the current website and gathering ideas on what a modern NuGet.org should look like and do. Some of the common themes we’ve heard in our discussions include:</p>\n<ol>\n  <li>The website looks old and dated</li>\n  <li>Current UI makes it hard to find existing package information to judge the legitimacy of a package</li>\n  <li>Package info on the NuGet website can be lacking and makes it hard to gauge package viability</li>\n</ol>\n\n<p>Additionally, after going through accessibility testing, we found a lot of bugs with our current site. Issues ranged from pages impossible to navigate with a keyboard to colors lacking contrast. We knew that we had to do better.</p>\n\n<h2 id=\"overview-of-changes\">Overview of changes</h2>\n<p>With all the feedback in mind, we set out to create the new, fully-accessible NuGet website that empowers you to easily discover, understand, and use the packages you need.</p>\n\n<h3 id=\"accessibility-fixes\">Accessibility fixes</h3>\n<p>We are committed to making sure that NuGet.org is fully accessible to all users. We addressed many accessibility issues for this preview in accordance with <a href=\"https://www.section508.gov/content/learn/laws-and-policies\">Section 508 Laws</a> and <a href=\"https://www.w3.org/TR/WCAG20/\">Web Content Accessibility Guidelines (WCAG 2.0 AA)</a>. If you find any accessibility issues, please let us know by <a href=\"https://github.com/NuGet/NuGetGallery\">filing an issue on GitHub</a>.</p>\n\n<p>Some of the changes we’ve made include:</p>\n<ul>\n  <li>Updating tab ordering on all pages to ensure proper keyboard navigation</li>\n  <li>Setting ARIA attributes on elements to make sure screen-reader technologies work on the website</li>\n  <li>Ensuring all interactive elements have visual feedback for when they are focused by the keyboard</li>\n  <li>Setting text colors to properly contrast with backgrounds with a minimum ratio of 4.5:1</li>\n</ul>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-Accessibility-Focus.gif\" alt=\"Accessibility Demo\" /></p>\n\n<h3 id=\"more-prominent-package-details\">More prominent package details</h3>\n<p>During our discussions, we heard from you what information is important when determining the viability of a package. The importance of various aspects like freshness, download count, license type, access to a project site, and many more influenced the design of a more streamlined package details page.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-PackageInfo-Overview.png\" alt=\"Package Details Page\" /></p>\n\n<p>We created sections to divide package details to make it easier to parse through all the information to get a better understanding of a package. All the vital information is placed at the top of the page to be seen first when navigating to the page. Additionally, the project site now displays as the full URL (if it is under a certain number of characters), publish date is more readable, and license type is made more prominent.</p>\n\n<p>Now that NuGet is supported by a variety of consoles, we wanted to support the many ways users can add packages to their projects. We’ve made it easier to copy the command to install a package, and added a new tab for the command to install using the .NET CLI.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-PackageInfo-CLI.gif\" alt=\"CLI Support Demo\" /></p>\n\n<h3 id=\"streamlined-account-settings\">Streamlined account settings</h3>\n<p>We’ve made it easier for users to access their account settings, moving away from a centralized account page that combined non-related settings together. Now, API keys and package management controls can be accessed from any page with the account dropdown. It’s much easier for authors to manage their packages.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-AccountSettings.gif\" alt=\"New Account Settings Menu\" /></p>\n\n<h3 id=\"easier-package-management\">Easier package management</h3>\n<p>For package authors, we’ve made it easier to edit and manage packages. The “Manage Packages” page is more descriptive for each package, showing information that mirrors the search results page.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-ManagePackages.png\" alt=\"Manage Packages\" /></p>\n\n<p>Additionally, we’ve improved the workflow for editing and listing a specific package version by enabling users to select a version of a package from a dropdown, rather than having to navigate to a specific version’s details page.</p>\n\n<h3 id=\"giving-credit-to-you-the-community\">Giving credit to you, the community</h3>\n<p>Ever wonder why the <a href=\"https://www.nuget.org/policies/About\">About page</a> seemed to have such a small amount of Gallery contributors, when there were definitely more people involved? We did too! So, we made sure everyone who has ever contributed to the <a href=\"https://github.com/NuGet/NuGetGallery\">NuGet Gallery repo on GitHub</a> is properly thanked and shown on our About page.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-About.png\" alt=\"About Page\" /></p>\n\n<p>We wouldn’t be anything without our community, and we wanted to show how thankful we are for your contributions.</p>\n\n<h3 id=\"updates-to-our-blog-and-status-page\">Updates to our blog and status page</h3>\n<p>Since we redesigned the main NuGet website, it only makes sense that we give the <a href=\"http://blog.nuget.org\">blog</a> and <a href=\"https://status.nuget.org\">status</a> pages some love as well. We aligned the pages with the design of the new website to ensure consistency across all of NuGet.org. We cleaned up the blog to make it easier to browse for posts, and made the status page easier to understand and find operational issues.</p>\n\n<h2 id=\"whats-in-the-works\">What’s in the works?</h2>\n<p>Like we said before, we didn’t want to just change pixels on the website. This is not a one-time pass to leave until we need to do another redesign in a couple of years. We’re taking this opportunity to be more iterative on the website and continue to build out and bring new features that improve your experience. As such we have a couple of features that we’ve begun working on that will come to NuGet.org in the coming months.</p>\n\n<h3 id=\"package-documentation-integration\">Package documentation integration</h3>\n<p>We get that packages don’t always offer enough details about what the package is and how to use it. As such we want to give users more information about packages by integrating ReadMe content.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-Packages-Documentation.png\" alt=\"Documentation on Package Details\" /></p>\n\n<p>Upon package upload, users will be able to upload or write a ReadMe file to attach to their package. Alternatively, they can link their package to a repository that will pull the ReadMe automatically. This will enable package consumers to get a better sense of a package without having to go to a package’s project site, and empower package authors to create content to aid in the adoption of their packages.</p>\n\n<h3 id=\"status-banner\">Status banner</h3>\n<p>Being notified of the operational status is important for any service. For NuGet, we want to make it easier for users to see if we are experience issues right from the homepage rather than trying to find the <a href=\"https://status.nuget.org\">Status page</a>.</p>\n\n<p><img src=\"/images/2017-07-18-NuGetOrg-Gets-A-Facelift/NuGet-Gallery-ServiceWarning.png\" alt=\"Status Banner\" /></p>\n\n<h3 id=\"upcoming-backlog\">Upcoming backlog</h3>\n<p>Additionally, we have a many more features in our backlog that we want to address in future updates to NuGet.org. Some items on our backlog include:</p>\n<ul>\n  <li>Making search better by improving the relevance of returned results and offering advanced search options (e.g. Target Framework, Author, etc.)</li>\n  <li>Adding deeper repository integration by showing repo statistics (open pull requests, last commit, star counts, etc.)</li>\n</ul>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>We’re really excited to share this new experience with you, so please give the <a href=\"https://preview.nuget.org\">NuGet.org Preview site</a> a try!</p>\n\n<p>We’d love to hear any feedback you have on the website, or things you’d like to see. Fill out our <a href=\"https://www.research.net/r/XP9GS73\">feedback survey</a>, or leave a comment below. If you discover any bugs with the preview site, <a href=\"https://github.com/NuGet/NuGetGallery\">file an issue on GitHub</a>.</p>\n\n<p>While we work on incorporating your feedback, we will continue to maintain <a href=\"https://www.nuget.org\">NuGet.org</a> in case you find any workflow blockers. We’ll be taking the next couple of weeks to respond to your feedback and will be continuously pushing updates to the preview site. We plan to integrate the new design into NuGet.org in August.</p>\n\n<p>This is just the first step, and we’re excited to continue to bring new features to NuGet.org to make your experience discovering, using, and managing packages better.</p>\n","Href":"http://blog.nuget.org/20170718/NuGet-Gallery-Gets-A-Facelift.html","RawContent":null},{"Title":"NuGet Package Identity and Trust","PublishedOn":"2017-04-17T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><strong>Update on 10/16/2017:</strong> Package ID Prefix Reservation is now live. The documentation can be found <a href=\"https://docs.microsoft.com/en-us/nuget/reference/id-prefix-reservation\">here</a>.</p>\n\n<p>We want to start this post with a huge thanks to you, the NuGet community. Over the last several months we have been talking to many of you to get feedback on NuGet package identity and trust. We’ve learned so much from you and we hope that what we have planned addresses some of the top concerns you have expressed to us.</p>\n\n<p>One of the recurring messages we heard from you is that it is difficult to determine the origin of a package. More specifically, who produced and published the package that you want to use, and is that person or organization trustworthy?</p>\n\n<p>We want to tackle this problem head on – read on to see what’s in store for our first feature to address NuGet package identity. We are still working on the finer details of the solution, so any feedback you have is greatly appreciated. Please leave a comment on this post or reach out to me (<a href=\"mailto:dajaco@microsoft.com\">dajaco@microsoft.com</a>) directly.</p>\n\n<h2 id=\"summary\">Summary</h2>\n<p>Below you can find a quick summary of the first problem we are trying to solve, and our proposed solution. Read past the summary to get into some of the nitty gritty details of both the problem and our first set of solutions.</p>\n\n<h3 id=\"identity-problem\">Identity Problem</h3>\n<p>Today, there are multiple properties that identify a NuGet package. Each property serves a purpose, but this sometimes makes it difficult as a NuGet package consumer to fully understand the source of a NuGet package. Ultimately, we’ve observed customers want to know who produced and published the package they are about to consume.</p>\n\n<h3 id=\"initial-solution\">Initial Solution</h3>\n<p>To empower NuGet package consumers to quickly identify that the packages they consume originates from a trusted package owner, we are introducing a concept known as <a href=\"https://github.com/NuGet/Home/issues/1882\">verified package owners</a>. This feature will be exclusive to accounts registered with nuget.org. When an account owner is verified, we will provide a visual indicator for NuGet package consumers to know if the packages they are consuming originate from package owners that have verified their identity with the nuget.org server administrators. This should give NuGet package consumers the ability to quickly identify the true source of their package.</p>\n\n<p>In addition, verified package owners will have an opportunity to apply for a reserved package ID prefix. Only the owner that reserves a package ID prefix will be able to submit new packages that match the ID prefix glob pattern. For example, the .NET Foundation will manage the package prefix <strong>System.*</strong> – if you want to submit a package that matches the <strong>System.*</strong> naming pattern, you will first need to get permission from the .NET Foundation.</p>\n\n<h3 id=\"next-steps\">Next Steps</h3>\n<p>Based on your feedback, we realize there are several other areas of investment that we need to consider and prioritize over time. The verified package owner and reserved package ID prefix feature set is a tactical first investment to set us up for success in the future, and to empower NuGet package consumers with the information they need. As we continue to work on improving package identity, we want to make sure that we don’t negatively impact existing NuGet scenarios across all NuGet clients.</p>\n\n<p>Some other areas we are considering that are related to package identity are:</p>\n\n<ol>\n  <li><a href=\"https://github.com/NuGet/Home/issues/4628\">Making package licensing information more obvious to package consumers</a></li>\n  <li><a href=\"https://github.com/NuGet/Home/issues/2577\">NuGet package signing with digital certificates</a></li>\n  <li><a href=\"https://github.com/NuGet/NuGetGallery/issues/3791\">Consistent UI for package ID and package titles in VS and nuget.org so you can quickly uniquely identify a package</a></li>\n</ol>\n\n<h2 id=\"background-on-nuget-package-owners-authors-and-package-ids\">Background on NuGet package owners, authors and package IDs</h2>\n<p>To understand the source of confusion in package source identity, it’s important to review how NuGet works today. From talking to you, we have identified three properties that package consumers rely on to determine the “source” of the NuGet Package:</p>\n<ul>\n  <li>Package owner</li>\n  <li>Package author</li>\n  <li>Package ID prefix</li>\n</ul>\n\n<p>Each of these serve a separate purpose, but having different identifying properties makes it difficult to answer one extremely important question: <strong>who produced the package I am about to use in my project?</strong></p>\n\n<h3 id=\"package-owner\">Package owner</h3>\n<p>The package owner is the account on nuget.org that published the package. This value is unique to the nuget.org feed – local feeds or other remote feeds may or may not have any concept of a package <strong>owner</strong>. This is the value that is displayed when searching for packages on nuget.org:</p>\n\n<p><img src=\"/images/2017-04-17-NuGet-package-identity-and-trust/entity-framework-owner.png\" alt=\"Package Owner\" /></p>\n\n<p>For the <a href=\"http://www.nuget.org/packages/EntityFramework\">EntityFramework</a> package, the owners are <a href=\"http://www.nuget.org/profiles/aspnet\">aspnet</a>, <a href=\"http://www.nuget.org/profiles/EntityFramework\">EntityFramework</a>, and <a href=\"http://www.nuget.org/profiles/microsoft\">microsoft</a>.</p>\n\n<h3 id=\"package-author\">Package author</h3>\n<p>The package author is defined in the .nuspec file of the .nupkg – it is supposed to represent the person or organization that wrote the code for the package. Let’s look at the <a href=\"http://www.nuget.org/packages/EntityFramework\">EntityFramework</a> package again:</p>\n\n<p><img src=\"/images/2017-04-17-NuGet-package-identity-and-trust/entity-framework-author.png\" alt=\"Package Author\" /></p>\n\n<p>The listed author for the EntityFramework package is “Microsoft”. The data presented to you on nuget.org is different than what you see in Visual Studio, but in this case (as in most cases), the information is consistent. Because one of the owners on nuget.org is <a href=\"https://www.nuget.org/profiles/microsoft\">microsoft</a>, and the author is also listed as Microsoft, you can be confident this package indeed comes from Microsoft.</p>\n\n<h3 id=\"package-id-prefix\">Package ID prefix</h3>\n<p>Another property that package consumers use to identify the source of the package is the package ID prefix. When installing a package on the <a href=\"https://docs.microsoft.com/en-us/nuget/tools/package-manager-console\">Package Manager Console</a>, this is the beginning of the package ID – e.g. for the popular <a href=\"https://www.nuget.org/packages/Microsoft.AspNet.Mvc\">ASP.NET MVC package</a>, the package ID prefix is <strong>Microsoft.AspNet.MVC</strong>. Because it starts with <strong>Microsoft</strong>, many users trust that this package comes from Microsoft as the owner and author of the package.</p>\n\n<h3 id=\"examples-of-package-identity-causing-potential-confusion\">Examples of package identity causing potential confusion</h3>\n<p>Below are just three examples of packages that may be confusing to package consumers. In each of these cases, one of the three properties don’t provide consistent information about the package. For example, the package author may be <strong>Microsoft</strong>, but the nuget.org account <a href=\"https://www.nuget.org/profiles/microsoft\">microsoft</a> may not actually be an owner on the package.</p>\n<ul>\n  <li><a href=\"http://www.nuget.org/packages/System.Linq.Dynamic/\">System.Linq.Dynamic</a>\n    <ul>\n      <li>Author is listed as <strong>Microsoft</strong>, but <a href=\"https://www.nuget.org/profiles/microsoft\">microsoft</a> is not a package owner for this package</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.nuget.org/packages/System.Ben/\">System.Ben</a>\n    <ul>\n      <li><strong>System.*</strong> should be reserved for foundational .NET packages</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.nuget.org/packages/Microsoft.Office.Interop.Excel/\">Microsoft.Office.Interop.Excel</a>\n    <ul>\n      <li>Author is listed as <strong>Microsoft</strong>, but <a href=\"https://www.nuget.org/profiles/microsoft\">microsoft</a> is not a package owner for this package</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>Now, I want to stress that these packages are not necessarily bad packages!</strong> We are trying to empower NuGet package consumers with information about the package identity. Even though <a href=\"http://www.nuget.org/packages/System.Linq.Dynamic/\">System.Linq.Dynamic</a> has <strong>Microsoft</strong> as the listed author, but is not owned by <a href=\"https://www.nuget.org/profiles/microsoft\">microsoft</a>, the package is still a good package – in fact, it has close to 1 million downloads from .NET community members.</p>\n\n<h2 id=\"solving-the-package-identity-crisis\">Solving the package identity crisis</h2>\n<p>After talking to many NuGet community members, we have several ideas on how to fix this NuGet package identity problem. Our number one goal is to provide NuGet package consumers with meaningful information about who their package is coming from. In other words, when you are consuming a <strong>Microsoft.*</strong> package with a <strong>Microsoft</strong> author, you should quickly be able to determine if it <em>actually</em> comes from <strong>Microsoft</strong>, or if it comes from a different person or organization.</p>\n\n<p>To do this, we are going to introduce two features: <strong>verified package owners</strong> and <strong>package ID prefix reservation</strong>.</p>\n\n<h3 id=\"verified-package-owners\">Verified package owners</h3>\n<p>A verified package owner in its simplest form is just an account on <a href=\"https://www.nuget.org/\">nuget.org</a> who has proven to <a href=\"https://www.nuget.org/\">nuget.org</a> administrators that they are who they say they are. They have gone through an application and verification process to prove their identity. In addition, verified owners will be held to a stricter set of terms. Most notably, the author property for their packages must properly identify the source of the package. When you see <strong>Microsoft</strong> in Visual Studio next to a verified owner indicator, you can be confident that it comes from <strong>Microsoft</strong>. If you see <strong>Microsoft</strong> as an author for a package without the visual indicator, then you may want to do some additional research to determine who owns and publishes the package.</p>\n\n<h3 id=\"criteria-for-package-owner-verification\">Criteria for package owner verification</h3>\n<p>Verified package owners will <strong>not</strong> be available to all accounts on <a href=\"https://www.nuget.org/\">nuget.org</a>. Verified package owners must meet certain crtiera:</p>\n<ul>\n  <li>There must be significant risk of your packages or identity being confusing to nuget.org package consumers. This is often but not exclusive to the following:\n    <ul>\n      <li>Impact your packages have on the .NET community</li>\n      <li>Popularity of your NuGet packages (number of downloads from nuget.org is just one indicator of popularity)</li>\n    </ul>\n  </li>\n  <li>Being a co-owner of a package with a verified owner\n    <ul>\n      <li>This is to drive confidence in the contents of a package that is owned by multiple owners</li>\n    </ul>\n  </li>\n</ul>\n\n<p>To start, this will be a limited program that we will expand over time. Verified package owners will get several benefits. The most important one is that top-level packages that are owned by verified owners will have a visual indicator on both nuget.org and in Visual Studio that the package originated from verified owners. We will not evaluate if all transitive dependencies are also verified. If you can trust the author/publisher of the top-level package, you should be able to trust their ability to determine their package dependencies.</p>\n\n<h3 id=\"verified-package-owner-mockups\">Verified package owner mockups</h3>\n<p>You can see several possible examples of the visual indicator in the mockups below:</p>\n\n<p><img src=\"/images/2017-04-17-NuGet-package-identity-and-trust/nuget-org-verified-owners.png\" alt=\"nuget.org Verified Owners\" /></p>\n\n<p><img src=\"/images/2017-04-17-NuGet-package-identity-and-trust/vs-verified-owners.png\" alt=\"Visual Studio Verified Owners\" /></p>\n\n<h3 id=\"workflow-improvement-with-verified-package-owners\">Workflow improvement with verified package owners</h3>\n<p>We’ve learned from our customers about typical package consumption workflows – especially when package identity and trust is important. An example of a typical workflow before verified package owners are available is:</p>\n<ul>\n  <li>Discover package in the Visual Studio Package Manager UI or on the internet</li>\n  <li>Look at package author in Visual Studio</li>\n  <li>Refer to <a href=\"https://www.nuget.org/\">nuget.org</a> to look at package owners and number of downloads (and sometimes source code)</li>\n  <li>If the package owners somewhat match the author in Visual Studio, and the package seems generally trusted in the community, then add the package reference</li>\n</ul>\n\n<p>With verified package owners, we hope to reduce the workflow for many of the most critical .NET packages to the following:</p>\n<ul>\n  <li>Discover the package in Visual Studio Package Manager UI</li>\n  <li>See the verified indicator on a package with an author that you trust, and reference the package</li>\n</ul>\n\n<p>Only if the package is not coming from verified owners that you trust should you have to resort to additional research on nuget.org or elsewhere.</p>\n\n<h2 id=\"package-id-prefix-reservation\">Package ID prefix reservation</h2>\n<p>While we think package owner verification is a good start at improving identity related confidence for NuGet package consumers, we also want to address some concerns many package authors have expressed to us. There are cases where developers clone an open source repository, create a NuGet package, and publish it to <a href=\"https://www.nuget.org/\">nuget.org</a> with an appropriate package ID. While this is fine in practice, we’ve had several complaints that the package was intentionally not yet on nuget.org by the author of the code. Many times, this is because the code is not yet ready for broad distribution. It could still be pre-release code or not fully supported.</p>\n\n<p>As the code evolves and is ready to be submitted as a NuGet package, the original author of the code cannot publish the package with the package ID they want (since it had previously been published).</p>\n\n<p>With verified package owners being able to reserve package ID prefixes, this problem should be mitigated for key .NET partners. The most influential .NET contributors will be able to reserve a package ID prefix so that future package submissions that match the ID prefix pattern are reserved for them. This allows them to develop their code in the open, and only submit to nuget.org when they are confident the package is ready for broad consumption. If other community members want to publish the package earlier, they are welcome to use a different package ID prefix.</p>\n\n<p>We will not retrofit this to all previously submitted packages (so we don’t destroy existing dependencies), but we will evaluate existing packages and may delist or remove packages that appear to be intentionally abusing a package ID prefix.</p>\n\n<h2 id=\"criteria-for-package-id-prefix-reservation\">Criteria for package ID prefix reservation</h2>\n<p>Applying for a reserved package ID prefix will require package owners to be verified. Once the package ID prefix application is submitted, the <a href=\"https://www.nuget.org/\">nuget.org</a> team will review the following criteria with the .NET Foundation:</p>\n<ul>\n  <li>Does the ID prefix properly identify the package owner?</li>\n  <li>Are a significant number of the packages that have already been submitted by the owner under that package ID prefix?</li>\n  <li>Is the package ID prefix something common that should not belong to any individual owner or organization?</li>\n  <li>Would <em>not</em> reserving the package prefix cause ambiguity and confusion?</li>\n</ul>\n\n<p>What we are striving for is clear messaging on identity of the package and the source of the package. All issued reserved prefixes will be reviewed with .NET Foundation with all criteria heavily considered.</p>\n\n<h2 id=\"feedback\">Feedback!</h2>\n<p>There are a lot of complexities with NuGet package identity and trust. For us to address your needs properly, we desire your input. Please let us know what you think about this in the comments below or by emailing <a href=\"mailto:dajaco@microsoft.com\">dajaco@microsoft.com</a>. Alternatively, you can post your comments on the <a href=\"https://github.com/NuGet/Home/issues/1882\">NuGet issue</a> tracking this work.</p>\n\n<p>We sincerely thank you for your feedback as we continue to build a better NuGet for everyone!</p>\n","Href":"http://blog.nuget.org/20170417/Package-identity-and-trust.html","RawContent":null},{"Title":"NuGet is now fully integrated into MSBuild","PublishedOn":"2017-03-16T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the past, NuGet packages were managed in two different ways - packages.config and project.json -  each with their own sets of advantages and limitations. With Visual Studio 2017 and .NET Core, we have improved the NuGet package management experience by introducing the PackageReference feature in MSBuild. PackageReference brings new and improved capabilities such as deep MSBuild integration, improved performance for everyday tasks such as install and restore, multi-targeting and more.</p>\n\n<h2 id=\"try-out-packagereference-today\">Try out PackageReference today!</h2>\n\n<p>To get a piece of the PackageReference goodness, <a href=\"https://www.visualstudio.com/vs/whatsnew/\">download Visual Studio 2017</a> and create a .NET Standard class library or .NET Core project. These projects come with PackageReference enabled by default. You can also <a href=\"#what-about-other-project-types-that-are-not-net-core\">try PackageReference with other project types</a> .</p>\n\n<p>Install your favorite NuGet packages, try out different scenarios and workflows, and if you run into an issue or find something broken, <a href=\"https://github.com/Nuget/Home/issues\">open an issue on GitHub</a>.</p>\n\n<h2 id=\"packagereference--the-one-nuget-format-to-rule-them-all\">PackageReference – the one NuGet format to rule them all</h2>\n\n<h3 id=\"manage-all-project-dependencies-in-one-place\">Manage all project dependencies in one place</h3>\n<p>Just like project to project references or assembly references, you can now view and manage NuGet package references from the MSBuild project file (e.g. csproj).</p>\n\n<p><img src=\"/images/2017-03-16-NuGet-now-fully-integrated-into-MSBuild/pr-in-action.png\" alt=\"pr-in-action\" /></p>\n\n<h3 id=\"see-only-those-dependencies-you-care-about\">See only those dependencies you care about</h3>\n<p>In the past, if your project referenced package A, which in-turn referenced packages B, C and D, you would see all of them listed as your dependencies. With Transitive Package Restore, NuGet dynamically resolves dependencies giving you an uncluttered view of the packages you care about. Additionally, project files are not modified on restore, avoiding merge conflicts and file churn on commits. This also allows the project system to evolve independent of NuGet.</p>\n\n<h3 id=\"performance-improvements\">Performance improvements</h3>\n<p>Package installs/updates are now at least 5x faster. With PackageReference and Transitive Package Restore, we no longer stamp every down-level dependency into the project file. In a test project that references 5 packages, with each package having 20-30 dependencies of their own, update/install used to take ~10 mins to complete. With these new features, our tests show that these operations now take ~30ms.</p>\n\n<p>Solution-local packages folders are no longer used – Packages are now resolved against the user’s cache at <code class=\"highlighter-rouge\">%userdata%\\.nuget</code>, rather than a solution specific packages folder. This makes PackageReference perform faster and consume less disk space by using a shared folder of packages on your workstation.</p>\n\n<h3 id=\"fine-control-over-dependencies-and-content-flow\">Fine control over dependencies and content flow</h3>\n<ul>\n  <li>\n    <p>With the existing features of MSBuild, you can conditionally reference a NuGet package. This allows you to choose package references per target framework, configuration, platform, or other pivots. For example:</p>\n\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  &lt;PackageReference Include=\"NuGet.Versioning\" Version=\"3.6.0\" Condition = \"'$(TargetFramework)' == 'netstandard10'\"/&gt;\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>You might be using a dependency purely as a development harness and might not want to expose that to projects that will consume your package. In this scenario, you can use the PrivateAssets metadata to control this behavior. For example:</p>\n\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  &lt;PackageReference Include=\"Contoso.Utility.UsefulStuff\" Version=\"3.6.0\"&gt;\n      &lt;PrivateAssets&gt;All&lt;/PrivateAssets&gt;\n  &lt;/PackageReference&gt;\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>You can control the flow of dependency assets using Include/Exclude Assets metadata. \n  In the following example, everything except the content files from the package would be consumed by the project and everything except content files and analyzers would flow to the parent project.</p>\n\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  &lt;PackageReference Include=\"Contoso.Utility.UsefulStuff\" Version=\"3.6.0\"&gt;\n      &lt;IncludeAssets&gt;All&lt;/IncludeAssets&gt;\n      &lt;ExcludeAssets&gt;contentFiles&lt;/ExcludeAssets&gt;\n      &lt;PrivateAssets&gt;contentFiles;analyzers&lt;/PrivateAssets&gt;\n  &lt;/PackageReference&gt;\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>You now have flexibilty to express dependency versions using either version ranges or floating versions. In the first example, using version range, you can restrict the package version range which NuGet accepts from 1.3.2 up to 1.4.x, but not 1.5 and higher. In the second example, using floating version, NuGet will always bring the latest version of the ExamplePackage that matches the pattern 1.4.x.</p>\n\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  &lt;PackageReference Include=\"ExamplePackage\" version=\"[1.3.2,1.5)\" /&gt;\n\n  &lt;PackageReference Include =\"ExamplePackage\" version=\"1.4.*\"/&gt;\n</code></pre></div>    </div>\n  </li>\n</ul>\n\n<h3 id=\"define-nuspec-metadata-in-project-files\">Define nuspec Metadata in project files</h3>\n<p>You can now author NuGet packages by specifying NuGet properties in your project file. You can also define these properties from the project properties. Additionally, you can choose to auto-generate a NuGet package on every build by checking the “Generate NuGet package on build” property.</p>\n\n<p><img src=\"/images/2017-03-16-NuGet-now-fully-integrated-into-MSBuild/nuspecprops.gif\" alt=\"nuspecprops\" /></p>\n\n<h3 id=\"build-packages-directly-from-a-project\">Build packages directly from a project</h3>\n<p>Pack and Restore are msbuild targets, making NuGet a first class MSBuild citizen. For example, you can execute <code class=\"highlighter-rouge\">msbuild /t:pack</code> in a project directory to generate a NuGet package using the properties and metadata declared in the project file. \nIn a CI/CD scenario, NuGet error and warnings are collated with the MSBuild output, giving you a single view of your build output.</p>\n\n<h3 id=\"background-package-restore\">Background Package Restore</h3>\n<p>In prior configurations, you had to perform a build or an explicit restore to restore NuGet packages. With NuGet 4.0, background package restore automatically downloads and adds or removes NuGet packages as you edit PackageReference and save your project files.</p>\n\n<h3 id=\"package-project-duality\">Package project duality</h3>\n<p>As a package author, you can now expect the exact same behavior when referencing a library either as a Project to Project reference or as NuGet package. This streamlines your inner loop when authoring NuGet packages as you no longer need to go through the change-build-pack-restore loop to test a change.</p>\n\n<h3 id=\"develop-against-multiple-tfms\">Develop against multiple TFMs</h3>\n<p>You can now specify multiple target frameworks (TFMs) and at pack time, NuGet will do the right thing to create a nupkg with the correct package structure. For example:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;PropertyGroup&gt;\n\t&lt;TargetFrameworks&gt;netstandard1.4;net452;netcoreapp1.0&lt;/TargetFrameworks&gt;\n&lt;/PropertyGroup&gt;\n</code></pre></div></div>\n\n<h2 id=\"what-about-other-project-types-that-are-not-net-core\">What about other project types that are not .NET Core?</h2>\n<p>You can get a first look of what will come in the next NuGet update. Hop on to the <a href=\"https://blogs.msdn.microsoft.com/visualstudio/2017/03/16/visual-studio-2017-update-preview-and-windows-10-creators-update-sdk/\">Visual Studio 2017 Update 1 Preview 2</a> bandwagon. Once you have the VS 2017 U1 Preview 2, you can try PackageReference with any packages.config based project. Navigate to <code class=\"highlighter-rouge\">Tools &gt; Options&gt; NuGet Package Manager &gt; General</code> and check the “Allow format selection on first package install” option.</p>\n\n<p><img src=\"/images/2017-03-16-NuGet-now-fully-integrated-into-MSBuild/trypackageref.gif\" alt=\"trypackageref\" /></p>\n\n<p>Create a new packages.config based project and attempt to install a NuGet package. You will be prompted by the dialog below. Select the PackageReference option and click ok.</p>\n\n<p><img src=\"/images/2017-03-16-NuGet-now-fully-integrated-into-MSBuild/nuget-format-selection-dialog.png\" alt=\"nuget-format-selection-dialog\" /></p>\n\n<p>Some of the features discussed earlier are not yet fully supported for packages.config based projects such as defining nuspec metadata in project files, building packages directly from a project, background package restore, developing against multiple TFMs, and package project duality. We are hard at work to bring full PackageReference support to these project types. Our goal is to eventually make PackageReference the default and move away from all other formats.</p>\n\n<h2 id=\"will-existing-nuget-package-management-formats-continue-to-work\">Will existing NuGet package management formats continue to work?</h2>\n<p>The PackageReference feature is only supported in Visual Studio 2017. We remain fully committed to maintaining compatibility of existing projects created with Visual Studio 2015 in Visual Studio 2017. Your packages.config and project.json managed projects will continue to work in both versions of Visual Studio.</p>\n\n<h2 id=\"will-existing-nuget-packages-work-if-i-am-using-packagereference-for-wpf-windows-forms-or-aspnet-projects\">Will existing NuGet packages work if I am using PackageReference for WPF, Windows Forms or ASP.NET projects?</h2>\n<p>While we have done a lot of work to ensure that existing packages on NuGet.org just work with the PackageReference format, there are a few scenarios that will not be supported in the PackageReference world and might impact your ability to migrate away from packages.config. Some examples of scenarios that will not be supported include content folders (we have introduced <a href=\"https://docs.microsoft.com/en-us/nuget/schema/nuspec#including-content-files\">ContentFiles</a>), XDT transforms, PowerShell scripts i.e. install.ps1 and uninstall.ps1 (only init.ps1 is supported) . If you come across a package you consume in your WPF or Windows Forms app that worked previously but does not work on migrating your project to PackageReference, we would love to hear from you, so that we can investigate what the incompatibilities might be.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points, and your current or future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@NuGet.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home/issues\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20170316/NuGet-now-fully-integrated-into-MSBuild.html","RawContent":null},{"Title":"Announcing NuGet 4.0 RTM","PublishedOn":"2017-03-08T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Visual Studio 2017 comes with NuGet 4.0 which adds support for .NET Core, has a bunch of quality fixes and improves performance. This release also brings several improvements like support for PackageReference, NuGet commands as MSBuild targets, background package restores, and more.</p>\n\n<h2 id=\"downloads\">Downloads</h2>\n<p><a href=\"https://www.visualstudio.com/vs/whatsnew/\">Visual Studio 2017 RTM</a> is available for download <a href=\"https://www.visualstudio.com/downloads/\">here</a>. The NuGet Package Manager extension is already built-in, so you do not have to install or update it.</p>\n\n<p>NuGet.exe 4.0 is also available for download as a separate component, <a href=\"https://dist.nuget.org/index.html\">here</a>.</p>\n\n<h3 id=\"nuget-package-manager-extension-in-visual-studio-2017\">NuGet Package Manager Extension in Visual Studio 2017</h3>\n\n<p>Starting with NuGet 4.0 in Visual Studio 2017, the NuGet Package Manager will be shipped as a part of Visual Studio, and newer versions will not be available for download from the VS extensions gallery. NuGet updates will be pulled in automatically along with other Visual Studio updates.</p>\n\n<p>The NuGet 4.0 Package Manager Extension is currently not available for Visual Studio 2015 (Visual Studio 2015 comes with NuGet 3.4.4, and NuGet 3.5.0 is available as an explicit download for Visual Studio 2015 as well). NuGet 4.0 builds upon several new features and bug fixes available only in Visual Studio 2017, and hence the newer NuGet experiences will not be available in Visual Studio 2015. At the same time, we want packages to work seamlessly across Visual Studio versions. We will be monitoring feedback to determine what experiences we want to enable in Visual Studio 2015 in a future release (for example, the introduction of newer TFMs).</p>\n\n<h2 id=\"new-features\">New Features</h2>\n\n<h3 id=\"packagereference\">PackageReference</h3>\n\n<p>PackageReference will become the standard way to manage NuGet dependencies across all project types. With NuGet 4.0, PackageReference is fully supported for .NET Core projects. This allows you to use MSBuild conditions to choose package references per target framework, configuration, platform, or other pivots. It also allows for fine-grained control over dependencies and content flow. Here is an example of how you would add a PackageReference in your MSBuild-based project file:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;ItemGroup&gt;\n...\n    &lt;PackageReference Include=\"Contoso.Utility.UsefulStuff\" Version=\"3.6.0\"/&gt;\n...\n&lt;/ItemGroup&gt;\n</code></pre></div></div>\n\n<p>You can also try PackageReference with other project types such as WinForms, Windows Presentation Foundation(WPF), and Universal Windows Platform (UWP). More details about usage and known limitations of using PackageReference in non-.NET Core projects will be available on this blog soon.</p>\n\n<h3 id=\"first-class-msbuild-citizen\">First class MSBuild citizen</h3>\n\n<p>In the past, it was a little tricky to make NuGet work with MSBuild. In this release, we are shipping Restore and Pack as first class MSBuild targets. This will allow you to easily work with NuGet as you would with any task or target in MSBuild.\nYou can now produce  packages directly from a project. For example, you can do <code class=\"highlighter-rouge\">msbuild /t:pack</code>  in a project directory which would generate a NuGet package using the properties and metadata declared in the csproj file of the project.</p>\n\n<p>In CI systems, you no longer need to download <code class=\"highlighter-rouge\">nuget.exe</code> and run <code class=\"highlighter-rouge\">nuget restore</code> to restore packages. You can now use <code class=\"highlighter-rouge\">msbuild /t:restore</code> to restore packages.</p>\n\n<h3 id=\"background-package-restore\">Background Package Restore</h3>\n\n<p>In the past, you had to perform a build or an explicit restore to restore NuGet packages. With NuGet 4.0, background package restore automatically downloads and adds or removes NuGet packages as you edit PackageReference and save your project files.</p>\n\n<p><strong>New commands in the .NET CLI</strong></p>\n\n<p>We have added new commands for the .NET CLI - <code class=\"highlighter-rouge\">dotnet nuget locals</code>, <code class=\"highlighter-rouge\">dotnet nuget push</code>, and <code class=\"highlighter-rouge\">dotnet nuget delete</code>. <code class=\"highlighter-rouge\">dotnet nuget locals</code> allows you to manipulate and work with the nuget caches on your machine. <code class=\"highlighter-rouge\">dotnet nuget push / delete</code> – enables pushing packages to or deleting packages from NuGet servers. Additionally, <code class=\"highlighter-rouge\">dotnet restore</code> and <code class=\"highlighter-rouge\">dotnet pack</code> now have the same behavior as MSBuild restore and MSBuild pack providing a consistent and reliable experience.</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>dotnet restore == msbuild /t:restore\ndotnet pack == msbuild /t:pack  \n</code></pre></div></div>\n\n<h2 id=\"performance-improvements\">Performance Improvements</h2>\n\n<p>The following are some performance improvements that you might notice with NuGet 4.0:</p>\n\n<p><code class=\"highlighter-rouge\">nuget update</code> for UWP, WPF and other project.json based projects is now much faster. In our sample solution with 20 UWP projects, updating packages is 6 times faster than before. For <code class=\"highlighter-rouge\">packages.config</code> based projects, <code class=\"highlighter-rouge\">nuget update</code> is now about 20% faster.</p>\n\n<p><code class=\"highlighter-rouge\">nuget restore</code> for UWP, WPF and other project.json based projects has been improved. In one of our sample projects, restore times have been reduced from about 3800ms to about 400ms.</p>\n\n<p><code class=\"highlighter-rouge\">nuget update/install</code> for packages that have deep dependencies is now faster by an order of magnitude. For a sample scenario with 5 targets each having 20-30 deep dependency chains, <code class=\"highlighter-rouge\">nuget update/install</code> used to take about 10 mins to complete, compared to about 30ms now.</p>\n\n<p>In .NET Core, tool restores have been optimized so that tool references are restored only once per solution instead of once for every project.</p>\n\n<h2 id=\"breaking-changes\">Breaking Changes</h2>\n\n<h3 id=\"default-location-for-the-machine-wide-nugetconfig\">Default Location for the machine-wide NuGet.config</h3>\n\n<p>In Visual Studio 2017 and above, the machine-wide NuGet.config is located at <code class=\"highlighter-rouge\">%ProgramFiles(x86)%\\NuGet\\Config\\</code>. Going forward, nuget.exe v4.0.0+ will also treat this as the new location for the machine-wide configuration. The primary driver for the change is to improve security in a multi-user scenario. Previously we would write to the <code class=\"highlighter-rouge\">%ProgramData%</code> folders which don’t require Admin privileges to modify. <code class=\"highlighter-rouge\">%ProgramFiles(x86)%</code> folders are protected and only users with Administrative privileges, or those granted permissions by an administrator can change their contents.</p>\n\n<p><strong>Impact</strong> - <code class=\"highlighter-rouge\">NuGet.config</code> in <code class=\"highlighter-rouge\">%ProgramData%\\NuGet\\Config\\</code> will no longer be implicitly referenced or considered for hierarchical merging of <code class=\"highlighter-rouge\">NuGet.config</code>. This is only applicable if you were previously using machine-wide NuGet configuration files.\n<strong>Solution</strong> - You must manually migrate existing config files from <code class=\"highlighter-rouge\">%ProgramData%</code> to <code class=\"highlighter-rouge\">%ProgramFiles(x86)%</code></p>\n\n<h2 id=\"release-notes\">Release Notes</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/nuget/release-notes/nuget-4.0-rtm\">4.0 release notes</a></p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points, and your current or future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home/issues\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20170308/Announcing-NuGet-4.0-RTM.html","RawContent":null},{"Title":"Introducing scoped API keys","PublishedOn":"2017-02-02T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><strong>Update 2/14 (05:00 PM PST): This feature is now live! Login to your <a href=\"https://www.nuget.org/account\">nuget account</a> and expand the <em>API Keys</em> section to see the new experience.</strong></p>\n\n<p>Since last year, we have been working on several fronts to advance NuGet as a secure environment for package distribution. This post describes an experience that will allow you to have better control of API keys that you use to push packages. Please note that this experience is currently only available on our staging environment and will be deployed to Nuget.org once we have incorporated your feedback, as described below.</p>\n\n<h2 id=\"feature-summary\">Feature summary</h2>\n<p>This feature will give you better control on your APIs as you can now:</p>\n\n<ul>\n  <li><a href=\"#create-scoped-api-keys\">Create multiple scoped API keys</a> that can be used for different packages with varying expiration timeframes.</li>\n  <li><a href=\"#obtain-api-keys\">Obtain API keys securely</a>.</li>\n  <li><a href=\"#edit-existing-api-keys\">Edit existing API keys</a> to change package applicability.</li>\n  <li><a href=\"#refresh-or-delete-existing-api-keys\">Refresh or delete existing API keys</a> without hampering operations using other keys.</li>\n</ul>\n\n<p><strong>We would love for you to try this feature and give us feedback!</strong></p>\n\n<p>Go to <a href=\"https://int.nugettest.org\">https://int.nugettest.org</a> to try the feature. Since this is a staging environment, you might have to create a new account and push new packages to try out the feature. Also, to set API key and then to push packages, you have to use <code class=\"highlighter-rouge\">-Source</code> option as specified below:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nuget.exe setApiKey [your API key] -Source https://int.nugettest.org/api/v2/package\nnuget.exe push MyPackage.1.0.nupkg -Source https://int.nugettest.org/api/v2/package\n</code></pre></div></div>\n\n<p>Share your feedback with us via comments in the blog, filing a <a href=\"https://github.com/Nuget/nugetgallery/issues\">Github issue</a> or sending an <a href=\"mailto:feedback@nuget.org?subject=[Scoped%20API%20keys]%20\">email to our team</a>.</p>\n\n<h2 id=\"why-introduce-the-concept-of-scoped-api-keys\">Why introduce the concept of scoped API keys?</h2>\n<p>We made some <a href=\"http://blog.nuget.org/20160825/Changes-to-Expiring-API-Keys.html\">changes to API keys</a> last year. We want to further that experience with the introduction of the concept of scopes for API keys that will allow you to have more fine-grained permissions. Today, NuGet offers a single API key for an account, and that approach has several drawbacks:</p>\n\n<ul>\n  <li><strong>One API key to control all packages:</strong> With a single API key that is used to manage all packages, it becomes really difficult to securely share the key when multiple developers are involved with different packages, and share a publisher account. An example of an account where we see a lot of pain on this front is our own Microsoft account that we use to push hundreds of packages across many teams.</li>\n  <li><strong>All permissions or none:</strong> Anyone with access to the API key has all permissions (publish, push and un-list) on the packages. This is often not desirable in a multiple developer/team environment.</li>\n  <li><strong>Single point of failure:</strong> A single API key also means a single point of failure. If the key is compromised, all packages associated with the account could potentially be compromised. Refreshing the API key is the only way to plug the leak which results in an interruption to your CI/CD workflow. In addition, there may be cases when you want to revoke access to the API key for an individual (for example, when an employee leaves the organization). There isn’t a clean way to handle this today.</li>\n</ul>\n\n<p>With scoped API keys, we have tried to address the problems stated above and at the same time, we have made sure that none of the existing workflows will break.</p>\n\n<h2 id=\"create-scoped-api-keys\"><a name=\"create-scoped-api-keys\"></a>Create scoped API keys</h2>\n<p>You can now create multiple API keys based on your requirements. An API key can apply to one or more packages, have varying scopes that grant specific privileges, and have an expiration date associated with it.</p>\n\n<p><img src=\"/images/2017-02-02-introducing-scoped-api-keys/intro.png\" alt=\"overview\" /></p>\n\n<p>In the screenshot above, you can have an API key named ‘Contoso service CI’ that can be used to push packages for certain ‘Contoso.Service’ packages, and is valid for 365 days. This is a typical scenario where different teams within the same organization work on different packages and the members of the team are provided the key which grants them privileges only on the package they are working on. The expiration serves as a mechanism to prevent stale or forgotten keys.</p>\n\n<h3 id=\"using-glob-patterns\">Using glob patterns</h3>\n<p>If you are working on multiple packages and have a large list of packages to manage, you may choose to use globbing patterns to select multiple packages together. For example, if you wish to grant some key certain scopes on all packages whose ID starts with Fabrikam.Service, you could do so by specifying “fabrikam.service.*” in the Glob pattern text box.</p>\n\n<p><img src=\"/images/2017-02-02-introducing-scoped-api-keys/glob-pattern.png\" alt=\"Glob patterns\" /></p>\n\n<p>Using glob patterns to determine API key permissions will also apply to new packages matching the glob pattern. For example, if you try to push a new package named ‘Fabrikam.Service.Framework’, you can do so with the key you would have created in the above step, since the package matches the glob pattern “fabrikam.service*”</p>\n\n<h2 id=\"obtain-api-keys-securely\"><a name=\"obtain-api-keys\"></a>Obtain API keys securely</h2>\n<p>For security, a newly created key is never shown on the screen and is only available with the copy button. Similarly, it will not be accessible again after the page is refreshed.</p>\n\n<p><img src=\"/images/2017-02-02-introducing-scoped-api-keys/copy-api-key.png\" alt=\"Obtain API keys\" /></p>\n\n<h2 id=\"edit-existing-api-keys\"><a name=\"edit-existing-api-keys\"></a>Edit existing API keys</h2>\n<p>Another use case is being able to update the key permissions and scopes without changing the key itself. If you have a key with specific scope(s) for a single package, you may choose to apply the same scope(s) on one or many other packages.</p>\n\n<p><img src=\"/images/2017-02-02-introducing-scoped-api-keys/edit-api-keys.png\" alt=\"Edit API keys\" /></p>\n\n<h2 id=\"refresh-or-delete-existing-api-keys\"><a name=\"refresh-or-delete-existing-api-keys\"></a>Refresh or delete existing API keys</h2>\n<p>The account owner can choose to refresh the key, in which case the permission (on packages), scope and expiry remain the same but a new key is issued making the old key unusable. This is helpful in dealing with stale keys or where there is any potential of an API key leakage.</p>\n\n<p><img src=\"/images/2017-02-02-introducing-scoped-api-keys/refresh-api-key.png\" alt=\"Refresh API keys\" /></p>\n\n<p>You can also choose to delete these keys if they are not needed anymore. Deletion will remove the key and make it unusable.</p>\n\n<h2 id=\"faqs\">FAQs</h2>\n<p><strong>What happens to my old (legacy) API key?</strong></p>\n\n<p>Your old API key (legacy) continues to work and can work as long as you want it to work. However, as was the case before, these keys will be retired if they have not been used for more than 365 days to push a package. Refer to the blog post <a href=\"http://blog.nuget.org/20160825/Changes-to-Expiring-API-Keys.html\">changes expiring to API keys</a>  for more details. You can no longer refresh this key. You need to delete the legacy key and create a new scoped key, instead.</p>\n\n<p><strong>Note:</strong> This key has all permissions on all the packages and it never expires. You should consider deleting this key and creating new keys with scoped permissions and definite expiry.</p>\n\n<p><strong>How many API keys can I create?</strong></p>\n\n<p>There is no limit on the number of API keys you can create. However, we advise you to keep it to a manageable count so that you do not end up having many stale keys with no knowledge of where and who is using them.</p>\n\n<p><strong>Can I delete my legacy API key or discontinue using now?</strong></p>\n\n<p>Yes. You can, and you probably should. We recommend you delete the legacy API key and start using the new key(s) as soon as we move this feature into our production service (this feature is currently only present in our staging environment).</p>\n\n<p><strong>Can I get back my API key that I deleted by mistake?</strong></p>\n\n<p>No. Once deleted, you can only create new keys. There is no recovery possible for accidently deleted keys.</p>\n\n<p><strong>Does the old API key continue to work upon API key refresh?</strong></p>\n\n<p>No. Once you refresh a key, a new key gets generated that has the same scope, permission and expiry as the old one. The old key ceases to exist.</p>\n\n<p><strong>Can I give more permissions to an existing API key?</strong></p>\n\n<p>You cannot modify the scope but you can edit the package list it is applicable to.</p>\n\n<p><strong>How do I know if any of my keys expired or getting expired?</strong></p>\n\n<p>If any key expires, we will let you know through a warning message at the top of the page. We also send a warning e-mail to the account holder 10 days before the expiration of the key so that you can act on it well in advance.</p>\n\n<p><img src=\"/images/2017-02-02-introducing-scoped-api-keys/expired-api-key-warning.png\" alt=\"Expired keys\" /></p>\n\n<h2 id=\"next-steps\">Next steps</h2>\n<p>We would love to hear your feedback. Keep them flowing via comments in the blog, filing a <a href=\"https://github.com/Nuget/nugetgallery/issues\">Github issue</a> or by <a href=\"mailto:feedback@nuget.org?subject=[Scoped%20API%20keys]%20\">sending an email</a> to our team. Once we address the feedback, we would like to go live with this feature - preferably in a couple of weeks from today.</p>\n","Href":"http://blog.nuget.org/20170202/introducing-scoped-api-keys.html","RawContent":null},{"Title":"NuGet - Ending Windows XP support","PublishedOn":"2017-01-19T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>At NuGet, we are constantly improving our security. One of the steps we are taking is to move our HTTPS end points to meet industry standards for algorithms and protocols. This means that connecting to nuget.org services from machines that don’t support modern cipher algorithms will no longer be supported (such as TLS 1.0 support in Windows XP). <a href=\"https://support.microsoft.com/en-us/kb/2934207\">Windows XP reached end of OS support on April 8, 2014</a>, and does not meet this minimum requirement. Therefore, <strong>we plan to end NuGet support for Windows XP on April 8, 2017</strong>.</p>\n\n<p>After support is discontinued, you will no longer be able to connect to nuget.org services from any Windows XP machines. Examples of scenarios that will no longer work include browsing the nuget.org web site, pushing packages using Nuget.exe or using the NuGet package manager inside Visual Studio. To continue using nuget.org services, you need to move to an OS that supports more modern cipher algorithms (such as Windows 10).</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points, and your current or future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20170119/nuget-end-of-xp-support.html","RawContent":null},{"Title":"Improving the NuGet documentation experience on docs.microsoft.com","PublishedOn":"2017-01-12T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In late 2016, we started on the journey of improving the docs experience for NuGet with the <a href=\"http://blog.nuget.org/20160920/NuGet-Docs-GoLive.html\">revamped docs experience</a>.\nContinuing that journey, today we are announcing the move to <a href=\"https://docs.microsoft.com/en-us/nuget\">docs.microsoft.com/nuget</a>. Given how NuGet has grown to become an integral part of the Visual Studio and .NET ecosystems, this move furthers the integration by providing a seamless experience to navigate documentation across .NET, Visual Studio and NuGet.</p>\n\n<p>This move also brings several improvements such as:</p>\n\n<ul>\n  <li>Responsive design supporting multiple form-factors such as mobile devices, tablets, and PCs.</li>\n  <li>Adding side-notes for articles</li>\n  <li>Adding comments as well as subscribing to them</li>\n  <li>Viewing estimated reading time and understanding the freshness of the content</li>\n</ul>\n\n<h2 id=\"will-my-existing-references-to-documentation-break\">Will my existing references to documentation break?</h2>\n\n<p>Existing references should continue to work. We have updated the old docs with permanent redirects which will redirect you to the new page. If you find a broken reference, please <a href=\"https://github.com/NuGet/Home/issues\">open an issue on our GitHub repo</a> and we’ll work to get it fixed.</p>\n\n<h2 id=\"how-can-i-contribute\">How can I contribute?</h2>\n\n<p>Every page that allows contribution has an “Edit” button at the top right which navigates to the md file. Feel free to make changes and submit a PR from your branch. The NuGet team will review the changes and work with you to get it merged.</p>\n\n<p>If you would like to raise a request for new docs or changes to existing docs, feel free to <a href=\"https://github.com/NuGet/Home/issues\">open a new issue</a>.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points, and your current or future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20170112/nuget-docs-move-to-msftdocs.html","RawContent":null},{"Title":"NuGet.Server 2.11.3 now available","PublishedOn":"2016-12-21T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today we are releasing an update to the <a href=\"https://www.nuget.org/packages/NuGet.Server/2.11.3/\">NuGet.Server package</a>. The purpose of this update is to address a bug that enabled NuGet.Server to be installed on projects that target .NET Framework versions less than 4.6.</p>\n\n<h2 id=\"issue-addressed\">Issue addressed</h2>\n<p>Previously, there was a bug in NuGet.Server 2.11.2 (<a href=\"https://github.com/NuGet/NuGetGallery/issues/3257\">3257</a>, <a href=\"https://github.com/NuGet/NuGetGallery/issues/3406\">3406</a>) that incorrectly considered the package to be compatible with projects that target .NET Framework prior to 4.6. Upon installing the package, the build would fail due to a missing NuGet.Server reference. With this update, users will not be able to install NuGet.Server with incompatible projects.</p>\n\n<h2 id=\"try-it-out\">Try it out!</h2>\n<p>This update of the NuGet.Server version 2.11.3 is now available for you to <a href=\"https://www.nuget.org/packages/NuGet.Server/2.11.3/\">download at nuget.org</a>. It comes with fixes that help new users of the package that might be using the wrong project type. Try it out, and let us know if you have any feedback.</p>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points, and your current or future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, open an issue on GitHub.</p>\n","Href":"http://blog.nuget.org/20161221/NuGet.Server-2.11.3-now-available.html","RawContent":null},{"Title":"Announcing NuGet 4.0 RC","PublishedOn":"2016-11-21T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>NuGet 4.0 RC for Visual Studio 2017 is focused on adding support for .NET Core scenarios, addressing key customer feedback and improving performance in a variety of scenarios. This release brings several improvements like support for PackageReference, NuGet commands as MSBuild targets, background package restore, and more.</p>\n\n<p>This post gives an overview of the new features and improvements available in NuGet 4.0 RC.</p>\n\n<h2 id=\"downloads\">Downloads</h2>\n\n<p>NuGet.exe 4.0 RC will be available for download very soon. This blog post will be updated and we’ll tweet about it at that time.</p>\n\n<h3 id=\"nuget-package-manager-extension-in-visual-studio-2017\">NuGet Package Manager Extension in Visual Studio 2017</h3>\n\n<p>Starting with NuGet 4.0 in Visual Studio 2017, the NuGet Package Manager will be shipped as a part of Visual Studio, and newer versions will not be available for download from the VS extensions gallery. NuGet updates will be pulled in automatically along with other Visual Studio updates.</p>\n\n<p>NuGet has grown to be a core part of the Visual Studio environment, and going forward, we want to treat NuGet just like any other platform component and maintain a high bar for quality and compatibility. With rapid Visual Studio releases, we will continue to bring new experiences and improvements to you quickly. You can continue to get Preview builds of NuGet if you have opted into the <a href=\"http://blog.nuget.org/20160502/Introducing-The-NuGet-Beta-Channel.html\">NuGet beta channel</a>.</p>\n\n<p>The NuGet 4.0 Package Manager Extension is currently not available for Visual Studio 2015. We will send out an update when it is made available. Since NuGet 4.0 builds upon several new features and bug fixes in Visual Studio 2017, not all NuGet 4.0 features will be available in Visual Studio 2015.</p>\n\n<h2 id=\"new-features\">New Features</h2>\n\n<h3 id=\"packagereference\">PackageReference</h3>\n\n<p><a href=\"https://docs.nuget.org/ndocs/consume-packages/package-references-in-project-files\">PackageReference</a> will be the standard way to manage NuGet dependencies across all project types. With NuGet 4.0 RC, PackageReference is fully supported for .NET Core. This allows you to use MSBuild conditions to choose package references per target framework, configuration, platform, or other pivots. It also allows for fine-grained control over dependencies and content flow. Here is an example of how you would add a PackageReference in your MSBuild-based project file:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;ItemGroup&gt;\n...\n    &lt;PackageReference Include=\"Contoso.Utility.UsefulStuff\"&gt;\n        &lt;Version&gt;3.6.0&lt;/Version&gt;\n    &lt;/PackageReference&gt;\n...\n&lt;/ItemGroup&gt;\n</code></pre></div></div>\n\n<p>In NuGet 4.0 RTM that will coincide with Visual Studio 2017 RTM, we aim to fully support PackageReference for other project types such as WinForms, Windows Presentation Foundation (WPF), and Universal Windows Platform (UWP).</p>\n\n<h3 id=\"first-class-msbuild-citizen\">First class MSBuild citizen</h3>\n\n<p>In the past, it was a little tricky to make NuGet work with MSBuild. In this release, we are shipping Restore and Pack as first class MSBuild targets. This will allow you to easily work with NuGet as you would with any task or target in MSBuild.</p>\n\n<ul>\n  <li>You can now build packages directly from a project. For example, you can do <code class=\"highlighter-rouge\">msbuild /t:pack</code> in a project directory which would generate a NuGet package using the properties and metadata declared in the csproj file of the project.</li>\n  <li>In CI systems, you no longer need to download nuget.exe and run <code class=\"highlighter-rouge\">nuget restore</code> to restore packages. You can now use <code class=\"highlighter-rouge\">msbuild /t:restore</code> to restore packages.</li>\n</ul>\n\n<h3 id=\"background-package-restore\">Background Package Restore</h3>\n\n<p>In the past, you had to perform a build or an explicit restore to restore NuGet packages. With NuGet 4.0, background package restore automatically downloads and adds or removes NuGet packages as you edit PackageReference and save your project files.</p>\n\n<h3 id=\"new-commands-in-the-net-cli\">New commands in the .NET CLI</h3>\n\n<p>We have added new commands for the .NET CLI - <code class=\"highlighter-rouge\">dotnet nuget locals</code>, <code class=\"highlighter-rouge\">dotnet nuget push</code>, and <code class=\"highlighter-rouge\">dotnet nuget delete</code>. dotnet nuget locals allows you to manipulate and work with the nuget caches on your machine. dotnet nuget push / delete – enables pushing packages to or deleting packages from NuGet servers. Additionally, dotnet restore and dotnet pack now have the same behavior as MSBuild restore and MSBuild pack providing a consistent and reliable experience.</p>\n\n<p><code class=\"highlighter-rouge\">dotnet restore</code> == <code class=\"highlighter-rouge\">msbuild /t:restore</code></p>\n\n<p><code class=\"highlighter-rouge\">dotnet pack</code> == <code class=\"highlighter-rouge\">msbuild /t:pack</code></p>\n\n<h3 id=\"performance-improvements\">Performance Improvements</h3>\n\n<p>The following are some performance improvements that you might notice with NuGet 4.0:</p>\n\n<ul>\n  <li>nuget update for UWP, WPF and other project.json based projects is now much faster. In our sample solution with 20 UWP projects, it now takes about 1.2 mins for updating packages, where previously it would have taken about 7.5 mins to update 3 packages. For packages.config based projects, nuget update is now about 20% faster.</li>\n  <li>nuget restore for UWP, WPF and other project.json based projects has been improved. In one of our sample projects, restore times have been reduced from about 3800ms to about 400ms.</li>\n  <li>nuget update/install for packages that have deep dependencies is now faster by an order of magnitude. For a sample scenario with 5 targets each having 20-30 deep dependency chains, update/install used to take about 10 mins to complete, compared to about 30ms now.</li>\n  <li>In .NET Core, tool restores have been optimized so that tool references are restored only once per solution instead of once for every project.</li>\n</ul>\n\n<h2 id=\"breaking-changes\">Breaking Changes</h2>\n\n<h3 id=\"default-location-for-the-machine-wide-nugetconfig\">Default Location for the machine-wide NuGet.config</h3>\n\n<p>In Visual Studio 2017 and above, the machine-wide NuGet.config is located at <code class=\"highlighter-rouge\">%ProgramFiles(x86)%\\NuGet\\Config\\</code>. Going forward, nuget.exe v4.0.0+ will also treat this as the new location for the machine-wide configuration. The primary driver for the change is to improve security in a multi-user scenario. Previously we would write to the <code class=\"highlighter-rouge\">%ProgramData%</code> folders which don’t require Admin privileges to modify.  <code class=\"highlighter-rouge\">%ProgramFiles(x86)%</code> folders are protected and only users with Administrative privileges, or those granted permissions by an administrator can change their contents.</p>\n\n<ul>\n  <li>Impact - NuGet.config in <code class=\"highlighter-rouge\">%ProgramData%\\NuGet\\Config\\</code> will no longer be implicitly referenced or considered for hierarchical merging of NuGet.config.  This is only applicable if you were previously using machine-wide NuGet configuration files.</li>\n  <li>Solution - You must manually migrate existing config files from <code class=\"highlighter-rouge\">%ProgramData%</code> to <code class=\"highlighter-rouge\">%ProgramFiles(x86)%</code></li>\n</ul>\n\n<h2 id=\"release-notes\">Release Notes</h2>\n\n<p><a href=\"https://docs.nuget.org/ndocs/Release-Notes/NuGet-4.0-RC\">4.0 RC</a></p>\n\n<h2 id=\"issues-list\">Issues List</h2>\n\n<p>Issues fixed in 4.0 RC can be found <a href=\"https://github.com/Nuget/home/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%224.0+RC%22\">here</a> and <a href=\"https://github.com/Nuget/home/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%224.0+Beta1%22\">here</a></p>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n<p>The team is going to focus on finalizing .NET Core support, enabling PackageReference support for all project types, and making further improvements to the performance and quality of the product.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points, and your current or future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20161121/introducing-nuget4.0.html","RawContent":null},{"Title":"Announcing NuGet 3.5 RTM","PublishedOn":"2016-10-27T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>NuGet 3.5 RTM for Visual Studio 2015 and nuget.exe provide quality improvements, performance improvements, features and new target frameworks like netstandard and netcoreapp.</p>\n\n<h2 id=\"downloads\">Downloads</h2>\n\n<p>All NuGet downloads are available on <a href=\"https://nuget.org/downloads\">https://nuget.org/downloads</a>. NuGet.exe 3.5 RTM is not marked as the latest yet in the download page or uploaded as a package, so your version of NuGet.exe will not update to 3.5 RTM if you are using the update -self switch. Over the next few weeks once we get some more real world usage of the tools, we will make this change. This blog post will be updated and tweet will be sent out at that time.</p>\n\n<blockquote>\n  <p>Note: nuget.exe /update -self will not work for a few more days until we push nuget.commandline to nuget.org</p>\n</blockquote>\n\n<ul>\n  <li>\n    <p><a href=\"https://dist.nuget.org/win-x86-commandline/v3.5.0/NuGet.exe\">3.5 RTM of nuget.exe</a></p>\n  </li>\n  <li>\n    <p><a href=\"https://dist.nuget.org/visualstudio-2015-vsix/v3.5.0/NuGet.Tools.vsix\">3.5 RTM of NuGet Package Manager Extension</a></p>\n  </li>\n</ul>\n\n<h2 id=\"no-auto-update\">No Auto Update</h2>\n\n<p>Going forward, for the near future, we will not be automatically updating the NuGet Package Manager Extension in Visual Studio 2015. Instead users will have to download the extension from our <a href=\"https://nuget.org/downloads\">downloads page</a> to update their NuGet extension. This maintains stability and consistent behavior in stable versions of Visual Studio 2015.</p>\n\n<p>You can opt in to auto update or notifications from the gallery by using the beta channel, see details <a href=\"http://blog.nuget.org/20160502/Introducing-The-NuGet-Beta-Channel.html\">here</a>.</p>\n\n<h2 id=\"new-features\">New Features</h2>\n\n<h3 id=\"support-for-new-target-frameworks\">Support for new Target Frameworks</h3>\n\n<p>.NET Standard and Net Core App TFM support is now available in 3.5 (since RC) and supports netstandard1.6 TFM for Visual Studio 2015 users. <a href=\"https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md\">.NET Standard</a> provides a more concrete guarantee of binary portability to future .NET-capable platforms with an easier-to-understand platform versioning plan.</p>\n\n<h3 id=\"packagetype\">PackageType</h3>\n<p>We have started to lay the groundwork to support a new PackageType property in the nuspec. This property allows package authors to classify their packages (E.g Dependencies, Tools etc..). More information on this is available in the PackageType spec <a href=\"https://github.com/NuGet/Home/wiki/Package-Type\">here</a>.</p>\n\n<h3 id=\"minclientversion-support-in-projectjson\">MinClientVersion support in project.json</h3>\n\n<p>Project.json now supports <a href=\"https://docs.nuget.org/create/nuspec-reference\">MinClientVersion</a>. Packages.config scenarios allowed a package to define a required min version of client it can work with. This now works in project.json scenarios as well. You can now version packages that depend on newer NuGet versions so that you can prevent users from running into issues while trying to install packages using older versions of NuGet.</p>\n\n<h3 id=\"performance-improvements\">Performance Improvements</h3>\n\n<p>The key performance scenarios we have improved are Restore, Package Manager Console Load and Updating packages.</p>\n\n<p>Here are a few examples:</p>\n\n<ul>\n  <li>\n    <p>Restore times in portable apps deployed through <a href=\"https://github.com/projectkudu/kudu/wiki\">Kudu</a> was reduced from over 15 secs to 3 secs.</p>\n  </li>\n  <li>\n    <p>Package Manager Console Load in large solutions are now much faster. In one of our sample projects it reduced from over 132s to 10s.</p>\n  </li>\n  <li>\n    <p>Package Updates in Visual Studio with ReSharper installed has been significantly improved. In our tests we have seen it drop from over 140 secs to 68 secs. We working together with the resharper team on further improvements that require code changes on both sides.</p>\n  </li>\n</ul>\n\n<h3 id=\"better-mono-compatibility\">Better Mono Compatibility</h3>\n\n<p>The team has invested in improving compatibility of NuGet.exe and packages with Mono by rolling out a new CI pipeline dedicated to verifying our changes and builds on Mono. We have fixed several issues that were identified during our testing and continue to investigate and fix remaining issues in the next versions of NuGet and Mono.</p>\n\n<h3 id=\"semver-200-client-support\">SemVer 2.0.0 Client Support</h3>\n\n<p>You can now create and publish SemVer 2.0.0 compatible packages using the NuGet Client. This enables the community to create and publish <a href=\"http://semver.org/\">SemVer 2.0.0</a> compliant packages to their own repositories. We are working on adding support for SemVer 2.0.0 to NuGet.Server and NuGet.org, and this will be made available in a future release.</p>\n\n<h2 id=\"release-notes\">Release Notes</h2>\n\n<p><a href=\"https://docs.nuget.org/ndocs/Release-Notes/NuGet-3.5-rtm\">3.5 RTM</a></p>\n\n<h2 id=\"issues-list\">Issues List</h2>\n\n<p><a href=\"https://github.com/Nuget/home/issues?q=is%3Aissue+milestone%3A%223.5+RTM%22+is%3Aclosed\">3.5 RTM</a></p>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>The team is continuning to focus on transitioning .NET CLI from project.json into MSBuild and and further investments in performance and quality of the product.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>. You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20161027/Announcing-NuGet-3.5-RTM.html","RawContent":null},{"Title":"New experience for NuGet Documentation","PublishedOn":"2016-09-20T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Last month, we launched <a href=\"http://blog.nuget.org/20160822/Starting-down-the-path-towards-better-documentation.html\">a preview of the revamped Nuget docs experience</a>. We made a number of improvements:</p>\n\n<ol>\n  <li>New quick-starts for creating and consuming packages.</li>\n  <li>End to end guides for new platforms such as .NET Standard and UWP.</li>\n  <li>A simpler and more intuitive organization of topics.</li>\n  <li>Left pane of contents serves as an index and allows you to glance at all topics.</li>\n  <li>Cross-references with links to recommended reading, related topics and reference docs.</li>\n  <li>A modern look and feel to the docs site.</li>\n</ol>\n\n<p>We would like to thank you for trying out the preview and giving us valuable feedback. We have incorporated your feedback and ironed out some wrinkles we found along the way. Today, we are going live with the new experience on <a href=\"https://docs.nuget.org\">docs.nuget.org</a>.</p>\n\n<h2 id=\"will-my-existing-references-to-documentation-break\">Will my existing references to documentation break?</h2>\n\n<p>Existing references should still work. We have updated the old docs with permanent redirects which will redirect you to the new page. If you find a broken reference, please <a href=\"https://github.com/NuGet/Home/issues\">open an issue on our GitHub repo</a> and we’ll work to get it fixed.</p>\n\n<h2 id=\"how-can-i-contribute\">How can I contribute?</h2>\n\n<p>Every page that allows contribution has an obvious “Edit in Github” link at the top. This link will you take you to the md file. Feel free to make changes and create a PR from your branch. The NuGet team will review the change and work with you to get it merged.</p>\n\n<p>If you would like to raise a request for new docs or changes to existing docs, feel free to <a href=\"https://github.com/NuGet/Home/issues\">open a new issue</a>.</p>\n\n<h2 id=\"whats-next\">What’s next?</h2>\n\n<p>Over the next few weeks, we will continue to make more improvements to the docs with respect to content and organization. In addition, we are considering starting our docs migration into docs.microsoft.com in the coming months. Since NuGet is an integral part of the .NET Ecosystem, this move will make it easier to find and navigate our documentation. Moreover, we’ll have a consistent way to get feedback and enable contributions to docs from our users.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like to share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/30min/\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/NuGet/Home/issues\">open an issue on GitHub</a>.</p>\n\n","Href":"http://blog.nuget.org/20160920/NuGet-Docs-GoLive.html","RawContent":null},{"Title":"Changes to Expiring API Keys","PublishedOn":"2016-08-25T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In June, we published a blog post announcing <a href=\"http://blog.nuget.org/20160622/NuGet-API-key-expiration.html\">Expiring API Keys</a>. We received a lot of great feedback from the community about it.  In retrospect, we did not do a great job explaining the motivation and reasoning for this security measure to the community.</p>\n\n<p>This post goes into more detail about why we introduced Expiring API Keys, the immediate changes we are making to the design to address feedback, and improvements to our process to prevent a similar situation from happening in the future.</p>\n\n<h2 id=\"your-feedback\">Your Feedback</h2>\n\n<p>Let’s start with a summary of the most consistent feedback we heard from the initial plan:</p>\n\n<ul>\n  <li>Without automated renewal mechanisms, this feature would break CI builds and automation.</li>\n  <li>Large organizations, such as Serilog which has over 60 repos, would find it difficult to co-ordinate and ingest Expiring API Keys because their projects use a variety of CI and build systems.</li>\n  <li>Some packages are updated infrequently (only 3-4 times a year.) A 90-day expiration would cause them to have to renew the key each and every time they update.</li>\n  <li>Parallels with other systems were drawn (GitHub, Lets Encrypt, NPM, etc.) to point out that they were not imposing such measures in the name of security and if they did, they had auto-renewal mechanisms in place to address CI scenarios.</li>\n  <li>This introduces additional friction which is unnecessary for my scenario.</li>\n</ul>\n\n<p>Thanks for this great feedback. It caused us to press “pause” on our efforts and re-think the problem of leaked API keys and the plan for it.</p>\n\n<h2 id=\"why-expiring-api-keys\">Why Expiring API Keys?</h2>\n\n<p>Over the past few years, you have probably read stories about accounts being hacked on various online sites. Almost everyone has received a notification that you need to change your password on a site. Online security is a real challenge. API keys and username/passwords are not the same, but they do have a lot of similarities and have a shared set of risks on leaks and theft.</p>\n\n<p>This change was envisioned to solve 2 problems that we have today in NuGet.org.</p>\n\n<h3 id=\"leaked-keys\">Leaked Keys</h3>\n\n<p>Leaked keys are a security hole like any another leaked credential. If a developer of a popular package has their API key stored on their box, CI machines or personal accounts and their systems or accounts gets compromised, it would be trivial for the attacker to take advantage of this leak and publish malicious content by updating a popular package. While some key leaks are exploited immediately, some attackers hold on to keys until the circumstances are in their favor to exploit it for the maximum gain.</p>\n\n<h3 id=\"stale-keys\">Stale Keys</h3>\n\n<p>The NuGet ecosystem is about 5 years old now. There are many NuGet.org API keys that have not been used for greater than a year and a smaller set that have never been used to push packages. Many of the accounts tied to these keys could be dormant and might be unmonitored by the original account owners.</p>\n\n<p>If any of these dormant accounts or API keys are compromised, attackers can push updates to existing packages or create new packages that contain malicious content from these accounts.</p>\n\n<p>Rotating credentials after a set time period is a proven way to minimize this threat if not completely neutralize it. An example of this would be rotating passwords for users and service accounts in enterprises.</p>\n\n<h2 id=\"immediate-changes-to-the-feature-based-on-your-feedback\">Immediate changes to the feature based on your feedback</h2>\n\n<ul>\n  <li>Starting today, existing API keys that are used at least once each year will never expire. This approach enables the most active package maintainers to effectively opt-out of API key expiration. You can set expiry between 1 day and a year when you create or renew an API key.</li>\n  <li>We will expire all API keys that have been unused for a year immediately. This change will prevent dormant and unmonitored accounts from publishing malicious packages.</li>\n</ul>\n\n<h2 id=\"whats-coming-next\">What’s coming next?</h2>\n<p>While the plan above addresses some of the feedback that we got from the community and some of our goals in the short term, it does not address all the feedback.</p>\n\n<p>We are working on incorporating more pieces of feedback that like auto renewal mechanisms and multiple API keys. We will publish a blog post in the next month or so detailing our proposed design.</p>\n\n<h2 id=\"how-are-we-changing-rollout-of-security-features\">How are we changing rollout of security features?</h2>\n<p>In hindsight, given the scope of the feature and the impact to the ecosystem, we should have started by having the discussion with the community before rolling this out.</p>\n\n<p>Some security related features and changes cannot be disclosed in advance to protect operational security and minimize the chances of an attack. But there are others like Expiring API keys, that can be shared to get feedback before rolling it out to NuGet.org. We promise to do better in this regard in the future.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n<p>If you have more specific feedback on this topic, we have a GitHub issue open <a href=\"https://github.com/NuGet/NuGetGallery/issues/3092\">here</a> where we can continue the discussion.</p>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like to send us an email, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.\nYou can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home/issues\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160825/Changes-to-Expiring-API-Keys.html","RawContent":null},{"Title":"The path towards better documentation","PublishedOn":"2016-08-22T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><strong>Update 9/20 (11:00 A.M PST): The revamped NuGet Docs experience is now live on <a href=\"https://docs.nuget.org\">docs.nuget.org</a>. Read more about it here - <a href=\"http://blog.nuget.org/20160920/NuGet-Docs-GoLive.html\">New experience for NuGet Documentation</a></strong></p>\n\n<p><a href=\"https://docs.nuget.org\">docs.nuget.org</a> is the authoritative guide on everything NuGet. It is used as reference by nearly 180k developers with over 500k page views a month. Summary of the most consistent feedback we heard is given below:</p>\n\n<ol>\n  <li>The grouping is not intuitive and makes it difficult to find the right document.</li>\n  <li>Figuring out the end to end steps to build packages for new platforms is hard.</li>\n  <li>Lack of indexing and cross referencing makes it difficult navigate between samples, reference docs and release notes.</li>\n  <li>Some items only appear in release notes and blogs, but do not appear in the final docs.</li>\n</ol>\n\n<p>In this post, we are going to talk about the changes we recently made based on your feedback, and plans going forward.</p>\n\n<p>Before diving into details, we would like to thank a number of people who have helped us review and give feedback on these changes or inspired us to write new guides. Some of them have written a number of blog posts and tools that has significantly helped the community in understanding various package authoring techniques, NuGet concepts and APIs. There are many more who provided feedback through issues, tweets and other channels.</p>\n\n<ul>\n  <li><a href=\"https://oren.codes/\">Oren Novotny</a> (@onovotny)</li>\n  <li><a href=\"http://daveaglick.com/\">Dave Glick</a> (@daveaglick)</li>\n  <li><a href=\"http://paulbetts.org/\">Paul Betts</a> (@xpaulbettsx)</li>\n  <li><a href=\"http://ryandavis.io/\">Ryan Davis</a> (@rdavis_au)</li>\n  <li><a href=\"https://nblumhardt.com/\">Nicholas Blumhardt</a> (@nblumhardt)</li>\n  <li><a href=\"http://blog.stephencleary.com/\">Stephen Cleary</a> (@aSteveCleary)</li>\n</ul>\n\n<h2 id=\"what-did-we-change\">What did we change?</h2>\n\n<p>We have revamped the NuGet docs experience and we have a preview for you to try out. <a href=\"https://docspreview.nuget.org\">NuGet Docs Preview</a> addresses the majority of feedback from the community. Just to be clear, we are not replacing <a href=\"https://docs.nuget.org\">docs.nuget.org</a> just yet.</p>\n\n<p>We have made several improvements including:</p>\n\n<ol>\n  <li>New quick-starts for creating and consuming packages.</li>\n  <li>End to end guides for new platforms such as .NET Standard and UWP.</li>\n  <li>A simpler and more intuitive organization of topics.</li>\n  <li>Left pane of contents serves as an index and allows you to glance at all topics.</li>\n  <li>Cross-references with links to recommended reading, related topics and reference docs.</li>\n  <li>And finally, a modern look and feel to the docs site.</li>\n</ol>\n\n<p><img src=\"/images/2016-08-10-Starting-down-the-path-towards-better-documentation/nuget_docs_website.PNG\" alt=\"new nuget docs landing page\" /></p>\n\n<h2 id=\"how-are-the-new-docs-organized\">How are the new docs organized?</h2>\n\n<ol>\n  <li>Quickstarts -  These are very basic guides for both authors and consumers to get started</li>\n  <li>Guides - The idea here is to give you everything you need to know to execute a scenario end to end. Some of the key guides we have built are:\n    <ul>\n      <li><a href=\"https://docspreview.nuget.org/ndocs/guides/install-nuget\">Installing NuGet</a></li>\n      <li><a href=\"https://docspreview.nuget.org/ndocs/guides/build-for-uwp\">Creating a UWPpackage</a></li>\n      <li><a href=\"https://docspreview.nuget.org/ndocs/guides/build-for-net%20standard\">Creating a .NET Standard package</a></li>\n      <li><a href=\"https://docspreview.nuget.org/ndocs/guides/create-cross-platform-packages\">Creating a Bait and switch package</a></li>\n    </ul>\n  </li>\n  <li>Creating, Consuming and Hosting packages</li>\n  <li>Tools, Schema, API and Visual Studio Extensibility - Reference documentation</li>\n  <li>Policies - FAQs, Governance, and the policy around Dispute resolution and Deleting packages</li>\n  <li>Contribute guidance has been moved to the <a href=\"https://github.com/NuGet/Home/wiki/Contribute-to-NuGet\">Nuget/Home wiki on Github</a></li>\n</ol>\n\n<h2 id=\"will-my-existing-references-break\">Will my existing references break?</h2>\n\n<p>No, existing references will not break. When we update <a href=\"https://docs.nuget.org\">docs.nuget.org</a>, we’ll have permanent redirects in place that will redirect you to the new page.</p>\n\n<h2 id=\"how-can-i-contribute\">How can I Contribute?</h2>\n\n<p>We made the contribution link a lot more obvious. Every page that allows contribution has a “Edit in Github” link right at the top. This link will you take you to the md file. Feel free to make changes and create a PR from your branch. The NuGet team will review the change and work with you to get it in.</p>\n\n<p><img src=\"/images/2016-08-10-Starting-down-the-path-towards-better-documentation/edit_in_github.PNG\" alt=\"edit in github\" /></p>\n\n<p>If you would like to raise a request for new docs or changes to existing docs, feel free to <a href=\"https://github.com/NuGet/Home/issues\">open a new issue</a>.</p>\n\n<h2 id=\"what-are-we-going-to-do-moving-forward\">What are we going to do moving forward?</h2>\n<p>With the advent of .NET Core, the NuGet community is growing by leaps and bounds. We understand that we have to lower the barrier to entry to make it easy for authors to create packages and for users to consume them. The first step there is to have fantastic documentation in place that enables this.</p>\n\n<p>Over the next two weeks, we’ll closely look at any feedback on <a href=\"https://docspreview.nuget.org\">NuGet Docs Preview</a> and iron out any wrinkles before updating the old site <a href=\"https://docs.nuget.org\">(docs.nuget.org)</a>.</p>\n\n<p>In the coming quarter, we are looking into starting our docs migration into docs.microsoft.com similar to <a href=\"https://docs.microsoft.com/en-us/dotnet/articles/core/index\">.NET Core documentation</a>. Since NuGet and .NET are tied at the hip for the majority of its use cases, it’ll make it easier for our users to find and reference docs. In addition, we’ll have a consistent way to get feedback and enable contributions to docs from our users.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/NuGet/Home/issues\">open an issue on GitHub</a>.</p>\n\n","Href":"http://blog.nuget.org/20160822/Starting-down-the-path-towards-better-documentation.html","RawContent":null},{"Title":"Announcing NuGet 3.5 RC","PublishedOn":"2016-08-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>NuGet 3.5 RC for Visual Studio 2015 and nuget.exe provide quality improvements, performance improvements, features and new target frameworks like netstandard and netcoreapp.</p>\n\n<h2 id=\"downloads\">Downloads</h2>\n\n<p>All NuGet downloads are available on <a href=\"http://nuget.org/downloads\">http://nuget.org/downloads</a>.</p>\n\n<ul>\n  <li>\n    <p><a href=\"http://nuget.org/downloads\">3.5 RC of nuget.exe</a></p>\n  </li>\n  <li>\n    <p>3.5 RC is available through the following channels.</p>\n    <ul>\n      <li><a href=\"http://blog.nuget.org/20160502/Introducing-The-NuGet-Beta-Channel.html\">NuGet Beta Channel</a></li>\n      <li><a href=\"http://nuget.org/downloads\">3.5 RC direct download</a>.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"new-features\">New Features</h2>\n\n<h3 id=\"support-for-new-target-frameworks\">Support for new Target Frameworks</h3>\n\n<p>.NET Standard and Net Core App TFM support is now available in 3.5 RC and supports netstandard1.6 TFM for Visual Studio 2015 users. <a href=\"https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md\">.NET Standard</a> provides a more concrete guarantee of binary portability to future .NET-capable platforms with an easier-to-understand platform versioning plan.</p>\n\n<h3 id=\"packagetype\">PackageType</h3>\n<p>We have started to lay the groundwork to support a new PackageType property in the nuspec. This property allows package authors to classify their packages (E.g Dependencies, Tools etc..). More information on this is available in the PackageType spec <a href=\"https://github.com/NuGet/Home/wiki/Package-Type\">here</a>.</p>\n\n<h3 id=\"minclientversion-support-in-projectjson\">MinClientVersion support in project.json</h3>\n\n<p>Project.json now supports <a href=\"https://docs.nuget.org/create/nuspec-reference\">MinClientVersion</a>. Packages.config scenarios allowed a package to define a required min version of client it can work with. This now works in project.json scenarios as well. You can now version packages that depend on newer NuGet versions so that you can prevent users from running into issues while trying to install packages using older versions of NuGet.</p>\n\n<h3 id=\"performance-improvements\">Performance Improvements</h3>\n\n<p>The key scenarios we have improved are Restore, Package Manager Console Load and Update performance.</p>\n\n<ul>\n  <li>\n    <p>Restore times in portable apps deployed through <a href=\"https://github.com/projectkudu/kudu/wiki\">Kudu</a> have reduced from over 15 secs to 3 secs.</p>\n  </li>\n  <li>\n    <p>Package Manager Console Load in large solutions are now much faster. In one of our sample projects it reduced from over 132s to 10s.</p>\n  </li>\n  <li>\n    <p>Package Updates in Visual Studio with ReSharper installed has been significantly improved. In our tests we have seen it drop from over 140 secs to 68 secs. We working together with the resharper team on further improvements that require code changes on both sides.</p>\n  </li>\n</ul>\n\n<h2 id=\"release-notes\">Release Notes</h2>\n\n<p><a href=\"https://docs.nuget.org/release-notes/nuget-3.5-RC\">3.5 RC</a></p>\n\n<h2 id=\"issues-list\">Issues List</h2>\n\n<p><a href=\"https://github.com/Nuget/home/issues?q=is%3Aissue+milestone%3A%223.5+RC%22+is%3Aclosed\">3.5 RC</a></p>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>The team is now shifting gears into transitioning .NET CLI from project.json into MSBuild and and further investments in performance and quality of the product.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160811/Announcing-NuGet-3.5-RC.html","RawContent":null},{"Title":"Announcing NuGet 3.5  Beta 2 and 2.12 RTM","PublishedOn":"2016-06-27T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>NuGet 3.5 Beta 2 for Visual Studio 2015, nuget.exe and NuGet 2.12 RTM for Visual Studio 2013 releases provide quality improvements, performance improvements, .NET Core CLI support, and new target frameworks like netstandard and netcoreapp for our users.</p>\n\n<h2 id=\"downloads\">Downloads</h2>\n\n<p>All NuGet downloads are available on <a href=\"http://nuget.org/downloads\">http://nuget.org/downloads</a>.</p>\n\n<ul>\n  <li>\n    <p>2.12 RTM version of the Visual Studio 2013 will be available via <em>Tools -&gt; Extensions and Updates</em></p>\n  </li>\n  <li>\n    <p><a href=\"http://nuget.org/downloads\">3.5 Beta 2 of nuget.exe</a></p>\n  </li>\n  <li>3.5 Beta 2 is available through the following channels.\n    <ul>\n      <li><a href=\"http://blog.nuget.org/20160502/Introducing-The-NuGet-Beta-Channel.html\">NuGet Beta Channel</a></li>\n      <li><a href=\"http://nuget.org/downloads\">3.5 Beta 2 direct download</a>.</li>\n      <li>Integrated with <a href=\"https://visualstudiogallery.msdn.microsoft.com/c94a02e9-f2e9-4bad-a952-a63a967e3935\">Microsoft ASP.NET and Web Tools Preview 2</a></li>\n    </ul>\n  </li>\n  <li>The <a href=\"http://dot.net\">.NET CLI 3.5 Beta 2</a> dotnet restore command also has been updated to this version.</li>\n</ul>\n\n<h2 id=\"new-features\">New Features</h2>\n\n<h3 id=\"support-for-new-target-frameworks\">Support for new Target Frameworks</h3>\n\n<p>.NET Standard and Net Core App TFM support is now available for Visual Studio 2012 users via the 2.12 release.  3.5 Beta 2 also now supports netstandard1.6 TFM for Visual Studio 2015 users. <a href=\"https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md\">.NET Standard</a> provides a more concrete guarantee of binary portability to future .NET-capable platforms with an easier-to-understand platform versioning plan.</p>\n\n<h3 id=\"packagetype\">PackageType</h3>\n\n<p>We have started to lay the groundwork for the support for a new PackageType property in nuspec which enables package authors to classify their packages (E.g Dependencies, Tools etc..). More information on this is available in the PackageType spec <a href=\"https://github.com/NuGet/Home/wiki/Package-Type\">here</a>.</p>\n\n<h3 id=\"minclientversion-support-in-projectjson\">MinClientVersion support in project.json</h3>\n\n<p>Project.json now supports <a href=\"https://docs.nuget.org/create/nuspec-reference\">MinClientVersion</a>. You can now version packages that depend on newer NuGet versions so that you can prevent users from running into issues while trying to install packages using older versions of NuGet.</p>\n\n<h2 id=\"release-notes\">Release Notes</h2>\n\n<p><a href=\"https://docs.nuget.org/release-notes/nuget-3.5-beta2\">3.5 Beta 2</a></p>\n\n<p><a href=\"https://docs.nuget.org/release-notes/nuget-2.12\">2.12 RTM</a></p>\n\n<h2 id=\"issues-list\">Issues List</h2>\n\n<p><a href=\"https://github.com/Nuget/Home/issues?q=is%3Aissue+milestone%3A%223.5+Beta2%22+is%3Aclosed\">3.5 Beta 2</a></p>\n\n<p><a href=\"https://github.com/NuGet/Home/issues?q=is%3Aissue+milestone%3A2.12+is%3Aclosed\">2.12 RTM</a></p>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>The team is now shifting gears into transitioning .NET CLI from project.json into MSBuild and investing in performance and quality of the product.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160627/Announcing-NuGet-3.5-Beta-2-and-2.12-RTM.html","RawContent":null},{"Title":"NuGet API key expiration","PublishedOn":"2016-06-22T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><strong>Update 6/22 (2:15 P.M PST): We have  a lot of feedback coming in from the community on this topic. This change <em>will not have any impact for another 90 days at the minimum</em>. We are reviewing your feedback and will discuss further how to achieve our goal of improved security of NuGet.org.  We will have an update within the next 45 days. To continue the dicussion, we have openend a new GitHub issue <a href=\"https://github.com/NuGet/NuGetGallery/issues/3092\">here</a>.</strong></p>\n\n<p><strong>EDIT</strong> - Updates on this feature is available here - <a href=\"http://blog.nuget.org/20160825/Changes-to-Expiring-API-Keys.html\">Changes to Expiring API Keys</a></p>\n\n<p>NuGet.org is growing blazingly fast. The past couple of years have seen a tremendous growth in the usage of packages from the NuGet gallery. It’s important to us and the community that package consumers are able to trust and use the packages that are uploaded to NuGet.org. Making your API key on NuGet.org more secure is one more step in that direction.</p>\n\n<p>When publishing packages to <a href=\"https://www.nuget.org\">NuGet.org</a> from the command line, for example using <code class=\"highlighter-rouge\">nuget.exe</code>, you need an API key so that we can authenticate the publish operation on the server side. Starting today, this API key will have to be refreshed at least every 90 days. We are introducing API key expiration as a means to keep your API key on NuGet.org shorter-lived.</p>\n\n<h2 id=\"what-does-this-mean-for-me\">What does this mean for me?</h2>\n\n<p>Today, no action is required. To avoid a big rush when the API keys first expire, we have set the expiration for your current API key to a value between 90 and 110 days.</p>\n\n<p>When the API key expires, it can no longer be used for publishing packages to NuGet.org. At this point, your API key will have to be regenerated from your <a href=\"https://www.nuget.org/account\">account page</a>.</p>\n\n<h2 id=\"how-do-i-know-when-my-api-key-expires\">How do I know when my API key expires?</h2>\n\n<p>From <a href=\"https://www.nuget.org/account\">your account</a>, you can consult the date and time when your current API key will expire. When approaching the expiration date, we will send one e-mail informing you about the fact your API key is about to expire.</p>\n\n<p><img src=\"/images/2016-06-22-NuGet-API-key-expiration/account-page.png\" alt=\"NuGet account page - credentials section\" /></p>\n\n<p>We are also working on an update of the NuGet command line to display a warning when your API key is about to expire:</p>\n\n<p><img src=\"/images/2016-06-22-NuGet-API-key-expiration/api-key-about-to-expire.png\" alt=\"NuGet client warning when API key is about to expire\" /></p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160622/NuGet-API-key-expiration.html","RawContent":null},{"Title":"Consolidated REST API deployed","PublishedOn":"2016-05-19T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>A few weeks back, we deployed our consolidated REST API powering NuGet.org and the NuGet client experience in Visual Studio. An invisible change for our users, but a big change for the NuGet team. This consolidated REST API lays the foundation of our future work on the server side of NuGet. In this post, we want to expand a little on the history of the NuGet services and why it matters for us.</p>\n\n<h2 id=\"history-of-our-internal-rest-api\">History of our internal REST API</h2>\n\n<p>Historically, <a href=\"https://www.nuget.org\">NuGet.org</a> used to serve all requests for packages directly from our database. With the number of NuGet users increasing, the number of queries on our database also increased. Around two years ago, the NuGet team built an internal REST API for use by our own services. It would provide package metadata, provide search results, handle download counts and all that - with great results: the database got some breathing room.</p>\n\n<p>For the <a href=\"http://blog.nuget.org/20150223/nuget-3.0-beta.html\">beta release of the NuGet 3.0 client</a>, we faced a difficult decision: should we expose this REST API to the public, or build a new one? We decided to build a new, public REST API that would be used by our future NuGet clients. This decision was made because of several reasons. First, we wanted to move on from our OData API that was used in previous NuGet clients. Second, the REST API we had in place was very opinionated and tailored to our own services and not well suited for public access by our users.</p>\n\n<p>So we ended up with an internal and an external REST API. When new features were being added in NuGet 3.0 and beyond, we had to implement them in all of our API’s - resulting in a lot of duplicate work. Both API’s had their own caching layer, which proved quite the challenge in keeping data in sync.</p>\n\n<h2 id=\"what-we-did\">What we did</h2>\n\n<p>A few months ago, we set on an adventure of merging both REST API codebases and refactoring them to use the same caching layer. We cleaned up a lot of redundant code paths and optimized the caching layer. While not the scope of this effort, we also introduced a few minor improvements to several features - for example, we now recognize several commonly used acronyms like “EF” (Entity Framework) or “UWP” (Universal Windows Platform) in our search engine.</p>\n\n<p>We fixed several tokenization bugs and differences between the two services. A large test suite for search was added as well, boosting our confidence in future changes and investment in the search engine.</p>\n\n<p>Some improvements were introduced to the search results, like boosting on exact match to package id. A new logarithmic scale for download counts ranks packages with a high number of downloads <em>slightly</em> better - an algorithm which we will be tweaking further.</p>\n\n<p>A lot of work has been done on performance. We profiled the API during load tests to optimize code paths and reduce the API’s memory traffic and garbage collector pauses. One notable improvement is the cold start of the application, which is down to a minute as opposed to the original 7 minutes.</p>\n\n<p>Every few weeks we had a “flighting” moment where we would deploy our changes to a production-like environment, serving production traffic. This allowed us to benchmark the consolidated REST API and verify its responses.</p>\n\n<p>This week, we deployed this consolidated REST API. And nobody noticed - the very nature of this sort of change. We are really excited about it. Reduced maintenance is a benefit we’re really happy with. The refactored code base also lays the foundation for future work on our REST API.</p>\n\n<h2 id=\"whats-next\">What’s next?</h2>\n\n<p>The consolidated REST API, much like our <a href=\"http://blog.nuget.org/20160216/Switching-from-WCF-OData-to-Web-API.html\">switch from WCF OData to Web API OData</a>, is a project to reduce maintenance and improve the foundation on which the NuGet services are built, for today and tomorrow. We are also working towards documenting the API.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160519/Consolidated-REST-API-deployed.html","RawContent":null},{"Title":"The 1st Billion","PublishedOn":"2016-05-10T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today, <a href=\"https://nuget.org\">NuGet.org</a> reached one billion downloads. This is a momentous achievement for our users and the community of package authors who continue to use and build new libraries that is the cornerstone of .NET adoption. We want to take this opportunity to give a huge thank you to the millions of our users who made this milestone possible. With the advent of .NET Core, ASP.NET Core, Universal Windows Apps, open sourcing of the Xamarin Platform, and the accelerated use of NuGet, we believe we will hit the next 1 billion in a year or so.</p>\n\n<h2 id=\"journey-to-1-billion\">Journey to 1 Billion</h2>\n\n<p>NuGet started out as the NuPack project which was then <a href=\"http://haacked.com/archive/2010/10/29/nupack-is-now-nuget.aspx/\">renamed</a> to NuGet and accepted into the ASP.NET Open Source Gallery by the <a href=\"http://www.outercurve.org/\">OuterCurve foundation</a>. This was one of the first forays by Microsoft into Open Source development and we are proud of that heritage. For a taste of nostalgia, here are some of the very first posts around the NuGet project: <a href=\"http://weblogs.asp.net/scottgu/announcing-nupack-asp-net-mvc-3-beta-and-webmatrix-beta-2\">Scott Guthrie</a>, <a href=\"http://haacked.com/archive/2010/10/06/introducing-nupack-package-manager.aspx/\">Phil Haack</a>, <a href=\"http://www.hanselman.com/blog/IntroducingNuGetPackageManagementForNETAnotherPieceOfTheWebStack.aspx\">Scott Hanselman</a> and <a href=\"http://www.zdnet.com/article/microsoft-contributes-new-open-source-package-management-system-to-outercurve-foundation/\">Mary J Foley</a></p>\n\n<p>Here are some fun stats around our growth over the last 6 years. Data from the past 6 weeks or so across some of these dimensions are available in our <a href=\"https://www.nuget.org/stats\">statistics</a> page in NuGet.org.</p>\n\n<h2 id=\"package-downloads\">Package Downloads</h2>\n\n<p>Downloads in NuGet.org grew almost 80% this year. From an all time download count of 50 million in 2013, we now average around <strong>72 million downloads per month</strong> in 2016. NuGet from a day 1 was built with caching in mind and we have seen significant usage of NuGet via <a href=\"https://docs.nuget.org/create/hosting-your-own-nuget-feeds\">NuGet Server</a>, <a href=\"https://www.visualstudio.com/en-us/get-started/package/what-is-packaging\">VSTS Package Management</a>, <a href=\"https://www.myget.org/\">myget</a>, <a href=\"http://inedo.com/proget\">ProGet</a>, <a href=\"http://www.sonatype.org/nexus/\">Nexus</a>, <a href=\"https://www.jfrog.com/artifactory/\">Artifactory</a> and other third party services. These download numbers purely represent downloads from NuGet.org. We suspect the actual downloads of NuGet packages to be a much higher number.</p>\n\n<p>If you were curious which was the billion’th package that was downloaded. The magic number was taken by the <a href=\"https://www.nuget.org/packages/dnx-clr-win-x86/1.0.0-rc1-update2\">dnx-clr-win-x86</a> package, which was downloaded at around 3:15 a.m (PST) on 5/10/2016.</p>\n\n<h2 id=\"package-uploads\">Package Uploads</h2>\n\n<p>We have over 54K unique packages in NuGet.org and over 600K packages in total. Year over year we are seeing around 31% growth in the number of packages being uploaded to NuGet.org.</p>\n\n<p><img src=\"/images/2016-05-11-The-Ist-Billion/PackageUploads.png\" alt=\"Package Uploads\" /></p>\n\n<h2 id=\"tools-usage\">Tools Usage</h2>\n\n<p>This visualization shows the average count of requests from NuGet v3 client, the Windows x86 Command line and the .NET CLI NuGet Client over the last 2 weeks to NuGet.org endpoints. As you can see, there is huge interest in .NET Cross platform tools and we believe this is going to be a significant part of our tools traffic going forward.</p>\n\n<p><img src=\"/images/2016-05-11-The-Ist-Billion/ClientUsage.png\" alt=\"Tools Usage\" /></p>\n\n<h2 id=\"nugetorg\">NuGet.org</h2>\n\n<p>We now have around 600K users visiting NuGet.org on a monthly basis to search and peruse our packages. We are making investments in improving search and package information in the near future to make user engagement much more meaningful on the website.</p>\n\n<p><img src=\"/images/2016-05-11-The-Ist-Billion/SiteUsage.png\" alt=\"Site Usage\" /></p>\n\n<h2 id=\"community\">Community</h2>\n\n<p>An Open Source project thrives and survives on the patronage of its users. Even from the very early days, we have had significant contributions from the community. <a href=\"http://haacked.com/archive/2011/04/29/nuget-contributors.aspx/\">3 out of the top ten contributors</a> in the initial days  were individuals from the community. Fast forwarding to today, we have over 130 contributors on GitHub across <a href=\"https://github.com/NuGet/NuGet.Client\">NuGet.Client</a> and <a href=\"https://github.com/NuGet/NuGetGallery\">NuGetGallery</a>. While a number of these folks are MSFT’s, there is a large number of contributions from the community as well. We are always on the lookout for folks from the community to suggest ideas, and <a href=\"https://docs.nuget.org/contribute/contributing-to-nuget\">contribute</a> features to the project.</p>\n\n<p>Among non-Microsoft packages. <a href=\"https://www.nuget.org/packages/Newtonsoft.Json/\">Json.net</a> authored by our friend <a href=\"https://twitter.com/JamesNK\">James Newton-King</a>  reigns supreme with over 28 million downloads. Our most prolific author/owner with the largest number of  packages at this time is <a href=\"https://www.nuget.org/profiles/DefinitelyTyped\">Definitely Typed</a> which curates high quality <a href=\"http://www.typescriptlang.org/\">TypeScript</a> definitions with over 1,779 packages.</p>\n\n<p>We cannot reiterate enough how much our community means to us and we want to continue to partner with you all to innovate and push the boundaries of package management with NuGet.</p>\n\n<h2 id=\"why-you-should-be-using-nuget\">Why you should be using NuGet</h2>\n\n<p>There is a lot of innovation happening in the community around .NET which enables you to develop software faster than ever. NuGet is the most widely adopted system across the community for consuming shared components and is the primarily channel for showcasing this innovation. One of the big goals for us is to optimize developer productivity, reduce redundancy and promote code-reuse. Using NuGet Packages is one the most optimal ways to do this. We are here to help you succeed in adopting NuGet and if you would like to  talk to us about how NuGet can help you achieve these goals, do not hesitate to reach out to us at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a> or holler at us on Twitter <a href=\"https://twitter.com/nuget\">@nuget</a>.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly</a> link  to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.\nYou can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n\n","Href":"http://blog.nuget.org/20160510/The-1st-Billion.1.html","RawContent":null},{"Title":"Introducing The NuGet Beta Channel","PublishedOn":"2016-05-02T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today, we would like to introduce you to the NuGet Beta Channel for the Visual Studio 2015 NuGet Package Manager. In the last 2 months, we have been focusing on improving the quality of the package management experience in Visual Studio 2015 and we have released over 3 consecutive versions of the package manager with added features, improved quality and performance. We want to able to accelerate this cadence and make sure that our customers are able to access new features and bug fixes faster.</p>\n\n<p>We have been trying to accelerate our releases, but we realized that even when we share beta bits, it takes too much effort to discover them, and we end up getting bug reports only after we release the RTM version. We would like to reach interested users with our beta releases for feedback. This way we can simultaneously share improvements faster, and at the same time impact a smaller ring of users if we end up regressing a scenario.</p>\n\n<h2 id=\"who-is-this-for\">Who is this for?</h2>\n\n<p>The beta channel is recommended for the following users: -</p>\n\n<ul>\n  <li>You like to stay on the latest and greatest.</li>\n  <li>You want to try out new features.</li>\n  <li>You are experiencing a blocking issue and want to get access to the build with the fix before it hits RTM.</li>\n</ul>\n\n<p>We also hope that you use this opportunity to give us feedback on the quality of the release. If you run into any issues whatsoever, feel free to <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n\n<h2 id=\"what-goes-into-making-a-beta-build\">What goes into making a Beta build?</h2>\n\n<p>Beta fixes go through a decent amount of dedicated validation and dog-fooding by the team and our partners. Even though it’s called a beta, we will only release near RTM quality builds into this channel. We want to use the extra runway on our end to make sure that we incorporate any feedback that we might get from the users of the channel and catch any blocking issues early on.</p>\n\n<h2 id=\"how-do-i-get-access-to-the-beta-feed\">How do I get access to the Beta Feed?</h2>\n<p>You can get access to the Beta builds by the following the steps outlined below. We have published the 3.4.4 RC build fixing these <a href=\"https://github.com/Nuget/Home/issues?q=is%3Aissue+milestone%3A3.4.4+is%3Aclosed\">issues</a> to this channel today.</p>\n\n<ul>\n  <li>Add the Beta Feed: https://dotnet.myget.org/F/nuget-beta/vsix/ to the Additional Extension Galleries list in Tools-&gt;Options-&gt;Environment-&gt;Extensions and Updates.</li>\n</ul>\n\n<p><img src=\"/images/2016-05-02-Introducing-The-NuGet-Beta-Channel/ToolsSettings.png\" alt=\"Extensions and Updates Settings\" /></p>\n\n<ul>\n  <li>Navigate to Tools-&gt;Extensions and Updates and select Online. You should now be able to see the NuGet-Beta Feed there. Install the NuGet Package Manager Extension.</li>\n</ul>\n\n<p><img src=\"/images/2016-05-02-Introducing-The-NuGet-Beta-Channel/ExtensionUpdate.png\" alt=\"Extensions and Updates\" /></p>\n\n<ul>\n  <li>You are all set to get beta releases! Remember if you run into any issues while dogfooding the beta build or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</li>\n</ul>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs of our community. If you would like share your pain points and your current and future needs, use the <a href=\"https://calendly.com/harikm/nuget-feedback\">calendly link</a> to set up a quick 15-30 min call with us. If you would like to send us an email instead, hit us up at <a href=\"mailto:feedback@nuget.org\">feedback@nuget.org</a>.</p>\n\n<p>You can also leave a comment below, and as always, if you run into any issues or have an idea, <a href=\"https://github.com/Nuget/Home\">open an issue on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160502/Introducing-The-NuGet-Beta-Channel.html","RawContent":null},{"Title":"Announcing NuGet 3.4.3","PublishedOn":"2016-04-22T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today, we are releasing the 3.4.3 RTM version of the NuGet Visual Studio 2015 extension and the Windows x86 commandline executable. We continue to heavily invest in improving the quality of NuGet scenarios in Visual Studio and commandline. The complete list of issues fixed in this version is <a href=\"https://github.com/NuGet/Home/issues?q=is%3Aissue+milestone%3A3.4.3+is%3Aclosed\">available on GitHub</a>.  In this post, we will review the important changes in 3.4.3 release.</p>\n\n<p>You can download the latest 3.4.3 RTM VS extension and Windows x86 Commandline from <a href=\"https://dist.nuget.org/index.html\">here</a>.</p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<ul>\n  <li>Fixed some authorization issues with password protected private nuget feeds.</li>\n  <li>Fixed an issue around being unable to restore PCL’s from project.json with runtimes specified.</li>\n  <li>Some customers were running into intermittent failures when installing packages. This has now been fixed in this release.</li>\n  <li>Fixed an issue that caused restore failures in C++/CLI projects with project.json.</li>\n  <li>Some packages (E.g ModernHttpClient) where not being unzipped correctly when you use nuget in mono. This has now been fixed in this release.</li>\n</ul>\n\n<p>Our <a href=\"http://docs.nuget.org/release-notes/nuget-3.4.3\">release notes for 3.4.3</a> and the <a href=\"https://github.com/NuGet/Home/issues?q=is%3Aissue+milestone%3A3.4.3+is%3Aclosed\">issues list in GitHub</a>, goes into more details around the changes in this release.</p>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>Along with improving the overall quality and performance of the product, the team is cleaning up any remaining issues from the cross-platform support in conjunction with the .NET Command-Line-Interface release.  There are new features we want to implement around project.json capabilities, and improvements to NuGet.org service that enable a smoother publication process for package authors. Stay tuned for a more detailed update of our roadmap in the next month or so.</p>\n\n<h2 id=\"we-want-to-hear-your-feedback\">We want to hear your feedback!</h2>\n\n<p>We want NuGet to meet the evolving needs for community and provide an amazing package management and authoring experience. In order for us to do that, we need your help!!!</p>\n\n<p>We want to talk to you to understand your pain points and needs. This is the feedback we want to use as the foundation of our future roadmap. All we need is 15-30 minutes of your time. If you are interested in providing us with feedback, here is our calendly link - https://calendly.com/harikm/nuget-feedback. Book any available time that is convenient for you to talk to us. If you would like to send us an email instead, hit me up at harikm@microsoft.com.</p>\n\n<p>Our team is super excited about engaging with our customers more deeply and we would be happy to answer any questions you might have as well. As always, if you run into any issues or have an idea, open an issue on <a href=\"https://github.com/Nuget/Home/issues\">GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160422/Anouncing-NuGet-3.4.3.html","RawContent":null},{"Title":"Announcing NuGet 3.4.2","PublishedOn":"2016-04-09T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We have listened to the feedback from the community, and we have tried our very best to turn around quickly and address this feedback. Our primary focus for 3.4.2 have been around improving the quality and performance of the product.</p>\n\n<p>The complete list of issues fixed in this version is <a href=\"https://github.com/Nuget/Home/issues?q=is%3Aissue+milestone%3A3.4.2+is%3Aclosed\">available on GitHub</a>.  In this post, we’ll review the important changes in 3.4.2 release.</p>\n\n<p>You can download the latest 3.4.2 VS extension and Windows x86 Commandline (RC) from <a href=\"https://dist.nuget.org/index.html\">here</a>.</p>\n\n<h2 id=\"performance-improvements\">Performance Improvements</h2>\n\n<ul>\n  <li>We continue to invest heavily in performance improvements. For this release, we have significantly improved the performance of updates in a specific scenario, where updates on packages with deep dependency graphs took a really long time and hung Visual Studio.</li>\n  <li>In addition to this change, we have fixed an issue where we were hitting the network twice when fetching the update count in the VS UI. This was partially responsible for some timeout issues customers experienced in 3.4/3.4.1.</li>\n  <li>Finally, nuget restore without network traffic is 2.5x – 3x faster within Visual Studio.</li>\n</ul>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>We have fixed some issues that broke compatibility in some cases with Artifactory, Klondike and Nexus. We have further improved the quality of the ‘All Sources’ feature by fixing issues with merging versions and entries from multiple sources.</p>\n\n<p>Our <a href=\"http://docs.nuget.org/release-notes/nuget-3.4.2\">release notes for 3.4.2</a> and the <a href=\"https://github.com/Nuget/Home/issues?q=is%3Aissue+milestone%3A3.4.2+is%3Aclosed\">issues list in GitHub</a>, goes into more details around the changes in this release.</p>\n\n<h2 id=\"breaking-changes\">Breaking Changes</h2>\n\n<p>If you have not specified a <a href=\"https://docs.nuget.org/consume/nuget-config-file\">DefaultPushSource in nuget.config</a>, and try to push a package without specifying the Source parameter, you will get the following error message in 3.4.2</p>\n\n<p>“Source parameter was not specified”</p>\n\n<p>We have heard feedback from package authors and seen it in the support requests that we receive on nuget.org, that having a default behavior like this causes accidental publish of proprietary software that was never meant to be consumed publically. NuGet has a huge ecosystem with multiple private and public hosts and this change enables authors to be prescriptive about their intentions around package publications.</p>\n\n<h2 id=\"known-issues-in-342-windows-x86-commandline-rc\">Known Issues in 3.4.2 Windows x86 Commandline (RC)</h2>\n\n<p>These issues will be fixed early next week before we hit RTM.</p>\n\n<ul>\n  <li>Running nuget restore on a solution will fail if the solution file is placed in a lower folder hierarchy than the project files.</li>\n  <li>Running nuget delete command on a package using the V2 feed will fail. Use V3 feed instead.</li>\n</ul>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>The team is cleaning up any remaining issues from the cross-platform support in conjunction with the .NET Command-Line-Interface release.  There are new features we want to implement around project.json capabilities, and improvements to NuGet.org service that enable a smoother publication process for package authors.</p>\n\n<p>Download the latest version of the NuGet Visual Studio extension from <a href=\"https://dist.nuget.org/index.html\">dist.nuget.org</a></p>\n\n<h2 id=\"help-us-build-our-roadmap\">Help us build our roadmap</h2>\n\n<p>We want NuGet to meet the evolving needs for community and provide an amazing package management and authoring experience. In order for us to do that, we need your help!!!</p>\n\n<p>We want to talk to you to understand your pain points and needs. This is the feedback we want to use as the foundation of our future roadmap. All we need is 15-30 minutes of your time. If you are interested in providing us with feedback, here is our calendly link - https://calendly.com/harikm/nuget-feedback. Book any available time that is convenient for you to talk to us. If you would like to send us an email instead, hit me up at harikm@microsoft.com.</p>\n\n<p>Our team is super excited about engaging with our customers more deeply and we would be happy to answer any questions you might have as well. As always, if you run into any issues or have an idea, open an issue on <a href=\"https://github.com/Nuget/Home/issues\">GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160409/Anouncing-NuGet-3.4.2.html","RawContent":null},{"Title":"NuGet 3.4 Known Issues","PublishedOn":"2016-04-05T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>After releasing the NuGet 3.4 version last week, the team quickly heard feedback around an issue that made the NuGet extension very difficult to use.  There was a bug in the code that would prevent searching and installing of packages for some users.  After some researching, the team has identified the scenario that causes this problem and has a work-around to report.</p>\n\n<p>The key to this issue is in the NuGet configuration in Visual Studio.  If you see this when you enter the Visual Studio Tools -&gt; Options menu and choose NuGet Package Manager -&gt; Package Sources</p>\n\n<center><img title=\"Symptom UI\" src=\"../images/2016-04-05-NuGet-3.4-Known-Issues/symptomUI.png\" />\n</center>\n\n<p>Our team has identified that this issue appears for developers who have never modified their personal NuGet.config file at <code class=\"highlighter-rouge\">%appdata%\\nuget\\nuget.config</code>  The install for the NuGet extension no longer inteprets default content for this file in memory.  If you had not customized your NuGet sources, the new extension would not provide this default content in memory and lead to this scenario.</p>\n\n<p>Fortunately, there is a simple work-around: delete the empty file on disk and restart Visual Studio 2015.  This will trigger the NuGet extension to save a fresh copy of the default NuGet.config file, which should be the same as the one that was removed because the qualifying scenario is that it was never modified in the first place.</p>\n\n<h2 id=\"a-fix--a-patch\">A fix?  A Patch?</h2>\n\n<p>The team has identified a handful of issues that will be addressed with a <a href=\"https://github.com/NuGet/Home/milestones/3.4.2\">patch tentatively labeled v3.4.2 on GitHub</a>.  Among these are:</p>\n\n<ul>\n  <li>NuGet clients ignore no_proxy setting</li>\n  <li>‘All sources’ aggregate package source delivers duplicate entries</li>\n  <li>‘All Sources’ delayed results are not merged with existing results</li>\n  <li>VS 2015 Update 2 package update hangs</li>\n  <li>Crash when browsing sources with incorrect icon URLs</li>\n  <li>FindPackagesById casing changes in 3.4.1 breaks Artifactory integration</li>\n</ul>\n\n<p>The team has scheduled this 3.4.2 milestone for completion on April 9, and you should see it available for download either on the 9th or shortly after that.</p>\n","Href":"http://blog.nuget.org/20160405/NuGet-3.4-Known-Issues.html","RawContent":null},{"Title":"Introducing NuGet 3.4","PublishedOn":"2016-03-30T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet team is happy to introduce version 3.4 and 3.4.1 of the NuGet clients for Visual Studio 2015.  We shipped v3.4 with Visual Studio 2015 Update 2 and immediately followed that with the 3.4.1 release to address a small set of issues that were identified after Visual Studio bundled the NuGet 3.4 release.  There were three main areas that the team focused on:</p>\n\n<ul>\n  <li>Cross-Platform support</li>\n  <li>Improved Performance in Visual Studio</li>\n  <li>Minor user-interface improvements</li>\n</ul>\n\n<p>The cross-platform support is being validated, and we plan to release command-line versions of nuget.exe in the coming weeks.</p>\n\n<p>We think you’ll find these updates a welcome change that improves your day-to-day interactions with NuGet packages.  The complete list of issues fixed in this version is <a href=\"https://github.com/NuGet/Home/issues?q=milestone%3A%223.4+RTM%22+is%3Aclosed\">available on GitHub</a>.  In this post, we’ll review the important updates in the 3.4 and 3.4.1 versions.</p>\n\n<h2 id=\"visual-studio-performance-and-all-sources\">Visual Studio Performance and All Sources</h2>\n\n<p>In the 3.4RC we previously discussed the performance improvements in the UI.  We’ve taken those performance updates and added a few more things that we know you’ll be happy to see.  Check this video for a quick tour of the new enhancements:</p>\n\n<div style=\"text-align: center; width: 100%\"><iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/W6quyUV-cxY\" frameborder=\"0\" allowfullscreen=\"\"></iframe></div>\n\n<p>That video is not edited or enhanced for speed, that is real-time search and updates performance from outside of the pristine Microsoft networks.  The package lists on the Updates tab are now sorted alphabetically and the ‘All Sources’ aggregate NuGet source are available for you to search across in the user-interface.</p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>The clients have been updated to remove some of the extra interactions that felt unnecessary.  For example:</p>\n\n<ul>\n  <li>\n    <p>Packages in project.json can have a floating version number and were updating on every build regardless of whether the package has an update available.  The client has been optimized to only check for an update and apply it when forced to restore, clean, rebuild, or after a project.json modification.</p>\n  </li>\n  <li>\n    <p>The Visual Studio extension no longer are automatically adds the nuget.org repository source to your nuget.config files when you use the NuGet configuration user interface.</p>\n  </li>\n  <li>\n    <p>Shared projects no longer have packages restored to them, nor is a lock file written for them</p>\n  </li>\n  <li>\n    <p>The latest project.json schema for DNX is supported in the Visual Studio editor and by the NuGet extension</p>\n  </li>\n</ul>\n\n<h2 id=\"breaking-change\">Breaking Change</h2>\n\n<p>We are announcing a breaking change in the way that NuGet clients handle package version numbers.  The clients will now normalize the numbers to a format of <em>major</em>.<em>minor</em>.<em>patch</em>-<em>prerelease</em>  where major, minor, and patch are all integers.  The prerelease is treated as a string and will not be modified.  This means that if you search for version 1 of a package, the NuGet client will search for version 1.0.0  Similaryly, if you search for package version 1.01.0.0 the client will search for version 1.1.0</p>\n\n<p>Full details of this change are available in the documents under <a href=\"http://docs.nuget.org/Create/Versioning#Normalized_Version_Numbers\">normalized version numbers</a>.</p>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>The team is cleaning up any remaining issues from the cross-platform migration in conjunction with the .NET Command-Line-Interface release.  There are new features we want to implement for project.json capabilities and there are NuGet.org service improvements that we want to implement to better enable the publication of a team’s collection of packages.</p>\n\n<p>Download the latest version of the NuGet Visual Studio extension from <a href=\"https://dist.nuget.org/index.html\">dist.nuget.org</a></p>\n","Href":"http://blog.nuget.org/20160330/Introducing-NuGet-3.4.html","RawContent":null},{"Title":"Announcing NuGet 3.4 RC","PublishedOn":"2016-03-08T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>After several months of measuring, tuning, and testing, the NuGet team would like to announce version 3.4 RC of the NuGet clients for Visual Studio 2015 and the command-line.  There were three main areas that the team focused on for this version:</p>\n\n<ul>\n  <li>Cross-Platform support</li>\n  <li>Improved Performance in Visual Studio</li>\n  <li>Minor user-interface improvements</li>\n</ul>\n\n<p>We think you’ll find these updates a welcome change that improves your day-to-day interactions with NuGet packages.  The complete list of issues fixed in this version is <a href=\"https://github.com/NuGet/Home/issues?q=milestone%3A%223.4+Beta%22+is%3Aclosed\">available on GitHub</a>.  In this post, we’ll review the important updates in the 3.4-RC version.</p>\n\n<h2 id=\"visual-studio-performance\">Visual Studio Performance</h2>\n\n<p>The first thing that NuGet Visual Studio users should notice when using the NuGet UI is that it loads immediately and defaults to the ‘Installed’ view of packages.  Check out the un-edited animated GIF below to see just how fast this performs on an ASP.NET MVC 5.2 project:</p>\n\n<p><img src=\"../images/2016-03-08-Announcing-NuGet-3.4-RC/speedy-start.gif\" alt=\"Speedy Start\" /></p>\n\n<p>You’ll see similar speed improvements in the Updates and Consolidate tabs, where we’ve optimized the offline storage and retrieval of package information.  One other bit of tuning that we did to this screen was to enable gzip-compressed data from the NuGet repositories. This should be a small change that we can already see has made a big improvement in search and download performance from our services.</p>\n\n<p>Another feature that we cleaned up on the user-interface is that the Installed, Consolidate and Updates tabs now show the list of packages sorted alphabetically.  We know this was an important feature to the community and we updated the interface as requested.</p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>The clients have been updated to remove some of the extra interactions that felt unnecessary.  For example:</p>\n\n<ul>\n  <li>\n    <p>Packages in project.json can have a floating version number and were updating on every build regardless of whether the package has an update available.  The client has been optimized to only check for an update and apply it when forced to restore, clean, rebuild, or after a project.json modification.</p>\n  </li>\n  <li>\n    <p>The Visual Studio extension no longer are automatically adds the nuget.org repository source to your nuget.config files when you use the NuGet configuration user interface.</p>\n  </li>\n  <li>\n    <p>Shared projects no longer have packages restored to them, nor is a lock file written for them</p>\n  </li>\n  <li>\n    <p>The latest project.json schema for DNX is supported in the Visual Studio editor and by the NuGet extension</p>\n  </li>\n</ul>\n\n<h2 id=\"whats-next\">What’s Next</h2>\n\n<p>The team is cleaning up any remaining issues from the cross-platform migration and is looking at some further performance tuning for the clients.  There are new features we need to implement for project.json capabilities and there are NuGet.org service improvements that we want to implement to better enable the publication of a team’s collection of packages.</p>\n\n<p>Download the latest version of the NuGet command-line and Visual Studio extension from <a href=\"https://dist.nuget.org/index.html\">dist.nuget.org</a></p>\n","Href":"http://blog.nuget.org/20160308/Announcing-NuGet-3.4-RC.html","RawContent":null},{"Title":"Switching from WCF OData to Web API","PublishedOn":"2016-02-16T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>One of the less visible changes since we <a href=\"/20150720/nuget-3.0.0.html\">released NuGet 3.0</a> is that NuGet uses a new server “API v3”. This new API is designed around high availability for critical scenarios such as package restore and installing packages. API v3 will be the way forward for NuGet while keeping “API v2” around for older NuGet clients. We will be making a big change to the implementation of API v2 though: we’re switching from WCF OData to Web API.</p>\n\n<p>In this post, we want to take you through why we are making this change and what it means to our users.</p>\n\n<h2 id=\"background\">Background</h2>\n<p>When NuGet was released, we needed a client/server protocol that would allow us to query packages, fetch package metadata and download package artifacts. The logical choice at the time was <a href=\"http://www.odata.org\">OData</a>: by exposing our Entity Framework model over OData, the NuGet client could run any query on our database, using OData as the protocol.</p>\n\n<p>What we didn’t know was how popular NuGet was going to become. With more and more users, the number of queries vastly increased. And that increase was very visible on our database: since our OData implementation allowed for running pretty much any (read-only) query on the database, it often slowed down to a crawl.</p>\n\n<p>Was OData a bad choice then? We don’t believe so. OData has great features that allow for exposing data over HTTP, with querying and projection capabilities. However mapping that API 1:1 to our database was less brilliant in hindsight.</p>\n\n<p>The NuGet v3 API is centered around a static catalog of NuGet package metadata and a Lucene-based search engine, decoupling the increase in NuGet usage from the increase in database load. Of course not everyone is upgrading to V3 immediately, so we will have to have API v2 around for another while.</p>\n\n<h2 id=\"going-forward-with-api-v2\">Going forward with API v2</h2>\n<p>Keeping API v2 around in its current form does mean we are bound to a few prerequisites: we can’t easly change database models, we can’t easily redirect all incoming queries to the Lucene search to ensure V2 and V3 return the same data - although we already do this for some.</p>\n\n<p>When looking at the <a href=\"https://github.com/NuGet/NuGetGallery\">NuGet Gallery code base</a>, traces of a <code class=\"highlighter-rouge\">SearchHijacker</code> can be found. This is the class responsible for parsing incoming query expression trees from the WCF-based OData endpoint and tranlate them to Lucene, if possible. But parsing expression trees isn’t fun. There are a lot of edge cases, and as we’ve seen in our IIS logs, there are a lot of interesting queries coming in that can’t be hijacked towards Lucene and still hit our database, sometimes quite hard.</p>\n\n<p>The OData team in Microsoft has been hard at work in building a server-side OData framework for ASP.NET Web API. Where WCF OData would give us an expression tree which we have to parse ourselves, Web API OData can give us all OData query options as simple primitives (as well as the expression tree if we need it). This makes it more efficient in terms of translating queries for execution on Lucene and filter out query conditions that don’t make sense. So that’s what we are working on!</p>\n\n<p>Our initial version of the “Web API OData based v2 service”, or “new API v2” in short, is a 1:1 port of the old API v2. No changes in the API have been made: no query functionality was removed. We did make some caching changes to improve perceived  performance for developers in older versions of the client that are using the v2 endpoint (2013, 2012, 2010).</p>\n\n<p>The main goal for making this change was to explore if it was feasible to make the conversion and prepare for future improvements to it. Feel free to explore the <a href=\"https://github.com/NuGet/NuGetGallery/pull/2848\">changes we made to the NuGet Gallery on GitHub</a>.</p>\n\n<h2 id=\"whats-next\">What’s next?</h2>\n<p>We will now start looking at reducing the API surface where it makes sense. Some queries should not be allowed, others can be optimized. The ultimate goal is to make the API v2 a stable and performant shim on top of API v3, ensuring the data returned in both API’s is identical while not breaking backward compatibility.</p>\n","Href":"http://blog.nuget.org/20160216/Switching-from-WCF-OData-to-Web-API.html","RawContent":null},{"Title":"NuGet ContentFiles Demystified","PublishedOn":"2016-01-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><em>Updated - Feb 26, 2015: Thanks to <a href=\"https://twitter.com/rhyous\">Jared Barneck</a> for some suggested edits to add some steps to the sample NuGet creation process</em></p>\n\n<p>In NuGet 3.3, the <code class=\"highlighter-rouge\">contentFiles</code> feature was introduced to support project.json managed projects and packages that are indirectly referenced in a project.  This was an important change because it brings the ability to deliver static files, .pp file transforms, and language specific code into a project.  In this post, we’ll explore how to make use of this feature and show some samples of how to make the most of it in your projects.</p>\n\n<h2 id=\"definition\">Definition</h2>\n\n<p>Let’s start with a quick definition.  ContentFiles in NuGet are static files that the NuGet client will make available through the project.lock.json file to a project for inclusion in the project.  There are three different types of files that can be included as a content file:</p>\n\n<ul>\n  <li>Language specific files (.cs, .vb, .fs) that are directly included in a project</li>\n  <li>Language specific .pp transform files that are transformed and their output is included in the project for compilation</li>\n  <li>Other static files (text files, image files, etc) that can be embedded in a project or added for use during development and not included when the project is compiled</li>\n</ul>\n\n<p>ContentFiles are placed in a NuGet package in the <code class=\"highlighter-rouge\">/contentFiles</code> folder and their capabilities are defined in the <code class=\"highlighter-rouge\">/package/metadata/contentFiles</code> element inside the nuspec document.  Attributes are defined for these files that are passed to the project system to indicate how the files should be used in a project.</p>\n\n<p>When placing content into the <code class=\"highlighter-rouge\">contentFiles</code> folder, we have some options to help steer the project that uses the content.  There are two folder levels that are defined under contentFiles to categorize our content:</p>\n\n<p>1  Language (vb, cs, fs)\n 2  Target Framework Moniker or TFM (net35, wp81, etc)</p>\n\n<p>Either of these can be replaced with the catch-all <code class=\"highlighter-rouge\">any</code> name in order to deliver content to all languages or framework types.  In the case of our logo, we would like it to be delivered for all languages and for any framework type therefore we will place the logo in the <code class=\"highlighter-rouge\">contentFiles\\any\\any</code> folder.</p>\n\n<h2 id=\"supported-project-types\">Supported Project Types</h2>\n<p><strong>Update Oct 12, 2017</strong> This feature is supported for projects that use PackageReference and project.json package management formats. It is not supported for projects that use packages.config.</p>\n\n<p>This feature is only for packages that will be installed to projects that are managed using a project.json file. Currently only two projects types are managed by a project.json.</p>\n\n<ol>\n  <li>UWP apps</li>\n  <li>Portable class libraries</li>\n</ol>\n\n<p>The contentFiles option is not available for other project types.</p>\n\n<h2 id=\"first-example---include-a-branding-image\">First Example - Include a Branding Image</h2>\n\n<p>A first example that we can look at would be to include a png of your organization’s logo so that all applications have the same logo in the ‘About’ page.  In the case of NuGet, we would want to use the same .NET Foundation logo everywhere.  To build a package to deliver this logo, we could create a <code class=\"highlighter-rouge\">contentFiles</code> folder on disk and a nuspec to define the package.</p>\n\n<h3 id=\"step-1---create-a-contentfiles-folder\">Step 1 - Create a contentFiles folder.</h3>\n\n<p>We like to work in <code class=\"highlighter-rouge\">c:\\dev</code>, so lets create a project folder called <code class=\"highlighter-rouge\">ContentFilesExample</code> and place a folder underneath it to hold our content.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\contentFiles\n</code></pre></div></div>\n\n<h3 id=\"step-2---add-a-branding-image\">Step 2 - Add a branding image</h3>\n\n<p>Create the following folder structure:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\contentFiles\\any\\any\\images\\\n</code></pre></div></div>\n\n<p>Notice: We followed the procedure discussed above for our folder structure. The first “any” folder is the language. The second “any” folder is the target framework. We could have been more specific and something like used <code class=\"highlighter-rouge\">cs\\net40</code> to apply the contents to projects using c-sharp in .NET 4.0. Also, to make it even clearer that this is an image, we added an images folder.</p>\n\n<p>Put an image into that folder. In this example, our image is called dnf.png.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\contentFiles\\any\\any\\images\\dnf.png\n</code></pre></div></div>\n\n<h3 id=\"step-3---create-the-contentfilesexamplenuspec-and-add-appropriate-xml\">Step 3 - Create the contentFilesExample.nuspec and add appropriate Xml</h3>\n\n<p>Let’s create the nuspec manifest file for this package and populate it with the information NuGet needs.  We can create and place this file at:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\ContentFilesExample.nuspec\n</code></pre></div></div>\n\n<p>Next, we need to author the nuspec appropriately to deliver this image with an EmbeddedResource action.  A minimum nuspec document for this package may look like the following:</p>\n\n<div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">&lt;?xml version=\"1.0\"?&gt;</span>\n<span class=\"nt\">&lt;package&gt;</span>\n  <span class=\"nt\">&lt;metadata</span> <span class=\"na\">minClientVersion=</span><span class=\"s\">\"3.3.0\"</span><span class=\"nt\">&gt;</span>\n    <span class=\"nt\">&lt;id&gt;</span>ContentFilesExample<span class=\"nt\">&lt;/id&gt;</span>\n    <span class=\"nt\">&lt;version&gt;</span>1.0.0<span class=\"nt\">&lt;/version&gt;</span>\n    <span class=\"nt\">&lt;authors&gt;</span>nuget<span class=\"nt\">&lt;/authors&gt;</span>    <span class=\"c\">&lt;!-- The NuGet team authored this package --&gt;</span>\n    <span class=\"nt\">&lt;owners&gt;</span>nuget<span class=\"nt\">&lt;/owners&gt;</span>      <span class=\"c\">&lt;!-- The NuGet team owns this package --&gt;</span>\n    <span class=\"nt\">&lt;requireLicenseAcceptance&gt;</span>false<span class=\"nt\">&lt;/requireLicenseAcceptance&gt;</span>\n    <span class=\"nt\">&lt;description&gt;</span>A content v2 example package.<span class=\"nt\">&lt;/description&gt;</span>\n    <span class=\"nt\">&lt;tags&gt;</span>contentv2 contentFiles<span class=\"nt\">&lt;/tags&gt;</span>\n    <span class=\"c\">&lt;!-- Build actions for items in the contentFiles folder --&gt;</span>\n    <span class=\"nt\">&lt;contentFiles&gt;</span>\n        <span class=\"c\">&lt;!-- Include Assets as Content --&gt;</span>\n        <span class=\"nt\">&lt;files</span> <span class=\"na\">include=</span><span class=\"s\">\"**/images/*.*\"</span> <span class=\"na\">buildAction=</span><span class=\"s\">\"EmbeddedResource\"</span> <span class=\"nt\">/&gt;</span>\n    <span class=\"nt\">&lt;/contentFiles&gt;</span>\n  <span class=\"nt\">&lt;/metadata&gt;</span>\n<span class=\"nt\">&lt;/package&gt;</span>\n</code></pre></div></div>\n\n<p>Notice the file-globbing pattern on the <code class=\"highlighter-rouge\">files/@include</code> attribute.  We have a lot of flexibility to reference groups of files and can define features for them using this markup.</p>\n\n<h3 id=\"step-4---build-the-nuget-package\">Step 4 - Build the nuget package</h3>\n\n<p>You may need to download nuget.exe to do this from here: <a href=\"https://dist.nuget.org/index.html\">Download NuGet</a>.</p>\n\n<p>For this example, we put a copy of nuget.exe in the <code class=\"highlighter-rouge\">c:\\dev\\ContentFilesExample\\</code> folder.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\nuget.exe\n</code></pre></div></div>\n\n<p>Open a command prompt and run the following:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cd c:\\dev\\ContentFilesExample\nnuget.exe pack ContentFilesExample.nuspec\n</code></pre></div></div>\n\n<p>This createas your nuget package and names it ContentFilesExample.1.0.0.nupkg</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\ContentFilesExample.1.0.0.nupkg\n</code></pre></div></div>\n\n<h3 id=\"step-5---install-the-nuget-package\">Step 5 - Install the nuget package</h3>\n\n<ol>\n  <li>Open Visual Studio.</li>\n  <li>\n    <table>\n      <tbody>\n        <tr>\n          <td>Go to File</td>\n          <td>New</td>\n          <td>Project</td>\n        </tr>\n      </tbody>\n    </table>\n  </li>\n  <li>Choose one of the supported project types: UWP app, or Portable class library. In this example, we are going to choose a portable class library.</li>\n  <li>Name it and click OK. For this example, we will leave the default name of ClassLibrary1.</li>\n  <li>\n    <table>\n      <tbody>\n        <tr>\n          <td>Now go to Tools</td>\n          <td>NuGet Package Manager</td>\n          <td>Package Manager Console.</td>\n        </tr>\n      </tbody>\n    </table>\n  </li>\n  <li>Run this command:</li>\n</ol>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Install-Package ContentFilesExample -source c:\\dev\\ContentFilesExample\n</code></pre></div></div>\n\n<p>You should see the image added to your project.</p>\n\n<h2 id=\"second-example---adding-files-from-other-locations\">Second Example - Adding files from other locations</h2>\n\n<p>The <code class=\"highlighter-rouge\">contentFiles</code> elements in the nuspec are pointers to files that exist inside the package.  We can also use the <a href=\"http://docs.nuget.org/Create/NuSpec-Reference#specifying-files-to-include-in-the-package\">standard NuGet files element</a> to move items from outside of the package folder hierarchy into the package. Lets start using that markup to add a CS file into the package.  I can add a file called <code class=\"highlighter-rouge\">ExampleInternals.cs</code> to the root of my package folder so that the file structure on disk is:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>c:\\dev\\ContentFilesExample\\ContentFilesExample.nuspec\nc:\\dev\\ContentFilesExample\\ExampleInternals.cs\nc:\\dev\\ContentFilesExample\\contentFiles\\any\\any\\images\\dnf.png\n</code></pre></div></div>\n\n<p>My nuspec will now be modified to contain the following:</p>\n\n<div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">&lt;?xml version=\"1.0\"?&gt;</span>\n<span class=\"nt\">&lt;package&gt;</span>\n  <span class=\"nt\">&lt;metadata</span> <span class=\"na\">minClientVersion=</span><span class=\"s\">\"3.3.0\"</span><span class=\"nt\">&gt;</span>\n    <span class=\"nt\">&lt;id&gt;</span>ContentFilesExample<span class=\"nt\">&lt;/id&gt;</span>\n    <span class=\"nt\">&lt;version&gt;</span>1.0.1<span class=\"nt\">&lt;/version&gt;</span>\n    <span class=\"nt\">&lt;authors&gt;</span>nuget<span class=\"nt\">&lt;/authors&gt;</span>\n    <span class=\"nt\">&lt;owners&gt;</span>nuget<span class=\"nt\">&lt;/owners&gt;</span>\n    <span class=\"nt\">&lt;requireLicenseAcceptance&gt;</span>false<span class=\"nt\">&lt;/requireLicenseAcceptance&gt;</span>\n    <span class=\"nt\">&lt;description&gt;</span>A content v2 example package.<span class=\"nt\">&lt;/description&gt;</span>\n    <span class=\"nt\">&lt;tags&gt;</span>contentv2 contentFiles<span class=\"nt\">&lt;/tags&gt;</span>\n    <span class=\"c\">&lt;!-- Build actions for items in the contentFiles folder --&gt;</span>\n    <span class=\"nt\">&lt;contentFiles&gt;</span>\n        <span class=\"c\">&lt;!-- Include Assets as Content --&gt;</span>\n        <span class=\"nt\">&lt;files</span> <span class=\"na\">include=</span><span class=\"s\">\"**/images/*.*\"</span> <span class=\"na\">buildAction=</span><span class=\"s\">\"EmbeddedResource\"</span> <span class=\"nt\">/&gt;</span>\n        <span class=\"nt\">&lt;files</span> <span class=\"na\">include=</span><span class=\"s\">\"cs/**/*.*\"</span> <span class=\"na\">buildAction=</span><span class=\"s\">\"Compile\"</span> <span class=\"nt\">/&gt;</span>\n    <span class=\"nt\">&lt;/contentFiles&gt;</span>\n  <span class=\"nt\">&lt;/metadata&gt;</span>\n  <span class=\"nt\">&lt;files&gt;</span>\n    <span class=\"nt\">&lt;file</span> <span class=\"na\">src=</span><span class=\"s\">\"contentFiles\\**\"</span> <span class=\"na\">target=</span><span class=\"s\">\"contentFiles\"</span> <span class=\"nt\">/&gt;</span>\n    <span class=\"nt\">&lt;file</span> <span class=\"na\">src=</span><span class=\"s\">\"ExampleInternals.cs\"</span> <span class=\"na\">target=</span><span class=\"s\">\"contentFiles\\cs\\any\"</span> <span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;/files&gt;</span>\n<span class=\"nt\">&lt;/package&gt;</span>\n</code></pre></div></div>\n\n<p>Notice that we now have defined all of the files that are included in the package outside of the metadata element.  Since we started declaring the files to include in the nuspec, all files must be declare in this way and the convention of just referencing the location on disk is no longer observed in this mode.</p>\n\n<h2 id=\"other-options\">Other options</h2>\n\n<p>The files that are referenced by the <code class=\"highlighter-rouge\">contentFiles</code> element in NuSpec have four attributes that can be set on them:</p>\n\n<ul>\n  <li><code class=\"highlighter-rouge\">include</code> OR <code class=\"highlighter-rouge\">exclude</code> - The pattern or filename that should be included or excluded in the package</li>\n  <li><code class=\"highlighter-rouge\">buildAction</code> - the action the compiler is recommended to take.  Possible values include: <code class=\"highlighter-rouge\">None</code>, <code class=\"highlighter-rouge\">Compile</code>, <code class=\"highlighter-rouge\">EmbeddedResource</code>.  The default value if this attribute is not provided is <code class=\"highlighter-rouge\">Compile</code></li>\n  <li><code class=\"highlighter-rouge\">copyToOutput</code> - should these files be copied to the output folder?  The default value is false.</li>\n  <li><code class=\"highlighter-rouge\">flatten</code> - Should the files be all delivered to the root folder of the project or should they keep the folder structure that they were packaged in.  The default value is false, which indicates they should create (if necessary) and keep the same structure they have after the TFM folder in the pacakge.</li>\n</ul>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>ContentFiles in NuGet packages allows the package author to deliver more information to their consumers about the content that is delivered to a project.json managed project.  The package author can help steer the compiler to provide settings for the files delivered to ensure that they are used properly by the project that installed the package.  You can read more about the <a href=\"http://docs.nuget.org/Create/NuSpec-Reference#contentfiles-with-visual-studio-2015-update-1-and-later\">contentFiles feature definition in the NuGet docs</a>.</p>\n\n","Href":"http://blog.nuget.org/20160126/nuget-contentFiles-demystified.html","RawContent":null},{"Title":"NuGet Targets for Project.Json now open source","PublishedOn":"2016-01-19T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>A question that comes up from time to time is: how does Visual Studio 2015 add references when using project.json files in conjunction with a csproj without modifying the csproj file?  This is a good question and demonstrates some of our strategy to help make NuGet easier to integrate into project systems without having to teach NuGet how to work with every project system.  We’ve released this component as open source, and we’ll show you where you can learn more about how it was built.</p>\n\n<p>There is a MSBuild task for csproj files that will examine the project.lock.json file and determine what assets should be added.  This build task then dynamically adds those resources to the MSBuild tree during design-time and build.  This component was closed source and we are now making it available from the NuGet organization on GitHub, with the Roslyn team maintaining the code.</p>\n\n<p>You can get the source code from the new <a href=\"https://github.com/NuGet/NuGet.BuildTasks\">NuGet.BuildTasks respository on GitHub</a>.</p>\n","Href":"http://blog.nuget.org/20160119/nuget-targets.html","RawContent":null},{"Title":"Accelerate your NuGet.Server","PublishedOn":"2016-01-13T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Since its inception, NuGet supports setting up custom package sources. There’s the default <a href=\"https://www.nuget.org\">NuGet Gallery</a>, there’s third-party NuGet hosting (see the <a href=\"http://docs.nuget.org/Contribute/Ecosystem\">NuGet Ecosystem</a>), we can use local directories on our hard drive or a network UNC share (like <code class=\"highlighter-rouge\">\\\\yourserver\\nuget</code>) and there’s the <a href=\"https://www.nuget.org/packages/NuGet.Server/\">NuGet.Server</a> package that we can use to create our own NuGet server.</p>\n\n<p>Developers and teams have been using NuGet.Server to host and share their NuGet packages internally without exposing them publicly on nuget.org. It’s easy to set up: <a href=\"http://docs.nuget.org/create/hosting-your-own-nuget-feeds#creating-remote-feeds\">install a NuGet package</a> and we can work with our own NuGet server over HTTP(S).</p>\n\n<p>Some users went above and beyond in hosting their own packages and grew their package repository to several hundreds of packages, a tipping point where NuGet.Server performance would suffer. Today we’re releasing an update that increases performance in these cases.</p>\n\n<p>This update also comes with support for new target frameworks, supporting (among others) the new capabilities of ASP.NET 5 and DNX.</p>\n\n<h2 id=\"improving-nugetserver-performance\">Improving NuGet.Server performance</h2>\n\n<p>Up until <a href=\"https://www.nuget.org/packages/NuGet.Server/2.8.6\">version 2.8.6</a> the NuGet.Server package has been using a flat folder structure to store packages. For example, this is what the server’s packages folder could look like:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>~/packages/PackageA.1.0.0.nupkg\n~/packages/PackageA.1.0.1.nupkg\n~/packages/PackageB.0.0.1-beta.nupkg\n~/packages/PackageB.0.0.1.nupkg\n</code></pre></div></div>\n\n<p>When accessing NuGet.Server, these packages (which are actually zip archives) would all be unzipped to a temporary folder to extract their metadata so that it could be served up on the exposed NuGet feed. This extraction would happen whenever NuGet.Server’s application pool was restarted as well as right after a package was pushed. To make things worse, each package would be read a second time to calculate the package hash which is surfaced in the NuGet feed. Bottom line: high-churn feeds with many packages were doing more unzipping than serving packages.</p>\n\n<p>After we <a href=\"http://blog.nuget.org/20150922/Accelerate-Package-Source.html\">introduced a new, expanded folder format</a> for directory based NuGet package sources, we started thinking about how using this structure could benefit users of NuGet.Server as well. We decided it would increase performance a lot! The expanded folder format would look like this:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>~/packages\n\t/PackageA\n\t\t/1.0.0\n\t\t\t/PackageA.1.0.0.nupkg\n\t\t\t/PackageA.nuspec\n\t\t\t/PackageA.1.0.0.nupkg.sha512\n</code></pre></div></div>\n\n<p>In this structure, every package is analyzed when pushed to the server. Of course, the .nupkg is stored so it can be served to the client. Next to the package, we extract the .nuspec containing the package’s metadata and write the package hash to disk as well.</p>\n\n<p>All NuGet.Server has to do on startup is read the .nuspec files for metadata which is much faster than unzipping all packages. Since the hash is also precalculated when a package is added to the feed, we no longer have to recalculate it - resulting in more performance gains.</p>\n\n<p>Why stop there? While we were at it, we decided we could also persist the in-memory package metadata cache that is created and load it again on the next server start. This improves NuGet.Server start time tremendously - only one file has to be read at startup if the persisted cache exists.</p>\n\n<h3 id=\"how-much-faster-is-it\">How much faster is it?</h3>\n\n<p>Of course we did some tests before and after upgrading NuGet.Server. Here are the results on an i7 with SSD:</p>\n\n<style>\ntable, th, td {\n    border: 1px solid black;\n    border-collapse: collapse;\n}\nth, td {\n    padding: 5px;\n}\n</style>\n\n<table>\n  <thead>\n    <tr>\n      <th></th>\n      <th>Before upgrade</th>\n      <th>After upgrade</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td># of files</td>\n      <td>6,875</td>\n      <td>20,625</td>\n    </tr>\n    <tr>\n      <td># of packages</td>\n      <td>6,875</td>\n      <td>6,875</td>\n    </tr>\n    <tr>\n      <td>Space consumed on server</td>\n      <td>3.94 GB</td>\n      <td>3.98 GB</td>\n    </tr>\n    <tr>\n      <td>First request to <code>/nuget</code> (cold start, no metadata cache)</td>\n      <td>75.266 sec</td>\n      <td>08.482 sec</td>\n    </tr>\n    <tr>\n      <td>First request to <code>/nuget</code>(warm start, with metadata cache)</td>\n      <td>n/a</td>\n      <td>00.712 sec</td>\n    </tr>\n    <tr>\n      <td>Second request to <code>/nuget</code></td>\n      <td>00.184 sec</td>\n      <td>00.158 sec</td>\n    </tr>\n    <tr>\n      <td>Memory usage on server (managed)</td>\n      <td>146 MB</td>\n      <td>210 MB</td>\n    </tr>\n  </tbody>\n </table>\n\n<p>Your results of course will vary, based on the number of package IDs, versions per package, the size of your packages, and their dependencies.</p>\n\n<h2 id=\"getting-started\">Getting started</h2>\n\n<p>It all starts with <a href=\"http://docs.nuget.org/create/hosting-your-own-nuget-feeds#creating-remote-feeds\">creating a remote NuGet feed with NuGet.Server</a>. In short, all we have to do is create an empty web application and install a NuGet package.</p>\n\n<blockquote>\n  <p><strong>Important:</strong> The accelerated <a href=\"https://www.nuget.org/packages/NuGet.Server/2.10.0-master-0002\">NuGet.Server package</a> is still in preview. Make sure to tick the “Include prereleases” box in Visual Studio’s NuGet dialog or use <code class=\"highlighter-rouge\">Install-Package NuGet.Server -Pre</code> to install / <code class=\"highlighter-rouge\">Update-Package NuGet.Server -Pre</code> to update an existing NuGet.Server.</p>\n</blockquote>\n\n<h3 id=\"upgrading\">Upgrading</h3>\n\n<p>To upgrade an existing NuGet.Server we can update the NuGet.Server package in our project.</p>\n\n<p>After the upgrade, the first start of the application will convert the flat packages folder structure into the expanded folder structure. If there are many packages on the server, this first launch may take a while (we’ve seen 6 minutes for 6,000 packages for this first launch). To overcome this performance hit, stop the server, <a href=\"https://dist.nuget.org/index.html\">download the NuGet.exe command line 3.3+</a> and run the following commands:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>REM Navigate to NuGet.Server web root\ncd c:\\path\\to\\nuget.server\n\nREM Copy the existing packages folder to a backup folder\nxcopy packages packages-backup /E /I /Q /H /Y\n\nREM Clean the original packages folder\ndel /f /s /q packages\n\nREM Let NuGet.exe initialize the expanded folder structure\nnuget init packages-backup packages\n</code></pre></div></div>\n\n<p>Once finished we can launch NuGet.Server using the new package folder structure. Note the <code class=\"highlighter-rouge\">packages-backup</code> folder can be removed after succesfully launching the NuGet.Server.</p>\n\n<h3 id=\"uploading-packages\">Uploading packages</h3>\n\n<p>There are two ways of uploading packages to NuGet.Server:</p>\n\n<ul>\n  <li>Using the NuGet.exe command line</li>\n  <li>Copying the NuGet package to the packages folder</li>\n</ul>\n\n<p>To upload packages using the NuGet.exe command line, make sure NuGet.Server has an API key set. For example add the following in Web.config:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;add key=\"apiKey\" value=\"SooperS3cr3t\"/&gt;\n</code></pre></div></div>\n\n<p>Once added, we can use NuGet.exe to upload packages to our NuGet server:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nuget push MyPackage.nupkg SooperS3cr3t -Source http://url.to.server\n</code></pre></div></div>\n\n<p>Another way of uploading packages is by copying the NuGet package to the root of the packages folder. The root acts as a “drop folder”: NuGet.Server will automatically pick up the package and store it in the expanded folder format.</p>\n\n<h3 id=\"consuming-packages\">Consuming packages</h3>\n\n<p>To consume packages from our NuGet.Server, we can <a href=\"http://docs.nuget.org/consume/package-manager-dialog#package-sources\">use the Visual Studio NuGet extension UI</a> or create/edit a NuGet.config file. When using source control among a team or multiple machines, adding a NuGet.config file registers our NuGet server with everyone who checks out our source code, including automated builds.</p>\n\n<p>Create a NuGet.config file with this content, and check it in at the root of the source tree:</p>\n\n<pre>\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;configuration&gt;\n  &lt;packageSources&gt;\n    &lt;add key=&quot;CustomNuGetServer&quot; value=&quot;http://url.to.server/nuget&quot; /&gt;\n  &lt;/packageSources&gt;\n&lt;/configuration&gt;\n</pre>\n\n<p><a href=\"http://docs.nuget.org/consume/nuget-config-file\">Read more about setting up a nuget.config file.</a></p>\n\n<h2 id=\"give-it-a-try\">Give it a try!</h2>\n\n<p>We’ve released this improved <a href=\"https://www.nuget.org/packages/NuGet.Server/2.10.0-master-0002\">NuGet.Server package</a> as a prerelease. It comes with performance improvements and support for new .NET target frameworks. Please give it a try and let us know how it performs in your setup!</p>\n","Href":"http://blog.nuget.org/20160113/Accelerate-your-NuGet.Server.html","RawContent":null},{"Title":"NuGet 3.3 Release","PublishedOn":"2015-11-18T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Big news:  a new version of the NuGet clients has been released!  This is version 3.3 of the client, with a <a href=\"https://dist.nuget.org/win-x86-commandline/v3.3.0/nuget.exe\">new command-line</a> and <a href=\"https://dist.nuget.org/visualstudio-2015-vsix/v3.3.0/NuGet.Tools.vsix\">Visual Studio 2015 extension</a> available for use.  Use the above links to download from the NuGet distribution site, also accessible with the ‘Downloads’ menu item above.  This is a release that the NuGet team worked closely with community influencers to ensure it closed some of the usability gaps and made packages a bit easier to build.  Complete details of this version are available in the <a href=\"http://docs.nuget.org/release-notes/nuget-3.3\">v3.3 release notes</a>, but lets take a look at the highlights of this release:</p>\n\n<h2 id=\"user-interface-updates\">User Interface Updates</h2>\n\n<p>Since the July 2015 release of NuGet with Visual Studio 2015, the top comments and requests heard by the NuGet team through the various feedback channels has been to add / modify features of the user interface.  With this release, we are deploying a number of changes that were recommended when reviewing with a number of influencers and Microsoft MVPs.</p>\n\n<h3 id=\"update-all-and-update-some\">‘Update All’ and ‘Update Some’</h3>\n\n<p>The top requested feature was the ability to update multiple packages from the user interface.  We heard several different stories from developers who wanted to be able to update packages, especially using the ‘Update All’ button that was in the Visual Studio 2013 interface.  We saw this as an opportunity to provide information early in the package management process and give a little more control.</p>\n\n<p><img src=\"../images/2015-11-18-nuget-3.3/update.png\" title=\"Update Panel Features\" style=\"width: 100%;\" /></p>\n\n<p>First, you’ll notice that the filter have been broken out as tabs.  The Updates tab now has a convenient badge on it to indicate the number of packages that have updates awaiting.  When you click the ‘Updates’ tab, the list of packages is on the right with some additional information about the packages including Author, currently installed version indicated with a check mark, and the latest available version beneath that.</p>\n\n<p>Each row has a checkbox, allowing you to choose which packages you want to update to the latest available version OR you can click the ‘Select all packages’ box at the top to select all packages.  The ‘Update’ button to the right will apply updates to all packages that are checked in this view.  If you still want to update a package with more control, you can use the right panel to select the exact version you would like to update to and click the Update button next to the package version.</p>\n\n<p>The Uninstall button for each package is always present on the right side of the panel so that you can uninstall specific packages.  We separated the Uninstall and Update buttons so that it was clear that you never need to uninstall in order to update a package.</p>\n\n<p>We also cleaned up the language of ‘Update’ from ‘Upgrade’.  We heard from developers that the ‘Upgrade’ wording made it sound like a fee would be charged by NuGet to install a new version.  This is NEVER the case, so we changed the caption to ‘Update’</p>\n\n<h3 id=\"action-buttons-on-package-list\">Action buttons on package list</h3>\n\n<p>We wanted to make the installation process for packages a bit easier than the previous drop-down action selector button process. It was confusing, and we wanted something simple.</p>\n\n<p><img src=\"../images/2015-11-18-nuget-3.3/packageList.png\" alt=\"Action Buttons on Package List\" /></p>\n\n<p>We are introducing action buttons on the package list.  When your mouse hovers over a package, you will see one or two action buttons for the package appear to the right of the version numbers.  The top version number with the check is the currently installed version, and the red X next to it will immediately uninstall that package.  The blue arrow next to the lower ‘Latest Available’ version number will update that package to the latest available version number displayed.  In the case where only one version number is present, this is the latest available version and you have not yet installed a version of that package.  A different arrow button will appear next to this number that you can click to immediately install that version number of the package in your project.</p>\n\n<p>We introduced a state badge overlay on the package icons on the right side to help give a visual indication if the package was current or if there was an update available.</p>\n\n<p>Finally, you still have full control over which version of a package is installed, with the package version combobox on the right-side as we saw in the previous screenshot.</p>\n\n<h3 id=\"options-optionally-visible\">Options, optionally visible</h3>\n\n<p>We know that the ‘Options’ section on the right side of the screen felt out of place to some people and was distracting that it would change content when you changed the action you wanted to perform.  Without an action combobox, we decided to list all options in this area.</p>\n\n<p><img src=\"../images/2015-11-18-nuget-3.3/options.png\" alt=\"Options Settings\" /></p>\n\n<p>This is a large section and it only really needs attention in a minimum number of use cases.  For those that don’t really need to look at and work with these options, you can click the arrow next to the Options label to hide the section.</p>\n\n<h3 id=\"consolidate\">Consolidate</h3>\n\n<p>The final new feature that we want to review is the Solution ‘Package Consolidate’ view.  When you choose to manage packages for the solution, an additional panel appears labeled ‘Consolidate’ with a badge to indicate how many packages in your solution are used in multiple projects with multiple distinct version numbers.</p>\n\n<p><img title=\"Solution View\" src=\"../images/2015-11-18-nuget-3.3/consolidate.png\" style=\"width: 100%;\" /></p>\n\n<p>We know that many developers consider multiple package versions across a solution to be a bad practice, and are introducing this indicator and panel to help manage this scenario.  In the screenshot you can see that there are two packages used in multiple projects with different version numbers.  In the case of EntityFramework, you can see the two version numbers and two projects on the right side.  The table of projects is sortable by Project or Version number, and you can choose which projects you would like to act on with the checkboxes to the left of the project name.  After choosing one or more projects, you can select the version you want to consolidate your solution to.  Clicking the Install button will install or update the selected projects with the chosen package version.  You could also click the Uninstall button to remove the package from the selected projects.</p>\n\n<h3 id=\"incompatible---try-bower\">Incompatible - Try Bower!</h3>\n\n<p>In cooperation with the web tools teams at Microsoft, we are introducing a feature to help developers of ASP.NET 5 projects find appropriate Bower packages that deliver the same content as popular web-focused NuGet packages.  If you are building an ASP.NET 5 project and search for a package like jQuery or Bootstrap that deliver CSS and JavaScript content for a web project, you will receive a recommendation in the package list to install the package with Bower instead of NuGet.</p>\n\n<p><img src=\"../images/2015-11-18-nuget-3.3/bower.png\" alt=\"Install with Bower\" /></p>\n\n<p>When you click the ‘Bower’ link in the NuGet package list, you will be routed to the new Bower Package Manager that comes with Visual Studio 2015 Update 1. That interface will be pre-populated with the appropriate matching package from Bower that we recommend you use instead of the NuGet package.</p>\n\n<h2 id=\"content-files\">Content Files</h2>\n\n<p>The next feature to discuss is a change to better support content files in packages.  Historically, you could include content in a <code class=\"highlighter-rouge\">content</code> folder and the NuGet client would copy that folders data into your project.  This had several side-effects that were difficult to manage:</p>\n\n<ul>\n  <li>What should the NuGet client do if the delivered content is modified on disk and the package is updated?  Should the content on disk in a project be overwritten by the new content delivered in the package update?  NuGet cannot reliably migrate modified content based on new content delivered in a package</li>\n  <li>How should the project be configured to act on the files delivered from a package?  Are the files supposed to be compiled, embedded, or just left on disk to be referenced?</li>\n</ul>\n\n<p>To better handle these scenarios and offer a significantly better experience for package authors and package consumers, we are introducing the <code class=\"highlighter-rouge\">contentFiles</code> folder structure and features.  In particular, this feature initially targets three key scenarios:</p>\n\n<ul>\n  <li>Delivering content that should be referenced and included in the project without modification for reference and reuse elsewhere in the project.</li>\n  <li>Providing a template to generate some code that should be referenced in a project using the .PP file extension and replacing tokens in those files based on MSBuild property values.</li>\n  <li>How should this content be managed when packages are included indirectly?</li>\n</ul>\n\n<p>The ContentFiles feature is only available to projects that are managed with a project.json file.  The dnu utility for ASP.NET 5 does not yet support this feature.</p>\n\n<h3 id=\"contentfiles-folder-layout\">ContentFiles folder layout</h3>\n\n<p>The new “contentFiles” folder is at the root of the package and has a strictly defined layout of folders within.  The first layer of folders defines the project language to which the content will be applied.  Valid names of folders here are <code class=\"highlighter-rouge\">vb</code>, <code class=\"highlighter-rouge\">cs</code>, and <code class=\"highlighter-rouge\">any</code>  The NuGet client will inspect the project into which the package is being installed and grab the content from the most specific folder (vb or cs) based on the language used in the project.  If a specific folder is not located in the project, the <code class=\"highlighter-rouge\">any</code> folder will be used if it is present.  If the NuGet client cannot locate an appropriate folder no content will be copied into the project.</p>\n\n<p>The second folder in the hierarchy is a target framework moniker (TxM) that defines the project framework into which the content will be copied.  All valid NuGet target frameworks are eligible to be referenced as the names of a folder at this level, in addition to the keyword <code class=\"highlighter-rouge\">any</code>.  A similar folder resolution strategy as the language folder is used here - the most specific folder name will be chosen by NuGet first, and the last folder to be chosen to copy content from is the <code class=\"highlighter-rouge\">any</code> folder.</p>\n\n<p>Content will only be copied from one folder location.</p>\n\n<p>There is an override folder name of <code class=\"highlighter-rouge\">_._</code> that can be used at the third level of folders to prevent delivering content to that combination of language and project framework type.</p>\n\n<p>Any folders at the third level and lower will be referenced by the project the package is being installed into.  Valid content folders in a package include:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/contentFiles/any/any/config.xml\n/contentFiles/any/net45/config.xml\n/contentFiles/cs/net45/config.xml\n/contentFiles/vb/any/_._\n</code></pre></div></div>\n\n<h3 id=\"project-content-configuration\">Project Content Configuration</h3>\n\n<p>In previous version of NuGet, the client would inspect the file extension and determine what project build action to configure.  With this feature, package authors can specify how the NuGet client will configure the project for this content.  Inside of the NuSpec document for a package, the author should include the new <code class=\"highlighter-rouge\">contentFiles</code> element with child <code class=\"highlighter-rouge\">files</code> items that define the project configuration for the content included in the package.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;contentFiles&gt;\n    &lt;!-- Embed image resources --&gt;\n    &lt;files include=\"any/any/images/dnf.png\"  buildAction=\"EmbeddedResource\" /&gt;\n    &lt;files include=\"any/any/images/ui.png\" buildAction=\"EmbeddedResource\" /&gt;\n\n    &lt;!-- Embed all image resources under contentFiles/cs/ using a wild card --&gt;\n    &lt;files include=\"cs/**/*.png\" buildAction=\"EmbeddedResource\" /&gt;\n\n    &lt;!-- Copy config.xml to the root of the output folder --&gt;\n    &lt;files include=\"cs/uap10.0/config/config.xml\" buildAction=\"None\" copyToOutput=\"true\" flatten=\"true\" /&gt;\n\n    &lt;!-- Include everything in the scripts folder except exe files --&gt;\n    &lt;files include=\"cs/uap10.0/scripts/*\" exclude=\"**/*.exe\"  buildAction=\"None\" copyToOutput=\"true\" /&gt;\n\n    &lt;!-- All other files in shared are compiled and use the default options --&gt;\n\n&lt;/contentFiles&gt;\t\n</code></pre></div></div>\n\n<p>Each files item has a set of attributes available to be configured:</p>\n\n<table>\n<tr>\n<th>Attribute</th>\n<th>Description</th>\n</tr>\n<tr>\n<td>include</td>\n<td><b>[Required attribute]</b> Include provides either a file path or a wild card path. All matching files from the contentFiles folder will have the attributes for that files node applied. Examples: **/*, **/*.cs, any/any/myfile.txt, **/net*/*</td>\n</tr>\n<tr>\n<td>exclude</td>\n<td>Exclude provides either a file path or a wild card path. All matching files will be excluded from the include.</td>\n</tr>\n<tr>\n<td>buildAction</td>\n<td>Build action taken by msbuild for the content items. Examples: None, Compile. <br /><b>Default Value: Compile</b></td>\n</tr>\n<tr><td>copyToOutput</td>\n<td>If True the content items will be copied to the build output folder<br /><b>Default Value: False</b></td>\n</tr>\n<tr>\n<td>flatten</td>\n<td>If False the content items will be copied to the build output folder using the full folder structure from the nupkg. This path will be relative to the TxM folder. Example: cs/net45/config/data.xml -&gt; config/data.xml  <br /><b>Default Value: False</b></td>\n</tr>\n</table>\n\n<h3 id=\"source-code-transformations\">Source Code Transformations</h3>\n\n<p>The content of *.pp files will be transformed and renamed to remove the .pp extension when a package is installed that contains this type of content.  The transformation of these files is the same process as with prior versions of NuGet.  <a href=\"http://docs.nuget.org/Create/Configuration-File-and-Source-Code-Transformations#specifying-source-code-transformations\">Documentation</a> about how these files are transformed and the options available are available online. All output of files that are transformed are added to a project with the build action of “Compile”.</p>\n\n<h2 id=\"visual-studio-team-services-and-credential-providers\">Visual Studio Team Services and Credential Providers</h2>\n\n<p>In Fall 2015, <a href=\"https://www.visualstudio.com/products/what-is-visual-studio-online-vs\">Visual Studio Team Services</a> introduced NuGet package hosting.  The VSTS hosted solution provides:</p>\n\n<ul>\n  <li>Private package hosting for your team or entire organization,</li>\n  <li>Enterprise-grade security and authentication,</li>\n  <li>Seamless integration with other VSTS components such as Team Build, and</li>\n  <li>Easy integration with third-party dev tools like Jenkins.</li>\n</ul>\n\n<p>More information about <a href=\"http://blogs.msdn.com/b/visualstudioalm/archive/2015/08/27/announcing-package-management-for-vso-tfs.aspx\">package management support for VSTS</a> is available online.  In this release, we are introducing support for credential providers that allow NuGet to work seamlessly with an authenticated feed like VSTS.</p>\n\n<p><a href=\"http://docs.nuget.org/Consume/Credential-Providers\">Instructions on how to install the Visual Studio Team Services credential provider </a> and configure the NuGet clients to use it are available on NuGet Docs.</p>\n\n<h2 id=\"folder-based-repository-commands\">Folder Based Repository Commands</h2>\n\n<p>Over the summer, we published a <a href=\"http://blog.nuget.org/20150922/Accelerate-Package-Source.html\">blog post</a> that demonstrated an improved method to organize packages in a shared folder for significant package installation performance gains.  In that blog post’s sample scenario, the install or restore time was reduced by 92% and the bandwidth use was reduced by 99.4%.</p>\n\n<p>We would like to help encourage more developers to realize this type of performance improvement in working with their local packages.  To help with that, we are introducing two commands to the <code class=\"highlighter-rouge\">nuget.exe</code> command-line tool to help configure and maintain this prescribed folder structure:</p>\n\n<p>Init will initialize the folder location based on the contents of another flat folder of packages.  This preparation will enable the folder to be read and consumed by a NuGet 3.x client at a higher speed.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nuget init c:\\myTestNugetRepository c:\\shared\\nuget_repo\n</code></pre></div></div>\n\n<p>This will initialize the folder at <code class=\"highlighter-rouge\">c:\\shared\\nuget_repo</code> with the contents of <code class=\"highlighter-rouge\">c:\\myTestNugetRepository</code></p>\n\n<p>Add will take a package and place it in an appropriate folder location for use in the new folder structure.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nuget add my.nupkg -Source c:\\shared\\nuget_repo\n</code></pre></div></div>\n\n<p>This command will add the package called <code class=\"highlighter-rouge\">my.nupkg</code> to the proper package folder location within the <code class=\"highlighter-rouge\">c:\\shared\\nuget_repo</code> folder.</p>\n\n<p>More information about this feature is available in the <a href=\"http://docs.nuget.org/Consume/Command-Line-Reference#folder-repository-commands\">NuGet docs</a>.</p>\n\n<h2 id=\"local-cache-management\">Local cache management</h2>\n\n<p>NuGet uses a local cache, several actually.  If you have ever run into an issue with your network or a corrupted package that was downloaded incompletely from a package repository, you’ve run into this scenario where you need to clear out your NuGet caches in order for NuGet to fetch a new version of the package.  We’ve made this operation easy to do with an additional <code class=\"highlighter-rouge\">locals</code> command on the NuGet command-line tool.  Syntax looks like the following:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nuget locals &lt;all | http-cache | packages-cache | global-packages&gt; [-clear | -list]\n</code></pre></div></div>\n\n<p>You can list the locations of these caches on disk, or you can instruct NuGet to clear them out for you which will force a new copy of the packages to be downloaded from any remote repositories that you have configured.</p>\n\n<p>More about the locals command can be found in the <a href=\"http://docs.nuget.org/Consume/Command-Line-Reference\">NuGet Command Line Reference</a>.</p>\n\n<h2 id=\"support-for-the-net-platform-standard\">Support for the .NET Platform Standard</h2>\n\n<p>The .NET Platform Standard announcement is covered in full detail on the <a href=\"http://blogs.msdn.com\">.NET Blog</a>  NuGet provides support for this new definition of compatibility across .NET Framework versions and verticals in the target frameworks specified in nuspec documents.</p>\n\n<p>More details about the various target frameworks and supported capabilities of the .NET Platform Standard are still evolving but can be <a href=\"https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/standard-platform.md\">found on GitHub</a>.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>These are the top level features that were brought into the NuGet package manager and clients with the 3.3 version.  A complete list of updates can be found in the <a href=\"http://docs.nuget.org/release-notes/nuget-3.3.0\">v3.3 release notes</a>.  The team is continuing to work on improving the user interface and the package management clients, looking forward to a 3.4 release early in Q1 2016.  A list of proposed fixes and updates can be found in the <a href=\"https://github.com/NuGet/Home/milestones/3.4\">3.4 milestone</a> on the NuGet GitHub repository.  Keep an eye on the NuGet blog in the days and weeks ahead as we are planning more posts about using the .NET Platform Standard and how to better work with building and managing packages.</p>\n","Href":"http://blog.nuget.org/20151118/nuget-3.3.html","RawContent":null},{"Title":"NuGet 3 - Visual Studio User Interface Discussion","PublishedOn":"2015-10-14T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We want to continue our discussion of the recent changes made to the NuGet experience with the v3 releases, and in this second blog post of the series we are going to focus on the user interface updates that were made for Visual Studio 2015.  I touched on it briefly in our last blog post about <a href=\"http://blog.nuget.org/20151008/NuGet-3-What-and-Why.html\">What and Why</a>, but this time lets go a little deeper into the functionality and then explore the changes that are being made.</p>\n\n<h2 id=\"2013-compared-to-2015\">2013 compared to 2015</h2>\n\n<p>We showed this side-by-side comparison in the last blog post, and it helps to show immediately what has changed:</p>\n\n<table>\n<tr>\n<td width=\"500\">\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/Vs2013.png\" />\n<br />\n<b>Before:</b> NuGet User Interface in Visual Studio 2013\t \n</td>\n<td width=\"500\">\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/Vs2015.png\" />\n<br />\n<b>After:</b> NuGet User Interface in Visual Studio 2015\n</td>\n</tr>\n</table>\n\n<p>I covered the good, bad, and ugly about this user interface previously, but lets now review some of the concepts and changes that are planned to make this experience better.</p>\n\n<h3 id=\"new-header\">New Header</h3>\n\n<p><img src=\"../images/2015-10-14-nuget-userinterface/newHeader.png\" alt=\"Prototype New Header\" /></p>\n\n<ul>\n  <li>The Filter combobox has been replaced with three filtered views of packages through the Browse, Installed, and Updates pivot menus.</li>\n  <li>We’re introducing a badge on the Updates menu to indicate how many packages in the current project have updates available</li>\n  <li>Search is now directly below the pivot menus to indicate that the search is within context of the menu selected</li>\n  <li>Include Pre-release has been relocated next to the search box to indicate that the search and pre-release filter apply together to the results.</li>\n  <li>Package source is moved to the right side.  Many developers don’t change this frequently, and we believe that keeping it away from the typical controls should ease confusion.</li>\n</ul>\n\n<h3 id=\"package-list---browse-view\">Package List - Browse View</h3>\n\n<p><img src=\"../images/2015-10-14-nuget-userinterface/packageList.png\" alt=\"Prototype Package List\" /></p>\n\n<p>We made some targeted enhancements in the package list to allow developers to quickly scan the package list and act on the contents.</p>\n\n<ul>\n  <li>The author and approximate download count are displayed next to the package name</li>\n  <li>A badge is added to the package icon when the latest version is installed (green check) or if there are updates available (arrow)</li>\n  <li>The currently installed version is listed with a down arrow</li>\n  <li>If a newer version is available, that version number is also listed with an up arrow</li>\n  <li>If no version is installed, the latest version number is listed with an arrow</li>\n  <li>Package versions are stacked vertically to allow for easy comparison of version numbers to help determine if a new version install is appropriate</li>\n  <li>Hovering over a package in the list reveals action buttons beneath the version numbers:\n    <ul>\n      <li>Down arrow will install the latest version when no version is currently installed</li>\n      <li>Up arrow will update to the latest version</li>\n      <li>An X will uninstall the package from the project</li>\n    </ul>\n  </li>\n</ul>\n\n<p>We think this design will result in many developers using the left panel for most of their package interactions and using the right details panel for ‘advanced’ operations.</p>\n\n<h3 id=\"package-list---updates-view\">Package List - Updates View</h3>\n\n<p><img src=\"../images/2015-10-14-nuget-userinterface/Updates.png\" alt=\"Prototype Updates List\" /></p>\n\n<p>This prototype demonstrates the concept for the new multiple package update feature.  When viewing the list of updates that are available (yes, the header in this prototype is not aligned with the previous images) a bar will be presented at the top of the package list to facilitate this operation.</p>\n\n<ul>\n  <li>Check the ‘Select all packages’ option to choose to update all available packages</li>\n  <li>Hover over any package in the list to gain access to an individual checkbox that can be used to update only those chosen packages in the list.</li>\n</ul>\n\n<h3 id=\"package-details---project-view\">Package Details - Project View</h3>\n\n<p><img src=\"../images/2015-10-14-nuget-userinterface/pkgDetailsProject.png\" alt=\"Prototype Package Details - Project View\" /></p>\n\n<p>We plan to simplify the actions that can be taken on a package on the right details pane:</p>\n\n<ul>\n  <li>Remove the action selector combobox</li>\n  <li>List the installed version (if any) with an Uninstall button next to it</li>\n  <li>Move the version combobox below the installed version and continue to allow developers to choose a version to update to.</li>\n  <li>The Upgrade button will have the caption “Update” in order to generically apply to ‘Upgrade’ and ‘Downgrade’</li>\n  <li>The release date of the package will be reported in the details at the bottom</li>\n</ul>\n\n<h3 id=\"package-details---solution-view\">Package Details - Solution View</h3>\n\n<p><img src=\"../images/2015-10-14-nuget-userinterface/pkgDetailsSolution.png\" alt=\"Prototype Package Details - Solution View\" /></p>\n\n<p>Solution view will present the familiar project hierarchy to allow you to work with multiple projects in the solution again.</p>\n\n<ul>\n  <li>The distinct count of package versions across the solution will be reported at the top of the panel</li>\n  <li>Currently installed version will be reported next to each project</li>\n  <li>Multi-select projects with checkboxes at the solution or project folder levels</li>\n  <li>Separate Uninstall and Update buttons</li>\n  <li>Version selector and Update button will update or install the package as necessary in all projects chosen.</li>\n</ul>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>We think these focused changes to address the most common issues that developers have in working with the user-interface will help with their daily workflow.  Additionally, we are continuing to focus on optimizing repository interactions so that this experience is more on-par with the ‘Add Reference’ dialog.</p>\n\n<p>This user interface update is scheduled for our next minor version release, version 3.3  You can follow along with the development on our <a href=\"https://github.com/NuGet/Home/milestones/3.3.0-Beta\">3.3-beta milestone on GitHub</a>  Do you see something in these samples that you like?  Is there something that you think could be improved?  Please comment in the Disqus section below, we appreciate your feedback.</p>\n\n<p>In our next blog post, we will demonstrate how to enhance packages to support modern portable class libraries.</p>\n","Href":"http://blog.nuget.org/20151014/nuget-userinterface.html","RawContent":null},{"Title":"NuGet 3.2.1-RC and NuGet 2.9-RC released","PublishedOn":"2015-10-12T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today we are releasing nuget.exe 3.2.1-RC and NuGet 2.9-RC. A number of issues were identified in both versions that prevented interoperability on Linux and OSX operating systems.  We also made some fixes to 3.2 in order to reduce network utilization.</p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>Below are the top highlights of these releases</p>\n\n<h3 id=\"29-rc\">2.9-RC</h3>\n\n<ol>\n  <li>Now skipping interpreting nuspec documents that are not well formed</li>\n  <li>Corrected an issue that prevented the NuGet extension from loading properly in Visual Studio 2013 Express</li>\n  <li>Improved handling the /r/n characters during network communication from a non-Windows operating system</li>\n</ol>\n\n<p>The complete 2.9 issue list is available in <a href=\"https://github.com/NuGet/Home/issues?q=milestone%3A2.9+is%3Aclosed\">GitHub</a></p>\n\n<h3 id=\"321-rc\">3.2.1-RC</h3>\n\n<ol>\n  <li>Corrected the casing of the NuGet.Config file being read.  This fixes an issue for operating systems with case-sensitive filenames</li>\n  <li>NuGet restore now ignores dnx projects (*.xproj) that should be processed with dnu</li>\n  <li>Improved resource handling when interacting with v2 services</li>\n  <li>Now updating csproj/vcxproj references properly when packages.config is updated</li>\n  <li>Improved handling of packages in the local machine cache that may have gotten corrupted during download</li>\n</ol>\n\n<p>The complete 3.2.1 issue list is available in <a href=\"https://github.com/NuGet/Home/issues?q=milestone%3A3.2.1+is%3Aclosed\">GitHub</a></p>\n\n<h2 id=\"download-from\">Download from</h2>\n\n<p>NuGet 3.2.1 extension for Visual Studio 2015\n<a href=\"https://dist.nuget.org/visualstudio-2015-vsix/v3.2.1-rc/NuGet.Tools.vsix\">https://dist.nuget.org/visualstudio-2015-vsix/v3.2.1-rc/NuGet.Tools.vsix</a></p>\n\n<p>NuGet 3.2.1 command line\n<a href=\"https://dist.nuget.org/win-x86-commandline/v3.2.1-rc/nuget.exe\">https://dist.nuget.org/win-x86-commandline/v3.2.1-rc/nuget.exe</a></p>\n\n<p>NuGet 2.9 extension for Visual Studio 2013\n<a href=\"https://dist.nuget.org/visualstudio-2013-vsix/v2.9.0-rc/NuGet.Tools.vsix\">https://dist.nuget.org/visualstudio-2013-vsix/v2.9.0-rc/NuGet.Tools.vsix</a></p>\n\n<h3 id=\"whats-next\">What’s next</h3>\n\n<p>We are working through a number of changes to the Visual Studio 2015 user interface and to improve the upload experience to the NuGet.org service in addition to reviewing your feedback and addressing any issues that are presented to us.  Look for a follow-up blog post later this week discussing the planned NuGet User Interface improvements.</p>\n","Href":"http://blog.nuget.org/20151012/nuget-3.2.1-rc.html","RawContent":null},{"Title":"NuGet 3 - What and Why?","PublishedOn":"2015-10-08T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Since Visual Studio 2015 was released in July, developers have started using a new version of NuGet, NuGet 3  We decided to introduce a number of significant changes based on feedback from the community.  With any major version change, some things break… and usually for a good reason.  We have bugs and issues that we are addressing and want to share what the plan was for versions 3.x and what the plan is for the future.</p>\n\n<p>The NuGet 2.x code base proved to be tightly coupling user interface and protocol. NuGet 3 included a major rewrite of the code base to allow for supporting the new V3 nuget server Protocol.</p>\n\n<h2 id=\"user-interface-changes\">User Interface Changes</h2>\n<p>The most noticeable change to the NuGet client is the updated user interface.  This is also the feature that has brought the most feedback.  What was changed? The only thing that changed was everything… this is a complete rewrite of the Visual Studio interface for NuGet, bringing new features and dropping other features.</p>\n\n<table>\n<tr>\n<td width=\"500\">\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/Vs2013.png\" />\n<br />\n<b>Before:</b> NuGet User Interface in Visual Studio 2013\t \n</td>\n<td width=\"500\">\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/Vs2015.png\" />\n<br />\n<b>After:</b> NuGet User Interface in Visual Studio 2015\n</td>\n</tr>\n</table>\n\n<p>Let’s review some of the items that were changed and what user feedback drove the change:</p>\n\n<h3 id=\"the-good\">The Good</h3>\n\n<ul>\n  <li>The NuGet window was changed to a docked window to allow continued work on other tasks in Visual Studio while packages are being installed</li>\n  <li>Package version selector was introduced to allow more control over which packages to install and manage, allowing explicit control of package versions in projects.  This also helps to prevent inadvertent breaks with new major package versions.</li>\n  <li>Visibility controls were introduced for the preview window because developers didn’t want to be distracted by this information and wanted to continue working without interruption.</li>\n  <li>The file conflict action combobox was added to allow control over how project content should be handled when a content package is installed or updated.  Content packages provide a dual purpose of scaffolding initial content or bringing libraries that were not intended to be changed.  With this configuration option, you can control what action NuGet should take when installing or updating packages that have existing files in your project that it would like to overwrite.</li>\n  <li>The Update Available indicator is introduced to allow you to work in any filtered view, and still know what packages your project has installed and what may need to be updated.<br />\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/UpdateIndicators.png\" alt=\"Update indicators in the package list\" /></li>\n</ul>\n\n<h3 id=\"the-bad\">The Bad</h3>\n\n<ul>\n  <li>The ‘All Sources’ package source was very hard to use, and the search results were not clear that were presented in the package list.  We are making changes to how this functions and is presented, hoping to reintroduce in a future release.</li>\n  <li>Package sources and states were converted to a pair of comboboxes to make it more of a filter action that leads to the search on the right side of the screen, similar to how many websites provide search capabilities.  This is confusing as the filter controls operate independently of each other.\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/Filters.png\" alt=\"Package Filters\" /></li>\n</ul>\n\n<h3 id=\"the-ugly\">The Ugly</h3>\n\n<ul>\n  <li>The introduction of an ‘Action’ combobox and button brings a context to the right panel that is not intuitive or discoverable.  We hear that when the action combobox is configured with a default value, developers can have difficulty locating alternate actions to take with the package.  In the prior user interface, all actions were made available as individual buttons that were easy to locate.\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/ActionCommand.png\" alt=\"Action Combobox and button\" /></li>\n</ul>\n\n<p>All in all, a number of really important updates for the user interface that added functionality.  However, we know that this hindered workflow for some developers.  We’re revisiting those decisions and in our next blog post, we’ll discuss what updates are being made.</p>\n\n<h2 id=\"update-all\">Update All</h2>\n\n<p>The most significant removal from the NuGet user-interface was that ‘Update All” was removed. After hearing from developers who were concerned about breaking changes introduced by a significant number of packages that were updated in their project, this button was not included in the revision.  When there are a number of major package changes, developers found the resultant projects difficult to work with due to the number of breaking changes introduced by updated packages.</p>\n\n<p>However, we also hear feedback from developers with more than 100 projects in a solution and are not able to update all of their packages quickly.  The ‘Update All’ button is a significant help to these developers, and they experience a significant delay in their workflow when they need to update each package individually.  For advanced users who prefer the Powershell console, the Update-Package command still provides ‘Update All’ functionality.  We understand that having this in the user-interface is important to many developers and we’re going to bring back the Update All button in our next user-interface update, scheduled for later this Fall.</p>\n\n<h2 id=\"nuget-v3-protocol\">NuGet v3 Protocol</h2>\n<p>The NuGet.org service was based on an open WCF data service that allowed for virtually unlimited open-ended queries against a SQL database.  The database server was at capacity and we were unable to scale it further without changing the implementation of the service.  The new protocol was designed to be more responsive and be able to operate across content-delivery networks without communicating to a central database server.  Package detail pages could be stored in a static JSON format on the web server and replicate across the NuGet CDN along with the packages.  This would allow for developers to get updates to their packages from local edge nodes without querying the central NuGet.org service which is designed to reduce latency.</p>\n\n<p>In practice over the last 4 months, we have seen a reduction in NuGet.org server resources and a dramatic increase in the utilization of the CDN.  From our telemetry, all regions that are using the new NuGet v3 protocol are experiencing a performance improvement.  Since the beginning of the year, we see major improvements in server response, even though download traffic has doubled over the last 10 months.<br />\n<img src=\"../images/2015-10-08-NuGet-3-What-and-Why/Downloads.png\" alt=\"Download Counts Over the Last 12 Months\" /></p>\n\n<h2 id=\"solution-level-packages\">Solution Level Packages</h2>\n<p>Solution packages were deprecated with this version of NuGet.  Why?  What do they bring to the feature set?  These packages typically did not deliver references for a project, but rather tools that could be shared among several projects.  Currently in Visual Studio 2015, these packages can be installed into a project that will be shared in the solution.  We now understand that this took some developers by surprise and it prevents solutions from being worked on with both Visual Studio 2013 and 2015.  We have a <a href=\"https://github.com/NuGet/Home/issues/1521\">tracking issue opened</a> that addresses this issue, and we are going to schedule it for a future release.</p>\n\n<h2 id=\"introducing-projectjson\">Introducing Project.JSON</h2>\n\n<p>For supporting .NET Core that comes with the Universal Windows Platform SDK and ASP.NET 5, we wanted to take several steps to address common questions and concerns that developers had with building applications that referenced NuGet packages.  We have introduced the project.json configuration file initially in ASP.NET 5 and Universal Windows Platform projects.  This was a chance to start these new project types with a package reference model that could address several significant concerns that developers shared with us:</p>\n\n<ul>\n  <li>Packages.config file would no longer described the developer’s intent of the packages they wanted to install once dependent packages are added.</li>\n  <li>Installing packages would modify the csproj/vbproj file and prevent it from being easily moved on disk and having a consistent experience in Visual Studio.</li>\n  <li>Support the ability to deliver .NET Core as packages</li>\n  <li>Developers who mixed updating packages from a command-line and from the Visual Studio interface would realize different changes to their project.  This made it difficult to configure and maintain continuous integration environments.</li>\n</ul>\n\n<p>Introducing a new package reference model allowed us to address these issues by bringing a new format that more closely aligned with helping a developer with a project, and not modifying the project for them.  This model could be introduced for the new Universal Windows Platform projects, and not affect other project types who could continue operating with the existing NuGet packages.config model.  Existing projects and project types that operate with packages.config and not project.json are not be subject to the following changes.</p>\n\n<h3 id=\"transitive-dependency-support\">Transitive Dependency Support</h3>\n<p>To better show a developer’s intent, we created the project.json dependencies feature where developers can directly reference only those packages that they need in their project.  Any dependencies are automatically discovered and restored without needing to explicitly document those references in project.json</p>\n\n<p><img src=\"../images/2015-10-08-NuGet-3-What-and-Why/projectJsonPackagesConfig.png\" alt=\"Project.JSON dependencies vs. Packages.config\" />\n<br />\n<strong>Project.json for a UWP project and a simulated packages.config showing some of the packages that would be referenced in the same project</strong></p>\n\n<p>The result is that you need to manage less package references and skip dealing with potential circular reference problems.</p>\n\n<h3 id=\"global-packages-folder\">Global Packages Folder</h3>\n<p>With Project.JSON managed projects, there is now a packages folder that is shared for all projects that you work with.  Packages are downloaded and stored in the <code class=\"highlighter-rouge\">%userprofile%\\.nuget\\packages</code> folder.  This means that if you are working on multiple UWP projects on your workstation, you only have one copy of the EntityFramework package and its dependencies on your machine.  All .NET projects will acquire package references from this global shared folder.  This also means that when you need to configure a new project, your project will not take time starting so that it can download a fresh copy of EntityFramework.nupkg   Instead, it will simply and quickly reference the files you have already downloaded.  ASP.NET 5 uses the <code class=\"highlighter-rouge\">%userprofile%\\.dnx\\packages</code> folder and as that framework nears completion it will use the <code class=\"highlighter-rouge\">%userprofile%\\.nuget\\packages</code> folder as well.</p>\n\n<h3 id=\"powershell-install-and-uninstall-scripts\">Powershell Install and Uninstall Scripts</h3>\n<p>Powershell script support was modified to no longer execute install and uninstall scripts, but init scripts are still executed.  Some of the reasoning for this is the inability to determine which package scripts need to be run when not all packages are directly referenced by a project.  Without an explicit install or uninstall for a dependency package, it is impossible to determine when these scripts should be run.  We do not believe there is a reliable and repeatable way to execute these scripts in this package reference model.  Additionally, as we want to ensure that NuGet provides a repeatable experience on the command-line this forces packages to run without script capabilities.  We plan to introduce features to address many of the common tasks that scripts provided.</p>\n\n<p>Additionally, running NuGet outside of Visual Studio at the command-line or on other operating systems cannot execute these Powershell scripts as they relied on Visual Studio automation.  Powershell is in NuGet to provide a shim to allow for missing features to run inside of Visual Studio.  Moving forward, we plan to introduce these features to provide this functionality.  Finally, many of these scripts relied on Visual Studio APIs that could break across versions of Visual Studio.</p>\n\n<h3 id=\"configuration-file-transforms\">Configuration File Transforms</h3>\n<p>Configuration file transforms are not typically re-runnable against a project.  In the indirect package reference model, NuGet does not know if a configuration transform has been applied to a project reliably.  To prevent these transforms from being executed multiple times against the same project, this feature was dropped.</p>\n\n<h3 id=\"content-packages\">Content Packages</h3>\n<p>With indirect package references, it is also not clear how to handle the content that may be delivered.  When a package is updated, does the content of the indirect references need to be re-copied into the project?  What happens to the files and content that a developer was maintaining in their project?  Without a reliable answer to these questions, we cut this feature in the short term, and are working to define a proper feature to deliver this functionality.  Follow our <a href=\"https://github.com/NuGet/Home/wiki/Bringing-back-content-support,-September-24th,-2015\">discussion on GitHub</a> to learn more about the new feature.</p>\n\n<h2 id=\"looking-forward\">Looking Forward</h2>\n<p>These changes that were introduced means that package authors and package consumers have some new decisions to make and new features to explore.  We plan to provide more details on these topics in the weeks ahead.  We will discuss the upcoming changes to the user interface, post walk-through tutorials demonstrating how to build new packages that target the Universal Windows Platform and how to update existing packages to make them available to the Universal Windows Platform.</p>\n\n<h2 id=\"summary\">Summary</h2>\n<p>We hope this gives you some insight into some of the decisions that were made to advance the NuGet product.  All of the changes were made with the hopes that they would reduce complexity and prevent any compatibility issues with new frameworks and features required by project systems that NuGet would support.  In our next post, we’ll discuss further the NuGet user interface, review some of your feedback, and explore the decisions around the updates that are coming.</p>\n","Href":"http://blog.nuget.org/20151008/NuGet-3-What-and-Why.html","RawContent":null},{"Title":"Package Content and Removals","PublishedOn":"2015-10-07T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet community is awesome; involved and eager to build software to make it easy for use in bigger projects that the components and libraries that they themselves are building.  Every now and again, community members can get a little too eager.  This post is going to address a recent issue that was presented to the NuGet.org administrators.</p>\n\n<p>In the <a href=\"https://www.nuget.org/policies/Terms\">terms of use</a> for the NuGet.org service:\n“<em>You may not upload or transmit any material that infringes or misappropriates any person’s copyright, patent, trademark, or trade secret, or disclose via the Website any information the disclosure of which would constitute a violation of a confidentiality obligation on your part.</em>”</p>\n\n<p>This is a legal disclaimer to protect both package and software authors from unauthorized copying and distribution.  Vendors who sell their software or provide paid customer support take special care with how their product is distributed, and many vendors who work with NuGet.org want to ensure that a proper quality package that they maintain is available for their customers.  They also want to prevent their customers from finding and using packages with similar names and branding that could be confused as their own.</p>\n\n<p>A number of packages were identified by <a href=\"http://www.oracle.com\">Oracle</a> that contained their software or were constructed in a way to appear as though Oracle produced the packages.  In an effort to provide the highest level of service for their customers, and to prevent Oracle customers from acquiring software that was not produced by Oracle, we have granted their request to remove these packages from the NuGet.org service.  If you are looking for the official Oracle software, they ask that you please download the <a href=\"https://www.nuget.org/packages/Oracle.ManagedDataAccess/\">Oracle.ManagedDataAccess</a> package or the <a href=\"https://www.nuget.org/packages/Oracle.ManagedDataAccess.EntityFramework/\">Oracle.ManagedDataAccess.EntityFramework</a> package to work with the Oracle database using Entity Framework.</p>\n","Href":"http://blog.nuget.org/20151007/Package-Content-and-Removals.html","RawContent":null},{"Title":"Why did my package download count suddenly go up","PublishedOn":"2015-09-30T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Last week, we released our <a href=\"/20150924/Revised-Download-Counts-and-Package-Statistics.html\">Revised Download Counts and Package Statistics</a> that are now based on the raw logs of our CDN. For this to become reality, we had to also import data from our old statistics data warehouse into the new system. As it turns out, we overlooked something very important: in the old system (and by importing data, also in the new system), NuGet download counts did not reflect non-normalized package versions. Today, we’re taking these downloads into account as well, resulting in an increase in package downloads for many NuGet packages that have been in the NuGet gallery for a long time.</p>\n\n<p>Our old statistics warehouse contained download facts for non-normalized versions, whereas all of our services only take normalized versions into account. The normalized version standardizes the version formats in use and makes querying and comparing packages easier. Say a package has version 2.0.0.0, we normalize that version into 2.0.0 and work with that version number instead. The same goes for 2.0 which becomes 2.0.0, essentially considering 2.0.0.0 and 2.0 as the same version. Another example would be version 1.2.3.0115, which is normalized as 1.2.3.115.</p>\n\n<p>Unfortunately, the old statistics warehouse was never updated when we started normalizing version numbers. The result of this change a few years ago was that the NuGet gallery no longer listed the correct number of package downloads, which we are now fixing with this update.</p>\n\n<h2 id=\"can-you-explain-that-again\">Can you explain that again?</h2>\n<p>As an example, take <a href=\"https://www.nuget.org/packages/NLog/\">NLog</a>, and more specifically its <a href=\"https://www.nuget.org/packages/NLog/3.0.0\">version 3.0.0</a>. If we download the package and open its nuspec file (e.g. with <a href=\"http://npe.codeplex.com/\">NuGet Package Explorer</a>), we can see it was published as version 3.0.0.0. That also means at one time, users were downloading version 3.0.0.0 until we switched our infrastructure to work with the normalized 3.0.0 instead. Here are the download counts for this package that we had in our old statistics warehouse:</p>\n\n<ul>\n  <li>NLog 3.0.0 - 42160 downloads</li>\n  <li>NLog 3.0.0.0 - 25531 downloads</li>\n</ul>\n\n<p>Before the change we will be doing this week, the NuGet gallery would show 42,160 as the download count as we can see in the image below. This is only the download count for version 3.0.0, however. After this change, we converted all downloads for version 3.0.0.0 into downloads for version 3.0.0, consolidating both counts to a total download number of 67,691 downloads for this package.</p>\n\n<p><img src=\"/images/2015-09-30-download-counts/example.png\" width=\"540\" /></p>\n\n<p>We have been hard at work to convert these old, historic downloads to also have normalized versions, which makes them visible to all of our systems now. This does mean many packages will see an increase in their number of downloads. It also means download numbers are now displaying the correct download number for packages that have been in NuGet since a long time.</p>\n","Href":"http://blog.nuget.org/20150930/Why-did-my-package-download-count-suddenly-go-up.html","RawContent":null},{"Title":"Meet the new NuGet status page","PublishedOn":"2015-09-28T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>On the server side we are working on boosting performance, scalability and reliability. We were also in need of a new status page to better communicate the status of the service. Without further ado: meet the new <a href=\"http://status.nuget.org\">status.nuget.org</a>!</p>\n\n<p><img src=\"/images/2015-09-28-Meet-the-new-NuGet-status-page/new-status-page.png\" alt=\"The new NuGet status page\" style=\"width: 100%\" /></p>\n\n<p>We’re happy with this new incarnation of our status page. It not only shows whether individual services are up or not, it also adds some insights in our back-end jobs like search indexing. And when we want to communicate written context about potential issues, we can now do so as well.</p>\n\n<h2 id=\"services-status\">Services status</h2>\n<p>The question we get when we have a production service issue is the one which is displayed in a prominent position on the status page: is NuGet up or not? All our status checks are aggregated into one status which immediately tells users of our status page what is going on.</p>\n\n<p><img src=\"/images/2015-09-28-Meet-the-new-NuGet-status-page/service-status-summary.png\" alt=\"Status summary - is NuGet up or not\" style=\"width: 100%\" /></p>\n\n<p>One of the key elements that we kept from the previous status page is the services status. Where our old status page just showed indivivual checks, we decided to show the current status of individual NuGet features. By clicking a particular feature we can see more details of the individual services that contribute to that feature, including their datacenter region when applicable.</p>\n\n<p><img src=\"/images/2015-09-28-Meet-the-new-NuGet-status-page/service-status-drill-down.png\" alt=\"Status drill down shows status per feature\" style=\"width: 100%\" /></p>\n\n<h2 id=\"insight-into-back-end-jobs\">Insight into back-end jobs</h2>\n<p>NuGet is not only front-end. Package uploads are a separate service. We also have several jobs running in the background - for example our indexing job. The index lag chart shows the time it takes for a new package to show up in the index. The lower the time, the faster new packages are available for consumption.</p>\n\n<p><img src=\"/images/2015-09-28-Meet-the-new-NuGet-status-page/chart-index-lag.png\" alt=\"Charts for various back-end jobs\" style=\"width: 100%\" /></p>\n\n<h2 id=\"additional-context-through-status-messages\">Additional context through status messages</h2>\n<p>When we detect a potential issue with the NuGet services, we are now able to comminicate about it through the status page. Whenever there’s a “hot” issue, we will show additional context about the issue at the top of the status page.</p>\n\n<p><img src=\"/images/2015-09-28-Meet-the-new-NuGet-status-page/communication-via-status-posts.png\" alt=\"Issue status messages\" style=\"width: 100%\" /></p>\n\n<p>Older messages are shown near the bottom of the page. Messages are visible for one week.</p>\n\n<p><img src=\"/images/2015-09-28-Meet-the-new-NuGet-status-page/historic-messages.png\" alt=\"Older status messages\" style=\"width: 100%\" /></p>\n\n<p>With this new status page we now can provide more insight into the status of the various services that serve NuGet features and provide more accurate details on potential issues through status messages.</p>\n","Href":"http://blog.nuget.org/20150928/Meet-the-new-NuGet-status-page.html","RawContent":null},{"Title":"Revised Download Counts and Package Statistics","PublishedOn":"2015-09-24T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the last few months we have been hard at work on the <a href=\"https://nuget.org\">NuGet.org</a> backend. One of the things we’ve done is switch to a new CDN. This work is all about reinforcing the foundations of nuget.org so we provide a better service experience and be in a position to build new features reliably. As a result we’re happy to announce <a href=\"https://www.nuget.org/stats\">package statistics are back</a>!</p>\n\n<p>From the NuGet gallery, we can see various statistics and trends in package downloads (for the last 6 weeks).</p>\n\n<p><img src=\"../images/2015-09-24-revised-download-counts/download-stats.png\" alt=\"NuGet download statistics\" /></p>\n\n<p>We can drill down to individual packages and get details on the number of downloads per package version, NuGet client name and even the operation. This allows us to compare the volume of new package installs to package restores.</p>\n\n<p><img src=\"../images/2015-09-24-revised-download-counts/operations-for-package.png\" alt=\"Package operations\" /></p>\n\n<p>Package statistics allow package authors to get an idea of how many times their package was downloaded. As a package consumer, we can look at the download counts to see if a particular package is being used by just a few developers, or the world.</p>\n\n<h2 id=\"background\">Background</h2>\n<p>With more and more developers starting to use NuGet in their workflow, we saw an increase in downloads, load and stress on our servers.</p>\n\n<p>Back in April we identified that a key place the stress was coming from was package statistics. Every package download would write a log entry into the database, then redirect to our CDN. Writing this log entry would, depending on the amount of users hitting the NuGet feed, often block or timeout, resulting in unhappy developers worldwide. As a quick fix, we made a calculated compromise that affected package owners by disabling this logging.</p>\n\n<p>We quickly re-enabled package download tracking, but disabled the statistics reports. This means we still collected data on the “side”, confident of not losing historical information, but keeping the server healthy for the package consumers audience.</p>\n\n<h2 id=\"how-we-track-package-downloads\">How we track package downloads</h2>\n<p>Fast-forward a few months, and we redesigned the way we collect package download information. Our main goal was to reduce churn on the gallery database. As a matter of fact, we decided to remove downloads information from the main database altogether.</p>\n\n<p>A first step towards getting package statistics back was switching CDN providers. With the Azure CDN, we are able to collect raw request logs from the various CDN nodes around the world. There is a small delay in getting these request logs, but since we can trust the CDN to keep track of download information such as the package URL and NuGet client version, we no longer have to log this information ourselves.</p>\n\n<p>A second step, of course, was parsing these logs. There are a number of good and fast libraries out there that can parse the W3C log file format we get from the CDN. Parsing is one thing, but cleaning up data a second thing. We spent a lot of time parsing gigabytes of logs each day, analyzing the incoming data. We’ve seen weird requests that we didn’t want to keep track of - some developers seem to have configured NuGet as a Maven source. We’ve seen crazy values in user agent strings and request URLs in general.</p>\n\n<p>Once we were confident we could filter out the required information from these logs, we started working on a new data warehouse where each download is linked to various dimensions like date and time, client version, package id and so on. From this warehouse, we can now generate download counts displayed on the NuGet gallery and in Visual Studio, the various statistics shown on the website and so on.</p>\n\n<p>Of course, that’s not all. We wanted to keep the “old” data, which we had to import into our new data warehouse. After trying several approaches (querying and matching), we found that the cleanest way would be to import the old data as a W3C log file itself. We exported the old warehouse into a few gigabytes of logs, and let our newly created ingestion jobs crunch them into facts.</p>\n\n<p>In the meanwhile, we looked at what would be the best way to get these numbers into the NuGet website. For statistics this was an easy task: we could generate the same files the gallery has always served statistics from. More complex was the use of the <code class=\"highlighter-rouge\">DownloadCount</code> from our gallery database all over the place. We built a <a href=\"https://github.com/NuGet/NuGetGallery/commit/dca16252946f0728677b8a5f344b95721f79d5ac\">thin interception layer</a> that sets the download counts from the same source our V3 search engine uses. We also had some raw SQL queries to replace for the autocomplete feature in the VS2013 Package Manager Console - which we now <a href=\"https://github.com/NuGet/NuGetGallery/commit/764ce67c1680df04ee570c9156eaac9d20cb5550\">forward to the V3 API</a>.</p>\n\n<h3 id=\"why-are-some-numbers-different-from-before-how-reliable-are-these-statistics\">Why are some numbers different from before? How reliable are these statistics?</h3>\n<p>While analyzing the data we have in our statistics warehouse, we found that there is a large number of user agents that should not be represented in download counts and statistics. One example of clients types which we now exclude are search engine crawlers. This change makes the numbers now represent actual package consumption.</p>\n\n<p>All of these changes now provide reliable statistics, and can be used to build out new features going forward. By leveraging the CDN request logs, we can now also track downloads that are made by DNX, as it never used the gallery endpoints anyway. Load on our main gallery database dropped significantly, resulting in a faster and more stable NuGet.org experience.</p>\n\n<p>Thanks folks for being so patient with us on this.</p>\n","Href":"http://blog.nuget.org/20150924/Revised-Download-Counts-and-Package-Statistics.html","RawContent":null},{"Title":"Accelerate your network share hosted Package Source","PublishedOn":"2015-09-22T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>This is a guest blog, by Andrew Arnott from the Visual Studio team. Andrew was having performance issues with NuGet updating or installing packages from a UNC share. These issues where well known, and our solution in the past was to point people to http servers. We discussed this issue with Andrew and suggested that the new supported folder structure introduced in NuGet 3 and in 2.8.7 should resolve the issue.</p>\n\n<p>This blog is the result of Andrew’s experiments with the structure in his project.</p>\n\n<p>(The NuGet team)</p>\n\n<h2 id=\"accelerate-your-network-share-hosted-package-source\">Accelerate your network share hosted Package Source</h2>\n\n<p>NuGet is fairly flexible in where you set up your package sources. Besides the default nuget.org web service, you can set up alternate package sources at other HTTP URLs such as myget.org or your own NuGet server and even local directories on your hard disk or network UNC shares like \\yourserver\\nuget. When using a network share as your package store, there is a really fast and a really slow way to do it. In this post, we’ll review the two options and help you accelerate your network share based package store if you’re doing it the slow way.</p>\n\n<p>Why would you want to set up a custom package source? There are a variety of reasons. Here are just a couple:</p>\n\n<ol>\n  <li>You want to use NuGet packages to share code internally without exposing them publicly on nuget.org</li>\n  <li>You have a continuous build server that produces nuget packages that you want to consume before releasing to nuget.org</li>\n</ol>\n\n<h3 id=\"custom-package-sources\">Custom package sources</h3>\n\n<p>First, let’s review how you set up a custom package source. You can do this using the Visual Studio NuGet extension UI, but if you’re using source control among a team or multiple machines, you’ll want to check in a nuget.config file that adds your custom package source so that everyone who checks out your source code, including any automated builds you have set up, will be able to restore your packages.</p>\n\n<p>Create a nuget.config file with this content, and check it in at the root of your source tree:</p>\n\n<pre>\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;configuration&gt;\n  &lt;packageSources&gt;\n    &lt;add key=&quot;YourServer&quot; value=&quot;\\\\yourserver\\NuGet&quot; /&gt;\n  &lt;/packageSources&gt;\n&lt;/configuration&gt;\n</pre>\n\n<p><a href=\"http://docs.nuget.org/consume/nuget-config-file\">Learn more about setting up a nuget.config file.</a></p>\n\n<h3 id=\"set-up-your-package-source-the-simple-way\">Set up your package source: the simple way</h3>\n\n<p>Now that we have our source tree prepared to restore packages from your network share, we need to get that network share up and going. After creating the directory on the network server and setting up permissions, it’s time to fill it with packages.</p>\n\n<p>The simplest way to set up a package store, whether on your local hard disk or on a network share, is to just drop all your .nupkg files into the same directory, as a flat list of files. For example, when using a network share a file listing may look like this:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\\\\yourserver\\nuget\\PackageA.1.0.0.nupkg\n\\\\yourserver\\nuget\\PackageA.1.0.1.nupkg\n\\\\yourserver\\nuget\\PackageA.1.0.2.nupkg\n\\\\yourserver\\nuget\\PackageB.0.0.1-beta.nupkg\n\\\\yourserver\\nuget\\PackageB.0.0.1.nupkg\n\\\\yourserver\\nuget\\PackageB.0.0.2-rc.nupkg\n</code></pre></div></div>\n\n<p>“Pushing” to this package source is as simple as copying a .nupkg you’ve built to that network directory.</p>\n\n<p>That’s it. Now the NuGet client can install and restore packages in your projects from this location.</p>\n\n<p>But it turns out that this doesn’t scale well. Package Restore tends to perform well in this configuration, but as the number of your packages grow, installing and updating packages in projects that use this package source can get very slow. The NuGet client has to download huge numbers of .nupkg files as it evaluates which package(s) need to be installed to find those that are version compatible with each other. This can make a simple package install or upgrade take several minutes (or longer), and download gigabytes of packages in the process.</p>\n\n<h3 id=\"set-up-your-package-source-the-fast-and-scalable-way\">Set up your package source: the fast and scalable way</h3>\n\n<p>The most performant upgrade you can make to your network share to boost performance is setting up <a href=\"http://docs.nuget.org/create/hosting-your-own-nuget-feeds#creating-remote-feeds\">a full scale NuGet package server</a> of your own. But suppose you can’t or don’t want to go to that trouble at this point, and just want to give your network share a big performance boost in just a few minutes. Here’s how you can do it.</p>\n\n<p>It turns out that when the NuGet client downloads those gigabytes of .nupkg files during package install or update, it only needs to look at a few small files in the package. Setting up your network share so that these files can be accessed by themselves without downloading the whole package makes a world of difference. This requires that we stop directly copying the .nupkg package to the network share and instead use the nuget add command available in <a href=\"https://dist.nuget.com/index.html\">nuget 3.3</a>.</p>\n\n<p>Before NuGet 3.3 was released you could have used these PowerShell <a href=\"https://gist.github.com/AArnott/45d884642684046c81cb\">Publish-Package</a> cmdlet to push the packages to the network share:</p>\n\n<div class=\"language-powershell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Publish-Package <span class=\"s2\">\"c:\\path\\to\\yourpackage.0.0.1-beta.nupkg\"</span> -PackageSource <span class=\"s2\">\"\\\\yourserver\\nuget\"</span>\n</code></pre></div></div>\n\n<p>This creates a different layout on your network share than a simple copy:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\\\\yourserver\\nuget\\\n\tyourpackage\\\n\t\t0.0.1-beta\\\n\t\t\tyourpackage.0.0.1-beta.nupkg\n\t\t\tyourpackage.nuspec\n\t\t\tyourpackage.0.0.1-beta.nupkg.sha512\n</code></pre></div></div>\n\n<p>Notice the .nupkg archive itself is still there, but it is also has the .nuspec file pre-expanded and package hash readily accessible. Also notice that all the files are within a folder structure named after the package ID and version. As you push more packages, you’ll end up with multiple version folders within your package ID folder.</p>\n\n<p>Also note that the version portion of the path has to be normalized for nuget to find it, the nuget init and add commands will normalize it for you. For example yourpackage.1.0.0.0 will create a normalized version folder of 1.0.0 (and not 1.0.0.0)</p>\n\n<h4 id=\"migrate-an-existing-flat-nupkg-file-list-to-the-new-layout\">Migrate an existing flat .nupkg file list to the new layout</h4>\n\n<p>This can be done with the nuget.exe init command in <a href=\"https://dist.nuget.com/index.html\">NuGet 3.3</a></p>\n\n<p>Pre NuGet 3.3 you can use the following <a href=\"https://gist.github.com/AArnott/45d884642684046c81cb\">Upgrade-PackageSource</a> PowerShell cmdlet:</p>\n\n<div class=\"language-powershell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Upgrade-PackageSource \\\\yourserver\\nuget\\packages \\\\yourserver\\nuget\\packages3\n</code></pre></div></div>\n\n<h4 id=\"how-much-faster-is-this-new-file-layout\">How much faster is this new file layout?</h4>\n\n<p>In my tests on a network share before and after migration, here are the results:</p>\n\n<style>\ntable, th, td {\n    border: 1px solid black;\n    border-collapse: collapse;\n}\nth, td {\n    padding: 5px;\n}\n</style>\n\n<table>\n  <thead>\n    <tr>\n      <th></th>\n      <th>Before</th>\n      <th>After</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td># of files</td>\n      <td>5,236</td>\n      <td>15,708</td>\n    </tr>\n    <tr>\n      <td># of packages</td>\n      <td>5,236</td>\n      <td>5,236</td>\n    </tr>\n    <tr>\n      <td>Space consumed on server</td>\n      <td>1.425 GB</td>\n      <td>1.432 GB</td>\n    </tr>\n    <tr>\n      <td>Update-Package x -Version y: time to execute</td>\n      <td>4:33</td>\n      <td>0:23</td>\n    </tr>\n    <tr>\n      <td>Update-Package x -Version y: MB downloaded</td>\n      <td>963 MB</td>\n      <td>5.6 MB</td>\n    </tr>\n  </tbody>\n </table>\n\n<p>Your results of course will vary, based on the number of package IDs, versions per package, the size of your packages, and their inter-dependencies.</p>\n\n","Href":"http://blog.nuget.org/20150922/Accelerate-Package-Source.html","RawContent":null},{"Title":"Announcing the NuGet 3.2 release","PublishedOn":"2015-09-16T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today we are publishing the version 3.2 updates to the NuGet clients.  We took customer feedback regarding issues and feature direction and assembled this release to address those immediate concerns. There are fixes available for a number of blocking issues and adds support for push and list for compliant V3 servers.  We also added support for the command line client to interact with v3 servers as well as project.json managed projects.  You can download the updates to both the <a href=\"http://dist.nuget.org/index.html\">nuget.exe command-line tool</a> and the <a href=\"https://visualstudiogallery.msdn.microsoft.com/5d345edc-2e2d-4a9c-b73b-d53956dc458d?SRC=Home\">Visual Studio 2015 extension</a>.</p>\n\n<p>We also decided to increment the version of nuget.exe (NuGet command line) to 3.2 to match the release of the Visual Studio Extension.  Both of these clients use the same core functionality, and we want to continue to publish them together.  By aligning version numbers, we are communicating that they have matching feature sets.</p>\n\n<p>Some of the NuGet 3.2 features related to project.json are depending on the win tools 1.1 release from today <a href=\"https://social.msdn.microsoft.com/Forums/en-US/e9df01f6-1474-4a4e-98fc-2567591c764f/update-11-release-notes-and-installation-instructions\">available</a></p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>Below are the top highlights of this release.  Detailed <a href=\"http://docs.nuget.org/release-notes/nuget-3.2\">release notes for v3.2</a> are available.</p>\n\n<h3 id=\"command-line\">Command line</h3>\n\n<ol>\n  <li>Improve handling of authenticated feeds, and provide support for authenticated V3 feeds.</li>\n  <li>Improve handling of network failures.</li>\n  <li>Support list and push command against V3 feeds.</li>\n  <li>Added Msbuild version selection support.</li>\n  <li>Support for restoring packages in project.json managed projects</li>\n</ol>\n\n<h3 id=\"visual-studio-extension\">Visual Studio Extension</h3>\n\n<ol>\n  <li>Improved handling of authenticated feeds, and added support for V3 authenticated feeds.</li>\n  <li>Fixed issues with network connectivity failures. *</li>\n  <li>Added restore context menu. This enables turning off “on build restore” or forcing a restore without building.</li>\n  <li>Improved logging *</li>\n  <li>Fixed issues for projects with linked app.config and web.config.</li>\n  <li>Added support for multiple csproj in one folder with project.json.</li>\n  <li>Fixed: NuGet in VS 2015 ignores disableSourceControlIntegration config setting.</li>\n</ol>\n\n<ul>\n  <li>\n    <ul>\n      <li>These are areas we plan to invest more in the upcoming releases.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>the complete list of issues is tracked here <a href=\"https://github.com/nuget/home/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+milestone%3A3.2.0-commandline+is%3Aclosed+-label%3AClosedAs%3ADuplicate\">Command line/NuGet.exe</a> and <a href=\"https://github.com/nuget/home/issues?q=is%3Aissue+is%3Aclosed+-label%3AClosedAs%3ADuplicate+milestone%3A3.2\">Visual Studio Extension</a>.</p>\n\n<h2 id=\"download-from\">Download from</h2>\n\n<p>NuGet extension for Visual Studio\n<a href=\"https://dist.nuget.org/visualstudio-2015-vsix/v3.2.0/NuGet.Tools.vsix\">https://dist.nuget.org/visualstudio-2015-vsix/v3.2.0/NuGet.Tools.vsix</a></p>\n\n<p>You can also update the NuGet extension with the Extensions and Updates feature inside of Visual Studio 2015.</p>\n\n<p>Nuget command line\n<a href=\"https://dist.nuget.org/win-x86-commandline/v3.2.0/nuget.exe\">https://dist.nuget.org/win-x86-commandline/v3.2.0/nuget.exe</a></p>\n\n<h3 id=\"whats-next\">What’s next</h3>\n\n<p>We have a collection of features and fixes that have been identified for our next client release.  Included in this group are minor updates to the NuGet for Visual Studio 2015 user interface and some NuGet.org server updates that should help performance of all clients.  We’ll share a roadmap on a future blog post that outlines the features that are planned.</p>\n\n<p>Over the next few weeks, we will be updating the NuGet.org service with new download statistics based on the traffic across our content delivery network and with reporting optimized to reduce stress on the main NuGet.org services.  Additionally, a new status.nuget.org status page will be published that better demonstrates key metrics, availability of the service, and status messages from the NuGet team.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>With the release of high impact, targeted development items, we are confident that your development experience will improve.  The near future of NuGet is exciting with several new features and several important customer feedback items targeted to be addressed in the Q3 2015 timeframe.  We are also working on improving our documentation and our documentation publication process.  NuGet is now a daily part of many developers process and we are going to continue to push to make it a quick and reliable component of your development effort.</p>\n","Href":"http://blog.nuget.org/20150916/nuget-3.2.html","RawContent":null},{"Title":"NuGet Command line and Visual Studio 2015 Extension 3.2 RC released","PublishedOn":"2015-09-02T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today we are releasing nuget.exe 3.2-RC command line. In addition to fixing a significant number of bugs, support has been added for push and list for compliant V3 servers.</p>\n\n<p>This wave also includes a release of the visual studio extension version 3.2-RC. This version is about addressing top blocking customer scenarios.</p>\n\n<p>The 3.2 RTM release is planned for September, for both nuget.exe and the NuGet extension.</p>\n\n<p>Note: We decided to bump the version of nuget.exe (NuGet command line) to 3.2 to match the release of the Visual Studio Extension.</p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>Below are the top highlights of this release</p>\n\n<h3 id=\"command-line\">Command line</h3>\n\n<ol>\n  <li>Improve handling of authenticated feeds, and provide support for authenticated V3 feeds.</li>\n  <li>Improve handling of network failures.</li>\n  <li>Support list and push command against V3 feeds.</li>\n  <li>Added Msbuild version selection support.</li>\n</ol>\n\n<h3 id=\"visual-studio-extension\">Visual Studio Extension</h3>\n\n<ol>\n  <li>Improved handling of authenticated feeds, and added support for V3 authenticated feeds.</li>\n  <li>Fixed issues with network connectivity failures. *</li>\n  <li>Added restore context menu. This enables turning off “on build restore” or forcing a restore without building.</li>\n  <li>Improved logging *</li>\n  <li>Fixed issues for projects with linked app.config and web.config.</li>\n  <li>Added support for multiple csproj in one folder with project.json (pending release of win 10 tools).</li>\n  <li>Fixed: NuGet in VS 2015 ignores disableSourceControlIntegration config setting.</li>\n</ol>\n\n<ul>\n  <li>\n    <ul>\n      <li>These are areas we plan to invest more in the upcoming releases.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>the complete list of issues is tracked here <a href=\"https://github.com/nuget/home/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+milestone%3A3.2.0-commandline+is%3Aclosed+-label%3AClosedAs%3ADuplicate\">Command line/NuGet.exe</a> and <a href=\"https://github.com/nuget/home/issues?q=is%3Aissue+is%3Aclosed+-label%3AClosedAs%3ADuplicate+milestone%3A3.2\">Visual Studio Extension</a>.</p>\n\n<h2 id=\"download-from\">Download from</h2>\n\n<p>NuGet extension for Visual Studio\n<a href=\"https://dist.nuget.org/visualstudio-2015-vsix/v3.2.0-rc/NuGet.Tools.2015.vsix\">https://dist.nuget.org/visualstudio-2015-vsix/v3.2.0-rc/NuGet.Tools.2015.vsix</a></p>\n\n<p>Nuget command line\n<a href=\"https://dist.nuget.org/win-x86-commandline/v3.2.0-rc/nuget.exe\">https://dist.nuget.org/win-x86-commandline/v3.2.0-rc/nuget.exe</a></p>\n\n<h3 id=\"why-did-we-move-to-the-dist-model\">Why did we move to the dist model?</h3>\n\n<ol>\n  <li>We moved off codeplex and we wanted a new easy-to-find place for the binaries.</li>\n  <li>NuGet 3.2 command line has some breaking changes from NuGet.exe 2.8, and although subtle we didn’t want to break existing users that auto pull the latest version.</li>\n</ol>\n\n<h3 id=\"whats-next\">What’s next</h3>\n\n<p>When we go live with the RTM release we plan to introduce both an html page linked from nuget.org that shows all available downloads, and a most recent version download link (per major version and globally).\nWe later plan to add a json end point to be able to programmatically get the available downloads.</p>\n\n<h2 id=\"what-else-is-going-on-with-the-team\">What else is going on with the team</h2>\n\n<p>We are working on finalizing the RTM releases for the above packages, as well as planning the work for the 3.3 release. Now that most of the critical blockers have been addressed, we started working on the UI update. <a href=\"https://github.com/NuGet/Home/wiki\">UI Design meeting</a> are available here, along with links to discussion and feedback items.</p>\n\n<p>On the server side we are working on boosting performance, scalability and reliability as well as moving the download statistics to a new mechanism that will reduce a large portion of the server stress. We are also finalizing a new status page to better communicate the status of the service. Both of these are in final stages of testing and validation and we hope to deploy them soon.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>Since the last release (3.1.1) in July, we have been focusing on the improving the quality of the NuGet extension. The focus was on high impact, short development items that we felt confident delivering in a shorter release cycle. We are also working on enhancing the documentation towards the RTM release of 3.2 and beyond. We plan to keep investing in the quality push, bug fixes towards the next release, as well as tackle bigger items than we did in this release.</p>\n","Href":"http://blog.nuget.org/20150902/nuget-3.2RC.html","RawContent":null},{"Title":"NuGet 2 code base moves to GitHub","PublishedOn":"2015-08-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the last few months we have constantly moved the issues and all new code base to GitHub. Today we moved the last bits of code from <a href=\"https://nuget.codeplex.com\">CodePlex</a> to <a href=\"https://github.com/NuGet/NuGet.V2\">GitHub</a>. We have stopped monitoring the CodePlex site completely, and will not be taking further looks at reports there or pull requests. As we keep working on NuGet 3.1.2 release for Visual Studio 2015 we will also work on 2.8.7 release with bug fixes for Visual Studio 2013.</p>\n\n<p>The tip branch we compile nuget.core from is the dev branch, this is a change from master we used in CodePlex. The change it to align this repo with the rest of the repos in nuget.org.</p>\n\n","Href":"http://blog.nuget.org/20150811/NuGet2-MoveToGitHub.html","RawContent":null},{"Title":"Announcing NuGet 3.1 with Support for Universal Windows Platform","PublishedOn":"2015-07-29T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today the NuGet team in collaboration with several other teams at Microsoft is happy to announce the release of a new version of the NuGet clients supporting the Universal Windows Platform and the new Portable class libraries. The NuGet tools are available through Tools-&gt;Extensions and Updates-&gt;Update tab in Visual Studio 2015 as well as from our <a href=\"https://github.com/nuget/home/releases\">GitHub repository</a>.  Additionally, we have released a new version of the NuGet command-line tool that you can download from <a href=\"http://dist.nuget.org/win-x86-commandline/v3.1.0-beta/nuget.exe\">NuGet.org</a>.</p>\n\n<p>In this post, we will review the new capabilities that package authors can use and the process that windows programmers need to follow in order to use NuGet with their projects.</p>\n\n<h2 id=\"introducing-projectjson\">Introducing Project.Json</h2>\n\n<p>Beginning with ASP.NET 5, we introduced support for the project.json file to describe the dependencies of a project with a clear definition of the packages that you immediately depend on.  In ASP.NET 5, this is the only file that defines how a project is configured, but with NuGet 3.1, you now use this file in your Universal Windows projects and modern portable class libraries (that target DNX, UWP, and .NET 4.6) to define your package references.  The good news about this is that the ‘Manage Packages’ dialog in Visual Studio will maintain your packages.config or project.json file appropriately for you based on the type of project that you are working on.</p>\n\n<p>This shift from the packages.config model also allows us to “reboot” the references in your projects, and use the new transitive dependency capabilities of NuGet.  We have heard from developers and package authors that when you add packages to your projects that you end up with a packages.config file that gets polluted with dependencies from the packages you depend on.  For example, NHibernate is a package that depends on the Iesi.Collections package.  In packages.config, I have two references, NHibernate and Iesi.Collections.  When I want to update NHibernate, I now have this question of “do I also update Iesi.Collections”?  I also have the opposite problem: if there is an update for Iesi.Collections, do I need to update NHibernate to support the new features in Iesi.Collections?  Developers could end up in this ugly cycle of managing their project’s package dependencies that were brought to them through a package reference.</p>\n\n<p><img src=\"../images/2015-07-29-Introducing-nuget-uwp/cycle.png\" alt=\"The cycle of decisions about updating packages\" width=\"600\" height=\"572\" /></p>\n\n<p>The transitive dependencies feature of NuGet abstracts this decision to update package references with improved support for semantic versioning in package definition files (nuspec documents).  Package authors have been able to <a href=\"http://docs.nuget.org/Create/Versioning#constraining-upgrades-to-allowed-versions\">specify a range of dependency versions that their packages support</a>, but when NuGet clients installed those dependencies they added a hard reference to a specific version in the packages.config file and those referenced packages looked like any other package reference that you added to your project.  A great example of this problem is the contents of a default ASP.NET MVC application’s packages.config file:</p>\n\n<p><img src=\"../images/2015-07-29-Introducing-nuget-uwp/mvcPackagesConfig.png\" width=\"600\" height=\"383\" alt=\"ASP.NET MVC default packages.config file\" /></p>\n\n<p>All of these things are added to my project, but I really just want Microsoft.AspNet.Mvc, Microsoft.AspNet.Identity.EntityFramework, Bootstrap, jQuery and Modernizr.  The other packages referenced by these are noise to me, and I now have hard references to specific versions.  With project.json, the versions of these noisy other packages goes away and I’m left with being able to manage just the five libraries that I will actually use in my project.  The NuGet client will resolve and manage all of these other packages behind the scenes for you, and keep those references within the constraints of the dependent versions declared by the packages that you declared you are using in your project.  This should dramatically simplify the project references experience for developers in their projects.</p>\n\n<p>We also know that developers have a ‘tribe’ of packages and tools that they prefer.  Why download and install them multiple times on a single developer workstation when you clearly already have them in project A and want to use them in project B?  NuGet now downloads and stores a copy of the packages in a global packages folder located in your <code class=\"highlighter-rouge\">%userprofile%\\.nuget\\packages</code> folder.  This should reduce disk space used on your workstation and prevent extra calls to fetch packages from NuGet.org to get items that you already have on disk.</p>\n\n<p>Project.json support is available for ASP.NET with NuGet 3.0, and for other project types starting with NuGet 3.1  More details about how project.json is used with NuGet can be found in the <a href=\"http://docs.nuget.org/consume/ProjectJson-Intro\">NuGet documentation</a></p>\n\n<h2 id=\"deprecated-features\">Deprecated Features</h2>\n\n<p>Starting with NuGet 3.1 when using project.json, we are deprecating support for executing the install.ps1/uninstall.ps1 scripts and delivering elements in the /content folder of packages.  Installing packages that have these elements will not execute the install.ps1 file and will not copy content to your project.  There are several reasons for these decisions:</p>\n\n<p>####Note: install.ps1/uninstall.ps1/content are still supported for projects using packages.config, and will be suppported going forward.</p>\n\n<ul>\n  <li>\n    <p>With transitive package restore picking what to uninstall and install is impossible to do reliably.</p>\n  </li>\n  <li>Similarly content was a mechanism copying content into the user project, when packages are updated there is an implicit uninstall process that cannot be reliably run.</li>\n  <li>\n    <p>NuGet needs to be able to fully support development outside of Visual Studio.  With the movement to support a full cross-platform .NET development experience, we know Powershell is not available in other environments that developers want to work on.  We also know that more developers are working outside of Visual Studio on .NET code, and we need to support those developers.</p>\n  </li>\n  <li>\n    <p>There are other package managers available that deliver a great experience for managing and delivering content.  We know that NuGet is a great package manager for .NET and want to encourage using the right tools for the right job; we believe you should also use those package managers to deliver and manage that content.</p>\n  </li>\n  <li>There is no longer support for the “any” framework, and you can no longer place files directly on the root of the build and lib folders of your package and have them delivered to a project.  It is important that you declare which framework(s) your files support so that NuGet knows the priority order to resolve those references.</li>\n  <li>Solution packages are no longer supported, as these packages are not modifying any specific project’s capabilities and were typically used to deliver shared resources that were re-used across projects.  With the new shared packages folder, these resources may already be on disk from another project.</li>\n</ul>\n\n<p>More details about what features are being deprecated with project.json and recommendations can be found in the <a href=\"http://docs.nuget.org/consume/ProjectJson-Intro\">NuGet documentation</a></p>\n\n<h2 id=\"new-target-frameworks\">New Target Frameworks</h2>\n\n<p>For package authors, another addition with this version of NuGet is support for new development frameworks and improved native package support across operating systems and architectures.  This is an exciting development for NuGet, as we reach further outside of the managed .NET framework model to support more ecosystems and empower our package authors to take their libraries to environments they previously could not reach.</p>\n\n<p>Target framework monikers (TFM) are a shorthand code used in the creation of a package to declare which frameworks binaries support and which dependencies are needed for each framework. You will find folder names in the package’s lib and ref folders that use this notation as well as elements in the package’s nuspec dependencies element that declare a targetFramework attribute with one of the TFM values to direct the NuGet client to deliver an appropriate library to a consuming project.</p>\n\n<p>The following TFMs continue to be available for use and the new TFMs being introduced are listed in the following table:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Description</th>\n      <th>Base Code</th>\n      <th>Available versions</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><b>Managed framework applications (WinForms, Console Applications, WPF, ASP.NET)</b></td>\n      <td>net</td>\n      <td>net11, net20, net35, net35-client, net35-full, net4, net40, net40-client, net40-full, net403, net45, net451, net452, net46</td>\n    </tr>\n    <tr>\n      <td><b>ASP.NET 5</b></td>\n      <td>dnxcore</td>\n      <td>dnxcore50</td>\n    </tr>\n    <tr>\n      <td><b>Windows Store</b></td>\n      <td>netcore</td>\n      <td>win8 = netcore45, win81 = netcore451, uap10.0</td>\n    </tr>\n    <tr>\n      <td><b>Windows Phone (appx model)</b></td>\n      <td>wpa</td>\n      <td>wpa81</td>\n    </tr>\n    <tr>\n      <td><b>Windows Phone (Silverlight)</b></td>\n      <td>wp</td>\n      <td>wp7 = sl3-wp, wp71 = sl4-wp71, sl4-wp, wp8 = wp8-, wp81</td>\n    </tr>\n    <tr>\n      <td><b>Silverlight</b></td>\n      <td>sl</td>\n      <td>sl2, sl3 = sl30, sl4 = sl40, sl5 = sl50</td>\n    </tr>\n    <tr>\n      <td><b>Xamarin</b></td>\n      <td></td>\n      <td>mono, MonoMac, Xamarin.Mac, MonoAndroid10, MonoTouch10, Xamarin.iOS10</td>\n    </tr>\n    <tr>\n      <td><b>Compact Framework</b></td>\n      <td>net-cf</td>\n      <td>net20-cf, net35-cf = cf35, net40-cf</td>\n    </tr>\n    <tr>\n      <td><b>Micro Framework</b></td>\n      <td>netmf</td>\n      <td>netmf41, netmf42, netmf43</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Those items listed with an equals (=) symbol are synonyms that NuGet supports. That’s a lot of support for a lot of different frameworks, and it can get confusing. Do I need to provide support for micro-framework in my managed framework package?  How much Silverlight support do I need? These are questions that you as a package author need to determine to best fit the needs of your package consumers.</p>\n\n<p>You will notice that there is no explicit call to support portable class libraries in the table.  While those combinations of frameworks are supported, we want you to have a more forward-compatible moniker for modern portable class libraries that will give you greater flexibility in the construction of your packages and definition of the frameworks you support.  Starting with NuGet 3.1, we are introducing the dotnet target moniker for modern portable class libraries.</p>\n\n<h3 id=\"dotnet-target-moniker\">dotnet Target Moniker</h3>\n\n<p>In previous versions of NuGet, package authors could specify the frameworks that a portable class library worked with as a collection of TFM abbreviations joined with plus symbols.  You could end up with folder names like “portable-net45+win8+wpa81+wp8” that could be confusing and lead to incompatibility issues for consumers of your package.  To make the portable class library and cross-platform development experience easier for package authors, we are introducing the dotnet moniker.</p>\n\n<p>This moniker is not directly tied to any specific version or framework capabilities, but rather is an indirect reference that tells NuGet: “this is the reference you should use if it supports the framework and runtime capabilities that you have”.  The NuGet client will then investigate that reference to determine what features and frameworks it supports.  This process continues until the NuGet client resolves the exact features supported by the dotnet reference and will then apply it if and only if it matches the features and requirements of your project.  The dotnet moniker can be referenced by .NET Framework 4.5 and later derived framework versions including Xamarin Android and Xamarin iOS.</p>\n\n<p>This doesn’t mean that you can simply build a portable class library (PCL), bundle it up with dotnet dependencies declared and be done.  If you want to be able to support projects using older versions of Visual Studio and NuGet clients that are building with traditional portable class libraries, you should still create and place a reference to the full PCL target framework moniker.</p>\n\n<p>When installing a package into a project type that is fully compatible with consuming the dotnet moniker (.NET 4.6, UWP, or ASP.NET 5), the dotnet moniker will be sought last, after attempting to find a reference that matches the framework or less specific framework of the project you are working on.  This hierarchy walk looks like the following:</p>\n\n<p><img src=\"../images/2015-07-29-Introducing-nuget-uwp/uapProject.png\" alt=\"UAP dependency resolution\" width=\"600\" height=\"532\" /></p>\n\n<p>If your project is a modern PCL using project.json that targets any of these frameworks, and no other framework, then the dotnet moniker will be analyzed first, followed by the standard PCL resolution strategy:</p>\n\n<p><img src=\"../images/2015-07-29-Introducing-nuget-uwp/pclProject.png\" alt=\"PCL dependency resolution\" width=\"600\" height=\"520\" /></p>\n\n<p>More details about how to use the new dotnet moniker with project.json and how it resolves can be found in the <a href=\"http://docs.nuget.org/consume/ProjectJson-Dependency\">NuGet documentation</a></p>\n\n<h2 id=\"nuget-command-line\">NuGet Command-Line</h2>\n\n<p>The command-like executable for NuGet, nuget.exe is now available with support to install, update, and restore packages to a project with either a packages.config or project.json file.  The pack command continues to work with nuspec files on disk and packages.config files, but has not been updated to generate a nuspec file based on a project.json file.  To work-around this, you will need to craft your own nuspec file for any new package content that you construct with a project.json packages reference.  We will issue an update that includes this feature in a future release.</p>\n\n<p>Additionally, this version of the command-line executable provides support for the NuGet.org v3 endpoints.  This new version of the nuget.org feed provides faster interactions and is a more reliable service with redundancy built-in and a content-delivery network enabled to assist in quickly delivering packages.</p>\n\n<p>Download a copy of the updated NuGet.exe at: <a href=\"http://dist.nuget.org/win-x86-commandline/v3.1.0-beta/nuget.exe\">http://dist.nuget.org/win-x86-commandline/v3.1.0-beta/nuget.exe</a></p>\n\n<h2 id=\"upgrade-known-issue\">Upgrade known issue</h2>\n<p>If you installed Windows 10 SDK/Windows 10 tools after upgrading the NuGet extension, the installer will downgrade the extension back to Version 3.1. You will need to update it again to 3.1.1.</p>\n\n<p>Note: The version showing up in the Extensions and Updates dialog is 3.1.60724.766, and in the powershell console is 3.1.1.0. We plan to unify the version numbers in one of the next releases, by moving to a model where the version numbers are just {Major}.{Minor} and the last two numbers represent roughly the date/time of the build and the build number.</p>\n\n<h2 id=\"summary\">Summary</h2>\n<p>These features that support the Windows 10 UWP application development and portable class library projects are now available for package authors and for package consumers.  We know that these changes are the first step on broader use of our package manager and .NET framework and will continue to improve that experience.  We are continuing to improve the .NET development experience and will be focused on delivering a package manager that supports all .NET developers on any platform building any type of project.</p>\n\n","Href":"http://blog.nuget.org/20150729/Introducing-nuget-uwp.html","RawContent":null},{"Title":"NuGet 3.0 Released","PublishedOn":"2015-07-20T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Its been a long journey to this date.  We’ve investigated and tested and released a number of interim builds for developers and package owners to test with the latest Visual Studio bits.  The NuGet team is happy to hear all of your feedback about our add-in for Visual Studio and would like to announce the availability of the NuGet 3.0 client with Visual Studio 2015.  This update to the NuGet extension comes with Visual Studio 2015 and is avaialble from the <a href=\"https://visualstudiogallery.msdn.microsoft.com/5d345edc-2e2d-4a9c-b73b-d53956dc458d\">Visual Studio extension gallery</a> We are also making available an update to the NuGet extension for Visual Studio 2013, and you can download version 2.8.6 from the <a href=\"\">Visual Studio extension gallery</a> as well.</p>\n\n<h2 id=\"changes\">Changes</h2>\n\n<p>There are no significant changes to the user interface since the last release candidate of NuGet, but we did make one change to remove a feature that was no longer necessary.  We have removed the ‘force’ flag from the powershell Install-Package command.  This is no longer needed, as the option was intended be used to install packages without installing their dependencies.  However, we already have an ‘ignore-dependencies’ flag, so the <a href=\"https://github.com/NuGet/Home/issues/680\">“force” option was declared redundant</a> and removed.</p>\n\n<h2 id=\"known-issues\">Known Issues</h2>\n\n<p>There were a number of known issues delivered with this release, and all of these items are fixed in our scheduled 3.1 release to coincide with the release of Windows 10 on July 29th.  You will be able to update your Visual Studio extension from the gallery on or after that date to fix these known issues.</p>\n\n<ul>\n  <li>Translation is not provided for the “Do not show this again” label on the preview window and the “Authors” label in the package description window.</li>\n  <li>When you working on a project by using TFS source control, NuGet cannot present the package manager user interface if the nuget.config file is marked as read-only.\n    <ul>\n      <li><strong>Workaround</strong>  Check out the file from TFS.</li>\n    </ul>\n  </li>\n  <li>Text in the yellow “restart bar” in the NuGet Powershell window is not visible when you use the Visual Studio dark theme.\n    <ul>\n      <li><strong>Workaround</strong> Use the Visual Studio light theme.</li>\n    </ul>\n  </li>\n  <li>Powershell execution policy prevents packages from being installed properly - <a href=\"https://github.com/NuGet/Home/issues/974\">Issue 974</a>  (this fix will not make the Windows 10 update, and will be in a release after that)\n    <ul>\n      <li><strong>Workaround</strong> Delete the registry key at: <code class=\"highlighter-rouge\">HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell</code></li>\n      <li><strong>Workaround</strong> Change the Powershell script execution policy on your Active Directory domain to “Allow all scripts”</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"updates-for-visual-studio-2013\">Updates for Visual Studio 2013</h2>\n\n<p>We made some focused changes in the extension for Visual Studio 2013 to support the new features of NuGet</p>\n\n<ul>\n  <li>Introduced the UAP Target Framework Moniker to support Windows 10 Application Development.</li>\n  <li>Support for NuGet protocol version 3 endpoints</li>\n  <li>Support for <a href=\"http://docs.nuget.org/consume/NuGet-Config-Settings\">nuget.config</a> protocolVersion attribute on repository sources.  Default value is “2”</li>\n</ul>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>There are a number of other lower level fixes in this release, and if you are curious about them you can review the issues list on GitHub.  Consult the release notes for <a href=\"http://docs.nuget.org/release-notes/nuget-3.0.0\">3.0</a> and <a href=\"http://docs.nuget.org/release-notes/nuget-2.8.6\">2.8.6</a> if you are interested in reading more.  We’re happy with this release, and have another version coming very soon to support the Windows 10 SDK.  We’ll blog more about that update when it is released.  Thank you for your interest, and happy coding!</p>\n","Href":"http://blog.nuget.org/20150720/nuget-3.0.0.html","RawContent":null},{"Title":"NuGet.org server status","PublishedOn":"2015-06-08T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>For the last few weeks we have experienced a few hours of downtime a few times a week. The NuGet community was very engaged in sharing the issues both on Twitter, <a href=\"mailto:support@nuget.org\">support@nuget.org</a>, personal emails, and GitHub. We thank you for that and appreciate your patience.</p>\n\n<p>We realize NuGet.org is a center to many of the day to day activities of a .NET developer. It is critical and we are working hard to make it better.</p>\n\n<p>We promised to get back to you with an update, here it goes.</p>\n\n<h3 id=\"nugetorg-state---early-may-2015\">NuGet.org state - early May 2015.</h3>\n\n<p>NuGet.org was initially built about four years ago on top of a SQL database and OData services and NuGet.org was a monolithic single web site. Some time ago the site was broken into micro services but most of the monolithic website was still left running with some areas of the code now calling or using the micro services.</p>\n\n<p>The services are running in multiple regions to allow for geo based redundancy. The site code was pretty much unchanged since August 2014 with only minor updates and improvements to the jobs infrastructure. As time went by the number of packages increased, as well as general traffic to the service and site and we hit a point in time when things started to become unstable.</p>\n\n<p>Here is a simplified diagram of NuGet.org</p>\n\n<p><img src=\"../images/2015-06-08/Architecture.png\" alt=\"Server architecture diagram\" /></p>\n\n<h3 id=\"what-were-we-seeing\">What were we seeing?</h3>\n\n<p>Every few days/weeks we would see the search service become unusable, each of the servers running the service will start failing to a point that the machine was not accessible anymore, but will recover within a short few minutes. Unfortunately once in a while that will happen in a loop, and we will see our machines recycle.</p>\n\n<p>The team was mostly focused on the Visual Studio 2015 release and the server issues were initially looking like temporary hiccups we thought we can deal with when the pressure for shipping the NuGet for Visual Studio 2015 subsided. We still had a few people working on server improvements, monitoring and addressing alerts. We kept things going typically by quickly recycling the servers/jobs/Web Sites and with the automatic fallbacks built into Nuget.Org.</p>\n\n<p>Unfortunately this became a pretty regular trend a few weeks ago, and it was clear we don’t have enough focus in the server area, and we decided to increase the focus there.</p>\n\n<p>We started with a plan to improve the server, along the following lines</p>\n\n<ol>\n  <li>Consolidate pieces of code that were pretty much doing the same thing.</li>\n  <li>Improve our backend jobs processing the newly uploaded packages.</li>\n  <li>Add additional monitoring and tracing to the servers to better pinpoint issues.</li>\n  <li>Fix the clear items coming up from reviewing the logs.</li>\n</ol>\n\n<h3 id=\"highlights-of-current-improvements\">Highlights of current improvements</h3>\n\n<h4 id=\"backend-jobs-improvements\">Backend jobs improvements</h4>\n<p>When the NuGet.org service recovered from one of the outages, we discovered that our fail-over data center was not being updated properly and package information was several weeks old. Packages published in the month of May did not appear in the search index.</p>\n\n<p>We have investigated the issue with these backup jobs, corrected it and applied monitoring to ensure that our backup data-centers are never that far out of date again.</p>\n\n<p>We consolidated all the backend jobs from two frameworks into a single framework, wrapped them in <a href=\"http://www.nssm.cc/\">nssm</a> for auto restart and now in the process of adding an auto restart for jobs that are hanging.</p>\n\n<h4 id=\"nuget-service-degradation\">NuGet Service Degradation</h4>\n<p>We had an auto healing feature that would switch to a different region when the machines in the search services were not responding/down. However in this case the services were not fully down. The behavior observed was that the service will stop responding for a few minutes to respond again. The response times also became significantly longer. Our switching code interpreted this incorrectly as a healthy/recovered state, and hence we never switched off to another data center.</p>\n\n<p>We made a change and now we will actively work with both data centers regularly, preferring the healthier search services. This was deployed on June 4th, which worked great in the June 5th outage, well until the other region went down as well. More on that below.</p>\n\n<h4 id=\"search-service-improvements\">Search service improvements</h4>\n<p>We identified a few major issues in the search service code that caused the failures</p>\n\n<ol>\n  <li>We had a code path that would cause large chunks of contiguous memory to be loaded. This caused memory spikes and Garbage collection gen 2 collections. This code is now using streaming instead and does not cause memory pressure.</li>\n  <li>We had another code path that invoked a lock, it was supposed to be called mostly at startup or from a background task but we found that it is being called from some request path, creating thread contention and major down time.</li>\n</ol>\n\n<p>On Friday June 5th we deployed a change that eliminated the top issue, and we are actively working on the second issue. With only the first fix in place we don’t see any further major issues in the service.</p>\n\n<p>We are currently monitoring the service and finding the next level items to be fixed.</p>\n\n<h4 id=\"apinugetorg-improvements\">Api.NuGet.org improvements</h4>\n<p>We identified that about 60% of the search queries on the site can be cached pretty trivially and reduce the stress both on the WebSite and the search service. These queries are variants of the default empty query used to list the top downloaded packages. Since the data returned from this query hardly changes, this was a quick and easy win.</p>\n\n<p>We are in the process of gradually deploying caching for this set of queries. We expect this to improve responsiveness of both the website and Visual Studio.</p>\n\n<h3 id=\"whats-next\">What’s next</h3>\n<p>We want to share our service prioritization list with you in order to be more transparent about our process. We prioritize our services support in this order:</p>\n\n<ol>\n  <li>Downloadable packages - Package restore, Package Install &amp; Update from command line</li>\n  <li>Searchable index</li>\n  <li>Up to date search index &amp; Package upload</li>\n  <li>Package download statistics</li>\n</ol>\n\n<p>We have brought the first 3 into a reasonable state, but we are focusing our efforts there, while download statistics is not being worked on until we feel the top three are in a good enough state.</p>\n\n<p>We are tracking our gallery items on <a href=\"https://GitHub.com/NuGet/NuGetGallery/issues\">https://GitHub.com/NuGet/NuGetGallery/issues</a></p>\n\n<p>Deployments are tracked by milestones, the next one is <a href=\"https://GitHub.com/NuGet/NuGetGallery/milestones/S2\">https://GitHub.com/NuGet/NuGetGallery/milestones/S2</a></p>\n\n<p>We deploy daily as necessary, but bigger changes are typically deployed early on Friday at the end of a milestone so that disruptions can still be dealt with, but the stress on the server is lower (and less developers are at work).</p>\n\n<h3 id=\"summary\">Summary</h3>\n<p>We are taking NuGet.org uptime very seriously, we are working at making it better one bit at a time. We appreciate all the feedback we are getting from you, good or bad.</p>\n\n<p>Please reach out to us in the following avenues</p>\n\n<p>For server issues - <a href=\"https://GitHub.com/NuGet/nugetgallery/issues\">https://GitHub.com/NuGet/nugetgallery/issues</a></p>\n\n<p>For bugs - <a href=\"https://GitHub.com/NuGet/home/issues\">https://GitHub.com/NuGet/home/issues</a></p>\n\n<p>For all other issues - <a href=\"mailto:support@nuget.org\">support@nuget.org</a></p>\n\n<p>We listen to Twitter <a href=\"https://twitter.com/nuget\">@nuget</a>, typically gets fast to us, just note it is not our official support line and the developer on call is not always on Twitter.</p>\n\n<p>Feel free to reach out to me personally as well <a href=\"https://twitter.com/yigalatz\">@yigalatz</a></p>\n","Href":"http://blog.nuget.org/20150608/nuget-server-status.html","RawContent":null},{"Title":"NuGet 3.0 RC 2 Released","PublishedOn":"2015-06-01T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the month since the Visual Studio 2015 RC release, we have heard from many of you with compliments, complaints, and bug reports. The NuGet team is happy to hear about all of the experiences you’ve had with our add-in for Visual Studio.  The team has been hard at work preparing for the final release of Visual Studio, and would like to issue an update to the <a href=\"https://visualstudiogallery.msdn.microsoft.com/5d345edc-2e2d-4a9c-b73b-d53956dc458d,\">Visual Studio extension</a> to ensure that we have ironed out some of the issues you may have run into.  You can also get a copy of the extension from Codeplex at <a href=\"https://nuget.codeplex.com/releases/view/615507\">https://nuget.codeplex.com/releases/view/615507</a>.</p>\n\n<h2 id=\"feature-tuning\">Feature Tuning</h2>\n\n<p>We did not want to add any new features while leading up to the final release with Visual Studio 2015, but we did find one or two items that we wanted to tune to ensure that developers have a great experience with the NuGet tools.  You will find in this update to the extension we have applied a number of performance updates to reduce the number of calls back to the NuGet.org service, the caching of the results in the package user interface, and remembering the state of the preview version checkbox from session to session.</p>\n\n<p>Performance tuning made the extension processor hungry, and we found that at times it would consume all resources on the processor of our workstations.  We’ve also introduced some throttling to ensure that the NuGet extension does not consume all available resources.</p>\n\n<p>Additionally, we heard from a number of you that the Preview Window was something that you were not interested in seeing.  Funny enough, there is a configuration option already available to hide the preview window… but its not something that we think was easy to find.  To simplify, we added a checkbox to the preview window that allows you to hide it and prevent it from returning in future package operations.</p>\n\n<p><img src=\"../images/2015-06-01-nuget-3.0-rc2/previewCheckbox.png\" alt=\"Location of checkbox to hide preview window\" /></p>\n\n<h2 id=\"fixes-addressed\">Fixes Addressed</h2>\n\n<p>We know that many developers are publishing packages that contain portable class libraries (PCLs) to support a variety of project types.  In this release you will find that we addressed issues related to the Windows Phone and new Universal Windows Platform choose which PCL from within a NuGet package that they should install.</p>\n\n<p>Additionally, we corrected an issue that <a href=\"https://github.com/NuGet/Home/issues/445\">prevented Xamarin iOS projects</a> from copying content into your project properly. Similarly, C++ developer will be happy to hear that an issue that <a href=\"https://github.com/NuGet/Home/issues/281\">prevented .targets files</a> from merging into a vcxproj file has been corrected as well.</p>\n\n<p>Authentication for secured feeds was addressed in this release.  We’ve reintroduced an authentication dialog when attempting to fetch content from a secured feed and we’ve taken care of issues related to querying that feed from the Powershell console.</p>\n\n<p>One thing that started to really bother us, and a number of customers reported it, was that the Powershell auto-complete function was case sensitive.  If I started searching for a microsoft.aspnet package, I would never find Microsoft.AspNet.Mvc  In this release, we’ve adapted the auto-complete in Powershell to be case insensitive.</p>\n\n<h2 id=\"package-logging\">Package Logging</h2>\n\n<p>One of the decisions we made early in this development cycle was to log all messages to the output window in Visual Studio.  This meant that we also started dumping error messages from the execution of the add-in into the output window as well, and we know you don’t want to see those errors that are outside of your project’s operation in there.  Internal issues with the NuGet client will now be logged to the standard Visual Studio activitylog.xml file that our Visual Studio support teams work with.</p>\n\n<p>For those messages from the NuGet package management process that you do need to interact with, we have improved a number of them to provide better clarity about errors or warnings during processing.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>There are a number of other lower level fixes in this release, and if you are curious about them you can review the issues list on GitHub.  We’re happy with this release, and we know there is more to be built in our client tools.  We’re planning to release a client update at least once a month through July and August.  Thank you for your interest, and happy coding!</p>\n","Href":"http://blog.nuget.org/20150601/nuget-3.0-rc2.html","RawContent":null},{"Title":"NuGet 2.8.5 Released","PublishedOn":"2015-03-31T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the last few weeks we saw a significant change in the NuGet ecosystem with the renaming of the K utilities and framework monikers to DNX.  To support that change and provide backwards compatibility for existing versions of Visual Studio, we are publishing an update to NuGet extensions for Visual Studio 2010, 2012, and 2013.  This update does not work with Visual Studio 2015 and is an update for existing 2.x NuGet extensions only. A copy of the <a href=\"http://docs.nuget.org/release-notes/nuget-2.8.5\">release notes</a> are available online.</p>\n\n<p><a href=\"http://nuget.codeplex.com/releases/view/612846\">Download the NuGet 2.8.5 update now</a></p>\n\n<h2 id=\"framework-monikers-added\">Framework Monikers Added</h2>\n\n<p>To allow packages that also target older versions of the .NET framework to continue to support the new capabilities of ASP.NET 5 and DNX we introduced three new framework monikers that can be used in the NuGet spec and package folder names:</p>\n\n<ul>\n  <li><strong>core50</strong> - A ‘base’ target framework moniker (TFM) that is compatible with the Core CLR.</li>\n  <li><strong>dnx452</strong> - A TFM specific to DNX-based apps using the full 4.5.2 version of the framework</li>\n  <li><strong>dnx46</strong> - A TFM specific to DNX-based apps using the full 4.6 version of the framework</li>\n  <li><strong>dnxcore50</strong> - A TFM specific to DNX-based apps using the Core 5.0 version of the framework</li>\n</ul>\n\n<h2 id=\"other-fixes\">Other fixes</h2>\n\n<p>we also included an important fix of an issue that prevented packages from installing into FSharp projects properly:</p>\n\n<p><a href=\"https://nuget.codeplex.com/workitem/4400\">https://nuget.codeplex.com/workitem/4400</a></p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>NuGet continues to support older versions of Visual Studio as newer technologies are released.  We will continue this practice so that newer versions of packages and NuGet services do not impair your development experience on older versions of development tools.</p>\n","Href":"http://blog.nuget.org/20150331/nuget-2.8.5.html","RawContent":null},{"Title":"NuGet 3.0 Beta 2 Released","PublishedOn":"2015-02-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>That was a quick turn-around…  we issued our 3.0 beta just a few days ago and our community of developers and supporters quickly found a number of issues with it.  Thank you to the early reporters on Twitter and on this blog for helping us to identify those issues. We would like to issue an update to our <a href=\"https://visualstudiogallery.msdn.microsoft.com/5d345edc-2e2d-4a9c-b73b-d53956dc458d,\">Visual Studio extension</a> to correct some of the stickier problems that were identified.  You can also get a copy of the extension from Codeplex at <a href=\"http://nuget.codeplex.com/downloads/get/1432773\">http://nuget.codeplex.com/downloads/get/1432773</a>.</p>\n\n<h2 id=\"fixes-addressed\">Fixes Addressed</h2>\n\n<p>Our new protocol delivers NuGet package data in JSON format from the nuget.org server.  One issue we ran into was a mishandling of the date formatting for non-US machines.  We addressed this issue and re-tested with a German workstation to verify that the problem is corrected.</p>\n\n<p>We had a backwards compatibility issue with Visual Studio due to a previously included reference to the Visual Studio v12 shell.  That type is not being loaded by Visual Studio 2015 (version 14 internally) and we fixed our references to use the Visual Studio v14 shell.</p>\n\n<p>The final issue we had reported to us was an interesting uninstall of the NuGet extension issue.  This is a particularly strange one because it does not happen on all machines, and we have not been able to isolate the trigger scenario.  It does appear to be an issue in Visual Studio when uninstalling an extension, and we are working with their team to address this.  We suspect that it could be an issue for other extension developers as well.</p>\n\n<p>We do not have a fix for this uninstall issue, but we do have a workaround if you encounter it.  We recommend that you follow these steps if you encounter it:</p>\n\n<ol>\n  <li>Uninstall the existing NuGet extension that you retrieved from the extension gallery.</li>\n  <li>With Visual Studio closed, download a new copy of the <a href=\"http://nuget.codeplex.com/downloads/get/1432773\">NuGet extension from Codeplex</a> instead of through the extension gallery.</li>\n  <li>Double-click the VSIX you downloaded to install a fresh copy of the NuGet extension.</li>\n  <li>When you next start Visual Studio, if you are prompted with an error about needing Admin privileges again, take the following steps:\n    <ol>\n      <li>Close Visual Studio</li>\n      <li>Start the Visual Studio Command Prompt, called “Developer Command Prompt for VS2015” as an Admin</li>\n      <li>Manually install the NuGet VSIX using VsixInstaller with the /admin switch.  eg:  <code class=\"highlighter-rouge\">VSIXInstaller.exe c:\\install\\nuget.tools.2015.vsix /admin</code></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"kpm-incompatibility\">kpm incompatibility</h2>\n\n<p>A note about using NuGet 3 with kpm: a new kpm client has not been issued that is compatible with the NuGet 3 API.  This means that if you are in an ASP.NET 5 project, you cannot use the NuGet v3 endpoint.  For these projects, we recommend that you disable the api.nuget.org service in the package sources dialog as follows:</p>\n\n<p><img src=\"/images/2015-02-26-nuget-3.0-beta2/config.png\" alt=\"\" /></p>\n\n<h2 id=\"legacy-package-restore-incompatibility\">Legacy package restore incompatibility</h2>\n\n<p>If you have a project with in the ‘legacy package restore mode’, with the .nuget folder at the root of your solution folder, you will run into a similar API incompatibility issue.  In this scenario, the nuget.exe client program that you have copied locally does not understand the v3 API and will not be able to restore packages for you using the api.nuget.org endpoint.  You have two options:</p>\n<ol>\n  <li>Disable the api.nuget.org endpoint as described above, enabling the v2 endpoint.</li>\n  <li><a href=\"http://docs.nuget.org/consume/package-restore/migrating-to-automatic-package-restore\">Migrate from legacy package restore mode to automatic package restore</a>.</li>\n</ol>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>We responded quickly to these issues because we heard your feedback, and we value our developers and customers who are using our NuGet extension for Visual Studio.  It is important to us that you have a good experience while using our product.  We are committed to improving your package management experience, and we will deliver on that promise.</p>\n","Href":"http://blog.nuget.org/20150226/nuget-3.0-beta2.html","RawContent":null},{"Title":"NuGet 3.0 Beta Released","PublishedOn":"2015-02-23T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Its time for the 3.0 beta release for NuGet, and this time we have some much sought-after enhancements in the works for you.  You can get access to the update NuGet binaries on <a href=\"http://nuget.codeplex.com/releases\">Codeplex</a> and through the Visual Studio extension manager.  We are only releasing these preview bits for Visual Studio 2013 (on CodePlex only) and for Visual Studio 2015.  We are releasing the Visual Studio 2013 version on Codeplex so that we don’t accidentally deliver a preview extension version into a production development environment. We will be delivering a new version of the extension for Visual Studio 2012 in the near future.</p>\n\n<p>We strongly recommend that you uninstall any prior version of the NuGet Visual Studio extension before installing this new version.  If you have any problems with this version of the extension, we recommend you revert to the <a href=\"http://nuget.codeplex.com/downloads/get/909582\">prior version</a> for use with Visual Studio 2015 preview.</p>\n\n<p>Let’s take a look at some of the updates:</p>\n\n<h2 id=\"visual-studio-extension-improvements\">Visual Studio Extension Improvements</h2>\n\n<p><img src=\"../images/2015-02-23-nuget-3.0-beta/ui.png\" alt=\"Visual Studio Extension UI\" /></p>\n\n<p>The user interface is no longer modal, and is a dockable window in Visual Studio with wrapping enabled for smaller screens.  That’s cool because now we can see a lot more of the package titles and descriptions that our package authors have worked so hard on.</p>\n\n<p>Across the top of the window is the name of the project you are currently working in.  Below that is the package source - a combobox of the various NuGet repositories available on your workstation.  The Filter combobox is next and it replaces the old accordion display that was on the left side of the screen.  There are three options in this box: All, Installed, and Upgrade Available.  This should allow you to quickly review the packages you have installed or review just those packages where updates are waiting to be installed.  Otherwise, the All option will show you packages available from your selected repository.</p>\n\n<p>The ‘Include Prerelease’ checkbox is fairly self-explanatory, showing those packages and their versions that are in prerelease state.  Next is the search text box.  We’ve gone to great lengths to improve the speed of the search on NuGet.  It was our number one requested feature, and we put a lot of work into making this a very fast search operation.  Check out the <a href=\"../images/2015-02-23-nuget-3.0-beta/nuget-perf.mp4\">attached video</a> for a side-by-side demonstration of Visual Studio 2013 with the old add-in and Visual Studio 2015 with the new add-in.  We achieved this performance improvement through the implementation of new search algorithms and a smaller payload of data being delivered from the NuGet.org servers in the JSON-LD format.  Our <a href=\"http://blog.nuget.org/20140424/building-nuget-3.x.html\">previous blog post</a> discusses this change further.</p>\n\n<p>We’ve also cleaned up the action pane on the right side of this dialog.  You can now select an action you’d like to take with your package and click a button to enact that action.  Any necessary configuration options for that action will be provided in the Options segment below.</p>\n\n<p>We heard your concerns about the preview UI that we provided, and the experience when you install, upgrade, or uninstall packages.  We’ve cleaned up that experience significantly.  We will (optionally) show you a preview of what changes NuGet will make to your project, and then shift focus to the Output Window’s Package Manager pane where you can observe and review the detailed log messages reported by NuGet.  This should feel very similar to completing a standard build for your project, something that we are sure all Visual Studio developers are familiar with.</p>\n\n<p><img src=\"../images/2015-02-23-nuget-3.0-beta/output.png\" alt=\"Package Manager Output Window\" /></p>\n\n<h2 id=\"new-powershell-cmdlets\">New Powershell Cmdlets</h2>\n\n<p>We are beginning to introduce and migrate functionality in our Powershell commands in this version of NuGet. We are starting with moving the package search functionality to the Find-Package cmdlet.  This allows us to keep package searching mechanisms separate from package fetching commands.</p>\n\n<p>We have also introduced the Sync-Package cmdlet that provides the same ‘consolidate’ functionality that the Visual Studio UI introduced.  We will be continuing to deliver parallel functionality in the UI and in powershell.  No more flipping back and forth between these two clients because one has more functionality that the other.</p>\n\n<p>We’ve also introduced some new switches to old favorite commands:</p>\n\n<ul>\n  <li>Install-Package now has a -Force switch that will force an uninstall and re-install of the same package</li>\n  <li>Install-Package can now accept a local or remote nupkg address or config file listing packages.  For example: install-package https://raw.githubusercontent.com/NuGet/json-ld.net/master/src/JsonLD/packages.config</li>\n  <li>Update-Package now has a -Version switch that accepts an enum value of Highest, HighestMinor, and HighestPatch to indicate which package version NuGet should install</li>\n</ul>\n\n<h2 id=\"re-architecting-for-a-purpose\">Re-architecting for a purpose</h2>\n\n<p>We have spent some time segmenting the NuGet source code to make re-use and modernization of the code much easier.  This allows us to engage and deliver functionality better, as that code is now more clearly segmented into client, configuration, and communications.  We are completing a move to a <a href=\"http://github.com/nuget\">GitHub source code repository</a>, and we think you will be very happy to see what we have prepared there for you to interact with.  We’ll have a more formal announcement when that move is completed.</p>\n\n<h2 id=\"building-nuget-with-nuget\">Building NuGet with NuGet</h2>\n\n<p>That sounds confusing, but this is an important step for us.  As the .NET framework starts to deliver the base class library with NuGet, we need to be able to support and deliver development practices that rely on NuGet as part of the build process for every reference in your project.  Our build process now compiles and delivers each of the segments of the NuGet application as a package for the NuGet client applications to consume.  This gives us maximum re-use of code and demonstrates to ourselves some of the issues that developers will have as they move into this style of coding.  This practice has given rise to some enhancement considerations for the NuGet client experience to improve this workflow.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>These are just a few of the changes in store for you when you install the new NuGet 3.0 beta that is now available.  We encourage you to download a copy and give it a try.  The performance improvements are significant, the UI updates should make things easier, and we’re listening to your feedback.  Please comment below about what you like, don’t like, or your suggestions for improvement.  We’ll publish a follow-up post with some of our ideas for next steps in the weeks ahead.</p>\n","Href":"http://blog.nuget.org/20150223/nuget-3.0-beta.html","RawContent":null},{"Title":"Package Signing","PublishedOn":"2015-02-03T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Package signing has been a major discussion point for a long time in the NuGet ecosystem. However, the NuGet Team didn’t want to rush into an implementation and end up creating something that restricted the ecosystem unnecessarily. Well, we now think we are ready to begin a process to introduce Package Signing, and we want to share our plans with the community so you can see what we’re thinking and give us feedback.</p>\n\n<h2 id=\"goals\">Goals</h2>\n\n<p>Up until now, the transfer of packages was secured from NuGet.org down to your machine, and from publisher’s machines up to NuGet.org using TLS/SSL. This has served us fairly well so far, but it suffers from a few issues:</p>\n\n<ol>\n  <li>It is dependent upon the NuGet server providing a secure connection. NuGet.org does so, but others may not.</li>\n  <li>It is dependent upon the security of NuGet.org itself. If NuGet.org is compromised, all bets are off and verification becomes very difficult (<a href=\"http://blog.rubygems.org/2013/01/31/data-verification.html\">RubyGems had an issue like this recently</a>).</li>\n  <li>If you use a server or file share which mirrors packages from NuGet.org, you must rely on the security of that server.</li>\n  <li>There is no way for a publisher to easily communicate to users that their credentials have been compromised and their packages should no longer be trusted.</li>\n  <li>The “multi-source” model in NuGet means packages can be downloaded from any of your configured sources. Nothing ensures that the package you download is from the same source you initially installed it from.</li>\n</ol>\n\n<p>Given these issues, we came up with a few goals for a Package Signing system:</p>\n\n<ol>\n  <li>After a package consumer installs a package, we want the system to be able to ensure that all future downloads of that package come from the same publisher.</li>\n  <li>When a consumer updates a package, we want the same assurance: That the new version is from the same publisher.</li>\n  <li>These assurances should be made external to the server hosting the package, meaning the package can be downloaded from any server and the assurance can still be verified.</li>\n  <li>Create a signing infrastructure that doesn’t restrict us from adding richer functionality later.</li>\n</ol>\n\n<p>An important <strong>non-goal</strong>: Once the package is on your local hard drive, we don’t think package signatures should play a role in future usage of that package. The contents of NuGet packages can already be signed using Authenticode and operating system policies can be applied to prevent the usage of unsigned or untrusted binaries. We are only trying to secure the transmission of the physical <code class=\"highlighter-rouge\">.nupkg</code> file from the author to your local drive.</p>\n\n<h2 id=\"what-were-actually-trying-to-do\">What we’re actually trying to do</h2>\n\n<p>It’s important here to stop for a second and clarify what we’re actually trying to do. We are not trying to provide a system that makes any claims as to the <em>authenticity</em> of a package. We are only making assertions about the <em>identity</em> of a package.</p>\n\n<p>This signing system is not trying to tell you that NuGet can verify that a package is the right version of Newtonsoft.Json, from James Newton-King. Instead, we can say that it’s Newtonsoft.Json from someone in control of the private key for some certificate <em>X</em>. Actually verifying that James Newton-King is in control of that certificate is a secondary process that we are not providing here. That may be something we can add to this system later, but it is <strong><em>NOT</em></strong> a primary goal of the system at the moment. More importantly, once you’ve gotten the package and verified that it works for your scenarios, you can be assured that future versions are from the same source.</p>\n\n<p>Our goal is to give package consumers the tools they need to make those identity decisions, and to ensure that once they have chosen to trust a particular package, we always deliver them the package they expect.</p>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>An easy technical solution to all of our goals would be to use <a href=\"http://msdn.microsoft.com/en-us/library/ie/ms537359%28v=vs.85%29.aspx\">Authenticode</a> to sign NuGet packages. This would solve most of the problems above (and would even solve some of the authenticity issues above), and is likely a good solution for large corporate publishers like Microsoft. Unfortunately, it is not suitable for Open-Source developers (who are a major part of our ecosystem) due to the prohibitive financial cost of Code Signing certificates. Also, Authenticode is a system designed for use on Microsoft Windows platforms, and we are targetting cross-platform audiences using ASP.NET 5. It is possible to implement Authenticode on those platforms, but given the other issues, it seems like Authenticode is not the ideal solution here. Instead, we developed our own system (inspired by Authenticode) that is a little more tailored to the unique aspects of the NuGet ecosystem.</p>\n\n<p>First, we will provide tools to allow publishers to manage their own signing certificates, without requiring Root CAs. If you have, or want to get, a certificate from a real Code Signing CA, you can use it with this system. However, you are not required to do so. We will provide tools to manage these certificates and use them to sign packages.</p>\n\n<p>We will also provide tools to generate signatures for NuGet packages using a signing certificate. The signature itself will be stored in a separate file and can be transferred up to NuGet servers compatible with API v3 as well as file shares. We use the <a href=\"https://tools.ietf.org/html/rfc5652\">CMS</a> format for encoding the digital signature. The signature is computed over the entire package ZIP file, including the nuspec and all metadata. This does mean that editing a signed package’s metadata (description, etc.) becomes more complicated, but we have some ideas for allowing authors to “re-sign” modified packages.</p>\n\n<p>When a user installs a signed package using the NuGet Dialog, the signature will be verified against the file. This verification is minimal, we will just be checking that the hashes actually match up, nothing about the certificates will be verified during this process. Assuming that verification completes, we will write the package into project.json/packages.config as before, but we will include some additional data about the certificates used to sign the package (this is based on the <a href=\"https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning\">Public Key Pinning</a> technique commonly used in SSL). The exact format is described in the spec, linked at the end of this post.</p>\n\n<p>In the future, whenever NuGet downloads that package for that project, it will do the following verification:</p>\n\n<ol>\n  <li>If the signature for the package NuGet downloaded cannot be found, it will be rejected and an error will be raised.</li>\n  <li>If the signature for the package NuGet downloaded is invalid (hashes don’t match), it will be rejected and an error will be raised.</li>\n  <li>If the package NuGet downloaded is not signed by the same publisher, it will be rejected and an error will be raised.\n    <ol>\n      <li>Note: We say “publisher” here not “key”. The publisher can, and should, rotate keys frequently as good security practice. See the spec, linked at the end of this post, for more details on how we do this securely.</li>\n    </ol>\n  </li>\n  <li>If the package NuGet downloaded is was signed by a certificate that was revoked or expired at the time it was signed, it will be rejected and an error will be raised\n    <ol>\n      <li>Note: The time the signature was <strong><em>made</em></strong> is used here, <strong><em>not</em></strong> the time of verification. You won’t have to reissue old packages just because your certificate expired. We will encourage the use of <a href=\"http://en.wikipedia.org/wiki/Trusted_timestamping\">Trusted Timestamping</a>, which is a service provided for free by most issuers of code-signing certificates, to record the time of signing. This is very similar to how Authenticode deals with the same problem.</li>\n    </ol>\n  </li>\n</ol>\n\n<p>This will also happen when NuGet updates the package. If the publisher has changed, the user warned about the change and given the option to approve it (similar to the way an SSH client presents the server’s public key to the user for approval). As a NuGet publisher, it will be your responsibility to safeguard your key. If you lose your root certificate key, users will have to uninstall and reinstall your package when you release a new version with a new key. We will provide guidance and tools to backup your key in a secure manner.</p>\n\n<h2 id=\"this-seems-familiar\">This seems familiar…</h2>\n\n<p>Ok, we’re entering slightly more controversial territory here :). If you think this system sounds a little like <a href=\"http://msdn.microsoft.com/en-us/library/wd40t7ad%28v=vs.110%29.aspx\">Strong-Named Assemblies</a>, well… you’d be right. Signing a package means effectively adding a piece of identity to the package. It is also true that in order to be truely confident about the identity of the packages you have installed, a package <em>should</em> embed the full cryptographic identity for the packages it depends on (much like how Strong Named assemblies can only reference other Strong Named assemblies). After all, you are only as secure as your weakest link. However, I think what we’ve come up with is a more appropriate solution for the NuGet ecosystem. Let’s start by going over some of the issues customers have encountered with Strong Names, then I will cover why we think this solution is more appropriate.</p>\n\n<ol>\n  <li>Assemblies with the same name but different Public Keys are generally considered to be completely different Assemblies. This is intentional, and occasionally useful, but most of the time it’s not what the user expects.</li>\n  <li>It is <em>extremely</em> difficult (if not impossible) to substitute an assembly deep in your dependency graph with a different copy that uses a different key.</li>\n  <li>Strong Named assemblies may only depend on other Strong Named assemblies.</li>\n  <li>Strong Naming is deeply embedded in the runtime and prevents applications from running. There is almost nothing you can do (short of turning verification off entirely) to force an assembly to load when it is not properly strong-named. Also, the processes used to force an assembly to load are usually machine-level and are difficult to synchronize across developers in a team.</li>\n</ol>\n\n<p>Here’s where we think our system differs:</p>\n\n<ol>\n  <li>Under our proposed system, two packages with the same package ID are <strong>always</strong> expected to be the same package, <strong>regardless</strong> of the signature. Two packages that differ by signature are interpreted as being different <em>variants</em> of the same package, not different packages entirely.</li>\n  <li>Because of the way NuGet packages are referenced, it is ALWAYS possible to override a “signed” dependency with a package that is signed with a different key, or even unsigned. In ASP.NET 5, if you depend on <code class=\"highlighter-rouge\">Foo</code> which depends on a signed copy of <code class=\"highlighter-rouge\">Bar</code>, you can just add a direct dependency on <code class=\"highlighter-rouge\">Bar</code> (with any key you want, or even no key at all) and the dependency further down the graph will be overridden by the top-level explicit dependency. Similarly, in packages.config, the indirect dependencies are listed right alongside direct dependencies and you can always remove or change the signature requirement on a specific package reference.</li>\n  <li>We will not be enforcing that signed packages depend solely on other signed packages. This does decrease the security of the system, but as with the previous point, you can always use an explicit dependency to enforce the signature restriction on a normally unsigned package. We will likely warn publishers when they are signing packages if they depend on unsigned packages, but this won’t restrict their ability to publish.</li>\n  <li>This system only affects the download of the <code class=\"highlighter-rouge\">.nupkg</code> file. Once the package is on disk, signatures don’t matter. This means that in the absolute worst case, if you want to just drop a <code class=\"highlighter-rouge\">.nupkg</code> on disk yourself, it <strong>will</strong> load successfully, regardless of signatures.</li>\n</ol>\n\n<p>We think that as a package consumer, it is extremely useful for you to have some kind of externally-verifiable statement of identity for a package. A package signature gives you that ability (specifically the ability to know: “This is Newtonsoft.Json, as produced by the owner of the private key matching public key X”). Similarly, it is useful for consumers to be able to say “I only want to receive updates for this package from the owner of the private key matching public key X.” However, the main lesson we feel we have learned from the concerns around Strong Naming is that we need to empower the consumer of a package to choose the identities they want to use for all packages in their dependency graph. That’s what we’re trying to achieve with this system. As a developer, you are always in control of the identities of <strong>all</strong> of your dependencies and can override them <strong>as you see fit</strong>.</p>\n\n<p>We are hopeful that we can provide a system in which every NuGet publisher will be willing and easily able to give a cryptographically-sound identity to their packages. Other package management systems such as Maven actually <a href=\"http://central.sonatype.org/pages/requirements.html\"><em>require</em> signatures</a> like these in order to publish to their central repositories. We see the potential for this system to become similarly prolific and if you don’t think you would sign your packages, we really want to know why!</p>\n\n<h2 id=\"timeline\">Timeline</h2>\n\n<p>The main timeline for this feature is ASP.NET 5. We are hoping to have something concrete for use with ASP.NET 5 projects when that platform releases it’s 1.0 version. Support for use in packages.config and the more traditional NuGet workflow will likely come shortly after (but <em>will</em> come!). Also, we expect that our first pass at this feature will only run on Windows. We are still working out the cross-platform story for signing and verifying packages. Most of the cryptography code we are using right now is implemented <em>inside</em> the Windows kernel, so we’ll need to work out exactly how we will do it on Mac and Linux (but we <em>will</em> be supporting those platforms post-RTM).</p>\n\n<h2 id=\"spec-and-feedback\">Spec and Feedback</h2>\n\n<p>A detailed specification of our plan is available <a href=\"https://github.com/aspnet/Signing/blob/dev/Spec.md\">on the aspnet/Signing repository</a>, since the initial work is happening in the ASP.NET 5 platform. Please review that as well if you have concerns because they may have been answered there! We really want your feedback here, so please don’t hesitate to comment on this post or in CodePlex!</p>\n","Href":"http://blog.nuget.org/20150203/package-signing.html","RawContent":null},{"Title":"Introducing the NuGet PowerShell Commands Survey","PublishedOn":"2014-12-03T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>You’ve probably seen the cool announcements from Microsoft about the new <a href=\"http://www.visualstudio.com/en-us/downloads/download-visual-studio-vs#d-community\">Community Edition of Visual Studio</a> and the upcoming <a href=\"http://www.visualstudio.com/en-us/downloads/visual-studio-2015-downloads-vs\">Visual Studio 2015</a> release in the new year.  We at the NuGet team have been ramping up our tools to support the new Visual Studio with a better visual experience and a better command-line experience.  We’ve also released some information about our upcoming v3 release of our protocol based on <a href=\"http://json-ld.org/\">JSON-LD</a>.</p>\n\n<p>Now we want to do something to stay true to the open-source license of our tool.  We want to ask you for your input about our PowerShell capabilities.  We will review all feedback and make decisions about the future direction of the NuGet PowerShell commands based on the results of this survey. This is an important artifact for us to ensure that we continue to deliver a package manager tool that provides significant value to you.  I promise that we will share the results of the survey and introduce how they fit into our planned roadmap for 2015 and beyond.</p>\n\n<p>So.. What are you waiting for? Make some clicky clicky noises with your mouse and take our survey at the following location:\n<a href=\"http://www.surveymonkey.com/s/C792HKX\">http://www.surveymonkey.com/s/C792HKX</a></p>\n","Href":"http://blog.nuget.org/20141203/Introducing-the-powershell-commands-survey.html","RawContent":null},{"Title":"NuGet 3.0 Preview","PublishedOn":"2014-11-12T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>On November 12, 2014, as part of the Visual Studio 2015 Preview release, we released NuGet 3.0 Preview. This is a big release for us (albeit a preview), and we’re excited to start getting feedback on our changes.</p>\n\n<h2 id=\"visual-studio-2012\">Visual Studio 2012+</h2>\n\n<p>This NuGet 3.0 Preview is included in Visual Studio 2015 Preview. We are working to get preview drops out for Visual Studio 2012 and Visual Studio 2013 very soon. We previously shared our intent to <a href=\"http://blog.nuget.org/20141002/visual-studio-2010.html\">discontinue updates for Visual Studio 2010</a>, and we did make that difficult decision.</p>\n\n<h2 id=\"brand-new-ui\">Brand New UI</h2>\n\n<p>The first thing you’ll notice about NuGet 3.0 Preview is our brand new UI. It’s no longer a modal dialog; it’s now a full Visual Studio document window. This allows you to open the UI for multiple projects (and/or the solution) at once, tear the window off to another monitor, dock it however you’d like, etc.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/new-ui.png\" alt=\"The new NuGet UI\" /></p>\n\n<p>Beyond the usability differences because of abandoning the modal dialog, we also have lots of new features in the new UI.</p>\n\n<h3 id=\"version-selection\">Version Selection</h3>\n\n<p>Perhaps the most requested UI feature is to allow version selection for package installation and update–this is now available.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/version-selection.png\" alt=\"Package Version Selection\" /></p>\n\n<p>Whether you are installing or updating a package, the version dropdown allows you to see all of the versions available for the package, with some notable versions promoted to the top of the list for easy selection. You no longer need to use the PowerShell Console to get specific versions that are not the latest.</p>\n\n<h3 id=\"combined-installedonlineupdates-workflows\">Combined Installed/Online/Updates Workflows</h3>\n\n<p>Our previous UI had 3 tabs for Installed, Online, and Updates. The packages listed were specific to those workflows and the actions available were specific to the workflows as well. While that seemed logical, we heard that many of you would often get tripped up by this separation.</p>\n\n<p>We now have a combined experience, where you can install, update, or uninstall a package regardless of how you got the package selected. To assist with the specific workflows, we now have a Filter dropdown that lets you filter the packages visible, but then the actions available for the package are consistent.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/uninstall-package.png\" alt=\"Uninstall a Package\" /></p>\n\n<p>By using the “Installed” filter, you can then easily see your installed packages, which ones have updates available, and then you can either uninstall or update the package by changing the version selection to see change the action available.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/update-package.png\" alt=\"Update a Package\" /></p>\n\n<h3 id=\"version-consolidation\">Version Consolidation</h3>\n\n<p>It’s common to have the same package installed into multiple projects within your solution. Sometimes the versions installed into each project can drift apart and it is necessary to consolidate the versions in use. NuGet 3.0 Preview introduces a new feature for just this scenario.</p>\n\n<p>The solution-level package management window can be accessed by right-clicking on the solution and choosing Manage NuGet Packages for Solution. From there, if you select a package that is installed into multiple projects, but with different versions in use, a new “Consolidate” action becomes available. In the screen shot below, <code class=\"highlighter-rouge\">Newtonsoft.Json</code> was installed into the <code class=\"highlighter-rouge\">SamplesClassLibrary</code> with version <code class=\"highlighter-rouge\">6.0.4</code> and installed into <code class=\"highlighter-rouge\">SamplesConsoleApp</code> with version <code class=\"highlighter-rouge\">5.0.4</code>.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/consolidate.png\" alt=\"Consolidate Versions\" /></p>\n\n<p>Here’s the workflow for consolidating onto a single version.</p>\n\n<ol>\n  <li>Select the <code class=\"highlighter-rouge\">Newtonsoft.Json</code> package in the list</li>\n  <li>Choose <code class=\"highlighter-rouge\">Consolidate</code> from the <code class=\"highlighter-rouge\">Action</code> dropdown</li>\n  <li>Use the <code class=\"highlighter-rouge\">Version</code> dropdown to select the version to be consolidated onto</li>\n  <li>Check the boxes for the projects that should be consolidated onto that version (note that projects already on the selected version will be greyed out)</li>\n  <li>Click the <code class=\"highlighter-rouge\">Consolidate</code> button to perform the consolidation</li>\n</ol>\n\n<h3 id=\"operation-previews\">Operation Previews</h3>\n\n<p>Regardless of which operation you’re performing–install/update/uninstall–the new UI now offers a way to preview the changes that will be made to your project. This preview will show any new packages that will be installed, packages that will be updated, and packages that will be uninstalled, along with packages that will be unchanged during the operation.</p>\n\n<p>In the example below, we can see that installing Microsoft.AspNet.SignalR will result in quite a few changes to the project.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/preview.png\" alt=\"Preview Installing SignalR\" /></p>\n\n<h3 id=\"installation-options\">Installation Options</h3>\n\n<p>Using the PowerShell Console, you’ve had control over a couple of notable installation options. We’ve now brought those features into the UI as well. You can now control the dependency resolution behavior for how versions of the dependencies are selected.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/dependency-behavior.png\" alt=\"Dependency Behavior\" /></p>\n\n<p>You can also specify the action to take when content files from packages conflict with files already in your project.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/file-conflict-action.png\" alt=\"File Conflict Action\" /></p>\n\n<h3 id=\"infinite-scrolling\">Infinite Scrolling</h3>\n\n<p>We used to get quite a bit of feedback on our UI having both the scrolling and paging paradigms when listing packages. It was pretty common to have to scroll to the bottom of the short list, click the next page number, and then scroll again. With the new UI, we’ve implemented infinite scrolling in the package list so that you only need to scroll–no more paging.</p>\n\n<p><img src=\"/images/2014-11-12-nuget-3.0-preview/infinite-scrolling.png\" alt=\"Infinite Scrolling\" /></p>\n\n<h3 id=\"make-it-work-make-it-fast-make-it-pretty\">Make it Work, Make it Fast, Make it Pretty</h3>\n\n<p>We are excited to get this new UI out for you to try out. During this Preview milestone, we’ve been following the good old adage of “Make it work, make it fast, make it pretty.” In this preview, we’ve accomplished most of that first goal–it works. We know it’s not quite fast yet, and we know it’s not quite pretty yet. Trust that we’ll be working on those goals between now and the RC release. In the meantime, we would love to hear your feedback about the <em>usability</em> of the new UI–the workflows, operations, and how it <em>feels</em> to use the new UI.</p>\n\n<p>There are a couple of functions that we’ve removed when compared to the old UI. One of these was intentional, and the other one just didn’t get done in time.</p>\n\n<h4 id=\"searching-all-package-sources\">Searching “All” Package Sources</h4>\n\n<p>The old UI allowed you to perform a package search against all of your package sources. We’ve removed that feature in the UI and we won’t be bringing it back. This feature used to perform search operations against all of your package sources, weave the results together, and attempt to order the results based on your sorting selection.</p>\n\n<p>We found that search relevance is really hard to weave together. Could you imagine performing a search against Google and Bing and weaving the results together? Additionally, this feature was slow, easy to <em>accidentally</em> use, and we believe it was rarely actually useful. Because of the problems the feature introduced, we received a number of bug reports on it that could never have been fixed.</p>\n\n<h4 id=\"update-all\">Update All</h4>\n\n<p>We used to have an “Update All” button in the old UI that isn’t there in the new UI yet. We will resurrect this feature for our RC release.</p>\n\n<h2 id=\"new-clientserver-api\">New Client/Server API</h2>\n\n<p>In addition to all of the new features in our new package management UI, we’ve also been working on some implementation details for NuGet’s client/server protocol. The work we’ve done is to create “API v3” for NuGet, which is designed around high availability for critical scenarios such as package restore and installing packages. The new API is based on REST and Hypermedia and we’ve selected <a href=\"http://json-ld.org\">JSON-LD</a> as our resource format.</p>\n\n<p>In the NuGet 3.0 Preview bits, you’ll see a new package source called “preview.nuget.org” in the package source dropdown. If you select that package source, we’ll use our new API rather to connect to nuget.org. We’ve made the preview source available in the UI while we continue to test, revise, and improve the new API. In NuGet 3.0 RC, this new API v3-based package source will replace the v2-based “nuget.org” package source.</p>\n\n<p>Despite the investment we’re putting into API v3, we’ve made all of these new features also work with our existing API v2 protocol, which means they will work with existing package sources other than nuget.org as well.</p>\n\n<h2 id=\"new-features-coming\">New Features Coming</h2>\n\n<p>Between now and 3.0 RTM, we are also working on some fundamental new NuGet features, beyond what you’ll see in the UI. Here’s a short list of salient investment areas:</p>\n\n<ol>\n  <li>We’re partnering with the Visual Studio and MSBuild teams to get <a href=\"http://blog.nuget.org/20141014/in-the-platform.html\">NuGet deeper into the platform</a>.</li>\n  <li>We’re working to abandon installation-time package conventions and instead apply those conventions at packaging time by introducing a new “authoritative” <a href=\"http://blog.nuget.org/20141023/package-manifests.html\">package manifest</a>.</li>\n  <li>We’re working to refactor the NuGet codebase to make the client and server components reusable in different domains beyond package management in Visual Studio.</li>\n  <li>We’re investigating the notion of “private dependencies” where a package can indicate that it has dependencies on other packages for implementation details only, and those dependencies shouldn’t be surfaced as top-level dependencies.</li>\n</ol>\n\n<h2 id=\"stay-tuned\">Stay Tuned</h2>\n\n<p>Please keep an eye on <a href=\"http://blog.nuget.org\">our blog</a> for more progress and announcements for NuGet 3.0!</p>\n","Href":"http://blog.nuget.org/20141112/nuget-3.0-preview.html","RawContent":null},{"Title":"Package Manifests","PublishedOn":"2014-10-23T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>As we work on the designs for getting <a href=\"/20141014/in-the-platform.html\">NuGet in the platform</a>, it has become clear that <strong>NuGet needs better support for carrying arbitrary artifacts in packages and exposing them for consumption after the initial package installation</strong>.</p>\n\n<h2 id=\"conventional-manifests\">Conventional Manifests</h2>\n\n<p>Since NuGet’s initial release, it has supported conventional manifests and only a few concepts.</p>\n\n<ol>\n  <li>Assembly references from the <code class=\"highlighter-rouge\">\\lib</code> folder</li>\n  <li>Content files from the <code class=\"highlighter-rouge\">\\content</code> folder</li>\n  <li>PowerShell scripts from the <code class=\"highlighter-rouge\">\\tools</code> folder</li>\n  <li>MSBuild props/targets imports from the <code class=\"highlighter-rouge\">\\build</code> folder</li>\n  <li>A <code class=\"highlighter-rouge\">README.txt</code> file at the root of the package to be opened automatically after installation</li>\n</ol>\n\n<p>All other files inside the package are completely ignored and NuGet’s existing design makes it difficult to expand on these concepts or introduce new ones.</p>\n\n<p>Before we dive into where we think NuGet is going, let’s look closer at what NuGet supports today within its manifests. These are all implemented based on conventions for how the package is laid out–the manifests are not explicitly declared within the <code class=\"highlighter-rouge\">nuspec</code>.</p>\n\n<h3 id=\"assembly-references\">Assembly References</h3>\n\n<p>The <code class=\"highlighter-rouge\">\\lib</code> folder is reserved for assemblies that will get referenced by the project. During installation, NuGet gets the list of assemblies in the <code class=\"highlighter-rouge\">\\lib</code> folder and calls the Visual Studio API for adding an assembly reference to each.</p>\n\n<p>There are a couple of additional features this folder supports.</p>\n\n<h4 id=\"target-framework-selection\">Target Framework Selection</h4>\n\n<p>If you provide a subfolder under <code class=\"highlighter-rouge\">\\lib</code> that matches a framework name we recognize, we use that as an applicability filter. When finding references from the package, we’ll choose the best <code class=\"highlighter-rouge\">\\lib</code> folder for the project; if none of the folders match, then installation fails.</p>\n\n<h4 id=\"deployment-only-assemblies\">Deployment-Only Assemblies</h4>\n\n<p>If your package needs to carry assemblies that are used only for deployment and don’t need actual Visual Studio/MSBuild references, then you can provide additional configuration within your <code class=\"highlighter-rouge\">nuspec</code> to specific which set of assemblies actually do need references.</p>\n\n<h3 id=\"content-files\">Content Files</h3>\n\n<p>The <code class=\"highlighter-rouge\">\\content</code> folder includes content files that will be copied into the project, putting those files directly into the project itself. This is how jQuery and other JavaScript/CSS files get into your project from a NuGet package.</p>\n\n<p>This scenario has come under debate for a couple reasons. Many developers don’t like that <a href=\"http://nuget.codeplex.com/workitem/1914\">NuGet packages get to specify where</a> in the project the content items will be placed. Others want to prevent the content files from getting copied into the project at all and <a href=\"http://nuget.codeplex.com/workitem/1239\">have Package Restore do the work instead</a>.</p>\n\n<p>Content files also support target framework filtering, XML <a href=\"http://docs.nuget.org/docs/creating-packages/configuration-file-and-source-code-transformations#Configuration_File_Transformations\">transformations for app configuration</a>, and <a href=\"http://docs.nuget.org/docs/creating-packages/configuration-file-and-source-code-transformations#Specifying_Source_Code_Transformations\">source code transformations</a> for replacing tokens with project properties.</p>\n\n<h3 id=\"powershell-scripts\">PowerShell Scripts</h3>\n\n<p>When a package carries an <code class=\"highlighter-rouge\">install.ps1</code> file within its <code class=\"highlighter-rouge\">\\tools</code> folder, the script will be run after package installation. An <code class=\"highlighter-rouge\">uninstall.ps1</code> is executed before uninstallation. Lastly, <code class=\"highlighter-rouge\">init.ps1</code> is executed every time the solution is opened (assuming the NuGet PowerShell Console is open). Target framework filters apply to this folder too.</p>\n\n<p>The mere existence of this feature is a blocker for allowing package installation outside the Visual Studio context. These scripts are executed through our PowerShell Console within Visual Studio, they reference Visual Studio DTE API, and they rely on the MSBuild project being loaded and available.</p>\n\n<p>This PowerShell capability has always been an escape hatch to allow a package to express something beyond the capabilities NuGet had for assembly references and content files. NuGet has no way of knowing whether these scripts are optional or if they are truly required for the package to work.</p>\n\n<h3 id=\"msbuild-imports\">MSBuild Imports</h3>\n\n<p>NuGet looks in the <code class=\"highlighter-rouge\">\\build</code> folder for props and targets files where the filename matches the package id. These are automatically imported into the project (at the top or bottom, respectively) using Visual Studio’s DTE API and applying the target framework filtering. We add the imports in a way that is friendly for Package Restore, but the workflow still isn’t great.</p>\n\n<p>This props/targets feature was added after we observed it was the most common use of PowerShell <code class=\"highlighter-rouge\">install.ps1</code> scripts. But oddly enough, this feature itself is another escape hatch to allow a package to express something beyond the capabilities NuGet had for assembly references and content files!</p>\n\n<h3 id=\"readmetxt\">README.txt</h3>\n\n<p>If the package has a <code class=\"highlighter-rouge\">README.txt</code> file at the root of the package, NuGet will automatically open this file when the package is installed (directly, not as a dependency). This is the only file we recognize for this feature–we don’t recognize Markdown or HTML files, and there are no conventions for determining applicability of showing this file. We’ve seen requests for conditionally opening this file in certain configurations, but we’ve had to tell those authors just to use PowerShell.</p>\n\n<h2 id=\"nuget-package-capabilities\">NuGet Package Capabilities</h2>\n\n<p>If you were paying attention, you noticed that two of NuGet’s five package conventions exist solely to augment NuGet’s built-in functionality.</p>\n\n<p><strong>Something’s wrong there.</strong></p>\n\n<p>Merging the two extensibility points into one, let’s recap the <em>actual</em> features NuGet packages offer:</p>\n\n<ol>\n  <li>Assemblies: either referenced or deployed</li>\n  <li>Content files: copied into your project</li>\n  <li>Extensibility points for other types of artifacts</li>\n  <li>A readme experience that is too restrictive</li>\n</ol>\n\n<p>That’s it. If you think about it, it’s pretty amazing that NuGet has had the adoption it has with its functionality boiling down to that.</p>\n\n<h2 id=\"revisiting-fundamentals\">Revisiting Fundamentals</h2>\n\n<p>When we look at the feedback we get from people who have invested heavily in using NuGet, we hear two common themes:</p>\n\n<ol>\n  <li>NuGet should resolve the assemblies at build-time instead of install-time</li>\n  <li>NuGet should let package consumers <a href=\"http://nuget.codeplex.com/workitem/1914\">control how content files are brought in</a> from packages, or <a href=\"http://nuget.codeplex.com/workitem/1239\">not bring them in</a> at all</li>\n</ol>\n\n<p>The feedback on the install-time actions goes all the way back to <a href=\"/20141010/nuget-is-broken.html\">NuGet’s initial design</a> and this is being revisited as we move into the platform, at least for the handling of assemblies from the <code class=\"highlighter-rouge\">\\lib</code> folder.</p>\n\n<p>It’s time to revisit the fundamentals of what is carried inside a NuGet package and design a new package manifest.</p>\n\n<h3 id=\"goals\">Goals</h3>\n\n<p>There are several salient goals for creating a new package manifest design.</p>\n\n<ol>\n  <li>Enable build-time manifest discovery and selection</li>\n  <li>Make NuGet ignorant of target frameworks so that it doesn’t have to be updated every time Xamarin or Microsoft adds a new framework</li>\n  <li>Allow applicability filters beyond target framework, including configuration, architecture, etc., and allow them to be nested</li>\n  <li>Make NuGet ignorant of the filters to make NuGet reusable in new domains and scenarios</li>\n  <li>Make NuGet ignorant of <em>the manifest artifacts themselves</em> to make NuGet reusable in new domains and scenarios</li>\n  <li>Ensure that the gallery and feed both expose all of the manifest information so that tools don’t have to download and unpack <code class=\"highlighter-rouge\">nupkg</code> files (pronounced “NUP-KEG” by the way) to discover what artifacts are in the package</li>\n  <li>Switch from XML-formatted <code class=\"highlighter-rouge\">nuspec</code> files to JSON (because people like authoring and reading JSON better, it’s consistent with the direction we’re taking the feed, and it could potentially align with <a href=\"https://github.com/aspnet/Home/wiki/Project.json-file\">ASP.NET vNext’s project.json file</a>)</li>\n</ol>\n\n<h3 id=\"separating-authoring-from-protocol\">Separating Authoring from Protocol</h3>\n\n<p>The <code class=\"highlighter-rouge\">nuspec</code> has always been NuGet’s “protocol”. It is how packages are understood. Except it is incomplete because it doesn’t include the package manifest–that part was just based on the files within the package itself. This approach allowed the files within the package to be self-describing and the single source of truth. But it has caused us some problems.</p>\n\n<p>Just to name a few of the issues we’ve faced:</p>\n\n<ol>\n  <li>The package contents are required to get the manifest</li>\n  <li>The manifest is needed to determine target framework compatibility</li>\n  <li>Since conventions are applied at package installation time (rather than pack time), adding new conventions is a backwards-compatibility nightmare!</li>\n</ol>\n\n<p>We want NuGet packages to have a clean authoring experience; you shouldn’t have to author the file manifest if it can be gleaned from conventions. But we need to reduce the protocol down to a single source of information (a package manifest) rather than requiring both the <code class=\"highlighter-rouge\">nuspec</code> and the package contents. We will also benefit greatly from applying any conventions at pack time and making packages’ behavior deterministic rather than vulnerable to the client’s understanding of conventions.</p>\n\n<h3 id=\"backwards-compatibility\">Backwards Compatibility</h3>\n\n<p>As we explore producing an authoritative package manifest at the time of packing, we have to be thoughtful of the NuGet clients that exist today–the ones that wouldn’t know to look for this new manifest. We want newly created packages to contain both the authoritative manifest and also be backwards compatible–except for when the packages use <em>new</em> features.</p>\n\n<h3 id=\"proposal\">Proposal</h3>\n\n<p>The most common scenario for packing today is when you have a <code class=\"highlighter-rouge\">nuspec</code> file and then artifacts on disk. You run <code class=\"highlighter-rouge\">nuget.exe pack</code> against your nuspec and you get the following result (ignoring the actual package contents):</p>\n\n<ul>\n  <li><code class=\"highlighter-rouge\">id.version.nupkg</code>\n    <ul>\n      <li><code class=\"highlighter-rouge\">id.nuspec</code></li>\n    </ul>\n  </li>\n</ul>\n\n<p>With the proposal, the result would be changed to the following:</p>\n\n<ul>\n  <li><code class=\"highlighter-rouge\">id.version.nupkg</code>\n    <ul>\n      <li><code class=\"highlighter-rouge\">id.nuspec</code></li>\n      <li><code class=\"highlighter-rouge\">nuget.manifest.json</code></li>\n    </ul>\n  </li>\n</ul>\n\n<h4 id=\"keeping-the-nuspec\">Keeping the nuspec</h4>\n\n<p>The <code class=\"highlighter-rouge\">nuspec</code> file inside the package would still be XML-based and it would contain the following critical components:</p>\n\n<ol>\n  <li>Id</li>\n  <li>Version</li>\n  <li>Authors</li>\n  <li>Description</li>\n  <li>NuGet minClientVersion attribute</li>\n</ol>\n\n<p>If the package does not use any new NuGet features, then all of the rest of the <code class=\"highlighter-rouge\">nuspec</code> would be filled in too (including fields such as <code class=\"highlighter-rouge\">Dependencies</code> and <code class=\"highlighter-rouge\">References</code>), and the <code class=\"highlighter-rouge\">minClientVersion</code> would not be set to require NuGet 3.0. That provides backwards-compatibility with old NuGet clients.</p>\n\n<p>If the package does use new NuGet features, then no other fields would be provided in the <code class=\"highlighter-rouge\">nuspec</code> and the <code class=\"highlighter-rouge\">minClientVersion</code> would be set to 3.0 (or newer). This compromise allows old NuGet clients to still load the package for display purposes but then respect the <code class=\"highlighter-rouge\">minClientVersion</code> when the user tries to install the package.</p>\n\n<h4 id=\"introducing-the-manifest\">Introducing the Manifest</h4>\n\n<p>The <code class=\"highlighter-rouge\">nuget.manifest.json</code> file would contain all of the information carried in the <code class=\"highlighter-rouge\">nuspec</code> but it would also carry the important artifact manifest. The conventions that NuGet applies at install-time today would be applied at pack time and then persisted into this manifest.</p>\n\n<p>When a NuGet 3.0 client reads a package that contains a manifest, the manifest would win and explicitly state what should be done with the package contents–no conventions would be applied at package installation time.</p>\n\n<h4 id=\"authoring-a-manifest-directly\">Authoring a Manifest Directly</h4>\n\n<p>Are you tired of maintaining an XML-based <code class=\"highlighter-rouge\">nuspec</code> file? Do you prefer JSON? Do you want to use new manifest features that we’ll be introducing? Great; you can author the manifest directly!</p>\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Conventions are an awesome way to imply configuration. But make sure you also allow explicit configuration to deviate from conventions.</p>&mdash; Jeff Handley (@JeffHandley) <a href=\"https://twitter.com/JeffHandley/status/522981703842021376\">October 17, 2014</a></blockquote>\n<script async=\"\" src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<p>If you want to take over manifest authoring, you’ll be able to. Instead of creating a <code class=\"highlighter-rouge\">nuspec</code> file, you would author a <code class=\"highlighter-rouge\">nuget.json</code> file (or perhaps use ASP.NET’s <code class=\"highlighter-rouge\">project.json</code> file). Authoring in this format allows you to either retain the pack-time conventions that NuGet will apply or override them as needed. When the package would be created, it would then have the following files in it:</p>\n\n<ul>\n  <li><code class=\"highlighter-rouge\">id.version.nupkg</code>\n    <ul>\n      <li><code class=\"highlighter-rouge\">id.nuspec</code></li>\n      <li><code class=\"highlighter-rouge\">nuget.json</code></li>\n      <li><code class=\"highlighter-rouge\">nuget.manifest.json</code></li>\n    </ul>\n  </li>\n</ul>\n\n<p>Three things happened here. First, the original <code class=\"highlighter-rouge\">nuget.json</code> file was brought into the package. Second, a <code class=\"highlighter-rouge\">nuget.manifest.json</code> file was created. And third, the <code class=\"highlighter-rouge\">id.nuspec</code> file was also created.</p>\n\n<p>We’d create the <code class=\"highlighter-rouge\">nuspec</code> file for backwards-compatibility reasons stated above. We’d create the <code class=\"highlighter-rouge\">nuget.manifest.json</code> file as a result of your author-time <code class=\"highlighter-rouge\">nuget.json</code> and the authoritative manifest. That allows for your author-time <code class=\"highlighter-rouge\">nuget.json</code> file to take some shortcuts and still use conventions as you desire, while retaining the authoritative nature of the manifest file. We’d also include your author-time <code class=\"highlighter-rouge\">nuget.json</code> file to still provide the nice package editing features that you get with tools like <a href=\"http://npe.codeplex.com\">NuGet Package Explorer</a>–that allows the <code class=\"highlighter-rouge\">nupkg</code> to remain a unit that can be copied around, edited, re-packed, and consumed. It could however be an option to omit the <code class=\"highlighter-rouge\">nuget.json</code> file from the package if you don’t want to ship your author-time format.</p>\n\n<p><em>Side-note… We’re also thinking that the <code class=\"highlighter-rouge\">nuget.manifest.json</code> file will utilize <a href=\"http://json-ld.org\">JSON-LD</a> the same way our API v3 work does.</em></p>\n\n<h4 id=\"relying-only-on-the-manifest\">Relying only on the Manifest</h4>\n\n<p>It’s critical to note that at package consumption time, NuGet 3.0 would <em>only</em> use the <code class=\"highlighter-rouge\">nuget.manifest.json</code> file. Even though the package still contains the <code class=\"highlighter-rouge\">nuspec</code> and potentially the author-time <code class=\"highlighter-rouge\">nuget.json</code> file, the <em>protocol</em> for consuming packages would be based on the <code class=\"highlighter-rouge\">nuget.manifest.json</code> file.</p>\n\n<p>We’d end up with a simple if block in the NuGet code:</p>\n\n<ol>\n  <li>If the package contains a <code class=\"highlighter-rouge\">nuget.manifest.json</code> file then use <strong>only</strong> that file for understanding the manifest and don’t apply any conventions at consumption time</li>\n  <li>Otherwise, read the <code class=\"highlighter-rouge\">nuspec</code> and the file list like NuGet always has, applying conventions at consumption time</li>\n</ol>\n\n<h2 id=\"more-to-discuss\">More to Discuss</h2>\n\n<p>We have a lot more to discuss about the plans for NuGet 3.0. We need to talk about what these arbitrary package manifests look like, how they’re configurable, how NuGet-based tools would read and understand the information, and more. We’ll keep working on writing up our thoughts on these topics, but please let us know what you think so far.</p>\n","Href":"http://blog.nuget.org/20141023/package-manifests.html","RawContent":null},{"Title":"NuGet: In the Platform","PublishedOn":"2014-10-14T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>I recently declared that NuGet is “<a href=\"/20141010/nuget-is-broken.html\">Broken By Design</a>.” Now, that was hyperbolic; I don’t really think NuGet is broken. In fact, I’m very pleased with NuGet (and proud of it). But I wanted to make the point that NuGet’s approach both earned it success but also came at a cost. NuGet can’t presently offer some expected package management features because it’s merely a package management façade over top of existing Visual Studio and MSBuild capabilities.</p>\n\n<p>I also wanted you all to know that we recognize that NuGet has been stagnating and that we want to make some changes.</p>\n\n<h2 id=\"the-right-approach\">The Right Approach?</h2>\n\n<p>For years, many have questioned the approach NuGet took bolting onto Visual Studio and MSBuild. Knowing the approach has led to being unable to provide some key new features, was it still the right approach?</p>\n\n<p><strong>Absolutely!</strong></p>\n\n<p>I whole-heartedly believe that the bolt-on approach that NuGet took directly led to its adoption and success. We do not at all regret the direction we went.</p>\n\n<h2 id=\"time-to-change\">Time To Change</h2>\n\n<p>Now that NuGet has gained broad adoption and our users are demanding actual <em>package management</em> features, it’s time to change. As mentioned in the previous post, our partner teams across ASP.NET, Visual Studio, .NET (CLR), MSBuild, and C++ recognize this too. Their users are also demanding package management features, through NuGet.</p>\n\n<p>Only because our collective users are demanding new features do we think we can now make NuGet part of the platform. Putting package management into the platform will result in some changes to how users build projects for the Microsoft development platform. Until recently, we didn’t have the feedback indicating that our users were ready to accept the changes required; we now believe some disruptive changes will be welcomed.</p>\n\n<h2 id=\"problems-to-fix\">Problems To Fix</h2>\n\n<p>In addition to the package management workflows that we cannot presently improve, there are some concrete problems our users face as a result of package management not being a fundamental project concept. Here are some of the problems we aim to address.</p>\n\n<h3 id=\"re-targeting-and-multi-targeting\">Re-Targeting and Multi-Targeting</h3>\n\n<p>Because project files end up with Hint Paths specific to target frameworks selected at package installation time, re-targeting your project can cause the Hint Paths to be stale. Additionally, you cannot multi-target the project by passing the target framework as a parameter to MSBuild, because the framework-specific Hint Paths are burned in for a single framework.</p>\n\n<h3 id=\"package-dependencies-from-project-references\">Package Dependencies From Project References</h3>\n\n<p>Consider the following scenario:</p>\n\n<p><img src=\"/images/2014-10-14-in-the-platform/multi-headed-app.png\" alt=\"Multi-Headed Apps\" /></p>\n\n<p>In this scenario, when you build the Windows Store App, MSBuild will detect the project reference to the Portable Class Library, and it will copy assemblies referenced by that library into the Windows Store App’s output folder. The same will happen for the Windows Phone App. Unfortunately, the Portable Class Library will get the NuGet package’s portable reference assembly rather than the Windows Store or Windows Phone implementation assemblies.</p>\n\n<p>To make this scenario work, MSBuild will ensure NuGet selects the libraries in the context of the consuming project, regardless of whether the package is a direct or indirect dependency.</p>\n\n<h3 id=\"new-build-artifact-types-and-pivots\">New Build Artifact Types and Pivots</h3>\n\n<p>NuGet presently understands managed assemblies and getting references added to them. You can include assemblies in your package that don’t get references, but the capabilities are quite limited. Furthermore, NuGet presently supports only pivoting your assembly selection by Target Framework/Version.</p>\n\n<p>With NuGet packages being a fundamental concept, the .NET team wants to ship more and more of their work as NuGet packages. And the C++ team wants to be able to use NuGet packages for their libraries as well. In order to satisfy the requirements that come in these scenarios, NuGet must allow new artifact types to be expressed in packages so that those artifacts can be exposed to the build.</p>\n\n<p>We are still working on the design for this, but we anticipate NuGet packages being able to express artifact groups that can pivot on the following properties:</p>\n\n<ol>\n  <li>Architecture</li>\n  <li>Configuration</li>\n  <li>Reference vs. Copy-Local</li>\n  <li>Language</li>\n  <li>Design-Time vs. Runtime</li>\n</ol>\n\n<p>For those of you familiar with <a href=\"http://msdn.microsoft.com/en-us/library/hh768146.aspx\">Extension SDKs</a>, you’ll notice the similarity. We plan to implement this as though NuGet could support <em>arbitrary</em> pivots, but we know of concrete scenarios for the properties listed above.</p>\n\n<h2 id=\"nuget-will-gain-a-first-class-presence\">NuGet Will Gain a First-Class Presence</h2>\n\n<p>What needs to change to make all of this happen? What does “putting package management into the platform” mean? Why is it disruptive? What is going to change?</p>\n\n<p><strong>We plan to change Visual Studio and MSBuild to understand the concept of package management; NuGet will gain a first-class presence.</strong> Here are some of the areas and features that will be affected:</p>\n\n<h3 id=\"msbuild\">MSBuild</h3>\n\n<p>We are working on a design where MSBuild, for all project types, will understand that projects can have NuGet packages installed. MSBuild will understand that the installed NuGet packages can have assemblies and other artifacts that need to be included in the build, and that build and environment properties can alter which artifacts need to be included.</p>\n\n<p>We expect the design will arrive at a workflow along these lines:</p>\n\n<ol>\n  <li>An MSBuild target will call into NuGet to get the project’s package manifest (as id/version pairs)</li>\n  <li>MSBuild will also get the package manifests for indirect package references (through project references)</li>\n  <li>An MSBuild target will call into NuGet to get the artifacts (references and other items) for each of the packages, respecting the project and environment properties for artifact selection</li>\n</ol>\n\n<p>This approach is very similar to what <a href=\"http://www.github.com/aspnet/home\">ASP.NET vNext</a> is already doing.</p>\n\n<h4 id=\"package-manifest\">Package Manifest</h4>\n\n<p>NuGet will do the work of reading our <code class=\"highlighter-rouge\">packages.config</code> file and returning the id/version pairs of packages that are installed. It’s important to note that MSBuild itself <em>will not know</em> how to load and parse the package manifest from <code class=\"highlighter-rouge\">packages.config</code>–only NuGet will. This allows us to add future features that change or extend the logic for the package manifest.</p>\n\n<p>Here is some of our thinking for future features that could be introduced.</p>\n\n<h5 id=\"direct-vs-indirect-dependencies\">Direct vs. Indirect Dependencies</h5>\n\n<p>We could change <code class=\"highlighter-rouge\">packages.config</code> to only include direct dependencies, rather than packages that are brought in as indirect dependencies. We would then perform dependency resolution at compile time when MSBuild queries NuGet for the list of installed packages.</p>\n\n<p>We expect to add an annotation to our package manifest to indicate whether the list contains the full closure or just the direct dependencies. You’d then be able to control whether you want to resolve dependencies at package installation time and write them into the manifest, or resolve dependencies at compile time.</p>\n\n<h5 id=\"floating-package-versions\">Floating Package Versions</h5>\n\n<p>Much like resolving dependencies at compile time, we could also choose package versions at compile time. Your package manifest could contain version ranges such as <code class=\"highlighter-rouge\">[2.4.0,2.5.0)</code> so that the newest patch version of 2.4.x could be selected on each build.</p>\n\n<p>While this feature is frequently requested, it can cause you some headaches too; it would be an opt-in feature.</p>\n\n<h5 id=\"manifest-locking\">Manifest Locking</h5>\n\n<p>For floating versions and compile-time dependency resolution, it would be important to allow you to override the variability of resolution, locking the build down to specific packages/versions when desired. We expect to add support for a <code class=\"highlighter-rouge\">packages.lock.config</code> file that would take precedence over <code class=\"highlighter-rouge\">packages.config</code> when NuGet is looking up the package manifest.</p>\n\n<p>With this approach, you could easily commit a <code class=\"highlighter-rouge\">lock</code> file into a release branch, but leave your development branch open. Of course, NuGet.exe would offer a feature such as <code class=\"highlighter-rouge\">nuget.exe lock</code> where the resolution would execute and a <code class=\"highlighter-rouge\">packages.lock.config</code> file would be written out for you.</p>\n\n<h5 id=\"json-formatted-package-manifest\">JSON-Formatted Package Manifest</h5>\n\n<p>A lot of users have requested that we move away from the XML-formatted <code class=\"highlighter-rouge\">packages.config</code> file, and instead adopt JSON for our package manifest. With MSBuild querying into NuGet for the list of packages installed, we leave the door open for making this switch. And it’s quite possible that instead of determining how we’ll extend <code class=\"highlighter-rouge\">packages.config</code> to support the new features of direct vs. indirect dependencies and floating package versions, we’ll instead create a <code class=\"highlighter-rouge\">nuget.json</code> file that has these concepts. We’re even considering a merger of our <code class=\"highlighter-rouge\">nuspec</code> file and this package manifest, along with potentially aligning with <a href=\"https://github.com/aspnet/Home/wiki/Project.json-file\">ASP.NET vNext’s <code class=\"highlighter-rouge\">project.json</code> file</a>.</p>\n\n<p>If we go down the path of using a <code class=\"highlighter-rouge\">nuget.json</code> file, we’d of course then use a <code class=\"highlighter-rouge\">nuget.lock.json</code> file for the manifest locking.</p>\n\n<h5 id=\"single-source-of-truth\">Single Source of Truth</h5>\n\n<p>Today, projects that consume NuGet packages have at least 2, and sometimes 3 “sources of truth.” In any system, having multiple sources of truth is just asking for trouble. Consider the following packages <strong>Microsoft.AspNet.SignalR.Core</strong> and <strong>Microsoft.AspNet.SignalR.Redis</strong>:</p>\n\n<p><strong>Microsoft.AspNet.SignalR.Redis</strong> depends on <strong>Microsoft.AspNet.SignalR.Core</strong></p>\n\n<p>Here is the layout of files that NuGet is managing package reference information in:</p>\n\n<ul>\n  <li>Microsoft.AspNet.SignalR.Core /\n    <ul>\n      <li>Microsoft.AspNet.SignalR.Core.csproj</li>\n      <li>Microsoft.AspNet.SignalR.Core.nuspec</li>\n      <li>packages.config</li>\n    </ul>\n  </li>\n  <li>Microsoft.AspNet.SignalR.Redis /\n    <ul>\n      <li>Microsoft.AspNet.SignalR.Redis.csproj</li>\n      <li>Microsoft.AspNet.SignalR.Redis.nuspec</li>\n      <li>packages.config</li>\n    </ul>\n  </li>\n</ul>\n\n<p>There is duplication in each of the files. The <code class=\"highlighter-rouge\">nuspec</code> has direct dependencies, the <code class=\"highlighter-rouge\">packages.config</code> has the closure of packages (direct and indirect dependencies), and the <code class=\"highlighter-rouge\">csproj</code> has the assemblies referenced as a result of installing the packages. The <code class=\"highlighter-rouge\">nuspec</code> might have other things that differ from the <code class=\"highlighter-rouge\">packages.config</code>, for example version ranges, extra files that should be copied into the package, extra metadata like release notes, project url etc.</p>\n\n<p>We want to consolidate this package reference information into one place. Here’s a potential approach for doing so:</p>\n\n<ol>\n  <li>Completely eliminate assembly references (that came from packages) in the <code class=\"highlighter-rouge\">csproj</code> file</li>\n  <li>Combine the “package manifest” concept in the <code class=\"highlighter-rouge\">packages.config</code> file with the “package authoring” metadata in the <code class=\"highlighter-rouge\">nuspec</code> file</li>\n  <li>Use this one file, presumably <code class=\"highlighter-rouge\">nuget.json</code>, to control the package manifest and package authoring</li>\n  <li>Determine the assembly references (that came from packages) at compile time</li>\n</ol>\n\n<p>We considered putting the package manifest directly into the <code class=\"highlighter-rouge\">csproj</code> file, as <code class=\"highlighter-rouge\">&lt;NuGetPackageReference&gt;</code> items, but that would come with a few drawbacks:</p>\n\n<ol>\n  <li>Installing a NuGet package would still result in updating the <code class=\"highlighter-rouge\">csproj</code> file, which must be done through the Visual Studio project systems</li>\n  <li>We’d still be married to the <a href=\"http://msdn.microsoft.com/en-us/library/envdte.aspx\">DTE</a> because NuGet should not manipulate project files directly</li>\n  <li>ASP.NET vNext, which doesn’t use <code class=\"highlighter-rouge\">csproj</code> files, would still need a different concept</li>\n  <li>Problems like XML merge conflicts would remain</li>\n  <li>It would be more difficult to implement tooling outside of MSBuild</li>\n</ol>\n\n<p>For these reasons, and to enable the ideal situation of NuGet not needing to update <code class=\"highlighter-rouge\">csproj</code> files <em>at all</em> when a package simply contains assemblies, we concluded it’s far better for NuGet’s package manifest to be separate from the project file itself. Of course, the separate package manifest should help with cross-platform scenarios too, which should help <a href=\"http://blog.xamarin.com/xamarin-studio-and-nuget/\">Xamarin</a> out quite a bit.</p>\n\n<h4 id=\"down-level-support\">Down-Level Support</h4>\n\n<p>We haven’t figured out all of the details for how this will be implemented, or if/how we can update previous versions of MSBuild to support NuGet in this way. We don’t expect the changes will be terribly invasive though, and we expect to use existing extensibility points in MSBuild to light this up. If we succeed therein, then down-level support should be possible. But it is quite likely down-level MSBuild support will land out of scope at first, so we might have to be creative.</p>\n\n<h4 id=\"project-transitioning\">Project Transitioning</h4>\n\n<p>We haven’t yet worked out the details for how you’ll transition your project over into the new “build-enlighted” NuGet package consumption mode. There will certainly need to be some sort of gesture to convert, but we don’t know what it will look like yet.</p>\n\n<h3 id=\"visual-studio\">Visual Studio</h3>\n\n<p>Several changes are being made in Visual Studio to make NuGet a first-class citizen in the environment.</p>\n\n<h4 id=\"package-management-ui\">Package Management UI</h4>\n\n<p>During the Visual Studio “14” timeframe, the NuGet team is designing a brand-new package management user interface. Our 4-year-old modal dialog that inherits from the Extensions and Updates dialog is getting completely replaced. Our new user interface is a document window that <em>behaves</em> similarly to the Project Properties window, although it <em>looks</em> completely different.</p>\n\n<p><img src=\"/images/2014-10-14-in-the-platform/new-ui.png\" alt=\"New Package Management UI\" /></p>\n\n<p>This new UI is part of <strong>NuGet 3.0</strong> and it will be available for <strong>Visual Studio 2012</strong>, <strong>Visual Studio 2013</strong>, and <strong>Visual Studio “14”</strong>. As we’ve previously announced, we are going to <a href=\"/20141002/visual-studio-2010.html\">discontinue updates for Visual Studio 2010</a>, so this new UI won’t be available there.</p>\n\n<p>Here are some of the new features available in the new user experience:</p>\n\n<ol>\n  <li>Consolidated Installed/Online/Updates view, with uninstall/install/update actions together in one place</li>\n  <li>Filters for viewing only installed packages or packages that have updates available, replacing the previously separate views</li>\n  <li>Version selection for package installs and updates within the UI (instead of having to drop down to PowerShell)</li>\n  <li>A preview feature that shows what packages will be uninstalled, installed, and left as-is for the selected action</li>\n  <li>Control over the dependency version selection</li>\n  <li>Ability to open NuGet Package Management windows for multiple projects at once</li>\n  <li>Package version consolidation across multiple projects</li>\n  <li>Improved performance and reliability when connected to nuget.org (using a new client/server protocol)</li>\n  <li>Better use of screen real estate and the ability to leave the window open</li>\n</ol>\n\n<p>After NuGet 3.0, we hope to update the UI again to show what artifact types the NuGet package carries. For instance, you could see ahead of time if the package has PowerShell scripts, web.config transforms, or other content files, or if it merely has assembly references. We could even add in installation options where you could disable the execution of the PowerShell scripts or the web.config transforms if desired.</p>\n\n<h4 id=\"solution-explorer\">Solution Explorer</h4>\n\n<p>When NuGet was merely bolting onto existing project systems’ capabilities, that resulted in the assemblies from packages being added into a project’s traditional <code class=\"highlighter-rouge\">References</code> node; there were no actual NuGet package reference entries.</p>\n\n<p>While we’re not sure when the feature will land, we are going to work with Visual Studio to get NuGet packages to show up as nodes in Solution Explorer. These nodes will provide some context menu items for common actions such as uninstalling and updating packages, which will navigate into the package management UI with the package and action selected.</p>\n\n<p>You’ll see this integration first in ASP.NET vNext projects, and then later across all other project systems.</p>\n\n<h3 id=\"nuget-in-new-domains-and-partnerships\">NuGet In New Domains and Partnerships</h3>\n\n<p>In addition to this big drive to get NuGet into the Microsoft development platform, we’ve also recently seen a huge increase in the number of new domains where NuGet is being used as an implementation detail or as a feature within new products. <a href=\"http://www.chocolatey.org\">Chocolatey</a> has been around forever, but with the introduction of <a href=\"https://github.com/OneGet/oneget/wiki/Q-and-A\">OneGet</a>, it’s gaining more momentum. Additionally, systems such as <a href=\"http://octopusdeploy.com/\">Octopus Deploy</a>, <a href=\"http://www.myget.org\">MyGet</a>, <a href=\"http://www.appveyor.com/\">AppVeyor</a>, <a href=\"http://scriptcs.net/\">scriptcs</a>, and many others have come to NuGet with requests to make our server and client bits more flexible for their scenarios.</p>\n\n<p>While we are working on getting NuGet into the platform, we’re also evaluating how much we should generalize NuGet packaging, libraries, and feeds to serve the needs of the new domains and partnerships. Those topics all fall much lower in priority, but it remains on our minds as we make significant code changes.</p>\n\n<h2 id=\"lots-to-do\">Lots To Do</h2>\n\n<p>We have a lot to do to make all of this happen. We hope you like the plans and that you’ll share your feedback with us eiher way. You have been very patient with us as we waited for the time to be right to change the general approach NuGet took from being a bolt-on to being adopted into the platform, and we do appreciate your patience.</p>\n\n<p>As you can probably imagine, all of this work has the NuGet team pretty well consumed. We’ve fallen behind in reviewing pull requests, issues, discussions, and other forums, and our release cadence has also slowed down significantly. Please bear with us as we remain focused on making big changes. If you’d like to get more involved in the project to help us get through this transition, please let us know how you’d like to help.</p>\n","Href":"http://blog.nuget.org/20141014/in-the-platform.html","RawContent":null},{"Title":"NuGet: Broken By Design","PublishedOn":"2014-10-10T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>On January 13, 2011, NuGet 1.0 was released with ASP.NET MVC 3. On June 19, 2012, NuGet 2.0 shipped in the box with all editions of Visual Studio 2012 (including the free ones). That was a little over 2 years ago, and NuGet’s adoption has been steadily increasing since then.</p>\n\n<p>Here are some interesting figures for recent NuGet usage from <a href=\"http://www.nuget.org\">nuget.org</a>:</p>\n\n<ul>\n  <li>Over 260,000,000 total package downloads</li>\n  <li>An average of 1,500,000 package searches per day</li>\n  <li>About 700,000 package downloads per day</li>\n  <li>Well over 250,000 total packages</li>\n  <li>More than 27,000 unique packages</li>\n</ul>\n\n<p>The NuGet is team quite happy with the adoption we’ve seen. But at almost 4 years old, NuGet is starting to show its age and some even claim that “NuGet is broken.”</p>\n\n<h2 id=\"reasons-for-success\">Reasons for Success</h2>\n\n<p>Before we delve into the ways in which NuGet can be considered “broken,” let’s take a look at why NuGet has been successful. We’ll see how some design choices made sense 4 years ago but can be questioned now. The challenge is to find ways to identify which choices should be revisited because circumstances have changed, and which ones need to be left alone to ensure NuGet’s continued success.</p>\n\n<h3 id=\"its-just-a-macro\">It’s Just a Macro</h3>\n\n<p>When NuGet was first released, it didn’t matter whether you were on a 1-person team or a 20-person team, because either way, you could start using NuGet on your project without disrupting the team’s existing workflows. All NuGet did was automate what you were doing manually:</p>\n\n<ol>\n  <li>Search the internet for the library you want</li>\n  <li>Download it as a zip</li>\n  <li>Right-click it, hit properties, and unblock the file</li>\n  <li>Unzip it into a solution-level folder for your external dependencies (I always called mine <code class=\"highlighter-rouge\">lib</code>)</li>\n  <li>Look inside the expanded contents for:\n    <ol>\n      <li>DLLs that need references added in your project (often involving some guess work)</li>\n      <li>Content files that you should copy into your project</li>\n      <li>Web.Config additions that need to be applied</li>\n      <li>Any README or other documentation listing out additional changes needed to your project</li>\n    </ol>\n  </li>\n</ol>\n\n<p>When I’m introducing NuGet to new audiences, I often explain that “NuGet is just a VS macro.” It’s honestly pretty true, both in spirit, and in how NuGet is implemented. Here’s how NuGet supported the above workflow:</p>\n\n<ol>\n  <li>A central repository at www.nuget.org is used for package discovery</li>\n  <li>Packages are expanded into a <code class=\"highlighter-rouge\">packages</code> folder at the solution-level</li>\n  <li>The contents of the package are automatically handled:\n    <ol>\n      <li>Assembly references are added from the package’s <code class=\"highlighter-rouge\">lib</code> folder, selecting the best target framework match and allowing specification of the subset of DLLs to reference when needed</li>\n      <li>Content files are copied into your project, with support for tokens getting replaced with values from the target project (such as root namespace)</li>\n      <li>Web.Config transforms are applied</li>\n      <li>PowerShell scripts can be run that automate any additional changes needed to the project</li>\n    </ol>\n  </li>\n</ol>\n\n<p>Automating package installation is great, but where NuGet really shined in the early days was when you needed to uninstall a package. NuGet would reverse the actions it took to install the package–and I don’t know about you, but that’s the part I would always mess up. Weeks or months could have passed since I referenced a library, and unwinding the steps I took to reference the library was always error-prone. NuGet nailed this.</p>\n\n<p>Combine the clean uninstallation and the installation of a package, and you have NuGet’s package update process. Clean, simple, and reliable. No guess-work for the package consumer–It Just Works<sup>TM</sup>!</p>\n\n<h3 id=\"no-prompts-or-choices\">No Prompts or Choices</h3>\n\n<p>During the install/uninstall/update workflows, NuGet intentionally avoids prompting users for any choices. Here’s the sum total of the prompts that NuGet has today:</p>\n\n<ol>\n  <li>License Acceptance for packages that require it</li>\n  <li>Whether to overwrite or ignore content files that already exist</li>\n</ol>\n\n<p>That’s it, and this is critical. If NuGet had prompts for all of the choices it needs to make, users would be intimidated and worried. NuGet took a “worry-free” approach so that package consumers had it easy. Here are some of the choices NuGet makes on your behalf:</p>\n\n<ol>\n  <li>Which version of the package to install: The latest version is selected automatically</li>\n  <li>How to resolve dependencies: Choose the lowest satisfactory dependency version</li>\n  <li>Which set of DLLs need to be referenced: Select the best target framework match</li>\n</ol>\n\n<h3 id=\"powershell-extensibility\">PowerShell Extensibility</h3>\n\n<p>This is one of the most contentious topics NuGet has faced. Many are still shocked that NuGet allows packages to run arbitrary PowerShell scripts during package installation. This topic came up recently when the actions of the ever-popular <a href=\"http://www.nuget.org/packages/Newtonsoft.Json\">Newtonsoft.Json</a> package <a href=\"https://github.com/JamesNK/Newtonsoft.Json/pull/387\">were criticized</a>. That package uses PowerShell to determine if the user just used the NuGet Package Manager dialog to find and directly install Newtonsoft.Json; if so, a web browser is opened to a documentation page for the package that, including helpful topics, has advertising on the page. Note that the script went to great lengths (justifying the “yolo” comment at the end of the file) to <em>only</em> show this popup if the user <em>directly</em> installed the package.</p>\n\n<p>While the actions of the Newtonsoft.Json package are questionable, they are not harmful, and therefore we support them. Many have argued, and some have demonstrated, that this power could be used for evil purposes. So why does NuGet support PowerShell scripts if it’s so dangerous?</p>\n\n<h4 id=\"escape-hatch\">Escape Hatch</h4>\n\n<p>It’s an extensibility point with unbounded functionality. Package authors could augment NuGet’s package installation conventions to perform any additional actions their package needs to be referenced. We often refer to the feature as an “escape hatch.”</p>\n\n<p>Here are some examples that we’ve seen over the years where PowerShell scripts proved to be valuable:</p>\n\n<h5 id=\"visual-studio-version-specific-files\">Visual Studio Version-Specific Files</h5>\n\n<p><a href=\"http://www.nuget.org/packages/jquery\">jQuery</a> uses PowerShell to provide the right IntelliSense file for you, depending on your version of Visual Studio.</p>\n\n<h5 id=\"target-framework-or-language-specific-content-files\">Target Framework or Language-Specific Content Files</h5>\n\n<p>Many packages need to choose content files based on target framework or project language. We ended up adding target framework selection to content files, but we’ve not yet added a project language-specific pivot.</p>\n\n<h5 id=\"msbuild-imports\">MSBuild Imports</h5>\n\n<p>Scores of packages modified the project to import an MSBuild targets file. At one point, this was the most common use case of PowerShell, so we added a first-class <code class=\"highlighter-rouge\">build</code> folder feature that identifies props and targets files that NuGet will automatically import.</p>\n\n<h5 id=\"advanced-webconfig-xml-transforms\">Advanced Web.Config XML Transforms</h5>\n\n<p>A lot of packages needed to make intelligent transformations to web.config that couldn’t be expressed in a transform file. We added XDT support to minimize the need for PowerShell in these cases.</p>\n\n<h5 id=\"native-assemblies\">Native Assemblies</h5>\n\n<p><a href=\"http://www.nuget.org/packages/Microsoft.SqlServer.Compact\">Microsoft.SqlServer.Compact</a> copies native assemblies into the project and hooks up a post-build event to ensure they’re copied into the project’s output folder.</p>\n\n<h5 id=\"tooling-and-scaffolding\">Tooling and Scaffolding</h5>\n\n<p><a href=\"http://www.nuget.org/packages/EntityFramework\">EntityFramework</a> exports a PowerShell Module so that cmdlets such as “Add-Migration” can be added into the NuGet PowerShell Console.</p>\n\n<h5 id=\"opening-readme-files\">Opening README Files</h5>\n\n<p>At one point the second most common use of PowerShell was to open a README file. We added the recognition of a <code class=\"highlighter-rouge\">README.txt</code> file in the package and when the package is directly installed, we’ll open the file automatically.</p>\n\n<p>We chose to only support TXT files and not HTML or Markdown. Perhaps because of this decision, some package authors still use PowerShell to open rich pages served from their websites. We’ve already mentioned Newtonsoft.Json, but Glimpse is another interesting example. They have some impressive logic:</p>\n\n<ol>\n  <li>Upon new installation, a web page is opened with info about the specific package version that was installed.</li>\n  <li>Their web page lists some additional Glimpse packages that could be beneficial to you.</li>\n  <li>Upon package update, they perform some, hmm, clever maneuvers to track the old package version and the new package version, and they open a browser window with <a href=\"http://www.semanticreleasenotes.org/\">Semantic Release Notes</a> applicable to the update path you just exercised.</li>\n</ol>\n\n<h4 id=\"filling-the-gaps\">Filling the Gaps</h4>\n\n<p>By adding features for target-framework-specific content files, MSBuild imports, XDT transforms, and README.txt files, we’ve covered a lot of the scenarios where authors had previously used PowerShell. But it’s clear we’ll never be able to fill all of the gaps.</p>\n\n<h3 id=\"requiring-visual-studio-to-install-packages\">Requiring Visual Studio to Install Packages</h3>\n\n<p>I can’t count the number of times someone has asked if they can install a package from the command-line, and then complained when they learn the answer is “No.” As explained above, NuGet is implemented as though it’s a Visual Studio macro. Our Visual Studio extension is where all of the logic exists for making modifications to make to the project, and this has been often criticized.</p>\n\n<h4 id=\"tightly-coupled-to-visual-studio\">Tightly Coupled to Visual Studio</h4>\n\n<p>With the mindset of NuGet simply automating the actions you were taking, it’s easy to understand why NuGet is implemented the way it is. The fact is, NuGet was built by a small team as a bolt-on to Visual Studio, allowing package management to be introduced to Visual Studio users with very low risk and no changes to Visual Studio itself.</p>\n\n<p>NuGet uses Visual Studio’s <a href=\"http://msdn.microsoft.com/en-us/library/envdte.aspx\">DTE</a> (<a href=\"http://stackoverflow.com/questions/17239760/what-is-the-visual-studio-dte\">Development Time Environment</a>) to automate the actions that you would have taken yourself. This is how assembly references are added, content files are copied into your project, and how MSBuild imports are applied. Even PowerShell scripts use the DTE to perform their custom actions against the projects. Using the DTE, any operations NuGet makes are handled just as though they were initiated manually.</p>\n\n<ul>\n  <li>When connected to source control, Visual Studio takes care of invoking the necessary actions</li>\n  <li>Project systems handle content files by understanding their file extensions and setting up build actions and custom tools (like the ResXFileCodeGenerator)</li>\n  <li>Project systems handle adding assembly references, generating the hint paths, and writing them into the project file</li>\n  <li>Visual Studio manages the project file in memory so that changes resulting from package operations are coordinated with any other unsaved changes you have</li>\n</ul>\n\n<h4 id=\"bolt-on-benefits\">Bolt-On Benefits</h4>\n\n<p>Using Visual Studio’s automation APIs to mimic what manual actions would have done allowed NuGet to get down-stream benefits. No changes to remaining workflows were required, because the result of installing a package matches exactly the result if the actions had been taken manually.</p>\n\n<ol>\n  <li>No new concepts are added to your project–other team members could be oblivious and unaffected</li>\n  <li>Source control integration (generally) works as you expect</li>\n  <li>No changes were required for your build to keep working (until you opted into Package Restore)</li>\n  <li>Tools like Web Deploy work just fine and don’t need to be aware of the NuGet packages</li>\n</ol>\n\n<p>Had we tried to alter these workflows when NuGet was being introduced, there’s no way we would have gotten traction–NuGet 1.0 would never have shipped. And even if it had shipped, it would have been considered too disruptive for a lot of users.</p>\n\n<h2 id=\"harmful-consequences\">Harmful Consequences</h2>\n\n<p>As a trade-off for the benefits NuGet realized with the bolt-on approach, there are some harmful consequences that resulted from the approach. As users adopt the package management concept in their projects, they then expect to have first-class package management experiences, but NuGet cannot offer them. All NuGet can offer is a package management façade over top of existing Visual Studio and .NET usage.</p>\n\n<h3 id=\"hint-paths-in-projects\">Hint Paths in Projects</h3>\n\n<p>Because NuGet asks the project system to add references to assemblies from a package, rather than inventing a new mechanism from which the assemblies could be resolved, the project system ends up baking a hint path into the project for where the assembly can be found.</p>\n\n<div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\n    <span class=\"nt\">&lt;Reference</span> <span class=\"na\">Include=</span><span class=\"s\">\"Newtonsoft.Json\"</span><span class=\"nt\">&gt;</span>\n      <span class=\"nt\">&lt;HintPath&gt;</span>..\\packages\\Newtonsoft.Json.4.5.11\\lib\\net40\\Newtonsoft.Json.dll<span class=\"nt\">&lt;/HintPath&gt;</span>\n    <span class=\"nt\">&lt;/Reference&gt;</span>\n    <span class=\"nt\">&lt;Reference</span> <span class=\"na\">Include=</span><span class=\"s\">\"System.Net.Http\"</span><span class=\"nt\">&gt;</span>\n      <span class=\"nt\">&lt;Private&gt;</span>True<span class=\"nt\">&lt;/Private&gt;</span>\n      <span class=\"nt\">&lt;HintPath&gt;</span>..\\packages\\Microsoft.Net.Http.2.0.30506.0\\lib\\net40\\System.Net.Http.dll<span class=\"nt\">&lt;/HintPath&gt;</span>\n    <span class=\"nt\">&lt;/Reference&gt;</span>\n</code></pre></div></div>\n\n<p>If you had downloaded <a href=\"http://www.nuget.org/packages/Newtonsoft.Json\">Newtonsoft.Json</a> and <a href=\"http://www.nuget.org/packages/Microsoft.Net.Http\">Microsoft.Net.Http</a>, expanded them into a <code class=\"highlighter-rouge\">lib</code> folder, and added references to their assemblies yourself, you would have ended up with virtually the same result as what you got through NuGet here. That’s because Visual Studio and MSBuild don’t understand the concepts of package at all, so we’re just reusing the mechanisms that were understood. But this detail of Hint Paths causes quite a few problems and introduces several limitations.</p>\n\n<h3 id=\"fixed-package-versions\">Fixed Package Versions</h3>\n\n<p>NuGet centralizes packages at the solution-level so that if packages are reused in multiple projects in the solution, only one copy of the package is needed. But since it’s possible to have multiple package versions in use across a solution, we need to have the package versions in the paths. That results in the version being coded into the project file and all of the hint paths.</p>\n\n<p>A lot of users would like package references to floating versions where the latest patch, minor, or major version can be used automatically. This would enable package updates to be consumed automatically in your project during development, while allowing you to lock the versions down as you stabilize for deployment. But with package versions embedded in the project file’s hint paths, the versions become fixed.</p>\n\n<h3 id=\"frequent-merge-conflicts\">Frequent Merge Conflicts</h3>\n\n<p>On medium to large teams, we hear that merge conlicts arise often because of all of the hint paths and assembly references embedded in the project. Merge conflicts in XML files… gah!</p>\n\n<h3 id=\"global-package-installation\">Global Package Installation</h3>\n\n<p>Large packages (especially packages for use in native projects) can take up a good chunk of your solid state hard drive. We’ve received many requests to support global package installations where the package is only on disk in one place but reused across many solutions. With relative paths to assemblies in the project files, it’s virtually impossible to pull off global package installations.</p>\n\n<h3 id=\"multi-homed-projects\">Multi-Homed Projects</h3>\n\n<p>It’s pretty common to include a project in mutliple solutions. Unfortunately, NuGet cannot understand when this is the case. And because NuGet uses a <code class=\"highlighter-rouge\">packages</code> folder at the solution level, the Hint Paths in projects become relative to the solution. If there are multiple solutions using a project, these relative paths can easily break.</p>\n\n<h3 id=\"project-re-targeting\">Project Re-Targeting</h3>\n\n<p>In the last few years, project re-targeting has become much more common–that is when you need to change the target framework(s) you’re building your project for. Mobile platforms and portable class libraries have introduced the need to re-target your project on a somewhat regular basis. But since NuGet performed target framework selection at package installation time, projects end up with Hint Paths specific to the framework(s) that were targeted at the time of installation.</p>\n\n<p>NuGet records into <code class=\"highlighter-rouge\">packages.config</code> the target framework that was in use when the package was installed. When the project is re-targeted, the tooling can detect which packages need to be reinstalled. Unfortunately, <a href=\"http://docs.nuget.org/docs/workflows/reinstalling-packages\">reinstalling packages</a> is sometimes cumbersome and error-prone; you’re left not quite sure what to do.</p>\n\n<h2 id=\"part-of-the-platform\">Part of the Platform</h2>\n\n<p>When NuGet was introduced, we simply bolted it onto the existing Visual Studio and MSBuild. It was the only way to ship and gain initial adoption. Almost 4 years later, we’ve accomplished those goals and then some. But without being part of the platform, NuGet cannot offer expected package management features to our users.</p>\n\n<p>The good news is that the NuGet, ASP.NET, Visual Studio, CLR, MSBuild, and C++ teams (among others) recognize this. We are all partnering to get NuGet package management adopted into the platform. ASP.NET vNext has been architected around NuGet packages from day one and the benefits are obvious. We’re hoping to gain many of the same benefits on other platforms.</p>\n\n<h3 id=\"goals\">Goals</h3>\n\n<p>While ASP.NET vNext has already gained a lot by understanding NuGet packages in its core, making progress in all other project systems is a bit trickier. Nonetheless, here are some of the features we’re hoping to unlock with the partnerships:</p>\n\n<h4 id=\"leave-project-files-alone\">Leave Project Files Alone</h4>\n\n<p>Instead of adding assembly references with Hint Paths into projects through the DTE, we want to leave project files alone. This would avoid the XML merge conflicts that arise far too often. Only the package manifest (<code class=\"highlighter-rouge\">packages.config</code>) would be updated when a package is installed.</p>\n\n<h4 id=\"automatic-re-targeting\">Automatic Re-Targeting</h4>\n\n<p>Rather than choosing the right target framework at package installation time, we want to make the choice at compile time. This would enable automatic re-targeting for packages, so that when you change your target framework, the next compile would automatically use the appropriate assembly references.</p>\n\n<h4 id=\"global-package-installation-1\">Global Package Installation</h4>\n\n<p>If NuGet is resolving assembly paths at compile time anyway, then the global package installation feature is unblocked. NuGet would be able to look up paths from a global installation folder as well as from a solution-level folder.</p>\n\n<p>We expect we’ll search several paths, with the solution-level location having the highest precedence.</p>\n\n<h4 id=\"multi-homing\">Multi-Homing</h4>\n\n<p>With compile-time reference resolution, we can also better support projects being reused in multiple solutions. We’d no longer have relative hint paths causing problems.</p>\n\n<h4 id=\"floating-package-versions\">Floating Package Versions</h4>\n\n<p>We want to allow package references to be configured to automatically pick up new versions within a specified version range, rather than always being fixed to a specific version. When we introduce this, we’d also need to introduce a “lock” mechanism where you could override the floating versions in a separate manifest file, perhaps <code class=\"highlighter-rouge\">packages.lock.config</code>.</p>\n\n<h4 id=\"command-line-installation\">Command-Line Installation</h4>\n\n<p>If NuGet is no longer modifying project files during package installations, then we could allow package installation from the command-line. Imagine if <code class=\"highlighter-rouge\">nuget.exe install</code> could just update <code class=\"highlighter-rouge\">packages.config</code> and the package would be used at the next compile; this could finally be doable.</p>\n\n<h3 id=\"limitations\">Limitations</h3>\n\n<p>Many of the benefits we outlined above should work out very well for packages that contain assembly references only. For packages that contain content files, the existing behavior would remain the same. MSBuild imports would continue to work as they do today as well. And PowerShell? Well, we expect we’ll keep PowerShell as-is for now, but we know we need to think about this topic some more.</p>\n\n<h2 id=\"next-steps\">Next Steps</h2>\n\n<p>We’ve made good progress with our partner teams on all of this, but there’s a lot left to do. We’ll follow up soon with notes on the designs we believe will accomplish the goal of getting NuGet package management deeper into the platform.</p>\n","Href":"http://blog.nuget.org/20141010/nuget-is-broken.html","RawContent":null},{"Title":"Visual Studio Tooling Guidance","PublishedOn":"2014-10-08T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>As NuGet continues to gain momentum, more Microsoft teams have been seeking to install NuGet packages from their Visual Studio tooling.  This began with ASP.NET, where NuGet was born, when project templates started coming with pre-installed NuGet packages.  More recently, we’ve heard of teams all across Microsoft with tooling gestures that result in NuGet packages being installed.</p>\n\n<p>We have some guidance we give these teams, but some have questioned our guidance.  We’re here to ask if you agree with us or if you think we should adapt to meet the expectations of these other teams.</p>\n\n<h2 id=\"installing-packages-from-nugetorg\">Installing Packages From nuget.org</h2>\n\n<p>The most common question is how tooling can install packages directly from <a href=\"http://www.nuget.org\">nuget.org</a>.</p>\n\n<h3 id=\"benefits-of-online-package-installation\">Benefits of Online Package Installation</h3>\n\n<p>Teams (that are usually new to NuGet) believe that they will begin shipping their libraries through NuGet and the libraries will no longer need to be installed on the user’s machine (like traditional SDKs).  They want their tooling to simply connect to nuget.org and install the package when the tooling gesture is performed.</p>\n\n<p>This would make their tooling installer a bit easier to maintain because they wouldn’t need to include the packages in the installer.  Instead they’d only maintain the tooling that triggers the installation.</p>\n\n<h3 id=\"why-we-discourage-online-installation\">Why We Discourage Online Installation</h3>\n\n<p>There are several reasons why we discourage online installation.  In fact, our Visual Studio API intentionally makes it difficult to do this, but it is technically possible.  Despite our firm guidance against it, some teams have proceeded to use this approach anyway.</p>\n\n<p>Here are the reasons we cite:</p>\n\n<h4 id=\"it-breaks-offline-scenarios\">It Breaks Offline Scenarios</h4>\n\n<p>Too many teams at Microsoft seem to think users are always online.  We frequently hear from our community that we should never assume a connection (let alone a good one), and we remind other teams of this as often as we can.</p>\n\n<p>If the tooling requires a connection to nuget.org, and the user is offline, there’s a whole new failure path that gets opened up.  What should the tooling do?  Fail and show a message?  Or fall back to a local package source?  If there is a local package source, why not just use it every time?</p>\n\n<h4 id=\"it-violates-nuget-configurations\">It Violates NuGet Configurations</h4>\n\n<p>NuGet users can configure their own package sources–and many users do.  Some users completely disable nuget.org and use their own internal package sources instead.  In fact, companies can even utilize <a href=\"http://docs.nuget.org/docs/reference/nuget-config-file#NuGet_config_extensibility_point\">NuGet’s hierarchical configuration</a> to apply Group Policy that disables nuget.org by default.</p>\n\n<p>If the user (or company) has disabled the nuget.org package source, for varying reasons including privacy, then Visual Studio tooling should respect this configuration.  Otherwise, the tooling teams must ensure that they alter the Visual Studio privacy policy to indicate that their tooling will connect to nuget.org regardless of the user’s NuGet configuration.</p>\n\n<p><em>Note: The Visual Studio privacy policy specifically calls out NuGet’s Package Restore feature and that it will connect to nuget.org by default.  But the policy informs users that they can change NuGet’s configuration to disable nuget.org or the Package Restore feature.</em></p>\n\n<h2 id=\"installing-the-latest-package-version\">Installing the Latest Package Version</h2>\n\n<p>Another frequent desire from tooling teams is to always install the latest version of the package.  This is another detail where we strongly advise against this behavior, and we get strong pushback from other teams.  Our Visual Studio API makes this exceptionally difficult to achieve, and teams have complained about how hacky their solutions need to be–we then explain to them that it’s because we really don’t want them doing it.</p>\n\n<h3 id=\"arguments-for-installing-the-latest-version\">Arguments for Installing the Latest Version</h3>\n\n<p>“We want to iterate on our packages more often than we ship our tooling.”  That’s what we hear every time a team argues for installing the latest version of the package rather than a fixed version.</p>\n\n<p>We also hear the argument that, “Our package coincides with an online service and we must keep them in sync.”</p>\n\n<h3 id=\"requiring-a-fixed-version\">Requiring a Fixed Version</h3>\n\n<p>With tooling that installs the latest version of a package, the tooling gesture becomes temporal, with the results of the gesture changing over time.  Perhaps this is just personal opinion, but I’d be furious if initiating a tooling gesture had a different effect today than it did three weeks ago or on a different project.</p>\n\n<p>Additionally, the tooling now becomes vulnerable to changes in the package that are incompatible with the tooling.  Sure, you can argue that <a href=\"http://semver.org\">Semantic Versioning</a> can be used to install the latest patch or minor version where compatibility is guaranteed, but I’ll respond with three counter arguments:</p>\n\n<ol>\n  <li>There’s no such thing as a compatibility guarantee</li>\n  <li>And all you’re doing is expanding your test matrix, with the possibility of handcuffing yourself</li>\n  <li>Besides, this would only help users who haven’t yet installed the package; it doesn’t solve the problem for users who already have</li>\n</ol>\n\n<p>What happens when you need to make a library change that breaks the tooling?  I guess you’re going to need to change your major version and ship new tooling anyway.  If you need to plan for iterating on your tooling, then why not just iterate on the tooling in the first place?</p>\n\n<p>Overall, we declare that the package consumer must be in control of when new package versions are installed.  Therefore, we summarize this topic by declaring:</p>\n\n<ol>\n  <li>Make the tooling install a fixed version</li>\n  <li>Allow the user to utilize existing NuGet tooling to update the package when it’s right for them</li>\n  <li>Update your tooling when you need to make a change to the tooling and package together</li>\n  <li><strong>Never let tooling update a package that is already installed!</strong></li>\n</ol>\n\n<p>We believe the last point is especially important.  If a tooling gesture that requires a package to be installed could update the package, the user’s application could become broken in ways you can’t predict.  Worse yet, updating the package for the sake of one tooling gesture could break the application in a distant area that the user might not even realize could be affected.  The package consumer is the only one who knows how the packages are being used in their application and therefore they should be the only ones controlling when packages are updated.</p>\n\n<h2 id=\"nuget-should-notify-users-of-package-updates\">NuGet Should Notify Users of Package Updates</h2>\n\n<p>After teams hear our guidance on installing fixed package versions through tooling, they almost always complain about how hard it is for users to update packages.  This is especially true for teams whose users are relatively new to NuGet and aren’t yet accustomed to checking for NuGet package updates.</p>\n\n<h3 id=\"projects-need-to-be-kept-updated\">Projects Need To Be Kept Updated</h3>\n\n<p>Package authors generally think every update they push is an important one and their users need to update right away.  Depending on the type of package, this can sometimes be valid.  If the package coincides with a service, then it’s possible that users must get the update.  We’ve seen circumstances where server APIs were changed and old clients were broken.  For those situations the package consumer does need to get the latest version of the package in order for their application to work.  But in the vast majority of other scenarios, the package updates aren’t nearly as important to package consumers as the authors would like to believe.</p>\n\n<h3 id=\"package-update-notifications-fall-short\">Package Update Notifications Fall Short</h3>\n\n<p>Despite some authors thinking package update notifications would be a panacea, it certainly wouldn’t be.</p>\n\n<ol>\n  <li>How would NuGet control the flow of notifications to the user so that only truly important updates cause notifications?</li>\n  <li>Who decides what is “important”?</li>\n  <li>At what point would the notification be presented to the user?</li>\n  <li>How would the user dismiss or “snooze” notifications?</li>\n  <li>How would you notify the user if they aren’t actively working on the project that consumes the package?</li>\n</ol>\n\n<p>The last point is the most crucial I believe.  If you’re relying on notifications inside Visual Studio to inform the user that an installed package is out of date, but the user’s application is deployed to production and in maintenance mode, how will they ever get the notification?</p>\n\n<h2 id=\"your-thoughts\">Your Thoughts</h2>\n\n<p>What do you think?  Is our guidance on the mark here, or do you think we should adjust?  We’d appreciate hearing your feedback, especially from the package consumer point of view.</p>\n","Href":"http://blog.nuget.org/20141008/vs-tooling.html","RawContent":null},{"Title":"Discontinuing Updates for Visual Studio 2010","PublishedOn":"2014-10-02T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>As we work on some big changes for NuGet 3.x, we’re finding that we’re at a crossroads: Should we use .NET 4.5 and improve our Visual Studio UI using new features available in Visual Studio 2012, Visual Studio 2013, and Visual Studio “14”; or should we retain support for Visual Studio 2010?</p>\n\n<p>Visual Studio 2010 has been supported since NuGet’s introduction.  But supporting it prevents us from using .NET 4.5 and since it has different visual styling from the newer versions of Visual Studio, it’s holding us back on some of our new UI.</p>\n\n<h2 id=\"visual-studio-2010-usage\">Visual Studio 2010 Usage</h2>\n\n<p>In July 2013, we started capturing what version of Visual Studio was being used when a package was installed.  Here’s what the data shows us from then vs. now:</p>\n\n<table>\n    <thead>\n        <tr>\n            <th>Visual Studio Version</th>\n            <th>Usage in July 2013</th>\n            <th>Usage in September 2014</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Visual Studio 2010</td>\n            <td>16%</td>\n            <td>6%</td>\n        </tr>\n        <tr>\n            <td>Visual Studio 2012</td>\n            <td>69%</td>\n            <td>28%</td>\n        </tr>\n        <tr>\n            <td>Visual Studio 2013</td>\n            <td>11%</td>\n            <td>62%</td>\n        </tr>\n        <tr>\n            <td colspan=\"3\">\n                <em>The remaining usage is spread across WebMatrix and Visual Studio \"14\"</em>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<p>While 6% of package downloads through Visual Studio 2010 is still notable, the quick adoption of Visual Studio 2013 is impressive.  We expect Visual Studio “14” to also have quick adoption.</p>\n\n<h2 id=\"discontinung-updates\">Discontinung Updates</h2>\n\n<p>If we “drop” Visual Studio 2010, here’s what it would mean:</p>\n\n<ul>\n  <li>NuGet 3.0+ would no longer include updates to the Visual Studio 2010 NuGet extension</li>\n  <li>NuGet 2.8 would remain available for Visual Studio 2010 users</li>\n  <li>New features introduced in NuGet 3.0+ would not be available to those users</li>\n  <li>Packages that require new features of 3.0+ would not be installable through Visual Studio 2010</li>\n  <li>The nuget.org gallery would continue to work for you as it does today</li>\n</ul>\n\n<p>At this point, we plan to move forward with this decision.  We would continue updating NuGet for Visual Studio 2012, Visual Studio 2013, and Visual Studio “14”.</p>\n\n<h2 id=\"objections\">Objections?</h2>\n\n<p>If you have objections to this plan, please leave us a comment explaining why you’re still using Visual Studio 2010 and why continued NuGet updates are important to you.  Remember, the existing NuGet 2.8 extension would remain available to you, and nuget.org will continue to work for you, you just wouldn’t be getting the latest NuGet features.</p>\n","Href":"http://blog.nuget.org/20141002/visual-studio-2010.html","RawContent":null},{"Title":"Target Framework Filtering and a Pending Breaking Change","PublishedOn":"2014-10-01T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Have you ever seen this error before?</p>\n\n<p><img src=\"/images/2014-10-01-targetframeworkfiltering/01-error.png\" alt=\"Could not install package because it does not contain any files that are compatible with your framework\" /></p>\n\n<p>Doesn’t it make you want to yell and scream at NuGet, “Why did you just show it to me if I couldn’t install it!?‽”</p>\n\n<p>Yeah, it makes us want to yell and scream too, so we decided to set about fixing it! Along with that, we’ve also discovered a bug we want to correct but unfortunately, it’s a breaking change so we wanted to get your feedback and do it in NuGet 3.0.</p>\n\n<h2 id=\"target-framework-filtering-in-search\">Target Framework Filtering in Search</h2>\n<p>We are deploying a change to make the nuget.org Search API filter out packages (and versions of packages) that are incompatible with the framework your project targets. This means that if you are targetting .NET 4.0, you will see MVC 4 but you won’t see MVC 5 in the list, because MVC 4 is the latest version that supports .NET 4.0. This also means that if you’re building a Windows Phone App, MVC won’t show up at all because no versions of it are compatible with Windows Phone.</p>\n\n<p>This feature should work in version 2.1 of NuGet and up. Since adding the new Search API in that version we’ve always sent the target framework of the project to the server, now we’ve just turned on the code on the server to do something with that data.</p>\n\n<p><em>We expect this to take effect around 6:00pm Pacific time on October 1st</em></p>\n\n<h3 id=\"some-caveats\">Some Caveats</h3>\n<p>There are a few caveats and quirks with this change, but they should be minor and affect very few users. The biggest one is that if you open the dialog from a package that targets a Xamarin framework, a portable profile or a framework we don’t understand, the filtering will be disabled. This is due to some limitations in our client-server interaction in NuGet 2.x. The good news is, we plan to fix those in 3.0! For the existing 2.x clients, we felt it would be better to just disable filtering when we don’t recognize a framework rather than accidentally filter in or out packages that shouldn’t be filtered.</p>\n\n<p>We also may occasionally filter out a package that NuGet will <em>technically</em> allow you to install. In those cases, you can still use Install-Package from PowerShell to force NuGet to try and install the package. However, NuGet only allows you to install these packages due to what we believe is a bug and something that we will be correcting in 3.0.</p>\n\n<h2 id=\"breaking-change-to-target-framework-handling\">Breaking Change to Target Framework Handling</h2>\n<p>In NuGet 3.0, we will be introducing a small breaking change in our Target Framework handling. We strongly believe this will have a very minimal impact on users, but we want to tell you about it and get your feedback.</p>\n\n<p>Consider a package with the following files:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>content/\n\tweb.config.transform\nlib/\n\tnet40/\n\t\tMyThingy.dll\n\tnet45/\n\t\tMyThingy.dll\n</code></pre></div></div>\n\n<p>In NuGet 2.0, if a package contains a file in <code class=\"highlighter-rouge\">content/</code> or <code class=\"highlighter-rouge\">lib/</code> that is <strong>not</strong> within a target framework folder, the package is allowed to install in to <strong>any project</strong> targeting <strong>any framework</strong> no matter what folder structure is used in the other folders. However, we believe that this is not generally what the author intends. In the above example, the author likely intended for the package to be installable into <code class=\"highlighter-rouge\">net40</code> and <code class=\"highlighter-rouge\">net45</code> projects <strong>only</strong>, but for the same config transform to be applied <strong>regardless of the target framework</strong>. In fact, this is exactly how the EntityFramework package is structured (with a few extra files), meaning EntityFramework can technically be installed into a Windows Store JavaScript project. When you do that, all you end up with is a fairly useless app.config and an entry in packages.config:</p>\n\n<p><img src=\"/images/2014-10-01-targetframeworkfiltering/02-what-the-ef.png\" alt=\"EntityFramework installation a JavaScript project\" /></p>\n\n<p>So, in NuGet 3.0, this behavior will be <strong>removed</strong>. We think this makes the behavior much clearer and easier to understand. The NuGet 3.0 behavior will be the following:</p>\n\n<ol>\n  <li>A Package has a set of zero or more <em>framework constraints</em>.</li>\n  <li>If a Package has no <em>framework constraints</em>, it can be installed into any project, regardless of target framework.</li>\n  <li>If a Package has <em>framework constraints</em>, it can be installed into any project that targets a framework <strong>compatible</strong> with any framework in the set.</li>\n  <li>If a Project targets a Portable profile, a package can only be installed if it has no <em>framework constraints</em>, or contains a portable profile <em>framework constraint</em> that targets a <strong>superset</strong> (i.e. the same, or more, but never fewer) of the frameworks supported by the project.</li>\n  <li>Package <em>framework constraints</em> are defined by the following algorithm:\n    <ol>\n      <li>Start with an empty set of <em>constraints</em></li>\n      <li>For each <a href=\"http://docs.nuget.org/docs/reference/nuspec-reference#Specifying_Framework_Assembly_References_(GAC)\">Framework Assembly Reference</a> with a non-null <code class=\"highlighter-rouge\">targetFramework</code> value, add that framework to the set of constraints</li>\n      <li>For each file in <code class=\"highlighter-rouge\">content/</code>, <code class=\"highlighter-rouge\">lib/</code>, <code class=\"highlighter-rouge\">build/</code> and <code class=\"highlighter-rouge\">tools/</code>: If file is in a subfolder of one of those top-level folders, AND the subfolder is a valid short framework name (i.e. net40, win81, etc.), add that framework to the set of constraints.</li>\n    </ol>\n  </li>\n</ol>\n\n<p>The net effect is this: If you never limit anything to a specific framework, your package can be installed into a project targetting <strong>any framework</strong>. However (here’s the new bit): as soon as you start limiting package contents to a specific framework, you will have to specify all the frameworks you want to support <em>somewhere</em> in the package. We still use the same logic we always used when selecting the files <strong>within</strong> the package, so if a file is not in a framework subfolder we will copy it (or reference it, or import it, or whatever we normally do with it) regardless of your project’s target framework. The only difference here is that adding a file that is not framework-specific does not lift the framework constraints placed by other files, whereas in NuGet 2.0 it would.</p>\n\n<p>There’s still plenty of time to discuss and adjust this policy so if you have comments, please let us know!</p>\n","Href":"http://blog.nuget.org/20141001/targetframeworkfiltering.html","RawContent":null},{"Title":"Supporting Semantic Versioning 2.0.0","PublishedOn":"2014-09-24T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><em><strong>Updated Sept. 2015:</strong> Our roadmap and requirements have changed and we have yet to implement these features as of NuGet v3.2.  We are tracking this issue on GitHub.  Please track <a href=\"https://github.com/NuGet/Home/issues/1359\">this issue</a> to follow our progress.</em></p>\n\n<hr />\n\n<p>We adopted <a href=\"http://semver.org\">Semantic Versioning</a> (SemVer) in <a href=\"http://docs.nuget.org/docs/release-notes/nuget-1.6\">NuGet 1.6</a>.  At the time, <a href=\"http://semver.org/spec/v1.0.0.html\">SemVer 1.0.0</a> was the current version of the spec.  Adopting SemVer provided NuGet support of pre-release package versions.</p>\n\n<p>Since introducing SemVer support, SemVer has reached <a href=\"http://semver.org/spec/v2.0.0.html\">2.0.0</a> and introduced some new features.  There have been <a href=\"\">a lot</a> of requests for NuGet to support SemVer 2.0.0 so these features can be used.</p>\n\n<ul>\n  <li><a href=\"https://nuget.codeplex.com/workitem/3924\">Allow Semantic Versioning 2.0.0 characters</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/1796\">Support build version information using SemVer RC1 notation</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/3416\">Support for SemVer 2.0 specification’s notion of pre-release builds</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2988\">NuGet should allow versions like 2.1-alpha.10</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2636\">Support semver &gt;= 2.0.0-rc.1 specification</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/3805\">Proper pre-release Semantic Versioning not respected</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2915\">Support Full Semantic Versioning</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2346\">Package versioning: combining prerelease &amp; build number not supported</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2247\">Implement semver v2.0</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2137\">Support SemVer build version in version strings</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/3426\">NuGet imposes artificial max string length of 20 characters for “SpecialVersion” (aka pre-release)</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/2931\">Version n.n-alpha.n “is not a valid version string”</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/1697\">Update SemanticVersion to match latest specs</a></li>\n</ul>\n\n<p>We’ve reviewed these issues that have been filed, consolidated them into just a couple of open issues, and we are planning to support these new SemVer 2.0.0 features in NuGet 3.0.  We expect they’ll be implemented between NuGet 3.0 Beta and NuGet 3.0 RTM–probably in a NuGet 3.0 RC release.</p>\n\n<h2 id=\"dot-separated-pre-release-identifiers\">Dot-Separated Pre-Release Identifiers</h2>\n\n<p>The most popular new feature in SemVer 2.0.0 is the dot-separated identifiers within pre-release labels.  For contrast, here are some pre-release version numbers using SemVer 1.0.0, ordered in the way a client understands them:</p>\n\n<ol>\n  <li>2.0.0-alpha1</li>\n  <li>2.0.0-alpha10</li>\n  <li>2.0.0-alpha2</li>\n  <li>2.0.0-beta</li>\n  <li>2.0.0-beta2</li>\n</ol>\n\n<p>While not everyone hits Alpha 10 in their pre-releases, it’s happened enough that this has been reported as an issue on NuGet.  This is working by design though, as the SemVer 1.0.0 spec didn’t support numeric value sorting within pre-release labels.  SemVer 2.0.0 introduces the feature with dot-separated identifiers.  It makes the following possible:</p>\n\n<ol>\n  <li>2.0.0-alpha.1.11.28</li>\n  <li>2.0.0-alpha.2.1.4</li>\n  <li>2.0.0-alpha.10.9.18</li>\n  <li>2.0.0-beta</li>\n  <li>2.0.0-beta.2</li>\n</ol>\n\n<p>NuGet 3.0 will understand these new dot-separated identifiers and properly sort them.</p>\n\n<h2 id=\"build-metadata\">Build Metadata</h2>\n\n<p>SemVer 2.0.0 also introduced a new version segment: build metadata.  Build metadata is appended to the version using the <code class=\"highlighter-rouge\">+</code> character.  While build metadata doesn’t affect version precedence, it allows the package author to embed metadata into the version number such as a commit hash, date, build number, or anything else that could be used for diagnostics.</p>\n\n<p>NuGet will have the following behaviors for version build metadata:</p>\n\n<ol>\n  <li>The build metadata will be respected and retained within the nuspec.</li>\n  <li>The build metadata will be shown in the UI as part of the version number.</li>\n  <li>NuGet.org will not allow you to publish multiple “builds” of the same version of a package (two versions where the only difference is the build metadata).</li>\n  <li>Other NuGet feeds may choose to allow multiple builds.  If they do, when the NuGet client needs to select the latest version of a package, it will arbitrarily select between packages that differ only by build metadata.</li>\n  <li>The NuGet client could however allow you to specifically choose a “build” of a package if the feed exposes multiple builds.</li>\n</ol>\n\n<h2 id=\"downstream-implications\">Downstream Implications</h2>\n\n<p>The changes required to support SemVer 2.0.0 in the NuGet client are quite simple, yes.  However, there are downstream effects that would occur, and those are harder to deal with.</p>\n\n<ol>\n  <li>All NuGet Servers would need to be updated to support the new version strings; otherwise the packages will fail to publish to the server</li>\n  <li>All NuGet Clients need to understand the change as well, so that when these new packages are uploaded to servers and exposed on the feeds, they will be able to parse the version</li>\n  <li>Projects that consume packages using these new versioning features will require NuGet 3.0 to be able to install/uninstall/restore packages</li>\n</ol>\n\n<p>While it’s acceptable to make this change and have packages fail to upload to servers when the version isn’t recognized, it’s not acceptable for NuGet Servers to begin exposing these new version numbers to old NuGet clients–it causes errors.  Therefore we must implement this in a way that won’t expose these new version numbers to old NuGet clients.</p>\n\n<p>And it’s noteworthy that the third point is left open here.  If you use NuGet 3.0 to install a package that uses a SemVer 2.0.0 version number, you won’t be able to use NuGet 1.x or 2.x clients to work with that project any longer.  That includes NuGet Package Restore where you might have nuget.exe in place on your machine to perform package restore for any project/solution.</p>\n\n<h2 id=\"versioning-the-nuget-feed-protocol\">Versioning the NuGet Feed Protocol</h2>\n\n<p>The good news is that we’ve been through this exercise before.  Back when NuGet was first adopting Semantic Versions, we were faced with the exact same problems.  When we introduced support for SemVer 1.0.0, we moved from NuGet API v1 to NuGet API v2.  This allowed us to change the data type of the package versions from a .NET System.Version (4-segment version number) to a string that could represent either a .NET System.Version or a Semantic Version.</p>\n\n<p>We are already creating a new NuGet feed protocol, so it’s convenient to make this SemVer change now.  We’ll allow SemVer 2.0.0 packages on NuGet API v3, but we won’t allow them to show up on API v2.  That means if you include build metadata in your package’s version, the package will only show up for NuGet 3.0+ users.</p>\n\n<p>While creating a package that uses a SemVer 2.0.0 version, we will recognize this and annotate the package as requiring NuGet 3.0 as the minimum client version.  If that minimum client version wasn’t already specified, we’ll provide a warning in the pack console output.</p>\n\n<p>While making these changes, we’ll also relax the current 20-character limitation on pre-release labels.  We expect to extend this to 255 characters.</p>\n\n<h2 id=\"feedback\">Feedback</h2>\n\n<p>We welcome your feedback on this plan.  While we’ve been thinking about this for a long time, we still have a little while before it’ll get baked in.</p>\n","Href":"http://blog.nuget.org/20140924/supporting-semver-2.0.0.html","RawContent":null},{"Title":"A New Package Statistics Warehouse","PublishedOn":"2014-08-20T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<h2 id=\"the-warehouse-is-dead-long-live-the-warehouse\">The Warehouse is Dead, Long Live the Warehouse!</h2>\n\n<p>Back in June, we blogged that our <a href=\"/20140603/nuget-stats.html\">package statistics were full of lies</a>.  We made a fix and expected reports to become correct on June 26th.  When June 26th came and went though, we discovered that the numbers were still questionable.  Since then, we’ve identified a few other issues leading to invalid statistics, and we’ve made notable improvements to our statistics system.  We are now confident that the statistics are trustworthy.</p>\n\n<p>As part of the work, we decided to discard our existing package statistics warehouse database and create a new one.  This new warehouse would only be populated with clean data and none of the invalid, historic data would survive.</p>\n\n<h2 id=\"how-we-create-statistics-reports\">How We Create Statistics Reports</h2>\n\n<p>If you don’t already have the background on how we create our package statistics reports, here’s an overview:</p>\n\n<p><img src=\"/images/2014-06-02-nuget-stats/dataflow.png\" alt=\"Data Flow for Download Statistics\" /></p>\n\n<p>You can read more about <a href=\"/20140603/nuget-stats.html#background\">this data flow</a> on our previous post about package statistics.</p>\n\n<h2 id=\"what-went-wrong\">What Went Wrong</h2>\n\n<p>The bug we fixed a couple months ago was related to how we pull data out of the primary gallery SQL database, where we weren’t properly ordering the results and it led to cases where we would get the same results out multiple times over multiple runs.  After fixing that and actively monitoring the data flowing through the system, we observed statistics still getting multiplied in our statistics warehouse.</p>\n\n<p>Moving data from our primary gallery SQL database to our warehouse was done with a record-by-record replicate process.  The logic was something like this:</p>\n\n<ol>\n  <li>Begin loop\n    <ol>\n      <li>[Warehouse] Read our replication marker that indicates the most recent download statistic that has been replicated</li>\n      <li>[Gallery] Read a batch of download events to be replicated</li>\n      <li>Begin inner loop over those statistics\n        <ol>\n          <li>[Warehouse] Replicate each download event into the warehouse’s <a href=\"http://en.wikipedia.org/wiki/Star_schema\">star schema</a></li>\n          <li>[Warehouse] Update the replication marker to the key of the download event that was just replicated</li>\n        </ol>\n      </li>\n      <li>Continue through all of the events in the batch that was just read</li>\n    </ol>\n  </li>\n  <li>Continue until a batch comes back empty because all events are older than the replication marker</li>\n</ol>\n\n<p>There were a few issues with this process:</p>\n\n<ol>\n  <li>It relied heavily on never having multiple instances of itself running</li>\n  <li>It was a record-by-record replication that wasn’t scaling very well</li>\n  <li>It was basically an infinite loop since download events always come in faster than a batch of them can be replicated</li>\n</ol>\n\n<p>After recognizing these three issues, we studied each of them closely to determine how impactful each issue was.</p>\n\n<h3 id=\"multiple-instances\">Multiple Instances</h3>\n\n<p>We found circumstances under which we had 2 instances of the replication running in our backend system.  And with the recognition that our process relied heavily on a single instance running, we studied the effects of 2 concurrent instances.  We observed that our replication marker would increase (as expected) and then momentarily <em>decrease</em>.  In our outer loop above, our two instances had each read a batch of events and were iterating through them at different speeds–this lead to duplication of the replicated stats.</p>\n\n<p>As we saw with our previous replication bug, this was leading to random duplication of download statistics in the warehouse and proved to us that none of the data in our warehouse could be trusted.</p>\n\n<h3 id=\"scaling\">Scaling</h3>\n\n<p>Once we concluded our warehouse data was invalid, we began plans for discarding the warehouse and populating a new warehouse with only clean data.  We began calculating how long it would take to reprocess the download events from the gallery database, replicating them into the new warehouse.  For the 6 weeks of download events present in the gallery database, we found that it would take 2-3 weeks to process them.  That means we were only able to replicate events 2-3 times as fast as they are coming in.  That’s not good!</p>\n\n<p>We knew this meant we needed to build a more efficient replication process that could A) keep up with increasing download events, and B) catch us up in a reasonable timeframe.</p>\n\n<h3 id=\"infinite-loop\">Infinite Loop</h3>\n\n<p>As the loop was constructed above, it becomes a virtually infinite loop.  That is okay on the surface–since it will always have work to do, let it keep running.  But for our backend work services, we like to monitor when processes start and how long they take–this allows us to know how long a job should take and then trigger alarms when jobs are running longer than expected.  We needed to restructure the process so that we could monitor its progress more effectively and know when the process was truly hung or failing.</p>\n\n<h2 id=\"cleaning-it-up\">Cleaning it Up</h2>\n\n<p>With the problems all understood, we set out to clean all of this up and resume our package statistics reporting as soon as possible.</p>\n\n<h3 id=\"a-new-warehouse\">A New Warehouse</h3>\n\n<p>After some deliberation, we concluded that the data in our existing warehouse was pretty much worthless.  Sure, it was still relatively representative of package downloads, but it certainly wasn’t accurate.  Besides, all of the reports we show on <a href=\"http://www.nuget.org/stats\">nuget.org/stats</a> are limited to the last 6 weeks, and we had that data in our gallery database.  So we could discard our existing warehouse; create a new, empty one; and populate it with cleanly replicated statistics.</p>\n\n<h3 id=\"a-new-replication-process\">A New Replication Process</h3>\n\n<p>We replaced the existing record-by-record replication process with a new batch-based process.  It takes the following approach:</p>\n\n<ol>\n  <li>[Gallery] Read the most recent download event that we want to jump to</li>\n  <li>Begin loop\n    <ol>\n      <li>[Warehouse] Read our replication marker that indicates the most recent download statistic that has been replicated</li>\n      <li>[Gallery] Read a batch of download events to be replicated</li>\n      <li>[Warehouse] Replicate the batch of events into the warehouse in one transaction, updating the replication marker at the same time</li>\n    </ol>\n  </li>\n  <li>Continue until we’ve replicated all the way through the initially-read download event from the gallery</li>\n</ol>\n\n<p>This process protects us against the issues we had with the previous system in the following ways:</p>\n\n<ol>\n  <li>Preventing concurrent processes from duplicating data\n    <ol>\n      <li>The <a href=\"https://github.com/NuGet/NuGet.Warehouse/blob/master/src/NuGet.Warehouse/dbo/Stored%20Procedures/AddDownloadFacts.sql\">warehouse replication process</a> aggressively locks our replication marker table to guard against concurrent transactions</li>\n      <li>It also filters the events being replicated down to those that are newer than the replication marker</li>\n    </ol>\n  </li>\n  <li>Scaling to perform far better than 2-3 times the throughput needed, but instead about 25+ times what’s needed\n    <ol>\n      <li>Pumping entire batches in and performing set-based operations allows SQL to shine the way it was meant to</li>\n      <li>At 25+ times the speed that download events occur, we can process a day’s events in one hour or less</li>\n      <li>We were able to catch up our 6 weeks of data in about a day</li>\n    </ol>\n  </li>\n  <li>Allowing the job to exit and providing extremely verbose logging\n    <ol>\n      <li>The new job <a href=\"https://github.com/NuGet/NuGet.Services.Work/blob/master/src/NuGet.Services.Work/Jobs/Stats/ReplicatePackageStatisticsJob.cs#L334\">emits logs</a> that have detailed information around how many records are left to process, the speed at which it’s processing them, and how much estimated time remains</li>\n      <li>The job reads the gallery’s latest download event before it begins the loop, and then it will only process up to that point</li>\n      <li>This allows the job to exit and work against a decent-sized batch the next time it’s invoked, instead of continuing to process the trickle of events</li>\n    </ol>\n  </li>\n</ol>\n\n<h3 id=\"in-production-now\">In Production Now</h3>\n\n<p>We put this new warehouse and process into production on Monday, August 18th.  The deployment went smoothly and we’ve been actively monitoring the replication job–it’s running very well.</p>\n\n<h2 id=\"results\">Results</h2>\n\n<p>So what does all this mean?  Let’s break down the impact all of this has had:</p>\n\n<h3 id=\"data-loss\">Data Loss</h3>\n\n<p>We lost the “Packages Downloaded Per Month” report on <a href=\"http://www.nuget.org/stats\">http://www.nuget.org/stats</a>.  This chart shows the trend of package downloads for the whole system over time.  It usually shows the trend over the past 6 months; now it just shows a dot for July.  Once August wraps up, we’ll see a new dot for August as well.</p>\n\n<p>During all of this, we also had a window of a 8 days where we were failing to capture download events entirely.  This was an accidental regression introduced into our <a href=\"https://github.com/nuget/NuGet.Services.Metrics\">Metrics Service</a> deployment where it was failing to record events into the gallery database entirely.  To be honest, we were distracted by the larger problems with download statistics and overlooked that service was failing as well.  We failed to capture download events from July 30th to August 7th.  That hit will likely be visible in the “Packages Downloaded Per Month” report at the close of August.</p>\n\n<h3 id=\"search-results\">Search Results</h3>\n\n<p>Because package installs over the last 6 weeks boost packages’ search relevance, we had some periods of search relevance being off as our old warehouse lacked recent data but our new warehouse didn’t yet exist.  That is all corrected now and search relevance is properly boosted based on recent installs again.</p>\n\n<h3 id=\"lower-numbers\">Lower Numbers</h3>\n\n<p>With the statistics reports back up and running, package authors will likely see that their download numbers are lower than they were before.  That’s because we’re no longer duplicating the data–the numbers were inflated before.</p>\n\n<p>Note that only the numbers shown on the package statistics reports were inaccurate before.  The overall/total download counts have remained accurate through this whole process since those numbers aren’t affected by the warehouse replication process.</p>\n\n<h2 id=\"going-forward\">Going Forward</h2>\n\n<p>We’ve improved our monitoring for this whole system, and more members of the team thoroughly understand the processes now too.  Overall, we should be able to maintain high confidence in our package statistics.  We will keep a better eye on it nonetheless.</p>\n","Href":"http://blog.nuget.org/20140820/new-statistics-warehouse.html","RawContent":null},{"Title":"NuGet 3.0 CTP 1 Released","PublishedOn":"2014-07-15T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Today marks an important milestone for <a href=\"/20140424/building-nuget-3.x.html\">Building NuGet 3.x</a>; we’ve published a NuGet 3.0 CTP1 build of our Visual Studio extension. This <strong><em>preview</em></strong> release represents a few months of code refactoring and <a href=\"/20140711/nuget-architecture.html\">server-side architecture</a> now being utilized by the client code. While the release doesn’t show off any slick new NuGet features or even address very many bugs, it reflects a lot of engineering work that unblocks us in several ways. We’d like to show you some of the changes we’ve made under the hood and ask for your help validating we haven’t regressed anything outside our test matrix.</p>\n\n<h2 id=\"what-we-released\">What We Released</h2>\n\n<p>The updated extensions can be found on our CodePlex project site under the <a href=\"https://nuget.codeplex.com/releases/view/116898\">NuGet 3.0</a> release page. Our pre-release versions don’t get published to the <a href=\"http://visualstudiogallery.msdn.microsoft.com/\">Visual Studio Extension Gallery</a>, so you have to download the updates from CodePlex in order to upgrade.</p>\n\n<h3 id=\"updates-for-visual-studio-2013-and-visual-studio-14\">Updates for Visual Studio 2013 and Visual Studio “14”</h3>\n\n<p>For this first CTP of NuGet 3.0, we’re only updating the extensions for Visual Studio 2013 and Visual Studio “14”. We’re not releasing an update for Visual Studio 2010 or Visual Studio 2012 at this time. We have always had a single extension that targets both of those versions, whereas we have separate extension for Visual Studio 2013 and Visual Studio “14”. NuGet 3.0 is now using some libraries that require .NET 4.5, and that would rule out updates for Visual Studio 2010.</p>\n\n<p>Whether or not subsequent releases for NuGet 3.0 will target Visual Studio 2010 is still undecided, but we’re strongly leaning toward cutting Visual Studio 2010 from the release. If we do make that decision, we’ll remove Visual Studio 2010 support from the Visual Studio 2010/2012 extension, making it Visual Studio 2012 only. We’d then provide support for Visual Studio 2012, Visual Studio 2013, and Visual Studio “14”.</p>\n\n<p>Rest assured that existing Visual Studio 2010 users will still be supported and will be able to use NuGet and NuGet.org to download and install packages. The NuGet 2.8.1 extension for Visual Studio 2010 will remain supported even though NuGet 3.x would be available for newer versions of Visual Studio.</p>\n\n<p>To update to the new version, download the VSIX file and double-click it to install it into Visual Studio. Note that for Visual Studio “14” you will first need to uninstall the existing NuGet extension; uninstalling requires running Visual Studio as Administrator.</p>\n\n<p>Here are the direct download links:</p>\n\n<ul>\n  <li><a href=\"https://nuget.codeplex.com/downloads/get/879740\">NuGet Package Manager for Visual Studio 2013</a></li>\n  <li><a href=\"https://nuget.codeplex.com/downloads/get/879741\">NuGet Package Manager for Visual Studio “14” CTP</a></li>\n</ul>\n\n<h2 id=\"noticeable-changes\">Noticeable Changes</h2>\n\n<p>While this CTP mostly represents changes we’ve made under the hood, there are a couple noticeable changes too.</p>\n\n<h3 id=\"removed-enable-nuget-package-restore\">Removed ‘Enable NuGet Package Restore’</h3>\n\n<p>When we introduced <a href=\"http://docs.nuget.org/docs/reference/package-restore#Automatic_Package_Restore_in_Visual_Studio\">Automatic Package Restore</a> in <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.7\">NuGet 2.7</a>, we knew that we’d eventually remove support for the MSBuild-integrated package restore approach. We didn’t want to prematurely remove it so we waited for the community to ask us to do so, and you have.</p>\n\n<p><a href=\"https://nuget.codeplex.com/workitem/4019\">NuGet Issue 4019</a> received quite a few votes and made its rounds on twitter a few times.</p>\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Every Time someone enables <a href=\"https://twitter.com/hashtag/nuget?src=hash\">#nuget</a> package restore on a solution, a kitten dies. Learn the new workflow! <a href=\"http://docs.nuget.org/docs/reference/package-restore\">http://docs.nuget.org/docs/reference/package-restore</a></p>&mdash; David Ebbo (@davidebbo) <a href=\"https://twitter.com/davidebbo/statuses/425493392475168768\">January 21, 2014</a></blockquote>\n<script async=\"\" src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Please vote for this <a href=\"https://twitter.com/hashtag/NuGet?src=hash\">#NuGet</a> issue and save some kittens <a href=\"https://nuget.codeplex.com/workitem/4019\">https://nuget.codeplex.com/workitem/4019</a> /cc <a href=\"https://twitter.com/davidebbo\">@davidebbo</a></p>&mdash; Xavier Decoster (@xavierdecoster) <a href=\"https://twitter.com/xavierdecoster/statuses/432976436623060992\">February 10, 2014</a></blockquote>\n<script async=\"\" src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<p>In NuGet 3.0, we are removing the context menu item that allows you to enable MSBuild-integrated package restore on new projects. If you have already enabled MSBuild-integrated package restore within your solution, the behavior will remain the same though:</p>\n\n<ol>\n  <li>The project will keep using MSBuild-integrated package restore instead of Automatic package restore</li>\n  <li>If you load new projects into the same solution, the integration is still viral and NuGet will silently enable MSBuild-integrated package restore on all projects within the solution</li>\n</ol>\n\n<p>You can learn how to migrate from MSBuild-integrated package restore to Automatic Package Restore at <a href=\"http://docs.nuget.org/docs/workflows/migrating-to-automatic-package-restore\">http://docs.nuget.org/docs/workflows/migrating-to-automatic-package-restore</a>.</p>\n\n<h3 id=\"new-package-source\">New Package Source</h3>\n\n<p>NuGet 3.0 CTP1 introduces a new package source with the name “nuget.org (3.0.0-ctp1) preview”. This preview package source is based on our new “API v3” protocol with <a href=\"http://json-ld.org\">JSON-LD</a>. The URL for the package source is <code class=\"highlighter-rouge\">http://preview.nuget.org/ver3-ctp1/</code>. Here are a few notes on this package source:</p>\n\n<ol>\n  <li>The root URL is a 404 (for now) - This is a temporary means for the client to identify that the package source might be v3.</li>\n  <li>In the 404 condition, the client will then send a request to /intercept.json and check for a JSON response.</li>\n  <li>This intercept.json resource identifies the resources the client can use for consuming package metadata instead of issuing OData requests. We’ll cover this more below in the <em>API v3 Requests</em> section.</li>\n</ol>\n\n<p>There’s a known issue that this package source is getting registered as disabled by default for some users. To switch from the ‘nuget.org’ package source to the new ‘nuget.org (3.0.0-ctp1) preview’ package source, edit your NuGet Package Sources.</p>\n\n<p><img src=\"/images/2014-07-15-nuget-3.0-ctp1/package-sources.png\" alt=\"Enable the Preview Package Source\" /></p>\n\n<h3 id=\"faster\">Faster!</h3>\n\n<p>You should notice that this new package source is noticeably faster. We haven’t measured it yet, but we’ve observed that everything is much more responsive. Search, package installation, and update checks should all be faster for you. This is a result of client requests going to our CDN to get data directly out of storage, instead of going through our v2 OData endpoint on the server.</p>\n\n<h2 id=\"changes-under-the-hood\">Changes Under the Hood</h2>\n\n<p>As mentioned earlier, most of the work in this release was actually done under the hood. We have now paid off some technical debt that has been holding us back from introducing new features to NuGet.</p>\n\n<h3 id=\"dependency-resolver\">Dependency Resolver</h3>\n\n<p>NuGet’s dependency resolution has always been a complicated piece of code, partly because it combined a few different concepts together.</p>\n\n<ol>\n  <li>Discover and reason over package dependencies</li>\n  <li>Download and unzip packages</li>\n  <li>Install packages into the project, copying in files and adding assembly references</li>\n</ol>\n\n<p>Once the deepest dependency was discovered, we’d start to perform actual package installations then we’d walk up the dependency graph until we reach the top. This was okay until some scenarios required back-tracking, which can result in uninstalling packages that were just installed. More importantly though, the implementation was a mess of spaghetti code that had gotten risky to touch.</p>\n\n<p>We’ve now completed some drastic refactoring of the dependency resolver and gotten it to where it can perform the actual dependency resolution separately from the act of installing/uninstalling packages. This allows us to make algorithm changes and test them purely against data (as it should have always been).</p>\n\n<p>As you’d expect, these code changes affect hot code paths and all of the core functionality of NuGet. We’ve tested these changes thoroughly, but please let us know if you find any scenarios where dependency resolution is behaving differently from before.</p>\n\n<h3 id=\"api-v3-requests\">API v3 Requests</h3>\n\n<p>We want NuGet 3.0 to use the new Linked Data protocol we’re implementing for nuget.org, but it is going to take a lot of time to write the new API v3 client and get it fully integrated into the Visual Studio extension. At the same time, we wanted the client to start making API v3 requests as soon as possible, to help us vet the design and protocol. To accomplish this, we’re now intercepting API v2 requests and translating them into API v3 requests when the server implements API v3.</p>\n\n<p>As mentioned above, we presently detect that a package source implements API v3 by way of a (temporary, hacky) handshake.</p>\n\n<ol>\n  <li>The package source URL returns a 404, and</li>\n  <li>Reponds to a request for /intercept.json with a document that provides some interception resources</li>\n</ol>\n\n<p>Here’s the intercept.json resource that we’re using for this preview:</p>\n\n<pre>\n    {\n      \"resolverBaseAddress\" : \"http://preview.nuget.org/ver3-ctp1/packageregistrations/1/\",\n      \"isLatest\" : \"http://preview.nuget.org/ver3-ctp1/islatest/segment_index.json\",\n      \"isLatestStable\" : \"http://preview.nuget.org/ver3-ctp1/islateststable/segment_index.json\",\n      \"allVersions\" : \"http://preview.nuget.org/ver3-ctp1/allversions/segment_index.json\",\n      \"searchAddress\" : \"https://api-search.nuget.org/search/query\",\n      \"passThroughAddress\" : \"http://nuget.org\"\n    }\n</pre>\n\n<p>Once the client completes this handshake with the server, we then intercept all outgoing OData requests the client is going to make, translate them into API v3 requests for the equivalent data, get the responses, and then manufacture OData-style responses out of the data returned.</p>\n\n<p>So under the hood, when you’re connecting to our new ‘nuget.org (3.0.0-ctp1) preview’ package source, every single request the client makes ends up going against our API v3 Search Service and JSON-LD resources. The JSON-LD resources are served out of Azure Storage and through our CDN; there’s no compute involved and we will achieve a significant improvement in availability.</p>\n\n<h3 id=\"package-manager-debug-console\">Package Manager Debug Console</h3>\n\n<p>For our own testing of the API v2 to API v3 interception, we found that we needed to create a Package Manager Debug Console. This console shows all of the v2 OData requests that are being made, how they’re translated into API v3 requests, whether or not our HTTP cache is hit, and the response details. We decided to include this debug console in the Visual Studio extension so that you too can see how the requests are being intercepted and handled.</p>\n\n<p>You can open the Package Manager Debug Console through the Tools \\ NuGet Package Manager menu.</p>\n\n<p><img src=\"/images/2014-07-15-nuget-3.0-ctp1/debug-console-menu.png\" alt=\"Package Manager Debug Console Menu Item\" /></p>\n\n<p>Once opened, all server requests are shown in the console with the request/response details. If you report any issues with the NuGet 3.0 CTP, we may ask you to provide the console output to us. Note that when you select text in the console, it doesn’t appear to be selected but it really is. Once you right-click after selecting text, you’ll see the text get highlighted properly.</p>\n\n<p><img src=\"/images/2014-07-15-nuget-3.0-ctp1/debug-console.png\" alt=\"Package Manager Debug Console\" /></p>\n\n<h2 id=\"known-issues\">Known Issues</h2>\n\n<h3 id=\"catalog-update-frequency\">Catalog Update Frequency</h3>\n\n<p>Our CQRS-style architecture on the server is still under development. There are times when our catalog updates are lagging behind, running slowly, or even completely shut off for a while. Once we get to where we’re happy with the server implementation, we’ll publish another NuGet release and switch from a “preview” package source to one that’s more stable.</p>\n\n<p>We are also not presently replicating <a href=\"/20130823/Introducing-Edit-Package.html\">package edits</a> into our API v3 catalog.</p>\n\n<h3 id=\"package-source-disabled-by-default\">Package Source Disabled by Default</h3>\n\n<p>As mentioned previously, some users will not see the ‘nuget.org (3.0.0-ctp1) preview’ package source after installing the new extension. If the package source doesn’t show up for you, check your NuGet Package Source settings and see if it’s disabled.</p>\n\n<h3 id=\"ssl-https-not-yet-supported\">SSL (HTTPS) Not Yet Supported</h3>\n\n<p>The new package source is registered as an HTTP address instead of HTTPS. This is a temporary limitation with our usage of our CDN, but we have a plan to work through it. In a future NuGet 3.0 release, we’ll switch back over to using SSL through an HTTPS address.</p>\n\n<h3 id=\"existing-visual-studio-14-extension-must-be-uninstalled\">Existing Visual Studio “14” Extension Must Be Uninstalled</h3>\n\n<p>If you’re using Visual Studio “14”, you will need to first uninstall the existing NuGet extension and then install the new one. Our previous release in Visual Studio “14” had an incorrect extension identifier; this new release fixes it, but you’ll need to uninstall the old version of NuGet.</p>\n\n<h2 id=\"sending-us-feedback\">Sending Us Feedback</h2>\n\n<p>Please check out this NuGet preview release and try it out. Disable the normal ‘nuget.org’ package source and enable the ‘nuget.org (3.0.0-ctp1) preview’ package source. Perform all of your usual NuGet work using that package source and let us know if you see any unexpected changes in behavior.</p>\n\n<p>Download the NuGet 3.0 CTP1 Visual Studio Extension now:</p>\n\n<ul>\n  <li><a href=\"https://nuget.codeplex.com/downloads/get/879740\">NuGet Package Manager for Visual Studio 2013</a></li>\n  <li><a href=\"https://nuget.codeplex.com/downloads/get/879741\">NuGet Package Manager for Visual Studio “14” CTP</a></li>\n</ul>\n\n<p>To send us your feedback, feel free to:</p>\n\n<ol>\n  <li>Post comments on this blog post</li>\n  <li>File issues on <a href=\"http://nuget.codeplex.com\">CodePlex</a> and mention that it’s a 3.0 regression</li>\n  <li>Reach us on Twitter at [https://twitter.com/nuget] or using <a href=\"https://twitter.com/search?q=%23nuget\">#nuget</a></li>\n</ol>\n\n<h2 id=\"nuget-30-plans\">NuGet 3.0 Plans</h2>\n\n<p>There’s still a lot in store for NuGet 3.0. We plan to reach the final release by the beginning of September. There will in fact be some new features and bug fixes in the release. You can expect to see:</p>\n\n<ol>\n  <li>A brand new package manager UI (and we’ll share screen shots as soon as we have them)</li>\n  <li>Ability to select specific package versions from the UI for package installs and updates</li>\n  <li>Package install/update “previews” where you can see what changes would occur if you installed/updated packages</li>\n  <li>Filtering packages by supported target framework, avoiding errors during package installation</li>\n  <li>Review and acceptance of pending external pull requests</li>\n  <li>Lots of bug fixes</li>\n</ol>\n\n<p>We know that many of you have noticed that it’s been a couple of months since we fixed many bugs or accepted pull requests. We have needed to stay focused on reaching the point of this CTP release with some drastic code refactoring, but we will now start getting caught back up. We appreciate your patience and understanding!</p>\n\n<p>Stay tuned for more updates along the way too; we plan to publish more preview releases of NuGet 3.0 between now and the final release.</p>\n","Href":"http://blog.nuget.org/20140715/nuget-3.0-ctp1.html","RawContent":null},{"Title":"The NuGet.org Architecture","PublishedOn":"2014-07-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>As part of <a href=\"/20140424/building-nuget-3.x.html\">Building NuGet 3.x</a>, we have been working on a significant re-architecture of <a href=\"http://www.nuget.org\">NuGet.org</a>. Progress has been steady and we are starting to see a return on investment. In this post, we’ll compare the legacy architecture to where we’ll be in the near future.</p>\n\n<h2 id=\"legacy-architecture\">Legacy Architecture</h2>\n\n<p>One of the goals when the NuGet Gallery project was started in 2011 was to provide a reference ASP.NET MVC application hosted in Azure. The project would follow our own prescriptive guidance and leverage the frameworks we build within our group:</p>\n\n<ol>\n  <li>ASP.NET MVC and Razor</li>\n  <li>SQL Azure</li>\n  <li>EntityFramework Code-First</li>\n  <li>WCF Data Services and OData</li>\n  <li>Azure Web Roles</li>\n  <li>Azure Storage</li>\n</ol>\n\n<h3 id=\"legacy-architecture-diagram\">Legacy Architecture Diagram</h3>\n<p><img src=\"/images/2014-07-11-nuget-architecture/legacy-diagram.png\" alt=\"Legacy Architecture Diagram\" /></p>\n\n<h3 id=\"deployment-details\">Deployment Details</h3>\n\n<p>Deploying this architecture was really straight-forward.</p>\n\n<ol>\n  <li>An Azure Web Role (3 instances, allowing redundancy even when one instance is being updated)</li>\n  <li>A SQL Azure database</li>\n  <li>An Azure Storage account\n    <ol>\n      <li>One container with public blobs for serving packages</li>\n      <li>One container with private blobs for in-progress package uploads</li>\n    </ol>\n  </li>\n</ol>\n\n<p>We also used EntityFramework’s database migrations, running them automatically when we deployed a new Web Role, and thereby keeping our production database schema in sync with the running code.</p>\n\n<p>During a deployment, we’d publish the update to the Web Role’s Staging slot, perform verification, and then do a VIP swap.</p>\n\n<h3 id=\"performance-over-time\">Performance Over Time</h3>\n\n<p>When the gallery was first introduced, the initial impression was that the site was fast.</p>\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Congrats to <a href=\"https://twitter.com/JeffHandley\">@JeffHandley</a> and <a href=\"https://twitter.com/haacked\">@haacked</a> and team on the new <a href=\"https://twitter.com/hashtag/nuget?src=hash\">#nuget</a> site launch! <a href=\"http://www.nuget.org\">http://nuget.org</a> <a href=\"https://twitter.com/hashtag/fast?src=hash\">#fast</a></p>&mdash; Scott Hanselman (@shanselman) <a href=\"https://twitter.com/shanselman/statuses/144130357560745986\">December 6, 2011</a></blockquote>\n<script async=\"\" src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<p>December 6, 2011 was a good day. We were proud of the new gallery. The code was simple, worthy of showcasing as “how to build web applications to run in Azure.” And the users agreed; the reception was thoroughly positive.</p>\n\n<p>Fast forward a couple of years though, and complaints about NuGet being slow became commonplace. Search was slow, package installations were slow, the website was slow, everything was slow. Even worse, people regularly complained about NuGet being down. Any interruption in SQL Azure or Azure Web Roles would directly affect the gallery.</p>\n\n<h3 id=\"scalability-characteristics\">Scalability Characteristics</h3>\n\n<p>With the legacy architecture, let’s take a look at what happens when a you right-click on a project and select ‘Manage NuGet Packages’.</p>\n\n<ol>\n  <li>From the Online tab, the NuGet dialog issues an OData query to perform a package search</li>\n  <li>On the server, the OData query flows through WCF Data Services, to EntityFramework, and then to SQL Azure</li>\n  <li>The results of the query are projected into an entity type that is returned in OData’s XML ATOM format</li>\n  <li>The client processes the response using WCF Data Services’ client library and renders the results</li>\n</ol>\n\n<p>This means that every time a user opens the NuGet dialog in Visual Studio, we perform a SQL query. In 2011 that was okay, but after NuGet started shipping with Visual Studio, it quickly became a scalability nightmare. We were essentially hitting ourselves with a distributed denial of service attack. This became all too clear the day that Visual Studio 2012 shipped with NuGet in the box, and the feed went down for several hours.</p>\n\n<p>NuGet Package Restore exacerbated the scalability challenges. This feature allows projects to omit packages from source control and download them during build. Since the packages are served from Azure Storage, it shouldn’t be that big of a deal; except the NuGet client needs to discover the package URL from the OData feed. As you might guess, this results in a SQL query. And any time we failed to process that query in time, builds would break. Ouch!</p>\n\n<h3 id=\"we-had-it-backwards\">We Had it Backwards</h3>\n\n<p>NuGet.org is an extremely read-heavy system, with millions of reads for every write, yet the architecture favored write-heavy systems that need to be immediately consistent. SQL Server, EntityFramework, and WCF Data Services with OData are great for systems where you have a relatively small number of users performing a similar number of reads and writes and where changes must be immediately reflected. But we have millions of users who need to reliably perform reads on relatively static data. Our architecture should reflect that.</p>\n\n<p>It’s difficult and costly to scale a fully consistent system to support the number of users that NuGet has. Fortunately, most of NuGet doesn’t need to be fully consistent; eventual consistency (within a few minutes or less) will suffice. Embracing this mindset with patterns like <a href=\"http://martinfowler.com/bliki/CQRS.html\">Command Query Responsibility Segregation (CQRS)</a> and <a href=\"http://www.martinfowler.com/eaaDev/EventSourcing.html\">Event Sourcing</a> enables us to work toward avoiding compute for the vast majority of NuGet’s reads. This approach will address the scalability concerns we have with the current system.</p>\n\n<h2 id=\"tomorrows-architecture\">Tomorrow’s Architecture</h2>\n\n<p>The majority of the NuGet team is now working on a new architecture. When we began the effort, we knew we needed to:</p>\n\n<ol>\n  <li><strong>Define availability goals</strong> while identifying which scenarios require immediate consistency or compute</li>\n  <li><strong>Separate reads from writes</strong> for scenarios that don’t require immediate consistency</li>\n  <li><strong>Optimize for incremental updates</strong> through since we have a relatively low number of writes</li>\n</ol>\n\n<h3 id=\"availability-goals\">Availability Goals</h3>\n\n<p>When we look at the NuGet.org service, we can break it down into a few buckets with different availability goals:</p>\n\n<ol>\n  <li><strong>Registration, Login, and Package Uploads</strong> - these require writes and/or immediate consistency\n    <ol>\n      <li>Registering a user and uploading a package write to the system</li>\n      <li>If a user changes their password or API key, that needs to be immediately enforced for logins and uploads</li>\n      <li>Package publishing must confidently identify package id/version conflicts</li>\n      <li><strong>Goal: Good Availability at 99.9% - interruptions don’t affect package consumers</strong></li>\n    </ol>\n  </li>\n  <li><strong>Search</strong> - this requires server compute but can be eventually consistent\n    <ol>\n      <li>If it takes a few moments for a newly published package to make it into the search index, that’s acceptable</li>\n      <li>We can keep the entire index in memory for extremely fast responses</li>\n      <li><strong>Goal: High Availability at 99.99% - interruptions block package discovery</strong></li>\n    </ol>\n  </li>\n  <li><strong>Package Installation and Restore</strong> - this should not require server compute and can be eventually consistent\n    <ol>\n      <li>It can take a few moments for a newly published package to become available on the feed</li>\n      <li>And once a package is published, it’s very rarely updated and then only its metadata can be modified</li>\n      <li><strong>Goal: Maximum Availability at 99.999% - interruptions break builds</strong></li>\n    </ol>\n  </li>\n</ol>\n\n<h3 id=\"separate-reads-from-writes\">Separate Reads from Writes</h3>\n\n<p>With these goals and scenarios clearly defined, we then understood what we needed to do:</p>\n\n<ol>\n  <li>Keep the existing CRUD-style architecture for registration, login, and package uploads\n    <ol>\n      <li>We might revisit this later but we’re within reach of the availability goal already</li>\n      <li>We believe by disconnecting other reads from this subsystem we’ll hit the goal easily</li>\n    </ol>\n  </li>\n  <li>Build an independently scalable Search Service\n    <ol>\n      <li>Use compute (Lucene.NET) but don’t require external resources for requests</li>\n      <li>Persist the index in Storage, update it incrementally, and cache the entire index in memory</li>\n    </ol>\n  </li>\n  <li>Use the query model to produce materialized presentations\n    <ol>\n      <li>While OData allows us to expose our data model for the client to query however it wants, it’s impossible to make all of the client queries efficient</li>\n      <li>Task-based presentations can be produced for serving the client’s specific needs very efficiently</li>\n      <li>We must be able to quickly detect changes in the write store and update all affected presentations of the data</li>\n      <li>This can all be done asynchronously with fault tolerance and parallelism</li>\n      <li>Materialized presentions can be persisted into Azure Storage and served from the CDN</li>\n    </ol>\n  </li>\n</ol>\n\n<h3 id=\"optimize-for-incremental-updates\">Optimize for Incremental Updates</h3>\n\n<p>With the conclusion that we didn’t want to change the CRUD-style architecture for the website and package uploads, we needed an approach for layering incremental update processing on top of the existing system. The database behind the website and package uploads will remain as-is, but we will query it from the back-end worker to extract changes. Then we’ll use the set of incremental changes to apply the updates to the Search Service and task-based presentations.</p>\n\n<p>We started with the Search Service. With its index in storage and cached in memory, we built a job in our Work Service to compare the database’s package data to what is stored in the Lucene index. We fine-tuned this and reached a point where we can update the index every minute without incurring any costly load on the database. This has been running in production for a few months and we’ve proven that we can effectively and efficiently extract and process incremental updates from our existing database.</p>\n\n<p>With that success behind us, we moved onto building a pipeline to produce presentation models to be used by the client. We can produce a full catalog of NuGet.org’s packages, efficiently and incrementally update it, transform those updates into the task-based presentation models, and persist those models into Azure Storage. We’re making changes to the NuGet client to read these presentations out of storage through our CDN instead of making OData queries.</p>\n\n<h2 id=\"patching-the-legacy-architecture\">Patching the Legacy Architecture</h2>\n\n<p>Knowing that the full server and client changes would take several months to get into place, we’ve been incrementally patching the legacy architecture. Here’s what is in place today:</p>\n\n<ol>\n  <li><em>(Unchanged)</em> ASP.NET MVC and Razor</li>\n  <li><em>(Unchanged)</em> SQL Azure</li>\n  <li><em>(Unchanged)</em> EntityFramework Code-First</li>\n  <li><em>(Modified)</em> WCF Data Services and OData, but with high-traffic queries getting intercepted</li>\n  <li><em>(Unchanged)</em> Azure Web Roles</li>\n  <li><em>(Unchanged)</em> Azure Storage</li>\n  <li><em>(New)</em> Lucene.NET-based Search Service, intercepting the Search and Package Restore queries</li>\n  <li><em>(New)</em> A separate SQL database for package statistics</li>\n  <li><em>(New)</em> A Work Service that processes async back-end jobs like migrating statistics data and producing reports</li>\n  <li><em>(New)</em> An additional SQL database for managing the queue of back-end work</li>\n</ol>\n\n<p>A subtle but impactful difference is that we intercept OData requests for Search and Package Restore and produce those results through our <a href=\"/20140411/new-search-on-the-gallery.html\">Search Service</a> instead of allowing those queries to reach the SQL database. We update the search index asynchronously using back-end jobs. We also introduced a second SQL database with a <a href=\"http://en.wikipedia.org/wiki/Star_schema\">star schema</a> for producing <a href=\"/20130226/Introducing-Package-Statistics.html\">package statistics reports</a> and then a third SQL database for managing the Work Service’s queue.</p>\n\n<h3 id=\"current-patched-architecture-diagram\">Current Patched Architecture Diagram</h3>\n<p><img src=\"/images/2014-07-11-nuget-architecture/current-diagram.png\" alt=\"Current Architecture Diagram\" /></p>\n\n<p>These changes introduced both the new Search Service and the Work Service as Azure Worker Roles. But we’ve also made some other deployment changes to improve availability of the gallery.</p>\n\n<ol>\n  <li>We deploy the front-end Web Role to two data centers\n    <ol>\n      <li>Azure Traffic Manager sits in front, in fail-over mode</li>\n      <li>The secondary data center runs in a read-only configuration against a recent SQL backup</li>\n      <li>If our primary data center fails, we are then failed-over to a recent read-only clone</li>\n    </ol>\n  </li>\n  <li>We deploy the Search Service Worker Role to two data centers\n    <ol>\n      <li>Azure Traffic Manager sits in front, in fail-over mode</li>\n      <li>Both front-end deployments access the Search Service through its Traffic Manager endpoint</li>\n    </ol>\n  </li>\n  <li>The front-end Web Role has Azure’s Auto-Scale feature enabled\n    <ol>\n      <li>We generally run on 3 Medium instances</li>\n      <li>We can scale up to 9 instances under heavy load</li>\n      <li>It’s configured to keep CPU utilization between 60%-80%</li>\n      <li>It scales up 1 instance at a time, waiting at least 10 minutes between scale actions</li>\n      <li>It scales down 1 instance at a time, waiting 20 minutes between scale actions</li>\n      <li>This allows us to scale up pretty quickly, but scale down a bit slower</li>\n    </ol>\n  </li>\n  <li>The Work Service is deployed as a Worker Role in Azure\n    <ol>\n      <li>We currently run 4 instances and it performs a lot of back-end work</li>\n      <li>We use Azure Scheduler to add jobs into the Work Service queue</li>\n      <li>This is done through HTTP PUTs into the Work Service’s HTTP endpoint</li>\n    </ol>\n  </li>\n</ol>\n\n<h3 id=\"deploying-api-v3\">Deploying API v3</h3>\n\n<p>Our current OData-based API is NuGet’s second API format, therefore we’ve been referring to our new implementation and the materialized presentation models as “API v3”. We are preparing to deploy API v3 in a CTP form very soon and we’ll post more details about it at that time. We know that we’ll be making quite a few changes between CTP and the stable release but we’ll invite ecosystem partners to work against the API and give us feedback.</p>\n\n<h2 id=\"what-were-achieving\">What We’re Achieving</h2>\n\n<p>This new architecture helps us achieve some fundamental capabilities:</p>\n\n<ol>\n  <li>Fast and Reliable Search Service\n    <ol>\n      <li>We incrementally update our search index and persist it into Azure Storage</li>\n      <li>The Search service loads the index entirely into memory</li>\n      <li>Search queries from both the client and the website are routed to the Search service’s HTTP endpoint where results are generated without loading any external resources</li>\n      <li>The Search service is independently scalable with Traffic Manager routing to a secondary data center when needed</li>\n    </ol>\n  </li>\n  <li>Efficient Dependency Resolution\n    <ol>\n      <li>The client’s requests are completely predictable - there’s no reason to <em>compute</em> the responses per request</li>\n      <li>We materialize dependency resolution presentations and serve them directly from storage through our CDN</li>\n      <li>These presentations contain all of the detailed dependency information for all versions of a package so the client can make very few HTTP requests to collect what it needs to construct the dependency graph</li>\n      <li>If the client needs different data for dependency resolution over time, we modify these presentations easily without ramifications to other parts of the system</li>\n    </ol>\n  </li>\n  <li>Highly Available Package Installation and Restore\n    <ol>\n      <li>Once a package id/version pair is known for installing or restoring a package, it must be fast and reliable</li>\n      <li>A lookup needs to occur to check the existence of a package id/version and discover its download URL</li>\n      <li>We also want to capture metrics for package statistics, knowing when/why packages are downloaded, but that can be done separately from the actual act of downloading the package</li>\n    </ol>\n  </li>\n  <li>Improved Ability to Implement New Features\n    <ol>\n      <li>We have a long list of features we want implement that would require the client getting more data from the server</li>\n      <li>The new architecture gives us the ability to expose data in a scalable and reliable way</li>\n      <li>We can also produce new feature-specific presentations when needed for new features without modifying existing presentations that are used in other scenarios</li>\n    </ol>\n  </li>\n</ol>\n","Href":"http://blog.nuget.org/20140711/nuget-architecture.html","RawContent":null},{"Title":"Monitoring nuget.org","PublishedOn":"2014-06-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We’ve recently found ourselves answering the same question repeatedly: <strong>How do you monitor nuget.org?</strong>  If you too are interested, here are the details.</p>\n\n<h2 id=\"monitoring-approaches\">Monitoring Approaches</h2>\n\n<p>We have two approaches for monitoring the gallery:</p>\n\n<ol>\n  <li>From the outside, checking HTTP endpoints that indicate public-facing service interruptions</li>\n  <li>From the inside, monitoring error logs and diagnostic data that indicate potential interruptions</li>\n</ol>\n\n<h3 id=\"external-monitoring\">External Monitoring</h3>\n\n<p>For our external monitoring, we use <a href=\"http://www.pingdom.com\">Pingdom</a>.  You can see our public Pingdom status page at <a href=\"http://status.nuget.org\">http://status.nuget.org</a>.  If you ever experience trouble connecting to <a href=\"http://www.nuget.org\">nuget.org</a> and you’re wondering, “Is NuGet down or is it just me?” you can visit <a href=\"http://status.nuget.org\">http://status.nuget.org</a> to find out.  If you see all green, then it might just be you.</p>\n\n<h4 id=\"public-status-page\">Public Status Page</h4>\n\n<p>Here are the checks shown on the status page:</p>\n\n<style type=\"text/css\"> TABLE.pingdomcheck { border-collapse: collapse; } TABLE.pingdomcheck THEAD TR TH, TABLE.pingdomcheck TBODY TR TD { border: 1px solid gray; padding: 0.5em; } TABLE.pingdomcheck TBODY TR TD:nth-child(2), TABLE.pingdomcheck TBODY TR TD:nth-child(3) { text-align: center; } </style>\n\n<table class=\"pingdomcheck\">\n    <thead>\n        <tr>\n            <th>Check</th>\n            <th>Interval</th>\n            <th>Notify when down</th>\n            <th>Purpose</th>\n        </tr>        \n    </thead>\n    <tbody>\n        <tr>\n            <td>DNS: nuget.org (root domain)</td>\n            <td>1 minute</td>\n            <td>5 minutes</td>\n            <td>\n                Verify that the DNS provider we use is returning the expected IP address for our root domain's A record. We redirect from nuget.org to www.nuget.org and use a CNAME record to route to Azure's Traffic Manager.\n            </td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www.nuget.org/api/v2/Search()?$filter=IsAbsoluteLatestVersion&amp;$orderby=DownloadCount%20desc,Id&amp;$skip=0&amp;$top=30&amp;searchTerm=''&amp;targetFramework='net40'&amp;includePrerelease=true\">feed (top 30 by downloads)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>This is the URL that is hit when you open the 'Manage NuGet Packages' dialog in Visual Studio.</td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www.nuget.org\">home page</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>Checks the status of the web site itself, and its ability to simply serve HTML.  There are no external resources required to serve the home page.</td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www.nuget.org/api/v2/package/NuGet.GalleryUptime/1.0.0\">package restore (download)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>\n                We use an unlisted NuGet.GalleryUptime package to verify that packages can be downloaded by the package restore process. This operation records package download statistics and then serves the actual nupkg file. If this check is down, builds using package restore will fail.\n            </td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www.nuget.org/api/v2/Packages(Id='NuGet.GalleryUptime',Version='1.0.0')\">package restore (lookup)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>\n                Before NuGet can download a package through the 'package restore (download)' URL, it must first query the API for the package to get its metadata that includes that download URL. This lookup ends up hitting our packages index and serving the results through the API. If this check is down, builds using package restore will fail.\n            </td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www.nuget.org/packages?page=1000&amp;prerelease=true\">packages page (search)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>\n                This page hits the website's search feature, loading results 19,981-20,000 for an empty search. This verifies that our search index is intact and complete. The check not only verifies the 200 OK response, but it also checks for the string 'Displaying results 19981 - 20000' in the response.\n            </td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://api-search-0.nuget.org/search/query\">search service (query)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>\n                The Search service runs as a separate deployment--the website makes HTTP requests to it for the website's search feature.  In addition to monitoring the website's ability to use the search, we also monitor the Search service directly.  We check for both a 200 OK response as well as as string of '\"data\":[{'' in the response to ensure there was data returned.\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<h4 id=\"other-checks\">Other Checks</h4>\n\n<p>We also have some other checks that don’t need to be on the public status page.</p>\n\n<table class=\"pingdomcheck\">\n    <thead>\n        <tr>\n            <th>Check</th>\n            <th>Interval</th>\n            <th>Notify when down</th>\n            <th>Purpose</th>\n        </tr>        \n    </thead>\n    <tbody>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www-0.nuget.org/api/v2/Packages\">DC0 - feed (raw packages list)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>\n                This is the raw packages feed from our primary data center. This check tells us the feed's health in that primary data center, where this might fail despite the feed being available from our secondary data center.\n            </td>\n        </tr>\n        <tr>\n            <td><a target=\"pingdomcheck\" href=\"https://www-1.nuget.org/api/v2/Packages\">DC1 - feed (raw packages list)</a></td>\n            <td>1 minute</td>\n            <td>3 minutes</td>\n            <td>\n                This is the raw packages feed from our secondary/fail-over data center. The secondary data center runs in readonly mode and it's generally behind the primary data center by about 30 minutes. Traffic manager fails over to this data center if the primary data center is unavailable.\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<p>In addition to these, we also monitor the <a href=\"http://docs.nuget.org\">documentation site</a> and our <a href=\"http://build.nuget.org\">build server</a>.</p>\n\n<h4 id=\"alerting\">Alerting</h4>\n\n<p>When Pingdom detects downtime, it sends a message to <a href=\"http://www.pagerduty.com\">PagerDuty</a> where we manage our on-call schedule and alerting rules. Our notification rules follow a pattern until the incident is acknowledged.</p>\n\n<ol>\n  <li>Immediately send email</li>\n  <li>Immediately send a text message</li>\n  <li>After 5 minutes, send another text message</li>\n  <li>After 10 minutes, make a voice call to the cell phone</li>\n  <li>After 11 minutes, make a voice call to the office phone</li>\n  <li>After 12 minutes, make a voice call to the home phone</li>\n  <li>After 15 minutes, escalate the incident to the backup on-call person and run the same process</li>\n  <li>After 30 minutes, alert half of the team through text messages</li>\n  <li>After 45 minutes, alert the other half of the team through text messages</li>\n</ol>\n\n<p>We’ve really enjoyed the flexible scheduling and alerting that PagerDuty offers. We have good peace of mind that if an incident does occur, we’ll be alerted and woken up if needed.</p>\n\n<h3 id=\"internal-monitoring\">Internal Monitoring</h3>\n\n<p>I’ll go into less detail about our internal monitoring–it’s not nearly as exciting. But at a high-level, we have a few moving pieces that we utilize for keeping tabs on the service’s health that is more subtle than the UP/DOWN observations that can be made by the external monitoring.</p>\n\n<h4 id=\"dashboard\">Dashboard</h4>\n\n<p>We have a dashboard website that we can look at any time we need to investigate a service incident. Sometimes we have this dashboard projected in our team room too. This is a separate project on GitHub, under the <a href=\"https://github.com/NuGet/NuGet.Services.Dashboard\">NuGet.Services.Dashboard</a> repository.</p>\n\n<p>The dashboard shows us elements for:</p>\n\n<ol>\n  <li>All of the Pingdom checks</li>\n  <li>Our Traffic Manager endpoint statuses</li>\n  <li>Our Web Role and Worker Role instance statuses</li>\n  <li>How many Web Role instances are currently running</li>\n  <li>Requests per hour</li>\n  <li>The current lag between the database and the search index</li>\n  <li>The number of new users today</li>\n  <li>The number of new packages today</li>\n  <li>Trendline of our requests per hour</li>\n  <li>Trendline of our error per hour</li>\n  <li>Trendlines for response times on all of the Pingdom checks</li>\n  <li>Trendline of the database requests</li>\n  <li>Trendline of the database connections</li>\n</ol>\n\n<p>It also has screens for drilling into a lot of the information captured on that main dashboard screen, as well as some other detailed diagnostic information, including:</p>\n\n<ol>\n  <li>Database index fragmentation</li>\n  <li>Database sizes</li>\n  <li>Error logs and trends</li>\n  <li>Backend job statuses and logs</li>\n</ol>\n\n<h4 id=\"diagnostic-alerts\">Diagnostic Alerts</h4>\n\n<p>As part of the Dashboard project, we also have some backend monitoring that can send alerts. For this, we use an Azure Virtual Machine that we configure Windows Scheduled Tasks onto. We use scheduled tasks to keep our service dependencies at a minimum for this monitoring. The tasks are configured through deployment scripts so there’s no manual schedule task setup to perform.</p>\n\n<p>We send low priority alerts out (that don’t text/call us) for data that starts to look unhealthy. This is done by connecting to PagerDuty’s API and issuing a Sev-2 incident. PagerDuty then sends the team an email. Here are some examples of the low priority alerts:</p>\n\n<ol>\n  <li>Number of database connections/requests crossing configured thresholds</li>\n  <li>Incoming website traffic rate increases dramatically</li>\n  <li>A surge of noteworthy exceptions being thrown</li>\n  <li>A lag between the database and search index beyond a configured threshold</li>\n  <li>Poor health of individual server instances or a spike in the instance count</li>\n  <li>Database size increases beyond a configured percentage of our size limit</li>\n  <li>Severe database index fragmentation</li>\n</ol>\n\n<h3 id=\"responding-to-incidents\">Responding to Incidents</h3>\n\n<p>When we do get an alert for an incident, the first thing we do is verify any service interruption. Then we will acknowledge the interruption and begin investigating.</p>\n\n<h4 id=\"acknowledgement\">Acknowledgement</h4>\n\n<p>Since we’re using PagerDuty, we need to acknowledge the incident there so that it doesn’t escalate to the next person on the team. Then we usually get onto Twitter and post an acknowledgement from the <a href=\"http://twitter.com/nuget\">@nuget</a> account. To be honest, sometimes we’re better about doing that than others, but it’s something we’re improving.</p>\n\n<p>If you’re experiencing trouble connecting to nuget.org, here’s what we recommend:</p>\n\n<ol>\n  <li>Check our Pingdom public status page at <a href=\"http://status.nuget.org\">http://status.nuget.org</a></li>\n  <li>Check our Twitter timeline at <a href=\"http://twitter.com/nuget\">http://twitter.com/nuget</a></li>\n</ol>\n\n<p>If you think NuGet is down and we haven’t acknowledged it yet, feel free to tweet at us by either mentioning <a href=\"http://twitter.com/nuget\">@nuget</a> or using the <a href=\"https://twitter.com/search?q=%23nuget\">#nuget</a> hashtag.</p>\n\n<h4 id=\"investigating\">Investigating</h4>\n\n<p>Once an incident is acknowledged, we jump into root cause analysis and try to find the component of the system that is failing. Sometimes it’s something on our side, sometimes it’s a service we consume from Azure. If the issue is purely on our side, we continue investigating and loop in other members of the team as needed. If the issue is due to an Azure service interruption, we check Azure’s status page and file tickets with them when needed. During the investigation, we again do our best to post updates to Twitter.</p>\n\n<h4 id=\"post-mortem\">Post-Mortem</h4>\n\n<p>We always complete a post-mortem after an incident. We share this with the entire team as well as our management at Microsoft. When it makes sense to do so, we also blog about the service interruption. Here are a couple of outage blog posts:</p>\n\n<ul>\n  <li><a href=\"http://blog.nuget.org/20130404/the-march-6-nuget-gallery-outage.html\">March 6, 2013</a></li>\n  <li><a href=\"http://blog.nuget.org/20140403/nuget-2.8.1-april-2nd-downtime.html\">April 2-3, 2014</a></li>\n</ul>\n\n<h3 id=\"measuring-uptime\">Measuring Uptime</h3>\n\n<p>Every month, we report our uptime to our management. To do so, we look at our Pingdom uptime report for the month and pick the <em>lowest</em> number from these three checks:</p>\n\n<ol>\n  <li>Feed (top 30 by downloads) - This represents the availability of consuming the feed in Visual Studio</li>\n  <li>Package Restore (lookup) - This is the package lookup that occurs to get a package’s download URL</li>\n  <li>Package Restore (download) - This is the act of downloading a package after looking it up</li>\n</ol>\n\n<p>Together those numbers give us a good representation of the perceived availability of <a href=\"http://www.nuget.org\">nuget.org</a> as they indicate if users can find and download packages.</p>\n\n<p>Here are the overall numbers we’ve had so far this calendar year:</p>\n\n<ol>\n  <li>June 2014 (1st-26th): 99.99%</li>\n  <li>May 2014: 99.78%</li>\n  <li>April 2014: 99.80%</li>\n  <li>March 2014: 99.98%</li>\n  <li>February 2014: 99.99%</li>\n  <li>January 2014: 99.53%</li>\n</ol>\n\n<p>As we’ve been <a href=\"http://blog.nuget.org/20140424/building-nuget-3.x.html\">building NuGet 3.x</a>, we’ve been doing so with the following scenario-based availability goals:</p>\n\n<ol>\n  <li>Package Restore: 99.999%</li>\n  <li>Package Discovery and Fresh Install: 99.99%</li>\n  <li>Package Upload and Website: 99.9%</li>\n</ol>\n\n<p>We definitely have our work cut out for us, but we’re making good progress on the re-architecture that we believe will make those goals attainable. Availability of NuGet is our team’s top priority and we’re making both server-side and client-side changes to make the service more reliable.</p>\n","Href":"http://blog.nuget.org/20140626/monitoring-nuget.html","RawContent":null},{"Title":"NuGet Package Download Stats","PublishedOn":"2014-06-03T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<h2 id=\"lies-damned-lies-and-package-statistics\">Lies, Damned Lies, and Package Statistics</h2>\n\n<p>We’ve been getting reports about package download statistics being inconsistent with packages’ overall download counts and people have asked us which numbers to believe. We’ve investigated the inconsistencies and found that due to a very subtle bug, <strong><em>you can’t trust the statistics right now, but you’ll be able to trust them again starting June 26th.</em></strong>.</p>\n\n<p>You can however trust the all-time download counts shown in search results and on the package details pages. Only the “Statistics” tab on the gallery is affected.</p>\n\n<h2 id=\"background\">Background</h2>\n\n<p>In order to fully explain the issue, we need to provide some background on how we record, aggregate, and report download statistics for packages.</p>\n\n<p><img src=\"/images/2014-06-02-nuget-stats/dataflow.png\" alt=\"Data Flow for Download Statistics\" /></p>\n\n<h3 id=\"step-1-record-downloads\">Step 1: Record Downloads</h3>\n\n<p>Every time a NuGet package is downloaded from the gallery, we record the download statistics into our SQL database. We don’t record the download directly against the package table, but instead into an table used as a queue. This allows us to avoid writing to the package table directly with every download–instead we aggregate the downloads in batches.</p>\n\n<p>This raw data is never shown anywhere on the gallery.</p>\n\n<h3 id=\"step-2-update-all-time-package-download-counts\">Step 2: Update All-Time Package Download Counts</h3>\n\n<p>Every 5 minutes, we take all of the downloads that have been recorded in our queue table and aggregate them. This aggregation tells us how many downloads each package had during the 5 minutes, and we update the package table in the database to increase the all-time download counts.</p>\n\n<p>These aggregated, all-time download counts are displayed on the Package Details page for any package. For example, the <a href=\"http://www.nuget.org/packages/Newtonsoft.Json/\">Json.NET</a> page shows the all-time downloads of all versions of the package as well as the all-time downloads for that specific version.</p>\n\n<h3 id=\"step-3-update-search-index\">Step 3: Update Search Index</h3>\n\n<p>Every minute, we update our search index using the already-aggregated all-time download counts. That means that it can be roughly 6 minutes from the time a package is downloaded to when the search index reflects that download. And for that minute in between aggregating package downloads and updating the search index, the search results might show a number slightly lower than the package details page.</p>\n\n<p>This search index is used for showing the packages list, with or without a search term. If you search for <a href=\"http://www.nuget.org/packages?q=json.net\">“json.net”</a>, you’ll see the search index’s value for the all-time download count for the Json.NET package.</p>\n\n<h3 id=\"step-4-replicate-downloads-to-statistics-warehouse\">Step 4: Replicate Downloads to Statistics Warehouse</h3>\n\n<p>We don’t want to keep all detailed package download records in our primary database–it would grow far too much. Instead, we replicate statistics over to a warehouse database, and we purge old download records from our primary database. The replication happens every 10 minutes, and we copy all details about the downloads into the warehouse. We keep the following information:</p>\n\n<ol>\n  <li>Package/Version</li>\n  <li>Operation (install, install-dependency, update, update-dependency, restore)</li>\n  <li>Date and Time (with precision of 1 hour)</li>\n  <li>Dependent Package/Version where applicable</li>\n  <li>NuGet Client (Visual Studio, WebMatrix, NuGet.exe, etc.) and Version</li>\n</ol>\n\n<p>The warehouse uses a star schema, allowing us to produce reports from several angles.</p>\n\n<h3 id=\"step-5-produce-statistics-reports\">Step 5: Produce Statistics Reports</h3>\n\n<p>Every 12 hours, we produce package download statistics reports and store them. Any page on the gallery under the <a href=\"http://www.nuget.org/stats\">Statistics</a> tab is rendering a report that was produced up to 12 hours earlier. These reports only reflect data from a rolling 6-week window of time and <em>not</em> the all-time download counts.</p>\n\n<p>Because the statistics reports are always a 6-week window, the numbers should always be lower than a package’s all-time download counts. But the reports we have been getting have shown that these statistics reports had <em>higher</em> values than the all-time numbers–that was obviously wrong.</p>\n\n<h2 id=\"how-far-off-are-the-statistics\">How Far Off are the Statistics?</h2>\n\n<p>It really varies from package to package. Generally, the more a package is getting downloaded, the more incorrect the statistics are. There’s no consistency across the packages though, so we can’t say exactly how much packages were affected. The only categorical statement we can make is: <strong><em>You can’t trust the statistics right now, but you’ll be able to trust them again starting June 26th.</em></strong></p>\n\n<p>For example, just looking at a window of 1 hour, Microsoft.AspNet.Mvc version 5.1.2 had 649 actual downloads that hour but the package statistics recorded 3035 downloads (a difference of 2386, or more than 365%). On the other hand, knockoutjs 2.2.0 had an hour with 5 actual downloads and 11 recorded downloads (a difference of 6, or 120%).</p>\n\n<h2 id=\"timeline-and-anatomy-of-the-bug\">Timeline and Anatomy of the Bug</h2>\n\n<p>The bug was introduced back in January, but we didn’t start getting reports of inconsistent data until April. We think the rollout of the <a href=\"/20140411/new-search-on-the-gallery.html\">new search service</a> brought more attention to our data and led people to start filing issues. The fix took effect on May 15th. This means that package download statistics are accurate after May 15th. Since our statistics reports are based on a rolling 6-week window, the statistics will be trustworthy again on June 26th.</p>\n\n<p>The bug was down in the process where we replicate data from the primary database to the warehouse (step 4 above). When pulling out the data not yet replicated, our SQL SELECT statement was missing an ORDER BY clause. This led to unpredictable results and a situation where we’d replicate the same data more than once.</p>\n\n<p>If you’re curious, it was a <a href=\"https://github.com/NuGet/NuGet.Services.Work/commit/98eda2c433c9b44922dee12ef6f373fde87de864#diff-e23a546b77f6a24c4929bbe8513888aeR95\">simple one-line fix</a> to correct this problem.</p>\n\n<h2 id=\"all-time-download-counts-are-accurate\">All-Time Download Counts are Accurate</h2>\n\n<p>Because the bug was in the process of replicating statistics over to the warehouse, only the warehouse and reports generated from it are affected. The all-time download counts are accurate on the package details pages and search results.</p>\n\n<h2 id=\"thank-you\">Thank You</h2>\n\n<p>Thank you for reaching out to us through <a href=\"http://github.com/NuGet/NuGetGallery/issues\">GitHub</a> and <a href=\"http://twitter.com/nuget\">Twitter</a> to let us know the data looked bad.</p>\n\n","Href":"http://blog.nuget.org/20140603/nuget-stats.html","RawContent":null},{"Title":"Redesigning the NuGet Websites","PublishedOn":"2014-05-08T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<h2 id=\"blog-redesign-is-live\">Blog Redesign is LIVE!</h2>\n\n<p>What better way to announce upcoming website redesigns than by implementing that redesign on our blog?  Earlier today, we deployed changes to <a href=\"http://blog.nuget.org\">http://blog.nuget.org</a> that apply a new visual design that we expect to carry over to the docs and gallery sites too.</p>\n\n<h2 id=\"redesign-goals\">Redesign Goals</h2>\n\n<p>The goals of the redesign effort are manifold. Here are some of our high-level desires for the websites:</p>\n\n<ol>\n  <li>Simplified, modern design</li>\n  <li>Fluid layout</li>\n  <li>Emphasize content instead of common elements</li>\n  <li>Seamless transitions between the gallery, documentation, and blog sites</li>\n  <li>Information re-organized for the three primary personas that interact with our sites</li>\n</ol>\n\n<h2 id=\"consistency-across-gallery-documentation-and-blog\">Consistency Across Gallery, Documentation, and Blog</h2>\n\n<p>With this deployment to the blog, our three sites are now quite inconsistent. The blog has the new look while the documentation and gallery sites still have the old design. This is temporary, as we expect to roll the new design out for <a href=\"http://docs.nuget.org\">http://docs.nuget.org</a> and <a href=\"http://www.nuget.org\">http://www.nuget.org</a>.</p>\n\n<p>We will apply the new design to the documentation site next, and we have to have that rolled out in a few weeks. Applying the design to the gallery will take some more time and it will be several weeks before we complete that. In the meantime, please feel free to share your feedback about the new design with us!</p>\n\n<h2 id=\"consume-create-contribute\">Consume, Create, Contribute</h2>\n\n<p>In addition to the refreshed visuals for the sites, we also plan to reorganize information across the documentation and gallery sites. Through reviewing the information we have across the sites and the interactions our users have with NuGet, we found we can organize our information into three categories:</p>\n\n<ol>\n  <li><strong>Consume</strong> - consuming NuGet packages in your projects</li>\n  <li><strong>Create</strong> - creating NuGet packages for yourself or to share</li>\n  <li><strong>Contribute</strong> - contributing to the NuGet project through filing bugs, adding documentation, or contributing code</li>\n</ol>\n\n<h2 id=\"graphic-designs\">Graphic Designs</h2>\n\n<p>We worked with the Microsoft Azure UX team to create the new graphic designs. In addition to what you’re seeing here on the blog, we have other page designs in place for documentation and the gallery. Here’s a sample of them.</p>\n\n<h3 id=\"gallery-home-page\">Gallery Home Page</h3>\n<p><img src=\"/images/2014-05-08-redesigning-the-nuget-websites/home.png\" alt=\"Gallery Home Page\" /></p>\n\n<h3 id=\"packages-list\">Packages List</h3>\n<p><img src=\"/images/2014-05-08-redesigning-the-nuget-websites/packages-list.png\" alt=\"Packages List\" /></p>\n\n<h3 id=\"package-detail\">Package Detail</h3>\n<p><img src=\"/images/2014-05-08-redesigning-the-nuget-websites/package-detail.png\" alt=\"Package Detail\" /></p>\n\n<h3 id=\"docs-home-page\">Docs Home Page</h3>\n<p><img src=\"/images/2014-05-08-redesigning-the-nuget-websites/doc-index.png\" alt=\"Docs Home Page\" /></p>\n\n<h2 id=\"docs-article\">Docs Article</h2>\n<p><img src=\"/images/2014-05-08-redesigning-the-nuget-websites/doc-article.png\" alt=\"Docs Article\" /></p>\n\n<h2 id=\"lots-to-do\">Lots to do…</h2>\n\n<p>We have a long list of features we need to build into the gallery to make it more useful.  We’ll be starting many of those features after we get this graphic redesign in place and while we make progress on <a href=\"http://blog.nuget.org/20140424/building-nuget-3.x.html\">NuGet 3.x</a>. In the meantime, please feel free to share your feedback with us on these new graphic designs.</p>\n","Href":"http://blog.nuget.org/20140508/redesigning-the-nuget-websites.html","RawContent":null},{"Title":"Building NuGet 3.x","PublishedOn":"2014-04-24T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<h2 id=\"evolution-of-nuget\">Evolution of NuGet</h2>\n\n<p>At MonkeySpace 2013 last July, we revealed some of our thinking for the <a href=\"http://vimeo.com/78045959\">Evolution of NuGet</a>.  These were the ideas we had for what would become NuGet 3.x and they included the following areas:</p>\n\n<h3 id=\"package-discovery\">Package Discovery</h3>\n\n<ol>\n  <li>Context-sensitive enumeration and search</li>\n  <li>Statistics and reports for package authors and consumers</li>\n  <li>Editable package metadata</li>\n  <li>Package discovery and sharing through social graphs</li>\n</ol>\n\n<h3 id=\"package-trust--incompatibility\">Package Trust / Incompatibility</h3>\n\n<ol>\n  <li>Organizations or team accounts</li>\n  <li>Owner reputation</li>\n  <li>Friendly license names and filters</li>\n  <li>Feeds for owners’ packages and followed packages</li>\n  <li>Create a system for reporting package incompatibilities</li>\n</ol>\n\n<h3 id=\"api\">API</h3>\n\n<ol>\n  <li>Create a RESTful API v3 for use by both the NuGet clients and ecosystem partners</li>\n  <li>Facilitate a high volume of reads on the API while significantly improving uptime</li>\n  <li>Existing OData service will be eventually consistent</li>\n</ol>\n\n<h3 id=\"package-installation--build\">Package Installation / Build</h3>\n\n<ol>\n  <li>Resolve references at build time for better retargeting and multi-targeting</li>\n  <li>Treat direct installs differently from dependencies</li>\n  <li>Global package installations</li>\n  <li>NuGet packages as a natural part of build</li>\n  <li>NuGet packages replace assemblies as the natural unit of reference</li>\n</ol>\n\n<h2 id=\"making-progress\">Making Progress</h2>\n\n<p>The full list is a pretty tall order but we’re making progress toward these goals.  In fact, since giving that talk in July 2013, here are some of the features that have been released:</p>\n\n<ol>\n  <li><a href=\"http://www.nuget.org/stats\">Statistics</a> for package authors and consumers</li>\n  <li><a href=\"http://blog.nuget.org/20130823/Introducing-Edit-Package.html\">Editable package metadata</a></li>\n  <li><a href=\"http://blog.nuget.org/20131011/friendly-license-names.html\">Friendly license names</a></li>\n  <li><a href=\"http://blog.nuget.org/20140411/new-search-on-the-gallery.html\">A new search experience on the Gallery</a></li>\n</ol>\n\n<p>Beyond this, the team has been concentrating on the RESTful API v3 architecture and design.  We came to the conclusion that a significant number of new features will be extremely data-driven and we needed to ensure the design was extremely scalable and reliable.  We couldn’t build those features on top of the compute-heavy architecture we have today.  <em>Let’s be honest, we already have more downtime than we’d like.</em></p>\n\n<p>Instead, it is time to re-architect the gallery and build up a new system based on micro-services.  Because the NuGet client tools need to be able to discover and interact with these micro-services, significant changes are required to the client as well as the server.  This new architecture will unlock the ability to create many new data-driven features while also providing a more reliable service for the core functions of NuGet.</p>\n\n<p>We’ve now embarked upon NuGet 3.x!</p>\n\n<h2 id=\"nuget-3x\">NuGet 3.x</h2>\n\n<h3 id=\"so-what-is-nuget-3x\">So what is NuGet 3.x?</h3>\n\n<p>A wave of NuGet client tools releases to begin taking advantage of a new server architecture.</p>\n\n<h3 id=\"what-does-that-mean\">What does that mean?</h3>\n\n<p>As we roll out new micro-services for the NuGet Gallery, we’ll be making significant changes to the NuGet client tools to utilize those services directly rather than going through a single OData-based API.</p>\n\n<h3 id=\"what-are-these-micro-services-that-youre-creating\">What are these micro-services that you’re creating?</h3>\n\n<p>Great question!  We have been able to break the NuGet Gallery up into the following conceptual package services:</p>\n\n<ol>\n  <li>Downloads (serving both package installs and restores)</li>\n  <li>Metadata and Feeds (for enumerating packages and resolving dependencies)</li>\n  <li>Search (getting context-sensitive package lists and search results)</li>\n  <li>Metrics (reporting download statistics)</li>\n  <li>Events (exposing a stream of activity on the gallery, which can be utilized by a variety of different consuming services)</li>\n</ol>\n\n<p>One of the key points here is that the downloads service is separated from the metadata service.  We’ve seen many times that package metadata needs to be fully exposed without having to download packages.  And we’ve also seen that there are scenarios for hosting package downloads without serving package metadata.</p>\n\n<p>We’re breaking Search out from the metadata/feeds because we’re using compute for search (via <a href=\"http://www.nuget.org/packages/Lucene.Net/\">Lucene.NET</a>), while we want package feeds/metadata to be served without compute.  Furthermore, Search is for human consumption while Feeds/Metadata are for programmatic consumption.</p>\n\n<p>The Metrics service allows package download statistics to be reported by the client explicitly, rather than recording those statistics <em>during</em> package download like we do today.  That would also create the opportunity for us to send more information in for statistics and allow users to opt out as desired.  The data collected would serve our context-sensitive search and statistics reports on where/how packages are used.  More importantly though, it will allow package downloads to be served without <em>any</em> compute that could possibly fail (and presently does more than is desirable).</p>\n\n<p>The Events service will expose a data stream for events that have occurred on the gallery–like new packages getting published and package ownership changing.  These events can be replayed to fully replicate nuget.org, setting up the opportunity for value-adding services such as gallery mirrors.</p>\n\n<h4 id=\"more-to-come\">More to come…</h4>\n\n<p>We know there will be more micro-services too; these are just the first handful we’re building.  The architecture allows new services to show up one-by-one.</p>\n\n<h2 id=\"api-v3\">API v3</h2>\n\n<p>Virtually all of this work centers around something we call “API v3.”  It’s the new RESTful API for connecting to NuGet services.  Each micro-service will have its own resource representations, but it all comes together under general guidelines that we put under this v3 umbrella.</p>\n\n<h3 id=\"linked-data\">Linked Data</h3>\n\n<p>The most critical principle for API v3 is the use of Linked Data.  Specifically, we have chosen to use <a href=\"http://json-ld.org\">JSON-LD</a> for our linked data format.</p>\n\n<p>Presently, NuGet clients have to know to connect to https://www.nuget.org/api/v2/ to consume our main feed.  That URL is our OData endpoint where all of the package data is exposed.  Our clients use WCF Data Services to construct OData-based URLs for specific requests–these include search queries, specific package lookups, and more.  All requests funnel through a single pipeline of code.  That code originally resulted in hitting our SQL server, but today we intercept queries and answer requests from our Lucene search index as often as we can.  The code is gnarly.</p>\n\n<p>We want to break out of this pattern and have specific resources for specific purposes.  We can then fine-tune responses for specific requests without much risk of unintended consequences.  Furthermore, we want to move away from the constructed URLs and generated proxies where changing the details of the server resources or HTTP responses would break existing clients. Instead, the v3 client will follow links to new resources and extract data that understands from responses, thereby enabling it to adapt as server resources evolve.  Linked Data with task-specific resources will provide this for us.</p>\n\n<p>If you’d like to see an example this, here’s a sneak peak at some JSON-LD blobs:</p>\n\n<ul>\n  <li><a href=\"http://nugetdev1.blob.core.windows.net/package-metadata/owners/nuget.json\">Packages owned by the ‘nuget’ user</a></li>\n  <li><a href=\"http://nugetdev1.blob.core.windows.net/package-metadata/packages/nuget.server.json\">The NuGet.Server package</a></li>\n  <li><em>These are best viewed in Chrome, using the <a href=\"https://github.com/callumlocke/json-formatter\">JSON Formatter</a> extension from the <a href=\"https://chrome.google.com/webstore/detail/bcjindcccaagfpapjjmafapmmgkkhgoa\">Chrome Web Store</a></em></li>\n</ul>\n\n<h3 id=\"eventually-consistent-responses\">Eventually Consistent Responses</h3>\n\n<p>We are working to eliminate compute from the request pipeline wherever possible.  NuGet is an extremely read-heavy system, with millions of reads for every write.  Yet today’s design uses a system where writes are relatively cheap and reads are very expensive.  It’s time to invert that!</p>\n\n<p>To achieve virtually free reads, we’re moving to an eventually consistent response model.  When packages get uploaded, package ownership changes, or other data writes occur, we’ll write that data to our authoritative data store immediately (presently SQL).  But requests for package metadata or downloads won’t query against that authoritative data store.  Instead, they will read JSON-LD blobs that are computed by back-end services.</p>\n\n<p>We have a “Work Service” in our mix of micro-services, and it is responsible for performing scheduled work.  Some of the scheduled work is to act upon data events from the authoritative data store.  If 57 new packages got published in the last 30 seconds, it will then queue up work to process those 57 packages.  That work will result in JSON-LD blobs getting produced and added into the system.</p>\n\n<p>This means it might take a few minutes before a published package is available for discovery and download.  But for that trade-off, we can scale out our read capacity in a proactically limitless manner.  And we can separately scale  our Work Service to make sure it can keep up with the data ingress.</p>\n\n<h3 id=\"nuget-client-api\">NuGet Client API</h3>\n\n<p>The NuGet client API is going to be overhauled–or dare we say, “rewritten.”  We’re not sure of the full scope of this work yet or how it will be represented in our assemblies; we know it will be drastic though.  The new API will provide the foundation for connecting to all of the micro-services, and it will be designed so that new micro-services can easily have new client handlers provided.  The API will also address many cross-cutting concerns to make those service handlers clean.</p>\n\n<p>Some cross-cutting concerns we know to exist are:</p>\n\n<ol>\n  <li>NuGet service registration and connection</li>\n  <li>JSON-LD document processing</li>\n  <li>Asynchronous linked data navigation</li>\n  <li>Heavy use of caching</li>\n  <li>Support for mirrors</li>\n  <li>Authentication and other networking concerns</li>\n</ol>\n\n<p>We’ve already made some progress in these areas.  For instance, we ported a Java-based JSON-LD processor over to C# and published it both to <a href=\"https://github.com/NuGet/json-ld.net\">GitHub</a> and <a href=\"http://www.nuget.org/packages/json-ld.net/\">NuGet</a>.  We’re also working on a library that builds on top of JSON.NET to provide asynchronous linked data navigation.  We’ll soon be working on a good cache implementation to use underneath both of those.</p>\n\n<p>The new client API will also provide some features for these areas:</p>\n\n<ol>\n  <li>Traversing package metadata easily without downloading packages</li>\n  <li>Downloading packages without having to first read their metadata</li>\n  <li>Invoke the dependency resolver without installing packages</li>\n  <li>Determine if a package is compatible with a project without actually trying to install it</li>\n  <li>Support for Semantic Versioning 2.0</li>\n  <li>Support for architecture, configuration, and toolset groups in packages</li>\n  <li>New dependency resolver features for more complex graphs</li>\n  <li>And much more…</li>\n</ol>\n\n<h3 id=\"nuget-services-components\">NuGet Services Components</h3>\n\n<p>Everything we’re doing on the service side is open-source of course.  You can find all of the NuGet Services components at <a href=\"http://github.com/nuget/\">http://github.com/nuget/</a>.  We used to just have a couple of repositories there, with one large repository for the gallery; now we have a bunch of independent repos for each of our service and operations components.</p>\n\n<p>NuGet already has a thriving ecosystem, but we hope that with this refactoring of the service components, we’ll enable the ecosystem to grow even further.  We’re hoping to see other teams eventually create new NuGet micro-services that can augment the code NuGet functionality.</p>\n\n<p>When a NuGet client connects to a NuGet repository, that repository can provide whatever subset of micro-services it wants.  This will allow new stand-alone services to be created by us and by the community and for users to consume them easily.</p>\n\n<h3 id=\"backwards-compatibility\">Backwards Compatibility</h3>\n\n<p>I hope it goes without saying, but we will maintain backwards compatibility on both the server and the client.  With the rewritten NuGet client code, we’ll maintain support for connecting to V1- and V2-based NuGet package sources.  And the NuGet Gallery will continue to serve its V2-based OData feed indefinitely.  That V2-based feed will become eventually consistent at some point, querying off a read-only copy of the live system’s database.</p>\n\n<h3 id=\"ecosystem-partners\">Ecosystem Partners</h3>\n\n<p>We will encourage all ecosystem partners to adopt API v3 as soon as the first client release is out with support for it.  Until then, no action is necessary.</p>\n\n<p>If you want to get involved as early as possible, please hop over to <a href=\"https://groups.google.com/forum/#!forum/nuget-ecosystem\">the nuget-ecosystem Google Group</a> and join us (or email <a href=\"mailto:nuget-ecosystem+subscribe@googlegroups.com\">nuget-ecosystem+subscribe@googlegroups.com</a>).  We’ve also been hanging out in <a href=\"https://jabbr.net/#nuget\">Jabbr</a> more often, and we’re usually listening to <a href=\"https://twitter.com/nuget\">@nuget</a> and <a href=\"https://twitter.com/search?q=%23nuget\">#nuget</a> on Twitter.</p>\n\n<h2 id=\"timeline\">Timeline</h2>\n\n<p>We are working on the release schedule that will be used to roll out the API v3-based client updates.  We expect the first release to be sometime this summer (U.S.), but we have’t decided on the scope of that release yet.  We’ll post more details to the client project home page on <a href=\"http://nuget.codeplex.com\">CodePlex</a> when we firm up the plans.</p>\n\n<p>Between now and then, we don’t expect to have any other NuGet client releases.  And we’re also not putting much effort into other NuGet features or bug fixes right now.  We tried for a long time to chip away at this V3 work while also implementing other features, but we weren’t making enough progress on V3.  We’re now officially heads-down building NuGet 3.x and we will remain that way for the next several months.</p>\n","Href":"http://blog.nuget.org/20140424/building-nuget-3.x.html","RawContent":null},{"Title":"A new search experience on the Gallery","PublishedOn":"2014-04-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>For a while now, we’ve been working on some major improvements to search. Last week we deployed these improvements to production on <a href=\"http://www.nuget.org\">http://www.nuget.org</a>. In this post, I’ll describe how the new service works. However, before we discuss the new service, let’s step back a bit and discuss the history of Search on NuGet.org</p>\n\n<h2 id=\"search-via-sql\">Search via SQL</h2>\n<p>Our first search implementation was done using our existing OData endpoints. We simply used the <a href=\"http://www.odata.org/documentation/odata-version-2-0/uri-conventions/#QueryStringOptions\">OData Query Operators</a> to filter data in our database by the User’s query. This had two major problems: It was fairly inefficient. SQL is a good engine for data lookup, but by default it is not as efficient at full-text search operations, like we wanted on NuGet.org. Second, it was inaccurate. Again, relational databases are great at lookup and querying, but only when the query is similarly structured. Our queries to SQL ended up as just a series of <code class=\"highlighter-rouge\">LIKE</code> comparisons for each field in our database <code class=\"highlighter-rouge\">OR</code>ed together.</p>\n\n<p>So, we opted to use a tool that was designed explicitly for full-text search to augment our SQL database…</p>\n\n<h2 id=\"lucene-on-the-web-server\">Lucene on the Web Server</h2>\n<p>Our second implementation was very much seen as an optimization for a very specific pair of cases: The search box in the NuGet Visual Studio Dialog, and the search box on the NuGet.org Website.</p>\n\n<p>Both of those views focus solely on the latest version of a package. So, our initial optimization was to take the latest version of each package and add it to a <a href=\"https://lucenenet.apache.org/\">Lucene.NET</a> powered index running off the local file system of each web server. Each machine had a background task running that synced its local Lucene index with data from the database. Search queries were then executed against that index. The result was a dramatic speed and relevance improvement. Lucene provides very powerful boosting and scoring extension points and we integrated some of our statistics in to that process.</p>\n\n<p>However, there were still a few problems:</p>\n\n<ol>\n  <li>Each machine had its own copy of the index, meaning a machine could get out of sync with the others</li>\n  <li>Our scoring algorithms were based off of total download counts, meaning new packages had a tough time getting noticed due to download-count-behemoths who have been in the gallery for years.</li>\n  <li>Finally, we wanted to expand the kinds of queries we could do with the Lucene index, but because the index only contained the latest version of each package, we were restricted to working with that set.</li>\n  <li>Having the index on the web server was useful, but constrained us to maintaining a smaller index in order avoid stressing the web server too much.</li>\n</ol>\n\n<p>To solve those problems, we started work from the ground up on a new search infrastructure.</p>\n\n<h2 id=\"nuget-search-service\">NuGet Search Service</h2>\n<p>To combat the issues we had with Lucene integrated into the web server, we developed an entirely new Search Service, written from the ground up. The service, like all NuGet.org code, is completely <a href=\"https://github.com/NuGet/NuGet.Services.Search\">open-source on GitHub</a>. The new Search Service is a separate HTTP service that is responsible for answering search queries. By moving search to its own set of machines, we hoped to reduce and even remove most of the issues we encountered with the previous search models.</p>\n\n<p>First, the search service stores the master copy of the Lucene index in Azure Blob Storage using the <a href=\"https://azuredirectory.codeplex.com/\">Azure Directory for Lucene.NET</a> library. Of course, accessing the index from Blob Storage would be very inefficient, so the entire index is kept in memory on the Search Service machines at all times. It is frequently synced with the Blob Storage copy, but in general, most queries should be served directly from memory. Storing the index in a central location allows it to be updated in a single location, while the memory cache allows queries to be served very quickly. We track round-trip times between the Gallery and this new Search Service and the average seems to be hovering around 80ms, which is as fast as most of our database queries (and even faster than some of the heavier ones!). Storing the authoritative copy of the index in blob storage also gives us a few major benefits. For example, we can easily spin up new Search Service nodes and they will just grab the latest index from blob storage (loading the whole index into memory takes about 2-5 minutes). Also, our <em>write</em> operations into the index (Adding new packages, deleting packages, updating existing packages, etc.) can be centralized and need only update the blobs.</p>\n\n<p>We also <strong>dramatically</strong> increased the scope of the Index. It now contains every single version of every package ever uploaded (see note below). At the time of this post, that comes to about 254,886 documents (the number only differs from the total package count on the Gallery due to packages being unlisted by their authors, something which we frequently do with test packages as well ;)). Despite the size, the total index size comes out to around 600MB. Of course, when the index was on the web server, this would be an unacceptable about of memory pressure to add, but on the Search Service, we have free reign over the entire machine! As the index grows, we can safely continue to scale up the available memory by moving to more memory-intensive Azure VM profiles. Of course, scaling up isn’t a perfect solution, so we will continue to monitor memory growth, but at our growth rates, it’s going to be the ideal solution for a long time.</p>\n\n<p><em><strong>Note:</strong> We do still hide unlisted packages from search queries. However, this is a good time to remind everyone that unlisting is <strong>not</strong> a secure way to remove data from NuGet. It is a mechanism to reduce a package’s visibility, <strong>not</strong> a way to prevent download of your package. If you need your package to be <strong>completely removed</strong>, use the Contact Support link on your package page to request that we delete the package.</em></p>\n\n<p>Lastly, we overhauled our scoring and analysis algorithms. This work started back in June of 2013, with the release of NuGet 2.6. In that release, the client began supplying an additional HTTP header when it requested a package for download: <code class=\"highlighter-rouge\">NuGet-Operation</code>. This header contained a value indicating what the user was doing in order to cause the package to be downloaded. Once NuGet 2.6 started sending this data, we began collecting download data into a data warehouse and categorizing it based on many different aspects, including this Operation value. This began to manifest in the Package Statistics pages you can view from each Package detail page. The next step was to take this data and use it in scoring.</p>\n\n<p>Whereas our previous algorithm scored results based on total download count, our new algorithm scores them based on “Recent Installs.” Specifically, it uses the number of downloads requested with a <code class=\"highlighter-rouge\">NuGet-Operation</code> value of <code class=\"highlighter-rouge\">Install</code> or <code class=\"highlighter-rouge\">Update</code> within the past <strong>6 weeks</strong>. This allows really popular packages like jQuery, EntityFramework and Newtonsoft.Json to remain fairly high up, because they are being Installed frequently, but also allows new packages to climb the ranks a little faster by shortening the time window and giving them a chance to catch up. Filtering by the <code class=\"highlighter-rouge\">Install</code> and <code class=\"highlighter-rouge\">Update</code> operations also allows us to filter out the noise caused by build servers using <a href=\"https://docs.nuget.org/docs/reference/package-restore\">Package Restore</a> to download packages on every build.</p>\n\n<h2 id=\"improving-relevance\">Improving Relevance</h2>\n\n<p>John Taylor, an engineer on our team, spent the last few months of 2013 diving in to Lucene scoring and fiddling with parameters trying to nail down some of the best ways to score results. We had a few smaller-scale tests where we released some sample algorithms to progressively larger groups of people to get feedback. In the end, we managed to nail down an algorithm which gave us confidence that we could handle most of our requests efficiently and accurately.</p>\n\n<p>Still, testing with a broad audience doesn’t cover everything, so we know there are going to be gaps. Please do not hesitate to give us feedback on our results by <a href=\"https://github.com/NuGet/NuGetGallery/issues\">filing bugs</a> or <a href=\"https://www.twitter.com/nuget\">pinging us on twitter</a>. Tuning our search algorithm will be a never-ending process so keep telling us what you think!</p>\n","Href":"http://blog.nuget.org/20140411/new-search-on-the-gallery.html","RawContent":null},{"Title":"NuGet 2.8.1 Released, April 2nd-3rd Downtime, and the New Search Service","PublishedOn":"2014-04-03T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>This blog post was planned to be published on April 2nd as the NuGet 2.8.1 release announcement.  However, on that same day (also the first day of <a href=\"http://www.buildwindows.com\">Build 2014</a>), NuGet.org suffered a severe service interruption.  It didn’t seem right to blog about the NuGet 2.8.1 release without also covering the interruption, so we waited a day and combined the posts.</p>\n\n<h2 id=\"nuget-281-released-with-windows-phone-81-support\">NuGet 2.8.1 Released with Windows Phone 8.1 Support</h2>\n<p>Let’s cover the fun stuff first!  On April 2nd, we released NuGet 2.8.1 to the Visual Studio Extension Gallery.  You can get the updates from within Visual Studio’s Extensions and Updates dialog, or directly from the extension gallery.  We also published NuGet.exe 2.8.1.</p>\n\n<p>Here are the downloads:</p>\n\n<ol>\n  <li><strong>Visual Studio 2013</strong>: <a href=\"http://visualstudiogallery.msdn.microsoft.com/4ec1526c-4a8c-4a84-b702-b21a8f5293ca\">Visual Studio Extension Gallery</a></li>\n  <li><strong>Visual Studio 2010 and 2012</strong>: <a href=\"http://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c\">Visual Studio Extension Gallery</a></li>\n  <li><strong>Command-Line Utility</strong>: <a href=\"http://nuget.org/nuget.exe\">Direct Download</a></li>\n</ol>\n\n<p>NuGet 2.8.1 includes support for Windows Phone 8.1, including both Silverlight-based libraries and WinRT-based libraries for Universal Apps.  For Silverlight-based Windows Phone 8.1 libraries, packages use the “wp81” framework name.  For WinRT-based Windows Phone App 8.1 libraries, packages use the “wpa81” framework name.</p>\n\n<p>In addition to the Windows Phone 8.1 support, we also fixed over a dozen bugs–mostly in nuget.exe.  See the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.8.1\">release notes</a> for other details about the release.</p>\n\n<h2 id=\"april-2nd-3rd-downtime\">April 2nd-3rd Downtime</h2>\n<p>As we tweeted about, we learned we had a few more vulnerabilities to heavy load than we had previously understood.  Perhaps due to the Build conference, or perhaps just a coincidence, <a href=\"http://www.nuget.org\">www.nuget.org</a> was experiencing unusually high browser traffic early in the morning on both April 2nd and April 3rd.  The extra load ultimately led to interruptions in most of our services.</p>\n\n<h3 id=\"services-impacted\">Services Impacted</h3>\n\n<p>During the times of interruption, the following services were impacted:</p>\n\n<ul>\n  <li>The website’s Packages page showed 0 packages</li>\n  <li>Search on the website and in Visual Studio reported no packages</li>\n  <li>The feed for Visual Studio reported no packages</li>\n  <li>Users were unable to sign into the website or upload packages</li>\n  <li>Some users’ package restore operations failed</li>\n</ul>\n\n<h3 id=\"root-cause\">Root Cause</h3>\n\n<p>The www.nuget.org home page makes http requests to a /stats/totals endpoint that performs a query to get the home page statistics to show the number of packages and downloads.  The request was configured to be cached, but the cache wasn’t behaving as we expect. This resulted in SQL queries for each request.  Under heavy load, these requests backed up and the queries became locked on each other.</p>\n\n<p>Additionally, all of our web server instances were maintaining their own copies of our Lucene search index.  On a schedule, the servers would all query the database to update the index as needed.  These queries are expensive and as we scaled out to more instances under load, the queries were running frequently.  With so many expensive queries running, these queries started timing out and causing the search indexes to become corrupt.</p>\n\n<h3 id=\"solution\">Solution</h3>\n\n<p>In order to reduce the load on our SQL database, we have implemented two changes that are now deployed to www.nuget.org.</p>\n\n<ol>\n  <li>We have completely disabled the home page query (instead returning static numbers for the time-being).</li>\n  <li>We have deployed our new Search Service which was planned to be released next week.</li>\n</ol>\n\n<h2 id=\"new-search-service\">New Search Service</h2>\n<p>At 8:00pm PDT on April 3rd, we deployed a significant update to <a href=\"http://www.nuget.org\">www.nuget.org</a> that changes the search implementation to use a dedicated <a href=\"https://github.com/nuget/NuGet.Services.Search\">Search Service</a>.</p>\n\n<p>We had planned to deploy this new search service next week, but the downtime we encountered April 2nd-3rd changed our plans.  The goals of the new Search Service include reducing load on our SQL Azure database and moving our Lucene search index out of the web servers and into Azure Blob Storage.  The Search Service runs independently, reading the index from blob storage, and the index is now maintained by back-end processes rather than on the web servers themselves.  We’re also able to direct more queries to the search service than we could handle with our previous index, relying less on SQL.</p>\n\n<p>The root cause analysis of our downtime uncovered that the SQL Azure load was the primary culprit, with the Lucene index updates being a significant contributor.  This new Search Service allows us to control the SQL load from our backend processes rather being tied to web traffic.</p>\n\n<p>We will publish a detailed blog post next week, but here’s what to expect from the new Search Service:</p>\n\n<ol>\n  <li>Search relevance has been completely overhauled.  We now boost search results by “recent installs” (the last 6 weeks of direct installs/updates) and we have drastically improved text analysis of package metadata.</li>\n  <li>Sort Options have been removed from the website.  Sorting by recent installs now produces the best results.  The sort options remain in Visual Studio and are still respected by our API.</li>\n  <li>The dropdown for “Include Prerelease” and “Stable Only” has been removed from the website.  As Prerelease packages have become more popular, this feature tended to caused confusion rather than provide benefit.  The dropdown is still in use in Visual Studio.</li>\n  <li>The search box on the website is now much bigger, promoted into the header, and more user-friendly.  Given search is the primary use of the site, this change was long overdue!</li>\n</ol>\n\n<p><img src=\"/images/2014-04-03-search-service/header.png\" alt=\"Updated header for www.nuget.org\" /></p>\n\n<p>Please let us know what feedback you have on the new Search Service.</p>\n\n<h2 id=\"downtime-timeline-and-details\">Downtime Timeline and Details</h2>\n\n<p>Here is our timeline of the downtime.  All times are Pacific Daylight Time.</p>\n\n<ul>\n  <li><strong>2014-04-01</strong>\n    <ul>\n      <li><strong>11:30pm</strong> - Some users started reporting incomplete search results late in the night on April 1st.  This appeared to just be our search index’s eventual consistency (although we now know that wasn’t the case).</li>\n    </ul>\n  </li>\n  <li><strong>2014-04-02</strong>\n    <ul>\n      <li><strong>12:00am to 4:00am</strong> - The index shrank all the way down to 0 packages during this time window.</li>\n      <li><strong>4:00am</strong> - The index’s state of 0 packages was affecting the website’s Packages page, and search on the website and in Visual Studio, and the Visual Studio feeds–everything reported 0 packages.  This triggered our automated alerts and it began paging us.</li>\n      <li><strong>4:45am</strong> - The interruption was confirmed; investigation had begun; and the initial notification was posted to twitter.</li>\n      <li><strong>5:30am</strong> - Some background services had been shut down to reduce load on the system.  We also found that package download statistics had not been getting automatically purged after migration into the warehouse, so a manual purge had begun.</li>\n      <li><strong>7:00am</strong> - Azure Support was engaged and they began helping us identify blocked queries and execute some SQL maintenance scripts to recalculate DB statistics and rebuild indexes.</li>\n      <li><strong>8:40am</strong> - We deployed an update to www.nuget.org that removed an unnecessary http request to /stats/totals from every page.  This request had been identified as triggering a SQL query that was causing locks.</li>\n      <li><strong>9:00am</strong> - All SQL indexes finished rebuilding and all DB statistics were recalculated.  The package download statistics purge was over 33% complete.</li>\n      <li><strong>10:30am</strong> - We found that our Output Cache was not working for the /stats/totals request, and every single user hitting the www.nuget.org home page was resulting in SQL queries to calculate the totals.</li>\n      <li><strong>10:45am</strong> - We deployed another update to www.nuget.org that hard-coded the values for the /stats/totals request (that serves the home page numbers) instead of querying SQL.</li>\n      <li><strong>11:00am</strong> - The load on our SQL database was drastically reduced and connectivity issues went away.  We rebuilt our search indexes successfully and the site was fully functional again.</li>\n      <li><strong>12:20pm</strong> - The package download statistics purge completed and all background services were resumed.</li>\n      <li><strong>11:55pm</strong> - There were reports that our index was shrinking again.  We successfully rebuilt them manually.</li>\n    </ul>\n  </li>\n  <li><strong>2014-04-03</strong>\n    <ul>\n      <li><strong>4:00am</strong> - Our monitoring alerted us that the search index was corrupt again.</li>\n      <li><strong>4:30am</strong> - Our indexes were manually rebuilt successfully.</li>\n      <li><strong>7:30am</strong> - We were under heavy load again and our web servers were scaling out.</li>\n      <li><strong>7:45am</strong> - Some of our new web server instances failed to build their search indexes, manual rebuilds failed, and other web server instances’ indexes became corrupt.</li>\n      <li><strong>8:00am</strong> - Many DB queries were failing; we engaged Azure support.</li>\n      <li><strong>9:00am</strong> - Diagnosis determined that the queries running to rebuild and update the Lucene indexes were significantly contributing to the SQL load.  We began the work to finalize the Search Service deployment that was planned for next week.</li>\n      <li><strong>10:45am</strong> - Traffic dropped off, the web servers scaled back down, search indexes were successfully rebuilt.</li>\n      <li><strong>11:00am</strong> - We began preparing a backup strategy deployment that would still use our web server based search indexes, but would disable all automatic updates to the index (limiting the index updates to manual rebuilds only).</li>\n      <li><strong>11:00am-8:00pm</strong> - The website ran steadily all day under normal load.  We continued our work and testing on the new Search Service while also validating our backup strategy deployment in case the Search Service deployment doesn’t go smoothly (we were planning for another week of testing).</li>\n      <li><strong>8:00pm</strong> - We deployed the new Search Service and the updated www.nuget.org front-end that uses the Search Service.  We also deployed our backup strategy deployment into the site’s staging slot in case we need to switch to it.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>The deployment we completed tonight should very significantly reduce the load on SQL by:</p>\n\n<ol>\n  <li>Not performing queries to get the home page statistics for every page load.</li>\n  <li>Running a single search index update process in the back-end instead of one on each web server.</li>\n  <li>Sending more requests into our search service instead of directing them to SQL.</li>\n</ol>\n\n<h3 id=\"work-items-discovered\">Work Items Discovered</h3>\n\n<p>While working through this incident, we identified a handful of work items that we will tackle immediately.</p>\n\n<ol>\n  <li>Determine why the ASP.NET caching isn’t working for the /stats/totals request</li>\n  <li>Replace the /stats/totals query with a background service that calculates the totals on a schedule and stores the results in blob storage to be served from the gallery rather than ever calculating the numbers directly</li>\n  <li>Determine why Package Restore was sporadically failing under the database load – as this was thought to be immune from database exceptions</li>\n  <li>Schedule more DB maintenance tasks through our background services to rebuild indexes and recalculate DB statistics</li>\n  <li>Fix the bug leading to our package statistics not being purged after being replicated into the warehouse database</li>\n  <li>Complete the work for having a read-only mirror up and running for when our primary site is down\n•\tThis work was already ongoing, but we are increasing the priority of it to have it finished very soon</li>\n</ol>\n\n<h3 id=\"appreciation\">Appreciation</h3>\n<p>We appreciate that while many of you reported the service interruption on twitter using either <a href=\"https://twitter.com/search?q=%40nuget%20OR%20%23nuget\">@nuget or #nuget</a>, you were kind and polite about it.  We know that there are countless developers around the world that rely on nuget.org being up and running all day every day, and we’re sorry that we let you down.  We are working to improve our reliability.</p>\n\n<p>Thank you for your support,</p>\n\n<p><a href=\"http://twitter.com/jeffhandley\">Jeff Handley</a> and the entire <a href=\"http://twitter.com/nuget\">NuGet team</a></p>\n","Href":"http://blog.nuget.org/20140403/nuget-2.8.1-april-2nd-downtime.html","RawContent":null},{"Title":"NuGet 2.6.1 for WebMatrix","PublishedOn":"2014-03-28T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet team released an updated NuGet Package Manager extension for WebMatrix on March 26, 2014. This update can be installed from the <a href=\"http://extensions.webmatrix.com/packages/NuGetPackageManager/\">WebMatrix Extension Gallery</a> using the following steps:</p>\n\n<ol>\n  <li>Open WebMatrix 3</li>\n  <li>Click the Extensions icon in the Home ribbon</li>\n  <li>Select the Updates tab</li>\n  <li>Click to update NuGet Package Manager to 2.6.1</li>\n  <li>Close and restart WebMatrix 3</li>\n</ol>\n\n<p>Here are the salient points from the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6.1-for-webmatrix\">release notes</a>.</p>\n\n<h2 id=\"notable-changes\">Notable Changes</h2>\n\n<p>This extension update addresses two of the biggest issues users have faced consuming NuGet packages within WebMatrix. The first was a <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6.1-for-webmatrix#NuGet_Schema_Version_Error\">NuGet schema version error</a> and the second was a bug leading to <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6.1-for-webmatrix#Zero-Byte_DLLs_in_bin_Folder\">zero-byte DLLs in the bin folder</a>.</p>\n\n<p>This latest release provides compatibility with the newest NuGet packages, preventing the schema error from occurring. New versions of packages including Microsoft.AspNet.WebPages can now be installed in WebMatrix.  Some of these packages were using NuGet features such as <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6#XDT_Web.config_transformation_support\">XDT config transforms</a>, which wasn’t supported in WebMatrix until now.</p>\n\n<h2 id=\"other-recent-improvements\">Other Recent Improvements</h2>\n\n<p>When NuGet Package Manager 2.8 was released for Visual Studio, we also released NuGet Package Manager 2.5.0 for WebMatrix.  While this was mentioned in the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.8#WebMatrix_NuGet_Client_Updates\">NuGet 2.8 Release Notes</a>, we didn’t mention the specific new features that update introduced.</p>\n\n<p>Those improvements include the ability to <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6.1-for-webmatrix#Update_All\">update all NuGet packages</a> in your web site together, as well as getting a prompt to <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6.1-for-webmatrix#Overwrite_Existing_Files\">overwrite existing files</a> when installing NuGet packages.</p>\n\n<h2 id=\"continued-updates\">Continued Updates</h2>\n\n<p>Because we extracted the NuGet functionality out of WebMatrix 3 into an extension contributed to the NuGet open-source project, we’ve been able to make these important updates without requiring an update to WebMatrix itself.  If you have other issues using NuGet within WebMatrix, <a href=\"https://nuget.codeplex.com/WorkItem/Create\">let us know by filing issues on CodePlex</a> so that we can address them.</p>\n","Href":"http://blog.nuget.org/20140328/nuget-2.6.1-for-webmatrix.html","RawContent":null},{"Title":"Update All Experience Explained","PublishedOn":"2013-12-16T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>While working on NuGet 2.8, we addressed some bugs dealing with the “Update All” behavior, where a single gesture will update all packages in the project.  During the testing of those fixes, another bug was filed stating, <a href=\"http://nuget.codeplex.com/workitem/3885\" title=\"Bug-3885\">After using Update All, packages remain in the Updates list</a>.  We have decided to mark that bug as “By Design” for now and get your feedback on it.  In order to explain why we consider it by design, let us first explore how install-package or update-package works in the following scenario.</p>\n\n<h2 id=\"scenario\">Scenario</h2>\n\n<p>The source repository contains package B versions 1.0.0, 1.0.5, 1.5.0 and 2.0.0.  It also contains package A version 2.0.0 which has a dependency on B (&gt;= 1.0.0) and version 1.0.0 which has no dependency on B.</p>\n\n<p>Now, a clean <code class=\"highlighter-rouge\">Install-Package A -version 2.0.0</code> would install A version 2.0.0 and install <strong><em>B version 1.0.0</em></strong> since that is the <strong><em>lowest version of the dependency</em></strong> that meets the dependency version requirements.</p>\n\n<p>Similarly, a clean <code class=\"highlighter-rouge\">Install-Package A -version 1.0.0</code> followed by <code class=\"highlighter-rouge\">Update-Package A</code> would first install A version 1.0.0 and then update to 2.0.0 and install <strong><em>B version 1.0.0</em></strong>.</p>\n\n<h2 id=\"dependencyversion\">DependencyVersion</h2>\n\n<p>Note that during Install-Package, you can use the -DependencyVersion switch to determine which version of the dependency is pulled in: Lowest/HighestPatch/HighestMinor/Highest.  This switch is being introduced in NuGet 2.8.</p>\n\n<p>For the example above,</p>\n\n<ul>\n  <li>DependencyVersion Lowest would bring in B version 1.0.0</li>\n  <li>DependencyVersion HighestPatch would bring in B version 1.0.5</li>\n  <li>DependencyVersion HighestMinor would bring in B version 1.5.0</li>\n  <li>DependencyVersion Highest would bring in B version 2.0.0</li>\n</ul>\n\n<p>As you may have guessed, <em>Lowest</em> is the default value when the switch is not specified.  This is true for both Update-Package PowerShell cmdlet and the ‘Update’ and ‘Update All’ buttons on the dialog.  Before the -DependencyVersion switch was introduced in NuGet 2.8, NuGet always used the <em>HighestPatch</em> behavior when resolving dependencies.</p>\n\n<h2 id=\"update-all\">Update All</h2>\n\n<p>Now, let us extend the same example to have another package C versions 1.0.0 and 2.0.0. \nImagine a project with the following packages installed on it:</p>\n\n<ul>\n  <li>Package A version 1.0.0</li>\n  <li>Package C version 1.0.0</li>\n</ul>\n\n<p>If we hit ‘Update All’ on this project, as you could guess, the end result would be the following:</p>\n\n<ul>\n  <li>Package A version 2.0.0</li>\n  <li>Package B version 1.0.0</li>\n  <li>Package C version 2.0.0</li>\n</ul>\n\n<p>This means that, after ‘Update All’, there is still one update available for B version 2.0.0.  In fact, there are 3 versions of B that are newer than the one installed as part of ‘Update All’.</p>\n\n<p>Hence, <a href=\"http://nuget.codeplex.com/workitem/3885\" title=\"Bug-3885\">Bug-3885</a>, which states that “After using Update All, packages remain in the Updates list.”</p>\n\n<p>Some argue that for the ‘Update All’ button and the ‘Update-Package’ PowerShell cmdlet, DependencyVersion should have been <em>Highest</em>.  That is incorrect for 3 reasons:</p>\n\n<ol>\n  <li>Packages that are not already installed are being updated to the latest version.  In the example, B version 2.0.0 gets installed while B version 1.0.0 would have sufficed.  This is not preferable.</li>\n  <li>Package author did not imply it.  In the example, author of ‘A’ wanted ‘B’ version 1.0.0 to be used with ‘A’ version 2.0.0.  But, ‘B’ version 2.0.0 gets installed instead.</li>\n  <li>‘Update’ and ‘Update All’ will behave differently from one another making it confusing.</li>\n</ol>\n\n<p>With the current behaviour, you can simply hit ‘Update All’ again to get the updates for the newly installed packages.</p>\n\n<h2 id=\"by-design\">By Design</h2>\n\n<p>In the case of new packages being installed while updating other packages, we’ve concluded that getting the lowest compatible version of those packages is the right design, for two reasons.  First, the user hadn’t specifically asked for those packages to be updated.  Second, it’s a simple extra step to update them once their installed.  This seems better than NuGet eagerly updating the packages, making the code a bit more complicated but more importantly making the behavior less predictable.</p>\n\n<p>We will be watching comments on the <a href=\"https://nuget.codeplex.com/workitem/3885\">issue</a> if you would like to add your thoughts.  If there’s overwhelming support for making NuGet eagerly get the new updates, we’ll reconsider the behavior in NuGet 2.9.</p>\n","Href":"http://blog.nuget.org/20131216/update-all-experience-explained.html","RawContent":null},{"Title":"NuGet Governance Model","PublishedOn":"2013-12-06T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Over the last couple of years, we’ve had the chance to meet with many individuals who both use and contribute to NuGet. One of the questions that has come up on more than one occasion pertains to how decisions get made for NuGet, especially decisions around which features are included in NuGet releases. This is an understandable question, especially since the NuGet core team consists of Microsoft employees.</p>\n\n<p>In order to provide more transparency around both the decision making structure and the different project contribution levels, we’ve published our <a href=\"http://docs.nuget.org/docs/reference/governance\">governance document</a> on <a href=\"http://docs.nuget.org\">docs.nuget.org</a>. Please take a look and let us know your thoughts.</p>\n","Href":"http://blog.nuget.org/20131206/nuget-governance-model.html","RawContent":null},{"Title":"Use your Microsoft account to log in to NuGet.org!","PublishedOn":"2013-12-06T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Starting today you can use your Microsoft account to log in to NuGet.org. I don’t know about you, but I want as few passwords as possible, so any opportunity to get rid of a password is great. Now, your NuGet.org password doesn’t have to be one of those many passwords you have to forget/lose/etc.</p>\n\n<p>To associate a Microsoft account with an existing account, make sure you’re signed out of NuGet.org and then click the sign-in link at the top right of the page. On this page, click the new “Sign in with a Microsoft account” button:</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/1-signinwithmsa.png\" alt=\"New Sign In Page\" /></p>\n\n<p>Sign in to your Microsoft account and grant us permission to use your account. If you already have a NuGet.org account, AND the email address in your Microsoft account is the same as the one in your NuGet.org account, you’ll see this page:</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/2-existingaccount.png\" alt=\"We found an existing account\" /></p>\n\n<p>Simply type in your current NuGet.org password and you’re done!</p>\n\n<p>If you’ve never created a NuGet.org account, or if you use a different email address for your Microsoft account, you’ll see the page below. You can either give us a username and email address to create a new account, or if you do already have an account (with a different email address) you can sign in to it and we’ll associate the two accounts.</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/3-doweknowyou.png\" alt=\"Do we know you?\" /></p>\n\n<p><strong>NOTE:</strong> We will not use the email address attached to your Microsoft account for any notification purposes. We only use the email address you enter and confirm when registering.</p>\n\n<p>Once you’ve associated your account, any time you click “Sign in with a Microsoft account” and are already logged in to your Microsoft account, you’ll be immediately signed in to NuGet.org! You can review your login credentials on the new Account management page, by clicking on your username at the top right when logged in to NuGet.org. When you associate a Microsoft account, you’ll be able to click the “Remove” button next to “Password Login” and we’ll delete the password from our system.</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/4-accountpage.png\" alt=\"Account Management Page\" /></p>\n\n<p>If you decide you want to re-enable password login for some reason, you can do that from the account page too:</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/5-enablepassword.png\" alt=\"Re-enable Password\" /></p>\n\n<p>We’ll send you an email and you can use the link in that message to set a new password (just like we do if you forget your password). Once you’ve re-enabled password login, you can remove your Microsoft account if you want. Of course, we never let you remove your last login credential.</p>\n\n<p>If you do lose access to your account (for example, your Microsoft account is hijacked, hacked or lost), you can still use the “Forgot My Password” link or <a href=\"https://www.nuget.org/policies/Contact\">contact us for assistance</a>.</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/6-forgotpassword.png\" alt=\"Forgot My Password\" /></p>\n\n<p><strong>NOTE: None of this changes the way you interact with nuget.exe</strong>, you still use an API Key that you get from the Account page. This may change over time, but we will continue support existing API Keys.</p>\n\n<h2 id=\"why-microsoft-account-what-about-other-providers\">Why Microsoft account? What about other providers?</h2>\n<p>You may be wondering why we chose Microsoft accounts and what our plans are for other providers. To put it simply, we chose Microsoft account, because of this:</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/7-whymsa.png\" alt=\"Visual Studio Microsoft account login\" /></p>\n\n<p>Starting in Visual Studio 2013, you log in to Visual Studio with a Microsoft account. In the future, we plan to integrate more with this system so that if you are logged in to Visual Studio with the same Microsoft account you use on NuGet.org, we can provide you with a customized experience. Imagine seeing lists of your favorite packages, custom feeds you design, etc.</p>\n\n<p>As for other providers, we are open to the idea, but we didn’t feel that any providers added much value since only Microsoft accounts are supported in Visual Studio. NuGet is the package manager for the Microsoft platform, and we expect most users are using Visual Studio and will have a Microsoft account. Having said that, we definitely recognize that not everyone uses Visual Studio, and there may be value in adding support for other providers. Since NuGet is an <strong>open-source project</strong>, we are very happy to hear from you if you feel we should add support for another provider. If you really want another provider supported, file an issue on our <a href=\"https://github.com/NuGet/NuGetGallery/issues\">Issue Tracker</a>.</p>\n\n<h2 id=\"coming-soon-persistent-sessions\">Coming Soon: Persistent Sessions</h2>\n<p>The next major authentication feature we plan to add is “persistent sessions”. The idea here is that once you log in on a machine, you remain logged in until you sign out. Users have been asking for this for a long time, and we have been listening. However, it’s not as simple as just “setting a boolean flag” to make your login persistent. Before persistent sessions can be introduced we need a few things. First, we need a feature like GitHub’s <a href=\"https://github.com/blog/1513-introducing-github-sudo-mode\">“sudo mode”</a> so that we can force users to re-authenticate before performing dangerous operations (like changing passwords) to reduce the risk of account hijacking when a user leaves a machine unattended. Second, we need a way for users to manage user sessions so they can revoke access from devices they have lost access to. Our initial plan for this second feature is to just sign you out of all sessions when you change your password (so if you lose access to a device, just change your password, even if you set it to the same thing again). In the future, we will likely have a feature where you can view a summary of all the devices you log in to NuGet.org with as well as how and when you last logged in. Something like GitHub’s Security History page:</p>\n\n<p><img src=\"/images/2013-12-05-microsoftaccountauthentication/8-githubsessions.png\" alt=\"GitHub Security History\" /></p>\n\n<p>These issues require a little extra design and implementation, but they’re near the top of our queue of things to do now, so expect to see them soon. I should note that if you have a Microsoft account, you <strong>do</strong> still have to click Sign In every time you restart your browser, but since Microsoft accounts have persistent sessions you <strong>don’t</strong> have to enter your password again! So we’re getting close!</p>\n\n<h2 id=\"a-small-breaking-change\">A small breaking change</h2>\n<p>As part of this change, we have broken a small part of our API. We had an “accidental feature” (i.e. it wasn’t intended ;)) where you could call our API and pass the API key in as a query string parameter, like this:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>POST https://www.nuget.org/api/v2/package?apikey=...\n</code></pre></div></div>\n\n<p>We have disabled this feature in this change as it was unintentional and undocumented. None of the NuGet tools use this feature, so as long as you’re using NuGet.Core, you shouldn’t have any issues, but if you do, just change your code to pass the API Key in the body of the “X-NuGet-ApiKey” header (which was the intended mechanism for providing API Keys) instead. If you have any concerns about this, please post an issue in our <a href=\"https://github.com/NuGet/NuGetGallery/issues\">Issue Tracker</a></p>\n","Href":"http://blog.nuget.org/20131206/microsoftaccountauthentication.html","RawContent":null},{"Title":"Starting Manage NuGet Packages for Solution dialog for projects under SourceGear Vault - issue and workaround","PublishedOn":"2013-11-18T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>There has been reports that VS hangs when Manage NuGet Packages for Solution menu item is clicked. When VS responds again, it reports the following error:</p>\n\n<p>“Loading the projects is required to complete the requested action. If you click the Cancel button, project loading will continue in the background, and you can try to perform the action again later.”</p>\n\n<p>When this happens, clicking Cancel button on the message dialog won’t work and Visual Studio has to be manually closed. This issue may be related to the association of your project with SourceGear Vault, which puts the read-only attribute to the packages.config file. One workaround for the issue is to remove the read-only attribute from the packages.config file. If this does not solve your hang issue, please report it to us by filing a bug on <a href=\"http://nuget.codeplex.com\">http://nuget.codeplex.com</a>.</p>\n","Href":"http://blog.nuget.org/20131118/Click-Manage-NuGet-Packages-for-Solution-hangs-VS.html","RawContent":null},{"Title":"VS hung on installing or updating packages may be related to ReSharper8.1 EAP","PublishedOn":"2013-11-07T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Recently there have been customer reports of hangs in Visual Studio while installing or updating NuGet packages. It could be related to <a href=\"https://nuget.codeplex.com/workitem/3775\">this issue</a>, if you have ReSharper 8.1 EAP installed.</p>\n\n<p>The solution is to update ReSharper to one of the stable versions such as ReSharper 8.1. If it doesn’t solve the issue for you, please report it to us through <a href=\"http://nuget.codeplex.com\">http://nuget.codeplex.com.</a></p>\n","Href":"http://blog.nuget.org/20131107/VS2013-hang-on-installing-or-updating-packages-may-be-related-to-ReSharper81EAP.html","RawContent":null},{"Title":"Package Restore and Consent Changes","PublishedOn":"2013-10-16T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>When NuGet 2.0 released, it included the requirement that in order to use package restore, you first <a href=\"http://blog.nuget.org/20120518/package-restore-and-consent.html\">needed to explicitly provide consent</a> to the NuGet client to download packages over the Internet. This requirement added some friction to normal developer workflows, and it added more friction in build and continuous integration sever scenarios. Needless to say, the feedback was not positive, and since releasing 2.0, we’ve been working with various groups to remove this friction.</p>\n\n<p>With NuGet 2.7, we have been able to remove the explicit consent requirement by making consent the default behavior and providing a means to explicitly “opt-out”. If you do not wish to have NuGet download packages from the Internet, you can disable the behavior by unselecting one or both of the checkboxes in the Package Manager settings dialog.</p>\n\n<p><img src=\"/images/package-restore-consent-changes-dialog.png\" alt=\"Package Manager Configuration Dialog\" /></p>\n\n<p>Additionally, we have <a href=\"http://blog.nuget.org/20130829/nuget-2.7-package-restore-consent-errors.html\">documented a known issue</a> and work around where it may appear that the default consent behavior has not changed in a clean installation of Visual Studio 2013.</p>\n\n<p>Thanks for bearing with us through any friction that the explicit consent requirement added to your work, and we hope that you’ll enjoy the freedom from that requirement going forward!</p>\n","Href":"http://blog.nuget.org/20131016/package-restore-and-consent-changes.html","RawContent":null},{"Title":"Friendly License Names","PublishedOn":"2013-10-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Yesterday afternoon, we enabled a new feature for both the NuGet gallery and the Visual Studio client (for NuGet &gt;= 2.7) which will display the list of license names for a package in addition to simply providing a link to the license text. The big idea behind this feature is that it will aid in the decision making process over whether or not to use a package.</p>\n\n<p>While displaying text such as “MIT” may seem like a trivial problem, there is a significant amount of complexity involved in determining the name from a license document. In this feature, license names are determined as a result of analyzing the license text itself.</p>\n\n<p>For this analysis, <a href=\"http://www.sonatype.com/news/sonatype-reduces-licensing-risks-with-new-update-to-nuget-and-visual-studio#.Ulgp8NxDsqw\">NuGet has partnered with Sonatype</a> and leveraged the power of their component lifecycle management (CLM) system. You may remember that in early 2012, Sonatype began enabling polyglot development shops to manage both their Java and .NET components with one repository when they <a href=\"http://www.sonatype.com/news/sonatype-brings-industry-leading-repository-manager-to-net-developers#.UlgqG9xDsqw\">included NuGet support in their Nexus repository</a>. As such, when Sonatype released CLM, it seemed only natural that we leverage our partnership to bring some of the power of that system to the NuGet community.</p>\n\n<p>While there’s a lot happening behind the scenes, browsing license names shows up in some pretty simple ways in the NuGet clients.</p>\n\n<p>On the gallery, you can see license names in search results or package listings:</p>\n\n<p><img src=\"/images/license-names-package-list.png\" alt=\"License names in search results\" /></p>\n\n<p>Or on an individual package details page:</p>\n\n<p><img src=\"/images/license-names-package-details.png\" alt=\"License names on package details page\" /></p>\n\n<p>In Visual Studio, the license name shows up just beneath the existing license link:</p>\n\n<p><img src=\"/images/license-names-vs-dialog.png\" alt=\"License names in Visual Studio\" /></p>\n\n<p>In the event that a license URL was not provided in the source package, or if the license could not be determined, no license name will be displayed. Finally, as the owner of a package, the NuGet gallery provides control over whether or not the analyzed license information should be displayed to users.</p>\n\n<p><img src=\"/images/license-names-disable.png\" alt=\"Managing license name visibility\" /></p>\n\n<p>We plan to continue exploring ways that we can reduce friction around package selection by incorporating more of these kinds of “package intelligence” capabilities into the NuGet client and server. If you have a specific scenario that you think would be helpful here, let us know!</p>\n","Href":"http://blog.nuget.org/20131011/friendly-license-names.html","RawContent":null},{"Title":"How to use XDT in NuGet - Examples and Facts","PublishedOn":"2013-09-20T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Starting with NuGet 2.6, XML-Document-Transform (XDT) is supported to transform XML files inside a project. The XDT syntax can be utilized in the .install.xdt and .uninstall.xdt file(s) under the package’s Content folder, which will be applied during package installation and uninstallation time, respectively.</p>\n\n<p>One of XDT’s greatest strengths is its <a href=\"http://msdn.microsoft.com/en-us/library/dd465326.aspx\">simple but powerful syntax</a> for manipulating the structure of an XML DOM. Rather than simply overlaying one fixed document structure onto another structure, XDT provides controls for matching elements in a variety of ways, from simple attribute name matching to full XPath support. Once a matching element or set of elements is found, XDT provides a rich set of functions for manipulating the elements, whether that means adding, updating, or removing attributes, placing a new element at a specific location, or replacing or removing the entire element and its children.</p>\n\n<p>In this blog, examples of using NuGet’s XDT feature to manipulate XML DOM are demonstrated, based on the common transformation scenarios of Web.config files. Important aspects of applying this feature including its drawback are also given, which we want your feedback on how to further improve this feature and make it more useful.</p>\n\n<h2 id=\"part-a-common-xdt-transformations-in-webconfiguninstallxdt-file\">Part A: Common XDT Transformations in Web.config.(un)install.xdt file</h2>\n\n<ul>\n  <li>Change the attribute values of an element in Web.config</li>\n</ul>\n\n<p>To change the attribute value such as connectionString of a Web.config file, either the  xdt:Transform=”SetAttributes” or  xdt:Transform=”Replace” attribute can be used in Web.config.(un)install.xdt file, in conjunction with the xdt:Locator attribute.</p>\n\n<p>The use of xdt:Transform=”SetAttributes” below will update the value of the connectionString attribute only, while leaving other attribute values in the &lt;add&gt; element untouched.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;connectionStrings&gt;\n    &lt;add name=\"DefaultConnection\" connectionString=\"value for the deployed Web.config file\" xdt:Transform=\"SetAttributes\" xdt:Locator=\"Match(name)\"/&gt;\n    &lt;/connectionStrings&gt;\n    ...\n  &lt;/configuration &gt;\n</pre>\n\n<p>On the other hand, the use of xdt:Transform=”Replace” will replace the entire  &lt;add&gt; element named “DefaultConnection”, with what’s specified in the Web.config.(un)install.xdt file.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;connectionStrings&gt;\n    &lt;add name=\"DefaultConnection\" connectionString=\"value for the deployed Web.config file\"  \n\t\t      providerName=\"System.Data.SqlClient\" xdt:Transform=\"Replace\" xdt:Locator=\"Match(name)\"/&gt;\n    &lt;/connectionStrings&gt;\n    ...\n  &lt;/configuration &gt;\n</pre>\n\n<ul>\n  <li>Replace all elements under a section of Web.config</li>\n</ul>\n\n<p>To replace all elements under the &lt;system.web&gt; section, the xdt:Transform=”Replace” attribute can be placed at the root of the  &lt;system.web&gt;  section. For example, the following XDT transform will update the entire  &lt;system.web&gt; section of the Web.config to just contain the two simple elements (&lt;compilation&gt; and &lt;httpRuntime&gt;) specified by the Web.config.(un)install.xdt file.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;system.web xdt:Transform=\"Replace\"&gt;\n      &lt;compilation debug=\"false\" targetFramework=\"4.5\" /&gt;\n      &lt;httpRuntime executionTimeout=\"00:05:00\"/&gt;\n    &lt;/system.web&gt;\n  &lt;/configuration&gt;\n</pre>\n\n<ul>\n  <li>Insert a new element before the specific element in Web.config</li>\n</ul>\n\n<p>Suppose the starting Web.config looks like below (from ASP.NET Web Forms Application):</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration&gt;\n    ...\n    &lt;system.webServer&gt;\n      &lt;modules runAllManagedModulesForAllRequests=\"true\" /&gt;\n    &lt;/system.webServer&gt;\n    &lt;runtime&gt;\n      ...\n  &lt;/configuration&gt;\n</pre>\n\n<p>To insert a new &lt;validation&gt; element in the &lt;system.webServer&gt; section but before the &lt;modules&gt; element, the xdt:Transform=”InsertBefore” attribute can be utilized in your Web.config.(un)install.xdt file:</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;system.webServer&gt;\n      &lt;validation validateIntegratedModeConfiguration=\"false\" xdt:Transform=\"InsertBefore(/configuration/system.webServer/modules)\" /&gt;\n    &lt;/system.webServer&gt;\n  &lt;/configuration&gt;\n</pre>\n\n<ul>\n  <li>Insert a section of elements if missing from the current Web.config</li>\n</ul>\n\n<p>There are occasions that the starting Web.config does not have the section present, which elements need to be inserted to. In this case, the xdt:Transform=”InsertIfMissing” can be used. However, for Web.config file that does have the target section available but contain different elements, the insertion won’t take place. The end result would be that the target section of the config file stays unmodified.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;configSections xdt:Transform=\"InsertIfMissing\"&gt;\n      &lt;sectionGroup name=\"elmah\"&gt;\n        &lt;section name=\"security\" requirePermission=\"false\" type=\"Elmah.SecuritySectionHandler, Elmah\" /&gt;\n        &lt;section name=\"errorLog\" requirePermission=\"false\" type=\"Elmah.ErrorLogSectionHandler, Elmah\" /&gt;\n        &lt;section name=\"errorMail\" requirePermission=\"false\" type=\"Elmah.ErrorMailSectionHandler, Elmah\" /&gt;\n        &lt;section name=\"errorFilter\" requirePermission=\"false\" type=\"Elmah.ErrorFilterSectionHandler, Elmah\" /&gt;\n      &lt;/sectionGroup&gt;\n    &lt;/configSections&gt;\n    ...\n  &lt;/configuration&gt;\n</pre>\n\n<ul>\n  <li>Two step transformation that ensures updating an existing value, or adding a new one</li>\n</ul>\n\n<p>So far the transformations that we talked about are all one-step transformation that adheres to the XDT syntax. For some of the cases, the package authors may not know the exact content of the starting Web.configs. Therefore, the transformation could fail, due to reasons such as the targeted sections/elements cannot be found. One common case would be direct calling xdt:Transform=”Insert” to a section or element that is not available in the current Web.config.</p>\n\n<p>As a workaround, one can apply a two-step transformation and have code like below in the Web.config.(un)install.xdt file, i.e. by removing the matching element if existing, and then inserting the element with the same name back. Fortunately the transformations are done in sequence, so this works with a Web.config that has &lt;appSettings&gt; section in place.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;appSettings&gt;\n    &lt;!-- \n\t\tDoing this in two steps (remove, then insert) ensures that we can update an existing value, or add a new one\n\t--&gt;\n      &lt;add\n\t  \tkey=\"page:Version\"\n\t\txdt:Transform=\"Remove\"\n\t\txdt:Locator=\"Match(key)\"/&gt;\n      &lt;add\n\t\tkey=\"page:Version\"\n\t\tvalue=\"2.0.0\"\n\t\txdt:Transform=\"Insert\" /&gt;\n    &lt;/appSettings&gt;\n  &lt;/configuration&gt;\n</pre>\n\n<ul>\n  <li>Transformation that can store/restore old values via package install/uninstall</li>\n</ul>\n\n<p>A cool thing that the NuGet’s XDT feature can do is that the original values can be stored upon package install, and then restored back via package uninstall. The example below showed that:</p>\n\n<p>During package install by calling Web.config.install.xdt, the “SourceFile_advances” key is replaced with a new value, while the old value is saved as a comment in the new &lt;local&gt; section.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;appSettings xdt:Transform=\"InsertIfMissing\"&gt;\n      &lt;add key=\"SourceFile_Advances\" \n\t\t\t  keyvalue=\"C:\\Code\\SavvysoftValuations\\new.csv\" xdt:Locator=\"Match(key)\" xdt:Transform=\"Replace\" /&gt;\n    &lt;/appSettings&gt;\n    &lt;local xdt:Transform=\"Insert\"&gt;\n      &lt;!-- &lt;add key=\"SourceFile_Advances\" keyvalue=\"C:\\Code\\SavvysoftValuations\\original.csv\" /&gt; --&gt;\n    &lt;/local&gt;\n  &lt;/configuration&gt;\n</pre>\n\n<p>During package uninstall by calling Web.config.uninstall.xdt, the &lt;appSettings&gt; and &lt;local&gt; section was removed and the original value for “SourceFile_advances” key was added back.</p>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;appSettings xdt:Transform=\"Remove\"&gt;\n    &lt;/appSettings&gt;\n    &lt;local xdt:Transform=\"Remove\"&gt;\n    &lt;/local&gt;\n    &lt;appSettings xdt:Transform=\"InsertIfMissing\"&gt;\n      &lt;add key=\"SourceFile_Advances\" keyvalue=\"C:\\Code\\SavvysoftValuations\\original.csv\" /&gt;\n    &lt;/appSettings&gt;\n  &lt;/configuration&gt;\n</pre>\n\n<h2 id=\"part-b-things-that-you-should-know-about-the-nuget-xdt-feature\">Part B: Things that you should know about the NuGet XDT feature</h2>\n\n<ol>\n  <li>\n    <p>Unlike the other NuGet packages, which files/references are automatically removed during package uninstallation, NuGet performs XML transformation specified in the .uninstall.xdt file. In that sense, XDT package uninstallation is not symmetrical to what’s been added by package installation.</p>\n  </li>\n  <li>\n    <p>The XDT feature can be apply to any XML files including the Web.Debug.config and Web.Release.config files. The transform .xdt files would need to be named Web.Debug.config.(un)install.xdt and Web.Release.config.(un)install.xdt accordingly.</p>\n  </li>\n  <li>\n    <p>The XDT feature works well under nested Content folders, also recognizes the targetframeworks, by placing under the approriate folder such as net45.</p>\n  </li>\n  <li>\n    <p>Due to limitation of the current transform syntax, authoring a universal package that can handle various forms of Web.config files (with sections/elements/attributes variations) can be difficult at this point. Especially, the combined usages of xdt:Transform=”InsertIfMissing” and/or xdt:Transform=”Insert” does not work well. Taking the below Web.config.install.xdt file as an example, when the &lt;runtime&gt; section does not exist, the whole section will be inserted, and the &lt;dependentAssembly&gt; element will be inserted one more time via the xdt:Transform=”Insert” statement.</p>\n  </li>\n</ol>\n\n<pre>\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n    &lt;runtime xdt:Transform=\"InsertIfMissing\"&gt; \n      &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt; \n        &lt;dependentAssembly xdt:Transform=\"Insert\"&gt; \n          &lt;assemblyIdentity name=\"X\" publicKeyToken=\"032d34d3e998f237\" culture=\"neutral\" /&gt; \n          &lt;bindingRedirect oldVersion=\"0.0.0.0-2.0.1.5\" newVersion=\"2.0.1.5\" /&gt; \n        &lt;/dependentAssembly&gt; \n      &lt;/assemblyBinding&gt; \n    &lt;/runtime&gt;\n  &lt;/configuration&gt;\n</pre>\n\n<p>One potential solution to this issue would be allowing customized XDT transform, so that more complicated syntax can be applied during package install/uninstall, such as merging sections and elements between the starting Web.config files and the specified transformations. By this way, we are moving up the complication to the XDT syntax layer, instead on the transform file itself. A <a href=\"http://blog.appharbor.com/2012/07/27/custom-web-config-transforms-and-merges\">sample custom transformation engine</a> has been authored by AppHarbor, with its <a href=\"https://github.com/appharbor/appharbor-transformtester\">open source tester</a> on github.</p>\n","Href":"http://blog.nuget.org/20130920/how-to-use-nugets-xdt-feature-examples-and-facts.html","RawContent":null},{"Title":"Issues uploading portable library packages [Fixed]","PublishedOn":"2013-09-10T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Starting September 3rd, some users started having issues uploading packages that contain portable libraries; on September 10th, we deployed a fix to address those issues.</p>\n\n<h2 id=\"errors-experienced\">Errors Experienced</h2>\n\n<p>Depending on how you were publishing your package, you would have experienced the errors in a few different ways.</p>\n\n<h3 id=\"upload-package-page-on-nugetorg\">Upload Package page on nuget.org</h3>\n\n<p>If you were uploading your package through the nuget.org website’s Upload Package page, the package would have initially uploaded okay, but you would have gotten an error when submitting the verified package details.</p>\n\n<p>The error would have been our standard “Error: Oh no, we broke something!” response page.</p>\n\n<h3 id=\"push-with-nugetexe\">Push with nuget.exe</h3>\n\n<p>If you were using nuget.exe push to upload your package to the gallery, you would have gotten a different, and misleading error. That error was coming back as “The remote server returned an error: (502) Bad Gateway.”</p>\n\n<h3 id=\"publish-through-nuget-package-explorer\">Publish through NuGet Package Explorer</h3>\n\n<p><a href=\"http://npe.codeplex.com\">NuGet Package Explorer</a> has the ability to publish packages directly. Attempting to publish packages with portable dependencies would lead to a vague error about a “bad request.”</p>\n\n<h2 id=\"broken-scenarios\">Broken Scenarios</h2>\n\n<p>It took us a few days to really get to the root cause of this issue, because we were observing a couple of different behaviors. When we finally had it figured out, here’s what it turned out to be.</p>\n\n<h3 id=\"scenario-1-packages-with-portable-libraries\">Scenario 1: Packages with portable libraries</h3>\n\n<p>In the scenario of a package containing portable libraries, there were a few details necessary to hit the error.</p>\n\n<ol>\n  <li>The \\lib folder of the package contained a subfolder for a portable library profile. Example: <code class=\"highlighter-rouge\">\\lib\\portable-net4+sl4+wp71+win8</code></li>\n  <li>The nupkg file was created using <code class=\"highlighter-rouge\">nuget.exe pack</code>.</li>\n  <li>The nupkg file was being uploaded either through the Upload Package page on the gallery, or from <code class=\"highlighter-rouge\">nuget.exe push</code>.</li>\n</ol>\n\n<p>If the nupkg file was created with NuGet Package Explorer, or just opened and saved in it, then the package could be uploaded successfully. If the nupkg file was published to the gallery directly from NuGet Package Explorer, that would also succeed.</p>\n\n<p>What we learned from this scenario was that even though NuGet Package Explorer uses the same endpoint as nuget.exe push, packages created within it were immune to the error.</p>\n\n<h3 id=\"scenario-2-packages-with-portable-dependencies\">Scenario 2: Packages with portable dependencies</h3>\n\n<p>Some package authors were bypassing scenario 1 by using NuGet Package Explorer to create their package, but they were still getting the errors. In this scenario, we found the packages had dependencies that only applied for portable libraries.  For instance, a dependency on Microsoft.Bcl.Async which only applies for portable library projects. NuGet Package Explorer would save this dependency’s target framework as “.NETPortable,Version=v0.0,Profile=net45+sl4+sp71” and that would trigger the errors during package uploads as well, even when publishing through NuGet Package Explorer.</p>\n\n<h2 id=\"root-cause\">Root Cause</h2>\n\n<p>The root cause of this issue ended up being a little complicated. Without diving too much into the details, here’s the general explanation, broken down into a few steps.</p>\n\n<h3 id=\"step-1---creating-the-package\">Step 1 - Creating the package</h3>\n\n<ol>\n  <li>Portable library folders names include <code class=\"highlighter-rouge\">+</code> characters</li>\n  <li>nuget.exe (built against .NET 4.0) encodes the <code class=\"highlighter-rouge\">+</code> characters, changing them to <code class=\"highlighter-rouge\">%2B</code></li>\n  <li>NuGet Package Explorer (built against .NET 4.5) <em>does not</em> encode the <code class=\"highlighter-rouge\">+</code> characters</li>\n</ol>\n\n<h3 id=\"step-2---uploading-the-package\">Step 2 - Uploading the package</h3>\n\n<ol>\n  <li>When processing a package upload, nuget.org always decodes folder names for package contents to determine the package’s supported frameworks</li>\n  <li>When the package was created with nuget.exe, the <code class=\"highlighter-rouge\">%2B</code> was decoded back to a <code class=\"highlighter-rouge\">+</code> character</li>\n  <li>When the package was created or published with NuGet Package Explorer, the <code class=\"highlighter-rouge\">+</code> character was decoded into a space</li>\n  <li>The decoded folder names determine the list of frameworks for the package</li>\n</ol>\n\n<h3 id=\"step-3---verifying-target-frameworks\">Step 3 - Verifying target frameworks</h3>\n\n<ol>\n  <li>With the list of frameworks, nuget.org verifies frameworks before storing them in the list of supported frameworks for the package</li>\n  <li>If unrecognized characters (such as spaces) are found in the framework name, the framework name is thrown out immediately</li>\n  <li>If the framework name contains only valid characters, and it’s found to be a portable library, we load the portable libraries from the .NET Framework installation and parse them to create normalized framework names</li>\n</ol>\n\n<h3 id=\"outcome\">Outcome</h3>\n\n<p>We found at this stage of the process that there were two possible outcomes:</p>\n\n<ol>\n  <li>Packages created or published with NuGet Package Explorer, whose decoded folder names had spaces in them, would get ignored as invalid framework names – this was causing data corruption where we weren’t capturing the portable profiles supported by the package</li>\n  <li>All other packages, whose decoded folder names had the correct <code class=\"highlighter-rouge\">+</code> characters, would fail to parse because of a bug in how we were reading the normalized framework names from the .NET Framework</li>\n</ol>\n\n<p><em>Note that packages in Scenario 2 above bypass the folder name encoding/decoding and they were skipping directly to outcome number 2 where the framework name parsing would fail.</em></p>\n\n<p>For the first outcome, we handled the exception gracefully but this led to data corruption–it was actually a silent failure.</p>\n\n<p>For the second outcome, we were not handling the exception and it was causing the visible errors users reported.</p>\n\n<h2 id=\"the-fix\">The Fix</h2>\n\n<p>We needed a two-part fix to address the issues here.</p>\n\n<ol>\n  <li>Parse the framework names correctly so that we don’t fail trying to read the normalized framework name from the .NET Framework.</li>\n  <li>Prevent spaces in the decoded folder names by putting the <code class=\"highlighter-rouge\">+</code> characters back in place.</li>\n</ol>\n\n<p>On September 10th, we deployed these fixes to the gallery and portable library packages can again be uploaded (with no data corruption). We are still working on correcting the data behind the packages that were successfully published over the past week that incurred the data corruption. The symptom of the data corruption is that despite the package being available on the gallery, users with previous versions of the package won’t always see the new version as an available update.</p>\n\n<h2 id=\"our-apologies\">Our Apologies</h2>\n\n<p>We are sorry for the trouble this issue has caused package authors over the past week. We appreciate that you immediately reached out to us and that you were patient while we investigated and fixed the bugs.</p>\n","Href":"http://blog.nuget.org/20130910/portable-package-issues.html","RawContent":null},{"Title":"NuGet 2.7 Package Restore Consent Errors","PublishedOn":"2013-08-29T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>After NuGet 2.7 was released with Automatic Package Restore and implicit consent, some users reported that they were still seeing build errors indicating that package restore consent had not been given. When we made the package restore changes in NuGet 2.7, we identified one scenario where this would happen but determined we couldn’t implement a fix and would rather have to document the cause and solution.</p>\n\n<h2 id=\"scenario-and-cause\">Scenario and Cause</h2>\n\n<p>In order to hit this problem, there’s a specific scenario you must be in. The scenario isn’t extremely common, but we have already heard reports of it.</p>\n\n<ol>\n  <li>Using a freshly built machine or a machine where Visual Studio was freshly installed</li>\n  <li>NuGet has been upgraded to NuGet 2.7</li>\n  <li>An existing solution is opened where the MSBuild-integrated package restore has already been enabled</li>\n  <li>The MSBuild-integrated package restore was enabled before NuGet 2.7 was released</li>\n</ol>\n\n<p>In this scenario, the solution contains a .nuget folder that has a nuget.exe in it versioned 2.6 or earlier. In those versions of nuget.exe, package restore consent was OFF by default (hard-coded to false when not present in nuget.config). When building this solution in Visual Studio, NuGet identifies that the MSBuild-integrated package restore is enabled and therefore automatic package restore is skipped. Then the old nuget.exe kicks in for the package restore and it does not find package restore consent to be given, yielding the following build error:</p>\n\n<p>Package restore is disabled by default. To give consent, open the Visual Studio Options dialog, click on Package Manager node and check ‘Allow NuGet to download missing packages during build.’ You can also give consent by setting the environment variable ‘EnableNuGetPackageRestore’ to ‘true’.</p>\n\n<h2 id=\"solution\">Solution</h2>\n\n<p>As explained on the <a href=\"http://docs.nuget.org/docs/reference/package-restore\">Package Restore</a> documentation, there are three ways to address this situation.</p>\n\n<ol>\n  <li><strong>Force save your NuGet settings with consent given.</strong> To do this, open Visual Studio’s options and under Package Manager, choose General. Uncheck and then re-check the boxes for consent and click OK. This forces your %AppData%\\NuGet\\NuGet.config file to be saved with consent explicitly given, allowing NuGet 2.6 and earlier to see that you’ve given consent.</li>\n  <li><strong>Update the version of NuGet.exe in your .nuget folder.</strong> To do this, run <code class=\"highlighter-rouge\">nuget.exe update -self</code> from your .nuget folder, which will download the latest version of NuGet.exe and replace the version in the .nuget folder. The latest version of NuGet.exe will infer consent to be ON even when not explicitly saved in the NuGet.config file.</li>\n  <li><strong>Migrate to Automatic Package Restore.</strong> For this approach, you would migrate from the MSBuild-integrated package restore to the Automatic Package Restore approach, following the <a href=\"http://docs.nuget.org/docs/workflows/migrating-to-automatic-package-restore\">documented walkthrough</a>.</li>\n</ol>\n","Href":"http://blog.nuget.org/20130829/nuget-2.7-package-restore-consent-errors.html","RawContent":null},{"Title":"Editing Package Metadata on the NuGet Gallery","PublishedOn":"2013-08-23T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In our next deployment, which is scheduled for the week of August 26th, 2013, we have added the ability to edit package metadata at any point in time before or after publishing the package.\nThis has been one of the frequent requests from package authors.</p>\n\n<p>The changes are current dpeloyed @ <a href=\"https://staging.nuget.org\">staging.nuget.org</a>. You can play around with the feature in this sandbox environment. Let us know your feedback and suggestions <a href=\"https://github.com/NuGet/NuGetGallery/issues\">here</a> in github.\nWe are aiming production deployment on 8/27/2013 barring any ship-stopper issues. Meanwhile, we will continue testing from our end as well.</p>\n\n<h2 id=\"edit-package\">Edit Package</h2>\n\n<p>Before the introduction of this feature, clicking on “Edit package” on your package page will give you the below message.</p>\n\n<p><img src=\"/images/2013-08-23-Introducing-Edit-Package/Old-EditPackage.png\" alt=\"Old EditPackage\" /></p>\n\n<p>With this new feature, the “Edit package” page will display all of the metadata of the package and lets you to update them.</p>\n\n<p>All the descriptive fields of the package like Title, Description, Summary, Icon Url, Project Url, Authors, Copyright, Tags and Release notes can be edited. However, updates to the functional details of the package like ID,Version, Dependencies and actual the content of the package requires a new version to be uploaded. This is inline with our current behavior. More details can be found in the <a href=\"http://docs.nuget.org/docs/working-specs/editing-package-descriptions\">spec</a> and the <a href=\"https://github.com/NuGet/NuGetGallery/issues/807\">forum discussion thread</a>.</p>\n\n<h2 id=\"editing-different-versions-of-a-package\">Editing different versions of a package</h2>\n\n<p>You can chose any specific version of the package (not necessarily the latest) and edit its metadata.\nThe “Edit package” page lists the package versions in the left pane making it easier to switch between versions.</p>\n\n<p><img src=\"/images/2013-08-23-Introducing-Edit-Package/Edit-Package-Versions.png\" alt=\"Edit Package Versions\" /></p>\n\n<h2 id=\"saving-and-undoing-edits\">Saving and undoing edits</h2>\n\n<p>Once you update the desired fields of the package and “Save” the edit, the changes will be submitted. It might take a few minutes for the new nupkg file to be created and the changes to reflect in the web page. When the changes are being applied, you (as the package owner) will see the below message in the package page and the new updated data, whereas other users would still see the old data.</p>\n\n<p><img src=\"/images/2013-08-23-Introducing-Edit-Package/Pending-Edit-Message.png\" alt=\"Pending Edit Message\" /></p>\n\n<p>You can click on “Undo pending Edits” link in the notification message to undo all the current edits before it gets applied. You can always make another edit at a later point of time to make further changes.</p>\n\n<h2 id=\"editing-while-uploading-a-new-package\">Editing while uploading a new package</h2>\n\n<p>Package details can be edited while uploading a new package as well.\nThe “Verify Details” page now displays all of the metadata of the package. You can update the details as required and a nupkg file with the modified data will be created and uploaded for you. This will help you in making quick edits to the package before publishing it.</p>\n\n<p><img src=\"/images/2013-08-23-Introducing-Edit-Package/Edit-Package-On-Upload.png\" alt=\"Edit Package On Upload\" /></p>\n\n<h2 id=\"searchinstallupdate-on-edited-package\">Search/Install/Update on edited package</h2>\n\n<p>Once the pending edit goes through, all search/Install/update operations on the package from VS client or the api/v2 feed will reflect the new data and nupkg.</p>\n\n<p>Note, it might take up to 10 minutes for the new changes to be reflected in search results (as the index needs to be updated).</p>\n\n<h2 id=\"how-it-works\">How it Works</h2>\n\n<p>When a package author submits a package, we queue the edit up for being applied. Our backend system processes the queue of edits the order they were submitted, creating an updated NuGet package file (.nupkg), replacing the originally uploaded package and leaving the version number the same. The package originally uploaded, along with its corresponding metadata, are archived in the system.</p>\n\n<p>As a result of the newly created nupkg file, the search index and package source feed are updated as well. This will have downstream effects on consumers of the package source feed as the package’s metadata and hash will be updated. From that point forward, users that install the package will get the updated package, while users that installed the package before the edit will obviously have the old package. When package restore is used, the updated package will be downloaded during package restore, seamlessly replacing the original.</p>\n\n<p>The end result is that package authors now have the ability to update package metadata without publishing a new version of the package. We hope this approach will address the many scenarios when package authors have needed the ability, while also not disturbing package consumers in any way.</p>\n","Href":"http://blog.nuget.org/20130823/Introducing-Edit-Package.html","RawContent":null},{"Title":"NuGet 2.7 Released","PublishedOn":"2013-08-22T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet team is excited to announce that NuGet 2.7 is now released in stable form. We published the release candidate on August 14th and we have not made any changes since then. For details\nabout what’s in the release, the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.7\">release notes</a> are published on <a href=\"http://docs.nuget.org\">docs.nuget.org</a>.</p>\n\n<h2 id=\"nuget-27-features\">NuGet 2.7 Features</h2>\n\n<ol>\n  <li>Package Restore by Default (with implicit consent)</li>\n  <li>Automatic Package Restore in Visual Studio</li>\n  <li>Simplified Package Restore from the Command-Line</li>\n  <li>Project Retargeting and Upgrade Build Errors/Warnings</li>\n  <li>NuGet Configuration Defaults</li>\n  <li>Renaming the Default Package Source</li>\n  <li>Performance Improvements</li>\n  <li>New Extensibility APIs</li>\n  <li>Development-Only Dependencies</li>\n</ol>\n\n<p>Note that with NuGet 2.7, we have removed support for <em>Visual Studio 2010 Express for Windows Phone</em> due to technical limitations related to the new automatic package restore. A separate download is available for that version of Visual Studio and it can be found on the <a href=\"https://nuget.codeplex.com/releases/view/107605\">NuGet 2.7 downloads</a> page on CodePlex. Support for <em>Visual Studio 2010 Express for Web</em> is still included in the primary extension published to the Visual Studio Extension Gallery.</p>\n\n<h2 id=\"visual-studio-2013\">Visual Studio 2013</h2>\n\n<p>NuGet 2.7 is the version of NuGet that will be included in Visual Studio 2013, with the exception of minor updates such as refreshed localization. When those updates are completed, we will republish NuGet 2.7, but no new features will be added.</p>\n\n<h2 id=\"known-issues\">Known Issues</h2>\n\n<p>There are two known issues with nuget.exe restore with the 2.7 release, and these will be fixed soon and the nuget.exe download will be updated along with the <a href=\"http://www.nuget.org/packages/NuGet.CommandLine/\">NuGet.CommandLine package</a>.</p>\n\n<ol>\n  <li><a href=\"https://nuget.codeplex.com/workitem/3596\">New package restore doesn’t work on Mono when using SLN file</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/3598\">New package restore doesn’t work with Wix projects</a></li>\n</ol>\n\n","Href":"http://blog.nuget.org/20130822/nuget-2.7-released.html","RawContent":null},{"Title":"Introducing NuGet Concierge","PublishedOn":"2013-08-16T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Twelve weeks ago, Microsoft’s Azure Applications Platform &amp; Tools team welcomed three 2nd-year college students, Jaspreet Bagga, Jeremiah Jekich, and Melissa McNeill, and gave them an opportunity to contribute to NuGet.</p>\n\n<h2 id=\"package-discovery\">Package Discovery</h2>\n\n<p>Discovering NuGet packages can be a daunting process. The best way to do so is either via word of mouth or online search. However, your friends aren’t always available when you’re looking for a new package at 3:00 in the morning. You could try to search online, but you’d need to spend unnecessary amounts of time sifting through the results before finding a package that may be helpful. We recognize that this time is better spent actually developing software. We wanted to create an accessible service to deliver package recommendations using real world data about how developers use packages.</p>\n\n<p><img src=\"/images/2013-08-16-introducing-nuget-concierge/screenshot.png\" alt=\"NuGet Concierge screenshot\" /></p>\n\n<h2 id=\"nuget-concierge\">NuGet Concierge</h2>\n\n<p>Thus was born <a href=\"http://concierge.nuget.org\">NuGet Concierge</a>, a package recommendation service that recommends packages to developers based on the packages currently being used in their project. We envisioned developers being able to upload their project’s packages.config file to the NuGet Concierge website, which would then present them with a list of packages they may find useful. Something along the lines of “Most projects that use Package A also use Package B.”</p>\n\n<p>So, at the beginning of the summer, we put out a call to the community via Twitter, asking for developers to upload their projects’ packages.config files to help seed our newly conceived recommendation service. We asked, and you delivered! Armed with a collection of over 350 packages.config files, the NuGet Concierge project was brought to life.</p>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>The first step was to translate the collected .config files into a structure that would allow us to analyze the relationships between packages. How often are individual packages used? But, more importantly, how are packages used together?</p>\n\n<p>So, we took the community’s .config files and parsed them, using them to construct a graph. In doing so, we tracked the number of times a package was used, a value we referred to as the package’s “popularity.” We also tracked how many times two packages were used together, which we referred to as the packages’ “pairing frequency.”</p>\n\n<h2 id=\"determining-relationships\">Determining Relationships</h2>\n\n<p>Let’s say we have two packages, EntityFramework and jQuery. By looking at our graph, we know the popularity of EntityFramework and the popularity of jQuery, as well as the pairing frequency between the two. In order to determine the strength of EntityFramework’s relationship with jQuery, we take the pairing frequency between the two and divide it by the popularity of EntityFramework. This gives us the percentage of time EntityFramework is used with jQuery. If we want to know how strongly jQuery is associated with EntityFramework, we simply take the pairing frequency and divide it by the popularity of jQuery.</p>\n\n<p><img src=\"/images/2013-08-16-introducing-nuget-concierge/relationships.png\" alt=\"Package Relationships\" /></p>\n\n<h2 id=\"making-recommendations\">Making Recommendations</h2>\n<p>Suppose a developer has a packages.config file that contains knockoutjs. In order to make recommendations, we look at all packages used with knockoutjs that are not currently in use in the developer’s project. In this case, let’s say knockoutjs is associated with Newtonsoft.Json and Modernizr at association strengths of 91% and 87% respectively. We would recommend Newtonsoft.Json first, followed by Modernizr.</p>\n\n<p><img src=\"/images/2013-08-16-introducing-nuget-concierge/graph.png\" alt=\"Package Graph\" /></p>\n\n<p>With NuGet Concierge, we made every effort to enable improvements over time. When users upload their packages.config file, we present them with the option to contribute their file to the NuGet Concierge dataset. This increases the pool of .config files from which we generate our graph. This means that our recommendations become more accurate the more NuGet Concierge is used.</p>\n\n<p>Additionally once users are presented with recommendations, they have the option to “Like” or “Dislike” each recommendation by giving it a thumbs up or a thumbs down. This information gets stored and allows us to analyze the usefulness of the recommendations we are making. If we find some packages are being recommended at a high association strength, but most users deem them unhelpful, we can adjust the system to recommend the packages at more appropriate strengths. Likewise, we can give a strength boost to packages recommended at low association strengths but deemed helpful by the community.</p>\n\n<p><img src=\"/images/2013-08-16-introducing-nuget-concierge/voting.png\" alt=\"Voting\" /></p>\n\n<h2 id=\"nuget-concierges-potential\">NuGet Concierge’s Potential</h2>\n\n<p>NuGet Concierge is just a conceptual prototype at the moment.  But if the concept proves to be valuable, we imagine NuGet Concierge as a fully integrated part of NuGet, having a presence in the Gallery, Visual Studio’s Manage NuGet Packages dialog, and the Package Manager Console. The greatest part of NuGet Concierge is the data powering it. The ability to reference real data about how packages are actively used together opens up a world of opportunities that can potentially help NuGet better serve developers.</p>\n\n<p>Until then, please feel free to try out NuGet Concierge at <a href=\"http://concierge.nuget.org\">http://concierge.nuget.org</a> and let us know if you like the concept and/or the recommendations. You can also see the code for NuGet Concierge at <a href=\"http://github.com/NuGet/Concierge\">http://github.com/NuGet/Concierge</a>.</p>\n","Href":"http://blog.nuget.org/20130816/introducung-nuget-concierge.html","RawContent":null},{"Title":"NuGet 2.7 Release Candidate Available","PublishedOn":"2013-08-14T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet 2.7 Release Candidate is now available, with an expected release before the end of August.</p>\n\n<ul>\n  <li><a href=\"https://nuget.codeplex.com/releases/view/107605\">Download: Visual Studio Extensions and NuGet.exe Command-Line</a></li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/list/advanced?release=NuGet%202.7&amp;status=all\">All Work Items for the Release</a></li>\n  <li>\n    <table>\n      <tbody>\n        <tr>\n          <td>[Open Issues](https://nuget.codeplex.com/workitem/list/advanced?keyword=&amp;status=Proposed</td>\n          <td>Active&amp;release=NuGet%202.7)</td>\n        </tr>\n      </tbody>\n    </table>\n  </li>\n  <li><a href=\"https://nuget.codeplex.com/workitem/list/advanced?keyword=&amp;status=Resolved&amp;release=NuGet%202.7\">Work Items Being Tested</a></li>\n</ul>\n\n<p>If you encounter any problems with NuGet 2.7, especially any regressions, please file an issue on <a href=\"http://nuget.codeplex.com\">CodePlex</a> right away and prefix the issue with “[NuGet 2.7]”.</p>\n\n<p>Please note that we plan to include NuGet 2.7 in the final release of Visual Studio 2013, so the features and bug fixes in this release will be available in-the-box for all Visual Studio 2013 users.</p>\n\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n\n<p>We would like to thank the following external contributors for their significant contributions to NuGet 2.7:</p>\n\n<ol>\n  <li><a href=\"http://www.codeplex.com/site/users/view/mxrss\">Mike Roth</a> (<a href=\"https://twitter.com/mxrss\">@mxrss</a>)\n    <ul>\n      <li>Show License url when listing packages and verbosity is detailed.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/adamralph\">Adam Ralph</a> (<a href=\"https://twitter.com/adamralph\">@adamralph</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/1956\">#1956</a> - Add developmentDependency attribute to packages.config and use it in pack command to only include runtime packages</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/tkrafael\">Rafael Nicoletti</a> (<a href=\"https://twitter.com/tkrafael\">@tkrafael</a>)\n    <ul>\n      <li>Avoid duplicate Properties key in nuget.exe pack command.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/benphegan\">Ben Phegan</a> (<a href=\"https://twitter.com/benphegan\">@BenPhegan</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/2610\">#2610</a> - Increase machine cache size to 200.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/derigel\">Slava Trenogin</a> (<a href=\"https://twitter.com/derigel\">@derigel</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3217\">#3217</a> - Fix NuGet dialog showing updates in the wrong tab</li>\n      <li>Fix Project.TargetFramework can be null in ProjectManager</li>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3248\">#3248</a> - Fix SharedPackageRepository FindPackage/FindPackagesById will fail on non-existent packageId</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/KevinBoyleRG\">Kevin Boyle</a> (<a href=\"https://twitter.com/kevfromireland\">@kevfromireland</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3234\">#3234</a> - Enable support for Nomad project</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/corinblaikie\">Corin Blaikie</a> (<a href=\"https://twitter.com/corinblaikie\">@corinblaikie</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3252\">#3252</a> - Fix push command fails with exit code 0 when file doesn’t exist.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/veselkamartin\">Martin Veselý</a>\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3226\">#3226</a> - Fix bug with Add-BindingRedirect command when a project references a database project.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/miroslavbajtos\">Miroslav Bajtos</a> (<a href=\"https://twitter.com/bajtos\">@bajtos</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/2891\">#2891</a> - Fix bug of nuget.pack parsing wildcard in the ‘exclude’ attribute incorrectly.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/zippy1981\">Justin Dearing</a> (<a href=\"https://twitter.com/zippy1981\">@zippy1981</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3307\">#3307</a> - Fix bug NuGet.targets does not pass $(Platform) to nuget.exe when restoring packages.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/benerdin\">Brian Federici</a> (<a href=\"https://twitter.com/benerdin\">@benerdin</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/3294\">#3294</a> - Fix bug in nuget.exe package command which would allow adding files with the same name but different casing, eventually causing “Item already exists” exception.</li>\n    </ul>\n  </li>\n  <li><a href=\"http://www.codeplex.com/site/users/view/dcazzulino\">Daniel Cazzulino</a> (<a href=\"https://twitter.com/kzu\">@kzu</a>)\n    <ul>\n      <li><a href=\"http://nuget.codeplex.com/workitem/2990\">#2990</a> - Add Version property to NetPortableProfile class.</li>\n    </ul>\n  </li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/DavidSimner\">David Simner</a>\n    <ul>\n      <li><a href=\"https://nuget.codeplex.com/workitem/3460\">#3460</a> - Fix bug NullReferenceException if requireApiKey = true, but the header X-NUGET-APIKEY isn’t present</li>\n    </ul>\n  </li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/friism\">Michael Friis</a> (<a href=\"https://twitter.com/friism\">@friism</a>)\n    <ul>\n      <li><a href=\"https://nuget.codeplex.com/workitem/3278\">#3278</a> - Fixes NuGet.Build targets file to so that it works correctly on MonoDevelop</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"notable-features-in-the-release\">Notable features in the release</h2>\n\n<h3 id=\"package-restore-by-default-with-implicit-consent\">Package Restore by Default (with implicit consent)</h3>\n\n<p>NuGet 2.7 introduces a new approach to package restore, and also overcomes a major hurdle: Package restore consent is now on by default! The combination of the new approach and the implicit consent will drastically simplify package restore scenarios.</p>\n\n<h4 id=\"implicit-consent\">Implicit Consent</h4>\n\n<p>With NuGet versions 2.0, 2.1, 2.2, 2.5, and 2.6, users needed to explicitly allow NuGet to download missing packages during build. If this consent had not been explicitly given, then solutions that had enabled package restore would fail to build until the user had granted consent.</p>\n\n<p>Starting with NuGet 2.7, package restore consent is ON by default while allowing users to explicitly <em>opt out</em> of package restore if desired, using the checkbox in NuGet’s settings in Visual Studio. This change for implicit consent affects NuGet in the following environments:</p>\n\n<ul>\n  <li>Visual Studio 2013 Preview</li>\n  <li>Visual Studio 2012</li>\n  <li>Visual Studio 2010</li>\n  <li>NuGet.exe Command-Line Utility</li>\n</ul>\n\n<h4 id=\"automatic-package-restore-in-visual-studio\">Automatic Package Restore in Visual Studio</h4>\n\n<p>Starting with NuGet 2.7, NuGet will automatically download missing packages during build in Visual Studio, even if package restore hasn’t been explicitly enabled for the solution. This automatic package restore happens in Visual Studio when you build a project or the solution, but before MSBuild is invoked. This yields a few significant benefits:</p>\n\n<ol>\n  <li>No further need to use the “Enable NuGet Package Restore” gesture on your solution</li>\n  <li>Projects don’t need to be modified, and NuGet won’t make changes to your project to ensure package restore is enabled</li>\n  <li>All NuGet packages, including those that included MSBuild imports for props/targets files, will be restored <em>before</em> MSBuild is invoked, ensuring those props/targets are properly recognized during the build</li>\n</ol>\n\n<p>In order to use Automatic Package Restore in Visual Studio, you only need to take one (in)action:</p>\n\n<ol>\n  <li>Don’t check in your <code class=\"highlighter-rouge\">packages</code> folder</li>\n</ol>\n\n<p>While all users are implicitly opted into automatic package restore, you can easily opt out through the Package Manager settings in Visual Studio.</p>\n\n<p><img src=\"http://docs.nuget.org/docs/release-notes/Images/NuGet-2.7/package-manager-settings.png\" alt=\"Package Manager Settings\" /></p>\n\n<h4 id=\"simplified-package-restore-from-the-command-line\">Simplified Package Restore from the Command-Line</h4>\n\n<p>NuGet 2.7 introduces a new feature for nuget.exe: <code class=\"highlighter-rouge\">nuget.exe restore</code></p>\n\n<p>This new Restore command allows you to easily restore all packages for a solution with a single command, by accepting a solution file or folder as an argument. Furthermore, that argument is implied when there’s only a single solution in the current folder. That means the following all work from a folder that contains a single solution file (MySolution.sln):</p>\n\n<ol>\n  <li>nuget.exe restore MySolution.sln</li>\n  <li>nuget.exe restore .</li>\n  <li>nuget.exe restore</li>\n</ol>\n\n<p>The Restore command will open the solution file and find all projects within the solution. From there, it will find the packages.config files for each of the projects and restore all of the packages found. It also restores solution-level packages found in the .nuget\\packages.config file. More information about the new Restore command can be found in the <a href=\"http://docs.nuget.org/docs/reference/command-line-reference#Restore_Command\">Command-Line Reference</a>.</p>\n\n<h4 id=\"the-new-package-restore-workflow\">The New Package Restore Workflow</h4>\n\n<p>We are excited about these changes to Package Restore, as it introduces a new workflow. If you want to omit your packages from source control you simply don’t commit the <code class=\"highlighter-rouge\">packages</code> folder. Visual Studio users who open and build the solution will see the packages automatically restored. For command-line builds, simply invoke <code class=\"highlighter-rouge\">nuget.exe restore</code> before invoking <code class=\"highlighter-rouge\">msbuild</code>. You’ll no longer need to remember to use the “Enable NuGet Package Restore” gesture on your solution, and we’ll no longer need to modify your projects to alter the build. And this also yields a much improved experience for packages that include MSBuild imports, especially for imports added through NuGet’s recent feature for <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.5#Automatic_import_of_msbuild_targets_and_props_files\">automatically importing props/targets files</a> from the \\build folder.</p>\n\n<p>In addition to the work we’ve done ourselves, we’re also working with some important partners to round this new approach out. We don’t have concrete timelines for any of these yet, but each partner is as excited as we are about the new approach.</p>\n\n<ul>\n  <li>Team Foundation Service - They are working to integrate the call to <code class=\"highlighter-rouge\">nuget.exe restore</code> into the default build scenarios.</li>\n  <li>Windows Azure Web Sites - They are working to allow you to push your project to Azure and have <code class=\"highlighter-rouge\">nuget.exe restore</code> called before your web site is built.</li>\n  <li>TeamCity - They are updating their NuGet Installer plugin for TeamCity 8.x</li>\n  <li>AppHarbor - They are working to allow you to push your repo to AppHarbor and have <code class=\"highlighter-rouge\">nuget.exe restore</code> called before your solution is build.</li>\n</ul>\n\n<p>With each of the partners above, they would use their own copy of nuget.exe and you would not need to carry nuget.exe in your solution.</p>\n\n<h3 id=\"project-retargeting-and-upgrade-build-errorswarnings\">Project Retargeting and Upgrade Build Errors/Warnings</h3>\n\n<p>Many times after retargeting or upgrading your project, you find that some NuGet packages aren’t functioning properly. Unfortunately, there is no indication of this and then there’s no guidance on how to address it. With NuGet 2.7, we now use some Visual Studio events to recognize when you’ve retargeted or upgraded your project in a way that affects your installed NuGet packages.</p>\n\n<p>If we detect that any of your packages were affected by the retargeting or upgrade, we’ll produce immediate build errors to let you know. In addition to the immediate build error, we also persist a <code class=\"highlighter-rouge\">requireReinstallation=\"true\"</code> flag in your packages.config file for all packages that were affected by the retargeting, and each subsequent build in Visual Studio will raise a build warnings for those packages.</p>\n\n<p>While NuGet cannot take automatic action to reinstall affected packages, we hope this indication and warning will guide help you discover when you need to reinstall packages. We are also working on <a href=\"http://docs.nuget.org/docs/workflows/reinstalling-packages\">package reinstallation guidance documentation</a> that these error messages direct you to.</p>\n\n<h3 id=\"nuget-configuration-defaults\">NuGet Configuration Defaults</h3>\n\n<p>Many companies are using NuGet internally, but have had a hard time guiding their developers to use internal package sources instead of nuget.org. NuGet 2.7 introduces a Configuration Defaults feature that allows machine-wide defaults to be specified for:</p>\n\n<ol>\n  <li>Enabled package sources</li>\n  <li>Registered, but disabled package sources</li>\n  <li>The default nuget.exe push source</li>\n</ol>\n\n<p>Each of these can now be configured within a file located at %ProgramData%\\NuGet\\NuGetDefaults.config. If this config file specifies package sources, then the default nuget.org package source will not be registered automatically, and the ones in NuGetDefaults.config will be registered instead.</p>\n\n<p>While not required to use this feature, we expect companies to deploy NuGetDefaults.config files using Group Policy.</p>\n\n<p><em>Note that this feature will never cause a package source to be removed from a developer’s NuGet settings. That means if the developer has already used NuGet and therefore has the nuget.org package source registered, it won’t be removed after the creation of a NuGetDefaults.config file.</em></p>\n\n<p>See <a href=\"http://docs.nuget.org/docs/reference/nuget-config-defaults\">NuGet Configuration Defaults</a> for more information about this feature.</p>\n\n<h3 id=\"renaming-the-default-package-source\">Renaming the Default Package Source</h3>\n\n<p>NuGet has always registered a default package source called “NuGet official package source” that points to nuget.org. That name was verbose and it also didn’t specify where it was actually pointing. To address those two issues, we’ve renamed this package source to simply “nuget.org” in the UI. The URL for the package source was also changed to include the “www.” prefix. After using NuGet 2.7, your existing “NuGet official package source” will automatically be updated to “nuget.org” as its name and “https://www.nuget.org/api/v2/” as its URL.</p>\n\n<h3 id=\"performance-improvements\">Performance Improvements</h3>\n\n<p>We made some performance improvement in 2.7 which will yield smaller memory footprint, less disk usage and faster package installation. We also made smarter queries to OData-based feeds which will reduce the overall payload.</p>\n\n<h3 id=\"new-extensibility-apis\">New Extensibility APIs</h3>\n\n<p>We added some new APIs to our extensibility services to fill the gap of missing functionalities in previous releases.</p>\n\n<h4 id=\"ivspackageinstallerservices\">IVsPackageInstallerServices</h4>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    // Checks if a NuGet package with the specified Id and version is installed in the specified project.\n    bool IsPackageInstalledEx(Project project, string id, string versionString);\n\n    // Get the list of NuGet packages installed in the specified project.\n    IEnumerable&lt;IVsPackageMetadata&gt; GetInstalledPackages(Project project);\n</code></pre></div></div>\n\n<h4 id=\"ivspackageinstaller\">IVsPackageInstaller</h4>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    // Installs one or more packages that exist on disk in a folder defined in the registry.\n    void InstallPackagesFromRegistryRepository(string keyName, bool isPreUnzipped, bool skipAssemblyReferences, Project project, IDictionary&lt;string, string&gt; packageVersions);\n \n    // Installs one or more packages that are embedded in a Visual Studio Extension Package.\n    void InstallPackagesFromVSExtensionRepository(string extensionId, bool isPreUnzipped, bool skipAssemblyReferences, Project project, IDictionary&lt;string, string&gt; packageVersions);\n</code></pre></div></div>\n\n<h3 id=\"development-only-dependencies\">Development-Only Dependencies</h3>\n\n<p>This feature was contributed by <a href=\"https://twitter.com/adamralph\">Adam Ralph</a> and it allows package authors to declare dependencies that were only used at development time and don’t require package dependencies. By adding a <code class=\"highlighter-rouge\">developmentDependency=\"true\"</code> attribute to a package in packages.config, nuget.exe pack will no longer include that package as a dependency.</p>\n\n<h3 id=\"removed-support-for-visual-studio-2010-express-for-windows-phone\">Removed Support for Visual Studio 2010 Express for Windows Phone</h3>\n\n<p>The new package restore model in 2.7 is implemented by a new VSPackage which is different from the main NuGet VSPackage. Due to a technical issue, this new VSPackage doesn’t work correctly in the Visual Studio 2010 Express for Windows Phone SKU as we share the same code base with other supported Visual Studio SKUs. Therefore, starting with NuGet 2.7, we are dropping support for Visual Studio 2010 Express for Windows Phone from the published extension.</p>\n\n<p>Since we are unsure how many developers are still using NuGet in that version/edition of Visual Studio, we are publishing a separate Visual Studio extension specifically for those users and publishing it on CodePlex (rather than the Visual Studio Extension Gallery). We don’t plan to continue to maintain that extension, but if this affects you please let us know by filing an issue on CodePlex.</p>\n\n<p>To download the NuGet Package Manager (for Visual Studio 2010 Express for Windows Phone), visit the <a href=\"https://nuget.codeplex.com/releases/view/107605\">NuGet 2.7 Downloads</a> page.</p>\n\n<h3 id=\"bug-fixes\">Bug Fixes</h3>\n\n<p>In addition to these features, this release of NuGet also includes many other bug fixes. There were 97 total issues addressed in the release. For a full list of work items fixed in NuGet 2.7, please view the <a href=\"https://nuget.codeplex.com/workitem/list/advanced?release=NuGet%202.7&amp;status=all\">NuGet Issue Tracker for this release</a>.</p>\n","Href":"http://blog.nuget.org/20130814/nuget-2.7-release-candidate.html","RawContent":null},{"Title":"Invoke the Manage NuGet Packages dialog programmatically","PublishedOn":"2013-07-25T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Recently I’ve been asked several times for how to invoke the Manage NuGet Packages dialog from VS components programmatically, and optionally auto-invoke the search when the dialog opens. Today I’d like to share the solution in this post.</p>\n\n<p>It’s actually very straightforward. The <strong>Manage NuGet Packages</strong> menu command is registered as a standard VS command, thus you can call <code class=\"highlighter-rouge\">DTE.ExecuteCommand()</code> to invoke it. The trick is to know the command name, which is <strong>Project.ManageNuGetPackages</strong>. Here’s a code sample:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>DTE dte = (DTE)GetService(typeof(SDTE));\ndte.ExecuteCommand(\"Project.ManageNuGetPackages\");\n</code></pre></div></div>\n\n<p>Note that it will open the <em>project-level</em> dialog. To open the <em>solution-level</em> dialog instead, you replace the command name with <strong>Tools.ManageNuGetPackagesforSolution</strong>.</p>\n\n<p>The <code class=\"highlighter-rouge\">ExecuteCommand()</code> method also accepts a second optional parameter of string type. If you pass a string value to it, the NuGet command handler will intepret it as a search query and will automatically issue a search request after it has opened the dialog.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>DTE dte = (DTE)GetService(typeof(SDTE));\ndte.ExecuteCommand(\"Project.ManageNuGetPackages\", \"jQuery\");\n</code></pre></div></div>\n\n<p>With the above code, assuming you have the Online tab selected the last time you closed it, you will see this:</p>\n\n<p><img src=\"/images/open-dialog-with-search.png\" alt=\"Dialog opened with search query \" /></p>\n\n<p>If, for some reason, you don’t like to call through DTE, you can also invoke the command directly through the <code class=\"highlighter-rouge\">OleMenuCommandService</code> service.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>var nugetCommandGuid = Guid.Parse(\"25fd982b-8cae-4cbd-a440-e03ffccde106\");\nvar nugetCommand = new CommandID(nugetCommandGuid, 0x100);  // 0x100 is the command id for project-level dialog\n\nOleMenuCommandService mcs = GetService(typeof(IMenuCommandService)) as OleMenuCommandService;\nmcs.GlobalInvoke(nugetCommand, \"jQuery\");\n</code></pre></div></div>\n\n<p>Again, to open the solution-level dialog, you set the command id to 0x200. These constants are set in the <a href=\"https://nuget.codeplex.com/SourceControl/latest#src/VsExtension/PkgCmdID.cs\" title=\"PkgCmdID.cs\">NuGet source code</a>.</p>\n","Href":"http://blog.nuget.org/20130725/invoke-manage-nuget-packages-dialog-programmatically.html","RawContent":null},{"Title":"NuGet 2.6 Released and Included in Visual Studio 2013 Preview","PublishedOn":"2013-06-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We are excited to announce that NuGet 2.6 has been released and it is included\nin the box with Visual Studio 2013 Preview. For details\nabout what’s in the release, the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.6\">release notes</a> are published on <a href=\"http://docs.nuget.org\">docs.nuget.org</a>.</p>\n\n<h2 id=\"nuget-26-features\">NuGet 2.6 Features</h2>\n\n<ol>\n  <li>Support for Visual Studio 2013</li>\n  <li>XDT Support</li>\n  <li>Machine-Wide Configuration</li>\n  <li>Contextualizing Search</li>\n  <li>Tracking Direct Installs vs. Dependency Installs</li>\n</ol>\n\n<h3 id=\"support-for-visual-studio-2013\">Support for Visual Studio 2013</h3>\n\n<p>NuGet 2.6 is the first release that provides support for Visual Studio 2013. And\nlike Visual Studio 2012, the NuGet Package Manager extension is included in every\nedition of Visual Studio.</p>\n\n<p>In order to provide the best possible support for Visual Studio 2013 while still\nsupporting both Visual Studio 2010 and Visual Studio 2012, and keeping the extension\nsizes as small as possible, we are producing a separate extension for Visual Studio\n2013 while the original extension continues to target both Visual Studio 2010 and 2012.</p>\n\n<p>Starting with NuGet 2.6, we will publish two extensions as below:</p>\n\n<ol>\n  <li><a href=\"http://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c/file/37502/30/NuGet.Tools.vsix\">NuGet Package Manager</a> (applies to Visual Studio 2010 and 2012)</li>\n  <li><a href=\"http://docs.nuget.org/docs/start-here/installing-nuget\">NuGet Package Manager for Visual Studio 2013</a></li>\n</ol>\n\n<p>With this split, the <a href=\"https://nuget.org\">nuget.org</a> home page’s “Install NuGet” button\nwill now take you to the <a href=\"http://docs.nuget.org/docs/start-here/installing-nuget\">installing NuGet</a>\npage, where you can find more information about installing the different NuGet clients.</p>\n\n<h3 id=\"xdt-support\">XDT Support</h3>\n\n<p>One of the most highly-requested features for the NuGet client has been to support more\npowerful XML transformations using the XDT transformation engine which is used in Visual\nStudio <a href=\"http://msdn.microsoft.com/en-us/library/dd465318(v=vs.100).aspx\">build configuration transformations</a>.\nIn April 2013, we made two big announcements regarding NuGet support for XDT. The first\nwas that the XDT library itself was being itself <a href=\"https://nuget.org/packages/Microsoft.Web.Xdt\">released as a NuGet package</a>\nand <a href=\"http://xdt.codeplex.com/\">open sourced on CodePlex</a>. This step enabled the XDT engine\nto be used freely by other open-source software, including the NuGet client. The second\nannouncement was the plan to support use of the XDT engine for transformations in the\nNuGet client. NuGet 2.6 includes this integration.</p>\n\n<h3 id=\"machine-wide-configuration\">Machine-Wide Configuration</h3>\n\n<p>As more companies are using NuGet internally, with private package sources, it has become\nimportant to apply machine-wide configuration for NuGet that can make it easy for\ndevelopers to get access to these private package sources in addition to the official\nNuGet package source at http://nuget.org.  Additionally, some development tools need to\nexpose additional package sources for developers for easy access to packages related to\nthose tools.</p>\n\n<p>With NuGet 2.6, the configuration model has been extended to allow machine-wide package\nsources to be registered for developers to easily discover those package sources. This is\na feature that Visual Studio 2013 itself utilizes to register a “.NET Framework Packages”\nfeed by default.</p>\n\n<h3 id=\"contextualizing-search\">Contextualizing Search</h3>\n\n<p>As the number of packages served by the NuGet gallery continues to grow at an exponential\npace, improving search remains ever at the top of the NuGet priority list. One of the\nplanned features for NuGet is contextual search, meaning that NuGet will use information\nabout the version and SKU of Visual Studio that you are using and the type of project that\nyou are building as criteria for determining the relevance of potential search results.</p>\n\n<p>Starting with NuGet 2.6, each time a package is installed, the context for the installation\nis recorded as part of the installation operation data.  Searches also send the same context\ninformation, which will allow the NuGet Gallery to boost search results by contextual\ninstallation trends.  A future update to the NuGet Gallery will enable this context-sensitive\nrelevance boosting.</p>\n\n<h3 id=\"tracking-direct-installs-vs-dependency-installs\">Tracking Direct Installs vs. Dependency Installs</h3>\n\n<p>Package authors are relying more and more on the <a href=\"http://blog.nuget.org/20130226/Introducing-Package-Statistics.html\">Package Statistics</a>\nprovided on the NuGet Gallery.  One significant missing data point that authors have asked\nfor is a differentiation between direct package installs and dependency installs.  Until now,\nthe NuGet client did not send any context around the installation operation for whether the\ndeveloper directly installed the package or if it was installed to satisfy a dependency.\nStarting with NuGet 2.6, that data will now be sent for the installation operation.  Package\nStatistics on the NuGet Gallery will expose that data as separate install operations, with\na “-Dependency” suffix.</p>\n\n<ul>\n  <li>Install</li>\n  <li>Install-Dependency</li>\n  <li>Update</li>\n  <li>Update-Dependency</li>\n  <li>Reinstall</li>\n  <li>Reinstall-Dependency</li>\n</ul>\n\n<p>In addition to the different operation name, the dependent package id is also recorded for the\ninstallation.  A future update to the NuGet Gallery will expose that data within reports, allowing\npackage authors to fully understand how developers are installing their packages.</p>\n\n<h2 id=\"bug-fixes\">Bug Fixes</h2>\n\n<p>NuGet 2.6 also includes several bug fixes. For a full list of work items fixed in NuGet 2.6, please view\nthe <a href=\"https://nuget.codeplex.com/workitem/list/advanced?keyword=&amp;status=Closed&amp;type=All&amp;priority=All&amp;release=NuGet%202.6&amp;assignedTo=All&amp;component=All&amp;sortField=LastUpdatedDate&amp;sortDirection=Descending&amp;page=0&amp;reasonClosed=All\">NuGet Issue Tracker for this release</a>.</p>\n","Href":"http://blog.nuget.org/20130626/nuget-2.6-released.html","RawContent":null},{"Title":"Package Manager Dialog vs. Package Manager Console, some differences!","PublishedOn":"2013-05-21T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>One common misconception we see among NuGet users is that NuGet could only install/ update to the latest version of a package in VS. This is due to the fact that through ‘NuGet Package Manager Dialog’ we only show that latest (stable or prerelease) version of any package. But, NuGet provides the ability to install/ update to <strong>any specific version</strong> of a package through Package Manager Console. Let’s see an example below on how to do this.</p>\n\n<p>##Install a specific version of a package##</p>\n\n<p>To bring up Package Manager Console in VS, go to View-&gt;Other Windows-&gt;Package Manager Console.</p>\n\n<p><img src=\"/images/PMC.png\" alt=\"Package Manager Console\" /></p>\n\n<p>You could use the highlighted dropdowns above to set the Package Source and the Project in which the package should be installed.</p>\n\n<p>To install EntityFramework 4.3.1, you could type the following in the console.</p>\n\n<p><strong><em>Install-Package EntityFramework -Version 4.3.1</em></strong></p>\n\n<p>In addition to being able to install a specific version of a package, there are a few other things that could be done through Package Manager Console, that are not available through UI. Let’s see those features below.</p>\n\n<p>##Reinstall packages that have already been installed##</p>\n\n<p>There may be instances when you would like to install a package that is already installed. For example, in some build or CI scenarios, the package version may not be incremented but you may want to install the latest produced package. This cannot be done through the Package Manager Dialog as NuGet will notify that the package is already installed. However, through Package Manager Console you could reinstall an existing package. Let’s say you have SamplePackage 1.8 already installed and you want to reinstall it. You can use the following command to reinstall SamplePackage. Reinstall will always install the same version that was previously installed.</p>\n\n<p><strong><em>Update-Package SamplePackage -reinstall</em></strong></p>\n\n<p><strong>Please note that -reinstall flag works only on NuGet Clients 2.1 and above</strong></p>\n\n<p>##Ignore dependencies when installing a package##</p>\n\n<p>Another thing that you could do through the Package Manager Console but not through the Package Manager Dialog is installing a package without it’s dependencies. To do this, you could use the -ignoreDependencies switch with Install-Package command. For example, jQuery.Validation package has a dependency on jQuery. When you install through the Package Manager Dialog the dependencies will always get installed. However, executing the following command in Package Manager Console will only install jQuery.Validation and not jQuery.</p>\n\n<p><strong><em>Install-Package jQuery.Validation -ignoreDependencies</em></strong></p>\n\n<p>##Force##</p>\n\n<p>The next thing that you could do with Package Manager Console easily is to force uninstall of a package that is being dependent upon by other packages. Let’s take the example of jQuery and jQuery.Validation in a project. When you try to uninstall jQuery from the project through the Package Manager dialog, you will see the following UI that tells you that it can’t be done.</p>\n\n<p><img src=\"/images/UninstallFailure.png\" alt=\"Failure on uninstall of a parent package\" /></p>\n\n<p>In case of Package Manager Dialog, you have to first uninstall the packages that have jQuery dependency before you can uninstall jQuery itself. However, with Package Manager Console, you can use the -force switch to uninstall the jQuery package.</p>\n\n<p><strong><em>UnInstall-Package jQuery -force</em></strong></p>\n\n<p>##Source##</p>\n\n<p>When you install NuGet, it automatically comes with one package source - the NuGet official package source. If you would like to install packages from other sources you need to go to <strong>Tools-&gt;Options-&gt;Package Manager-&gt;Package Sources</strong> to add other custom sources. But, if you would like to install a package from a custom source and not have it as one of your sources in your package sources, you can quickly do it through Package Manager Console using the -Source switch. An example is given below.</p>\n\n<p><strong><em>Install-Package MyPackage -Source PATH_TO_YOUR_CUSTOM_PACKAGE_SOURCE</em></strong></p>\n\n<p>The above are some of the differences between Package Manager Dialog and Package Manager Console and highlight how you could use the Package Manager Console to do some additional things that are not possible through the dialog. Have fun exploring the Package Manager Console!</p>\n\n<p>-Ranjini</p>\n","Href":"http://blog.nuget.org/20130521/package-manager-dialog-vs-package-manager-console.html","RawContent":null},{"Title":"Where else is NuGet used in Visual Studio?","PublishedOn":"2013-05-20T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>All NuGet users are probably familiar with both the Manage NuGet Packages dialog and the Package Manager Console. These are the main user interfaces for installing and managing packages.</p>\n\n<p>However, NuGet is also used in a couple of more subtle places. Below are a few of them that I am aware of. With the exception of the New Project dialog, these dialogs/commands invoke NuGet through the <a href=\"http://docs.nuget.org/docs/reference/invoking-nuget-services-from-inside-visual-studio\">well-documented MEF services</a> that NuGet exports.</p>\n\n<ol>\n  <li>\n    <p><strong>New Project dialog</strong></p>\n\n    <p>When you create a new Web Application project, either a Web Forms or MVC app, the project template invokes NuGet to install a set of pre-defined packages into the new project.</p>\n\n    <p>This feature is publicly documented here: <a href=\"http://docs.nuget.org/docs/reference/packages-in-visual-studio-templates\">http://docs.nuget.org/docs/reference/packages-in-visual-studio-templates</a>. Which means it’s not only available to Microsoft templates, but to any Visual Studio template.</p>\n  </li>\n  <li>\n    <p><strong>Add Service Reference dialog</strong></p>\n\n    <p>When you open the Add Service Reference dialog to add a reference to a WCF Data Service endpoint, the tool uses NuGet to install the latest version of the <strong>Microsoft.Data.Services.Client</strong> package and its dependencies.</p>\n  </li>\n  <li>\n    <p><strong>Publish dialog</strong></p>\n\n    <p>If you attempt to publish your web app to Windows Azure, the Publish dialog detects if your project is using SqlMembership provider, and if so, will ask you to upgrade to Universal provider in order to work with SQL Azure. If you accept, it will install the <strong>Microsoft.AspNet.Providers</strong> and <strong>Microsoft.AspNet.Providers.Core</strong> packages, as well as configure your web.config to use the Universal provider.</p>\n\n    <p><img src=\"/images/publish-dialog.png\" alt=\"Publish dialog\" /></p>\n  </li>\n  <li>\n    <p><strong>Enable Azure Authentication command</strong></p>\n\n    <p>If you enable <a href=\"http://www.asp.net/vnext/overview/latest/windows-azure-authentication\">Windows Azure Active Directory</a> authentication in your web app, the command will install the <strong>System.IdentityModel.Tokens.ValidatingIssuerNameRegistry</strong> package.</p>\n  </li>\n  <li>\n    <p><strong>Add Windows Azure Cloud Service project command</strong></p>\n\n    <p>The <strong>Add Windows Azure Cloud Service project</strong> command, which appears on the context menu for Web projects, uses NuGet to install the <strong>WindowsAzure.Storage</strong> and <strong>Microsoft.WindowsAzure.ConfigurationManager</strong> packages.</p>\n  </li>\n</ol>\n\n<p>I’m very happy to see various teams in Microsoft take advantage of NuGet to implement their own features. I expect even more widespread usage of NuGet in future versions of Visual Studio.</p>\n\n<p>-Luan</p>\n","Href":"http://blog.nuget.org/20130520/where-else-is-nuget-used-in-visual-studio.html","RawContent":null},{"Title":"Play with Packages, programmatically!","PublishedOn":"2013-05-20T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>One of the many often seen requests, from developers using NuGet, is examples on our NuGet core APIs. The requests range from finding meta-data for the packages to installing the package programmatically. In this blog post, I will provide a few examples of using NuGet Core APIs.</p>\n\n<h3 id=\"getting-started\">Getting Started</h3>\n\n<p>To use NuGet Core APIs, install <strong>NuGet.Core</strong> NuGet package in your project and add <strong>NuGet</strong> namespace to your <strong>using</strong> statements.</p>\n\n<h3 id=\"get-me-the-pre-released-versions-of-a-package\">Get me the pre-released versions of a package</h3>\n\n<p>Let’s say you would like to get the list of all pre-released versions of <strong>EntityFramework</strong> package. Below is the code snippet that would get you the list using NuGet API v2.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//ID of the package to be looked up\nstring packageID = \"EntityFramework\";\n\t\t\n//Connect to the official package repository\nIPackageRepository repo = PackageRepositoryFactory.Default.CreateRepository(\"https://packages.nuget.org/api/v2\");\n        \n//Get the list of all NuGet packages with ID 'EntityFramework'       \nList&lt;IPackage&gt; packages = repo.FindPackagesById(packageID).ToList();\n\n//Filter the list of packages that are not Release (Stable) versions\npackages = packages.Where (item =&gt; (item.IsReleaseVersion() == false)).ToList();\n\n//Iterate through the list and print the full name of the pre-release packages to console\nforeach (IPackage p in packages)\n{\n\tConsole.WriteLine(p.GetFullName());\n}\n</code></pre></div></div>\n\n<h3 id=\"help-me-get-a-package\">Help me get a package</h3>\n\n<p>Let’s say you would like to programmatically download and unzip a package in the path you want. Below is the code snippet that you would use to download and unzip the package in the path specified. The example below downloads and unzips <strong>EntityFramework 5.0.0</strong> to one of my projects.</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//ID of the package to be looked up\nstring packageID = \"EntityFramework\";\n\t\t\n//Connect to the official package repository\nIPackageRepository repo = PackageRepositoryFactory.Default.CreateRepository(\"https://packages.nuget.org/api/v2\");\n\n//Initialize the package manager\nstring path = &lt;PATH_TO_WHERE_THE_PACKAGES_SHOULD_BE_INSTALLED&gt;\nPackageManager packageManager = new PackageManager(repo, path);\n        \n//Download and unzip the package\npackageManager.InstallPackage(packageID, SemanticVersion.Parse(\"5.0.0\"));\n</code></pre></div></div>\n\n<h3 id=\"its-quite-easy-have-fun\">It’s quite easy, have fun!</h3>\n<p>As illustrated by the above examples, trying to work with NuGet packages programmatically is quite easy. Start exploring them today!</p>\n\n<p>-Ranjini</p>\n","Href":"http://blog.nuget.org/20130520/Play-with-packages.html","RawContent":null},{"Title":"A quick note about the new MinClientVersion attribute","PublishedOn":"2013-04-30T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the NuGet 2.5 release, we added the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.5##Add_a_%27Minimum_NuGet_Version%27_property_to_packages\">MinClientVersion</a> property to the package manifest schema to allow for a package to demand the minimum version of the NuGet client that can install it.</p>\n\n<p>Because this feature was added in version 2.5, older versions of NuGet won’t be able to recognize it. Therefore, older clients will <em>always</em> refuse to install packages with the MinClientVersion property set, even if you set it to a value smaller than the version of the client.</p>\n\n<p>For example, if you set MinClientVersion to 1.8, and the user tries to install your package with NuGet 2.2, the installation will fail even though 1.8 &lt; 2.2. The user will see the following error message:</p>\n\n<p><strong>The schema version of ‘MyPackage’ is incompatible with version 2.2.1.0 of NuGet. Please upgrade NuGet to the latest version from \nhttp://go.microsoft.com/fwlink/?LinkId=213942.</strong></p>\n\n<p>In sum, this feature will grow in its utility over future NuGet iterations, starting with version 2.6</p>\n\n<p>-Luan</p>\n","Href":"http://blog.nuget.org/20130430/a-quick-note-about-minclientversion-feature.html","RawContent":null},{"Title":"Support for Native Projects","PublishedOn":"2013-04-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>In the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.5\">NuGet 2.5 release notes</a>, we called out that NuGet now has support for native projects. We wanted to explain exactly what “support for native projects” means.</p>\n\n<h2 id=\"visual-studio-support\">Visual Studio Support</h2>\n\n<p>Until NuGet 2.5, if you were working in a Visual C++ project, the ‘Manage NuGet Packages’ context menu would not show up for the project; with NuGet 2.5, we now light this up. Any time we start supporting a new project type, we have to test to ensure all operations are working as expected. Each project system has slightly different behavior and this proved to be true with Visual C++ as well. We made the changes necessary to get NuGet install/update/uninstall operations working.</p>\n\n<h2 id=\"msbuild-integration\">MSBuild Integration</h2>\n\n<p>C++ projects tend to have many different configurations–more than what NuGet is able to handle. To address NuGet’s configuration limitations, we are relying heavily on MSBuild properties and targets for native packages. These MSBuild properties and targets do the heavy lifting of providing references at build time, based on your project’s configuration.</p>\n\n<p>To make MSBuild integration better, NuGet has created a new convention for automatically importing MSBuild properties and targets from a NuGet package. Alongside the existing \\content, \\lib, and \\tools folders, NuGet now recognizes a new top-level folder: <strong>\\build</strong>.</p>\n\n<p>Within the \\build folder, you can provide a “.props” file and/or a “.targets” file that will be automatically imported into the project. For this convention, the file name must match your package id with either a “.props” or “.targets” extension. For example, the ‘<a href=\"https://nuget.org/packages/cpprestsdk/\">cpprestsdk</a>’ package includes a ‘cpprestsdk.targets’ file in its \\build folder. Files with the “.props” extension will be imported at the top of the project file, and files with the “.targets” extension will be imported at the bottom of the project file.</p>\n\n<p>Note that this \\build folder can be used for all NuGet packages and not just native packages. The \\build folder respects target frameworks just like the \\content, \\lib, and \\tools folders do. This means you can create a \\build\\net40 folder and a \\build\\net45 folder and NuGet will import the appropriate props and targets files into the project. You no longer need to write PowerShell install.ps1/uninstall.ps1 scripts to import MSBuild targets files!</p>\n\n<h2 id=\"native-target-framework\">Native Target Framework</h2>\n\n<p>When targeting native projects, a new target framework name is now recognized: <strong>native</strong>. There is no versioning within the ‘native’ target framework; NuGet treats all C++ projects the same.</p>\n\n<p>We expect that most native packages will be produced using the <strong>\\build\\native</strong> folder, with at least a targets file and then a props file if needed. The ‘native’ target framework is also recognized for the \\content and \\tools folders, but because NuGet cannot directly add references to native projects, the ‘native’ target framework <em>is not</em> recognized within the \\lib folder.</p>\n\n<h2 id=\"creating-native-packages\">Creating Native Packages</h2>\n\n<p>If you’re interested in publishing your native libraries via NuGet, you can choose to create the NuGet packages manually. However, there’s an easier way–the CoApp project volunteered to write C++ oriented tools to create NuGet packages, and they have <a href=\"http://coapp.org/pages/releases.html\">released a beta version</a> of their tools. These tools simplify the process of generating the MSBuild files and NuGet packages from existing header and library files–you just need to create a configuration script to describe the contents of the package and then run the tools to generate the NuGet package.</p>\n\n<p>There are <a href=\"http://coapp.org/pages/tutorials.html\">tutorials</a>, <a href=\"http://coapp.org/pages/reference.html\">reference documentation</a>, and a <a href=\"https://www.youtube.com/watch?v=l4MAkR13JPA\">video</a> on how to use the tools to create NuGet packages. The CoApp project organizers also plan to create and publish packages for several open source libraries into the NuGet Gallery over the next several weeks.</p>\n\n<p>We’re encouraging people to publish packages with the “native” tag to make it easier to find packages you can use in C++ projects. You can search the NuGet Gallery using “tag:native” to find packages tagged with “native”. This works from both <a href=\"https://nuget.org/packages?q=tag%3Anative\">nuget.org</a> and within Visual Studio. <em>Note that not all packages tagged with “native” are actually C++ projects though.</em></p>\n\n<p>The <a href=\"http://coapp.org/news/2013-04-26-Announcing-CoApp-Tools-For-NuGet.html\">CoApp</a> and <a href=\"http://blogs.technet.com/b/openness/archive/2013/04/26/nuget-coapp-release.aspx\">Openness@Microsoft</a> blogs have additional information about this project.</p>\n\n<h2 id=\"feedback\">Feedback</h2>\n\n<p>Please leave us feedback here on the blog–we’d love to hear your experiences trying out NuGet in your C++ projects, and whether there are additional features we could add to make this work even better for you. This is just the start of C++ integration in NuGet and we need your input on where we should take this in the future to make working with C++ libraries in Visual Studio easier.</p>\n\n<h2 id=\"related-links-and-announcements\">Related Links and Announcements</h2>\n\n<ul>\n  <li><a href=\"http://blog.nuget.org/20130425/nuget-2.5-released.html\">NuGet 2.5 Release Announcement</a></li>\n  <li><a href=\"https://nuget.codeplex.com/releases/view/96733\">NuGet 2.5 Download Page</a></li>\n  <li><a href=\"http://coapp.org/releases\">CoApp’s PowerShell Tools Installer to create NuGet packages for C++ libraries and tools</a></li>\n  <li><a href=\"http://blogs.msdn.com/b/vcblog/archive/2013/04/26/nuget-for-c.aspx\">Announcement on the Visual C++ Team Blog</a></li>\n  <li><a href=\"http://blogs.technet.com/b/openness/archive/2013/04/26/nuget-coapp-release.aspx\">Announcement on the Openness@Microsoft Blog</a></li>\n  <li><a href=\"http://coapp.org/news/2013-04-26-Announcing-CoApp-Tools-For-NuGet.html\">Announcement on the CoApp Blog</a></li>\n</ul>\n\n","Href":"http://blog.nuget.org/20130426/native-support.html","RawContent":null},{"Title":"NuGet 2.5 Released","PublishedOn":"2013-04-25T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<h2 id=\"download-it-now\">Download it now</h2>\n\n<p>NuGet was included in all editions of Visual Studio 2012 and it’s also available for Visual Studio 2010 through the Visual Studio Extension Manager. To get the latest version of NuGet installed in Visual Studio, either check for updates in the extension manager or <a href=\"http://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c\">download the latest version directly</a>.</p>\n\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n\n<p>We would like to thank the following external contributors for their significant contributions to NuGet 2.5:</p>\n\n<ol>\n  <li><a href=\"https://www.codeplex.com/site/users/view/dsplaisted\">Daniel Plaisted (dsplaisted)</a> - Add MonoAndroid, MonoTouch, and MonoMac to the list of known target framework identifiers. <a href=\"https://nuget.codeplex.com/workitem/2847\">#2847</a></li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/knocte\">Andres G. Aragoneses (knocte)</a> - Fix spelling of NuGet.targets for a case-sensitive OS <a href=\"https://nuget.codeplex.com/workitem/2865\">#2865</a></li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/dfowler\">David Fowler (dfowler)</a> - Make the solution build on Mono.</li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/atheken\">Andrew Theken (atheken)</a> - Fix unit tests failing on Mono.</li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/OliIsCool\">Olivier Dagenais (OliIsCool)</a> - nuget.exe pack command does not propagate Properties to msbuild <a href=\"https://nuget.codeplex.com/workitem/2920\">#2920</a></li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/MiroslavBajtos\">Miroslav Bajtos (MiroslavBajtos)</a> - Modified XML handling code to preserve formatting. <a href=\"https://nuget.codeplex.com/workitem/1511\">#1511</a></li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/adamralph\">Adam Ralph (adamralph)</a> - Added recognized words to custom dictionary to allow build.cmd to succeed.</li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/broggeri\">Bruno Roggeri (broggeri)</a> - Fix unit tests when running in localized VS.</li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/garethevans\">Gareth Evans (garethevans)</a> -  Extracted interface from PackageService</li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/brugidou\">Maxime Brugidou (brugidou)</a> - Handle project dependencies when packing <a href=\"https://nuget.codeplex.com/workitem/936\">#936</a></li>\n  <li><a href=\"https://www.codeplex.com/site/users/view/XavierDecoster\">Xavier Decoster (XavierDecoster)</a> - Support Clear Text Password when storing package source credentials in nuget.cofig files <a href=\"https://nuget.codeplex.com/workitem/2991\">#2991</a>, <a href=\"https://nuget.codeplex.com/workitem/3164\">#3164</a></li>\n</ol>\n\n<p>We also appreciate the following individuals for finding bugs with NuGet 2.5 Beta/RC that were approved and fixed before the final release:</p>\n\n<ol>\n  <li><a href=\"https://www.codeplex.com/site/users/view/CodeChief\">Tony Wall (CodeChief)</a> - MSTest broken with lastest NuGet 2.4 and 2.5 builds <a href=\"https://nuget.codeplex.com/workitem/3200\">#3200</a></li>\n</ol>\n\n<h2 id=\"whats-included-in-nuget-25\">What’s Included in NuGet 2.5</h2>\n\n<p>This release was so big, we felt compelled to skip versions 2.3 and 2.4! To date, this is the largest release we’ve had for NuGet, with <a href=\"https://nuget.codeplex.com/workitem/list/advanced?release=NuGet%202.5&amp;status=all\">169 work items</a> in the release.</p>\n\n<p>For details about what’s in the release, the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.5\">release notes</a> are published on <a href=\"http://docs.nuget.org\">docs.nuget.org</a>.</p>\n\n<h3 id=\"here-are-the-most-notable-features\">Here are the most notable features:</h3>\n\n<ol>\n  <li>Allow users to overwrite content files that already exist</li>\n  <li>Automatic import of msbuild targets and props files</li>\n  <li>Specify different references per platform using <References></References> element</li>\n  <li>Update All button to allow updating all packages at once</li>\n  <li>Improved project reference support for NuGet.exe Pack</li>\n  <li>Add a ‘Minimum NuGet Version’ property to packages</li>\n  <li>Dependencies are no longer unnecessarily updated during package installation</li>\n  <li>NuGet.exe outputs http requests with detailed verbosity</li>\n  <li>NuGet.exe push now supports UNC and directory sources</li>\n  <li>NuGet.exe supports explicitly-specified Config files</li>\n  <li>Support for Native projects</li>\n</ol>\n\n<h2 id=\"nugets-description\">NuGet’s description</h2>\n\n<p>We’ve outgrown NuGet’s current description. According to <a href=\"http://nuget.org\">nuget.org</a>, we have the following description and slogan:</p>\n\n<blockquote>\n  <p><strong>Jump Start Your Projects with NuGet</strong></p>\n\n  <p>NuGet is a Visual Studio extension that makes it easy to install and update third-party libraries and tools in Visual Studio.</p>\n\n  <p><em>So install NuGet and get a jump on your next project!</em></p>\n</blockquote>\n\n<p>We have come up with a new description for NuGet:</p>\n\n<blockquote>\n  <p>NuGet is the package manager for the Microsoft development platform including .NET.\nThe NuGet client tools provide the ability to produce and consume packages.\nThe NuGet Gallery (<a href=\"http://nuget.org\">nuget.org</a>) is the central package repository used by all package authors and consumers.</p>\n</blockquote>\n\n<p>You can expect the home page at <a href=\"http://nuget.org\">nuget.org</a> to reflect this new description soon.</p>\n","Href":"http://blog.nuget.org/20130425/nuget-2.5-released.html","RawContent":null},{"Title":"XDT web.config transforms","PublishedOn":"2013-04-22T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Sitting there since October 12, 2010, with a total of 55 votes accumulated since then, there’s a NuGet feature that has had more than its fair share of attention: <a href=\"https://nuget.codeplex.com/workitem/232\">Support Visual Studio (XDT) Web.config Transforms</a>. It’s the 17th highest voted work item of all time for NuGet, and the 5th highest voted <em>open</em> work item. Today, we are announcing that we are finally unblocked on getting this feature integrated into NuGet!</p>\n\n<p>Last November, we made the decision to act on this feature request, and Luan Nguyen (<a href=\"https://www.codeplex.com/site/users/view/dotnetjunky\">dotnetjunky</a>) posted a <a href=\"https://nuget.codeplex.com/discussions/405195\">discussion thread</a> that NuGet would be taking a dependency on the XDT assembly. Within a few hours, Andreas Håkansson (<a href=\"https://www.codeplex.com/site/users/view/thecodejunkie\">thecodejunkie</a>) pointed out a really good glitch in our plan: we needed to make sure the feature would work on Mono!</p>\n\n<p>Fast forward 4 months, and we have resolution for the requirement of XDT support working on Mono–Microsoft has open-sourced the XML Document Transform (XDT) library at <a href=\"http://xdt.codeplex.com\">http://xdt.codeplex.com</a>, and NuGet will be taking a source dependency on XDT rather than a binary dependency.</p>\n\n<p>Here’s the net result of the work we’ve done with the team that develops the XDT library:</p>\n\n<ol>\n  <li>A <a href=\"http://nuget.org/packages/Microsoft.Web.Xdt/\">Microsoft.Web.Xdt</a> NuGet package is published to nuget.org.</li>\n  <li>The NuGet team used that NuGet package to prototype integration of NuGet and XDT.</li>\n  <li>The XDT library is open-sourced (not accepting contributions) at <a href=\"http://xdt.codeplex.com\">xdt.codeplex.com</a>.</li>\n  <li>The NuGet team will now use the XDT source to provide the integration.</li>\n  <li>This allows all NuGet users on all platforms to use the feature. NuGet can be built on Mono and have the XDT source built there too.</li>\n</ol>\n\n<p>NuGet package authors will be able to create two new files in their packages to perform XDT transforms:</p>\n\n<ol>\n  <li>web.config.install.xdt (and yes, files other than web.config are supported)</li>\n  <li>web.config.uninstall.xdt</li>\n</ol>\n\n<p>These files can use XDT functionality to transform XML files during install, and then to reverse the transformations upon uninstall. It’s a concept very similar to install.ps1/uninstall.ps1, but using the XDT library for the XML transforms.</p>\n\n<p>We are working on the source-based integration of this feature now, and we plan to include it in the NuGet 2.6 release in early summer 2013.</p>\n\n<p>For more information about the XDT library and its open source project, check out the <a href=\"http://blogs.msdn.com/b/webdev/archive/2013/04/23/xdt-xml-document-transform-released-on-codeplex-com.aspx\">.NET Web Development and Tools blog post</a>.</p>\n","Href":"http://blog.nuget.org/20130422/xdt-web-config-transforms.html","RawContent":null},{"Title":"Goodbye preview.nuget.org. Hello staging.nuget.org!","PublishedOn":"2013-04-19T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><a href=\"http://en.wiktionary.org/wiki/TL;DR\">TL;DR</a> The <a href=\"http://preview.nuget.org\">preview.nuget.org</a> site is going away. Switch to <a href=\"http://staging.nuget.org\">staging.nuget.org</a> by April 26th!</p>\n\n<h2 id=\"goodbye-previewnugetorg\">Goodbye preview.nuget.org</h2>\n<p>We have a version of the NuGet Gallery called “Preview” and it’s been hosted at <a href=\"http://preview.nuget.org\">preview.nuget.org</a> since early in the Gallery’s lifetime. Until recently, our QA team used preview.nuget.org to do their testing, but we’ve also occasionally advised package owners to use the site as a sandbox environment. Over time, this has put us in the situation of the “preview” site serving two different purposes: 1) it was an internal QA testing environment, and 2) it was a customer sandbox/preview environment.</p>\n\n<p>These two use cases for the environment have drastically different requirements. The QA environment needs to be sanitized to not have any real data and allow the QA team to do whatever they need to the data at any time. The customer sandbox environment needs to have a mirror of recent production data to provide a useful staging environment. Because of these conflicting requirements, we are separating our QA testing environment from the sandbox, and <strong>we’ll be decommisioning preview.nuget.org on April 26th</strong>.</p>\n\n<h2 id=\"hello-stagingnugetorg\">Hello staging.nuget.org</h2>\n<p>To provide a sandbox where package authors can stage their packages to test their publishing, we are creating a new staging environment at <a href=\"http://staging.nuget.org\">staging.nuget.org</a>. Staging is a very close mirror of production and its data is frequently copied from production (although not yet on any fixed schedule).</p>\n\n<p>If you have packages you want to publish and you’re nervous about the publishing process, please use <a href=\"http://staging.nuget.org\">staging.nuget.org</a>. Your account information and API key are not guaranteed to be in sync because the data is not a live mirror, but you can register and log on to Staging just like you would on <a href=\"http://nuget.org\">http://nuget.org</a>. You can then push your packages to Staging and ensure you have your publishing process and your package metadata just right before publushing to <a href=\"http://nuget.org\">nuget.org</a>.</p>\n","Href":"http://blog.nuget.org/20130419/goodbye-preview.html","RawContent":null},{"Title":"NuGet 2.5 Release Candidate","PublishedOn":"2013-04-15T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p><em>Updated:</em>\nThe NuGet 2.5 Release Candidate was available from April 15 to April 25, 2013.  For the several hundred of you that downloaded the release candidate, we truly appreciate your verification of the RC build that became the final release.</p>\n\n<h2 id=\"whats-included-in-nuget-25\">What’s Included in NuGet 2.5</h2>\n\n<p>This release was so big, we felt compelled to skip versions 2.3 and 2.4! To date, this is the largest release we’ve had for NuGet, with over <a href=\"https://nuget.codeplex.com/workitem/list/advanced?release=NuGet%202.5&amp;status=all\">160 work items</a> in the release.</p>\n\n<p>For details about what’s in the release, the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.5\">tentative release notes</a> have been published to <a href=\"http://docs.nuget.org\">docs.nuget.org</a>.</p>\n\n<h3 id=\"here-are-the-most-notable-features\">Here are the most notable features:</h3>\n\n<ol>\n  <li>Allow users to overwrite content files that already exist</li>\n  <li>Automatic import of msbuild targets and props files</li>\n  <li>Specify different references per platform using <References></References> element</li>\n  <li>Update All button to allow updating all packages at once</li>\n  <li>Improved project reference support for NuGet.exe Pack</li>\n  <li>Add a ‘Minimum NuGet Version’ property to packages</li>\n  <li>Dependencies are no longer unnecessarily updated during package installation</li>\n  <li>NuGet.exe outputs http requests with detailed verbosity</li>\n  <li>NuGet.exe push now supports UNC and directory sources</li>\n  <li>NuGet.exe supports explicitly-specified Config files</li>\n  <li>Support for Native projects</li>\n</ol>\n\n<h2 id=\"nugets-description-and-slogan\">NuGet’s description and slogan</h2>\n\n<p>We think we’ve outgrown NuGet’s current description. According to <a href=\"http://nuget.org\">nuget.org</a>, we have the following description and slogan:</p>\n\n<blockquote>\n  <p><strong>Jump Start Your Projects with NuGet</strong></p>\n\n  <p>NuGet is a Visual Studio extension that makes it easy to install and update third-party libraries and tools in Visual Studio.</p>\n\n  <p><em>So install NuGet and get a jump on your next project!</em></p>\n</blockquote>\n\n<p>We have come up with a new description for NuGet:</p>\n\n<blockquote>\n  <p>NuGet is the open-source package manager for the Microsoft platform and .NET/Mono.\nThe NuGet client tools provide the ability to produce and consume packages.\nThe NuGet Gallery (nuget.org) is the central package repository used by all package authors and consumers.</p>\n</blockquote>\n\n<p>We’d like your feedback on this new description. And for a new slogan to replace “Jump Start Your Projects with NuGet,” we’re still undecided.  We want something fun and maybe a little edgy. If you’d like to submit your idea, tweet your idea using the <a href=\"https://twitter.com/search/realtime?q=%23nugetslogan\">#nugetslogan</a> hashtag. Once we have a good list to choose from, we’ll open up a poll. Follow <a href=\"http://twitter.com/nuget\">@nuget</a> for updates.</p>\n\n<p><a class=\"twitter-timeline\" data-dnt=\"true\" href=\"https://twitter.com/search?q=%23nugetslogan\" data-widget-id=\"323970527691685888\">Tweets about “#nugetslogan”</a>\n<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+\"://platform.twitter.com/widgets.js\";fjs.parentNode.insertBefore(js,fjs);}}(document,\"script\",\"twitter-wjs\");</script></p>\n","Href":"http://blog.nuget.org/20130415/nuget-2.5-release-candidate.html","RawContent":null},{"Title":"Recent NuGet Gallery Updates","PublishedOn":"2013-04-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet Gallery crew has gotten into a rhythm of publishing updates every 2 weeks.  With the increased update frequency, we found that we needed to create a changelog to highlight new features.  That changelog is now available directly from within our <a href=\"https://github.com/NuGet/NuGetGallery\">source repository on GitHub</a>.</p>\n\n<p>You can access the changelog directly here:\n<a href=\"https://github.com/NuGet/NuGetGallery/blob/master/Changelog.md\">https://github.com/NuGet/NuGetGallery/blob/master/Changelog.md</a></p>\n\n<p>Here is the current log, showing the changes that have been made over the last 2 deployments.</p>\n\n<h2 id=\"april-4-2013\">April 4, 2013</h2>\n\n<h3 id=\"top-500-packages-exposed-in-the-feed\">Top 500 packages exposed in the feed</h3>\n\n<p>The nuget.org API (V2) feed now exposes the top downloaded packages (over the last 6 weeks). This can accessed be via url <a href=\"//nuget.org/api/v2/stats/downloads\">nuget.org/api/v2/stats/downloads</a>. At this time, the top 500 packages are shown by default and that is also the maximum number returned.</p>\n\n<p>You can limit the numbers of results using ?count in the query string.  For example, <a href=\"//nuget.org/api/v2/stats/downloads?count=10\">nuget.org/api/v2/stats/downloads?count=10</a> would return the top 10 downloaded packages in last 6 weeks - with information like download count, gallery url and feed url for that package.</p>\n\n<p>The default and maximum count of 500 might change over time, so we recommend always specifying a count parameter if you are programmatically consuming this data.</p>\n\n<h3 id=\"numeric-rank-for-packages-stats\">Numeric rank for packages stats</h3>\n\n<p>The <a href=\"http://nuget.org/stats\">Statistics page</a> now shows the numeric rank of the package (based on the download count).</p>\n\n<h3 id=\"links-to-gravatar-in-profile-page\">Links to gravatar in profile page</h3>\n\n<p>The profile editing page now includes help text and a link to gravatar making it easy for users to update their profile picture.</p>\n\n<h3 id=\"username-optimization-in-db-backend\">UserName optimization in DB (backend)</h3>\n\n<p>The “Users” table is optimized to have “UserName” as index for performance enhancements.</p>\n\n<h3 id=\"other-minor-bug-fixes\">Other minor bug fixes</h3>\n\n<p>Complete list can be found here: <a href=\"https://github.com/NuGet/NuGetGallery/issues?milestone=18&amp;state=closed\">Production Deployment 4/12</a></p>\n\n<h2 id=\"march-28-2013\">March 28, 2013</h2>\n\n<h3 id=\"support-for-minclientversion\">Support for MinClientVersion</h3>\n\n<p>You can now upload packages with “<a href=\"http://nuget.codeplex.com/wikipage?title=NuGet%202.5%20list%20of%20features%20for%20Testing%20days%203%2f27%20to%203%2f29%20%2c%202013\">minclientVersion</a>” to the NuGetGallery.</p>\n\n<p>The minclientVersion of the package will shown in the package home page right next to the package description.</p>\n\n<h3 id=\"contacting-support\">Contacting support</h3>\n\n<p>The “Report Abuse” page has been revamped to enable users to chose the specific issue with the package they are reporting. It also guides the user to differentiate between “Contact Owners” and “Report Abuse”.</p>\n\n<h3 id=\"improved-package-statistics\">Improved package statistics</h3>\n\n<p>The package statistics now shows the break down of downloads based on the NuGet client (like NuGet CommandLine 2.1, NuGet Package Manager console 2.2 and so on.  It also shows the split of the type of download operation (like Install, Restore, Update).</p>\n\n<h3 id=\"other-minor-bug-fixes-1\">Other minor bug fixes</h3>\n\n<p>Complete list can be found here: <a href=\"https://github.com/NuGet/NuGetGallery/issues?milestone=17&amp;state=closed\">Production Deployment 3/28</a></p>\n\n","Href":"http://blog.nuget.org/20130411/recent-nuget-gallery-updates.html","RawContent":null},{"Title":"The March 6th NuGet Gallery Outage","PublishedOn":"2013-04-04T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>On March 6th 2013, nuget.org’s package download was broken for one and a half hours. Some outages involve factors beyond our control; \nthis time it was very much our own fault and we would like to apologize. We \nalso want to openly discuss the outage and reassure you that we are working on preventing reoccurences.</p>\n\n<h2 id=\"timeline-of-events\">Timeline of events</h2>\n\n<p>The outage was triggered by the NuGet Gallery crew performing a regular planned upgrade to nuget.org. We had successfully completed the previous\nproduction upgrade as recently as 2 weeks prior (in fact we are now shipping code to nuget.org on regular 2-3 weeks intervals). The timeline of the \noutage was something like this:</p>\n\n<p>2:00 - We assembled to do deployment to production. Following our existing process, we backed up the production database, \nreviewed the state of our master branch in git, and checked that our preproduction environment still looked healthy.</p>\n\n<p>2:25 - We published the new code to the Production Web Role in Azure staging slots. Because we are using Entity Framework migrations at App Startup time, \nand because the VMs in staging slots run against the same database as the (still live) VMs in production slots, we did not feel safe testing these \nnew role instances prior to doing the VIP swap which brings the new code live.</p>\n\n<p>2:30 - We do the VIP swap, and the new code is now running nuget.org. We start doing sanity tests of production, and checking the error logs in case we will \nsee evidence of any problems there.</p>\n\n<p>A few minutes later, we started receiving tweets and emails stating that package downloads were failing.  We acknowledged the issue on twitter. <a href=\"https://twitter.com/nuget/status/309432341057634305\">Related tweet</a>.\nWe really appreciate your tweets at <a href=\"http://twitter.com/nuget\">@nuget</a> when you encounter site issues!</p>\n\n<p>2:35 - We realized gallery is redirecting package download requests to package URLs that don’t exist. We also realized why.\nThe problem is in our production environment package blobs have not been updated to the new naming convention that the new code we just deployed requires.</p>\n\n<p>We started running the batch job, which already exists, and has been used on preproduction environments. This will update the production environment package \nblobs and fix package downloads so the world can get their nupkgs. We estimated that this batch job will take 40-60 minutes to run.</p>\n\n<p>While we monitored the progress of the batch job, we were simultaneously second guessing ourselves and trying to think of a safe way to get the site back up faster. \nUnfortunately VIP swapping back to the old production VMs is not a viable solution, the reason again being the way we are using Entity Framework migrations at App_Start\nwhich means our old production code is probably not going to be happy with a database which is in a state it does not understand.</p>\n\n<p>2:40 - We got worried. The batch job seemed to be working very slowly, or not at all.</p>\n\n<p>3:05 - We realized the batch job itself is broken. We fixed the code, and restarted the whole batch job. Again we monitored progress of the batch job. \nThis time, eventually, we could verify it was working properly. We thought the batch job would take about an hour to complete, but it ended up taking 85 minutes.\nPackages gradually became available for download during this time, so some people may have seen their problems resolved sooner. <a href=\"https://twitter.com/nuget/status/309439911881240577\">Related tweet</a>.</p>\n\n<p>4:30 - We verified that the batch job had completed and all packages are back up and working. <a href=\"https://twitter.com/nuget/status/309461232967110656\">Related tweet</a>.</p>\n\n<h2 id=\"the-problematic-code-changes\">The Problematic Code Changes</h2>\n\n<p>Here’s what motivated the change causing all these problems:</p>\n\n<ol>\n  <li>Package IDs in URLs on the nuget gallery are case insensitive.</li>\n  <li>Azure Blob Storage, which we use for holding all our nupkg files for download, is case sensitive.</li>\n  <li>Package IDs have their ‘canonical’ casing preserved in the NuGet database, and is used to build the filename that retrieves the blob from blob storage.</li>\n  <li>The canonical casing is determined the <em>first</em> time the package is published and it was immutable.  Many package authors have wished to change the casing, but we couldn’t support it.  This meant that any given version of a package might claim a package ID that is different from the canonical ID.</li>\n</ol>\n\n<p>The consequence of 3. and 4. is that in order to service a package restore download request, which contains the package ID in casing which may be different from blob storage, \nnuget.org must query the database to retrieve the canonical ID before we could service the download request. As a further consequence package download stops \nworking any time our database goes down.</p>\n\n<h3 id=\"avoiding-the-database-for-package-downloads\">Avoiding the database for package downloads</h3>\n\n<p>We updated the code that handles package download requests to look for packageID.ToLowerCase(); This means we no longer have to hit the database to retrieve package ID’s canonically cased version, \nwe can just use ToLowerCase() on the package ID sent in the download request.</p>\n\n<p><em>We apologize for the irony! We intended package downloads to become more robust but actually ended up breaking package downloads.</em></p>\n\n<h2 id=\"the-postmortem---what-went-wrong\">The Postmortem - What Went Wrong</h2>\n\n<p>We held a meeting the day after the outage, where we did a break-down starting with a summary of everything that went wrong, during the upgrade and outage. Here’s <em>what</em> went wrong.</p>\n\n<ol>\n  <li>The outage happened. We published a problem code to the VMs without the required associated data because we are missing a step in the deployment.</li>\n  <li>We tested the production environment after we published the code. This is when we discovered the issue. The time spent testing and discovering the issue contributes to the total delay between the problem occurring and us fixing the problem.</li>\n  <li>We were not confident we could safely revert the VIP swap to unpublish from production. If we could have done it then package downloads would have started working immediately, and it would have been probably a 5 minute downtime, not a 1.5 hour downtime. So our inability to safely revert is a problem.</li>\n  <li>The batch job for fixing the problem failed the first time. It contributed to the outage duration significantly the time to realize the script was broken and fix it again was 20 minutes or more.</li>\n  <li>And finally, the missed step of running the fixed batch job to recover the gallery just takes a long time because it’s doing a lot of work.</li>\n</ol>\n\n<p>In a deeper analysis of <em>how</em> the problem code went into production in the first place without knowing that it would cause a problem, we found out that</p>\n\n<ul>\n  <li>The script had been run against our QA environment (called Preview) <em>by the developer</em>, without involving QA in testing the script.</li>\n  <li>The script had not been run against the preproduction environment (called Staging) ever. One reason for that is that Preview and Staging share the same Azure blob storage account, so it would have made no difference to observable behavior during testing.</li>\n  <li>Even though the need for running the script had been communicated verbally to the crew, because it was weeks earlier and because the step was not part of the deployment process for Preview and Staging, \nthe step was completely forgotten about by the time it came to do the actual production deployment.</li>\n  <li>QA team had noticed issues downloading from Preview and Staging environments but not realize they were important because it was <em>normal for download to be broken in these environments</em>.\nThe reason is these environments don’t have the full set of the production blob data in their own storage account.</li>\n</ul>\n\n<h2 id=\"conclusions---what-we-plan-to-change\">Conclusions - What We Plan to Change</h2>\n\n<p>Plans for preventing and mitigating future nuget.org downtime caused by the NuGet gallery crew’s upgrades to nuget.org.</p>\n\n<ul>\n  <li>\n    <p>Ensure our deployment checklist of ALL steps required for deployment is updated alongside any code changes that require special deployment steps.</p>\n  </li>\n  <li>\n    <p>Validate production deployments using automated tests immediately after going live. We want to be able to detect the problems faster than it can be tweeted to us.</p>\n  </li>\n  <li>\n    <p>Expect problems during upgrades, and have a clear recovery plan in place for every deployment. The plan details how to quickly and safely recover when the deployment fails.</p>\n  </li>\n</ul>\n\n<p>Ideally our recovery plan should always be VIP swap. We are currently experimenting with changing our use of Entity Framework to a model which will not depend on running migrations during the deployment itself.</p>\n\n<p>A second recovery plan is database restore <em>plus</em> VIP swap. We would first set the Gallery to Read-Only mode (this is new) during the deployment, which means you will be unable to create accounts and upload packages while the deployment occurs.</p>\n\n<ul>\n  <li>\n    <p><em>Test</em> the recovery plan in preproduction before doing the production deployment. (Confidence in a plan that has been dreamed up under pressure and not been tested is low!)</p>\n  </li>\n  <li>\n    <p>We need to make the QA and Preproduction environments squeaky clean and as reliable as production. We should never have issues that occur there that get ignored and thereby slip into production.</p>\n  </li>\n  <li>\n    <p>Stopping Preview and Staging from sharing the blob storage account will help us ensure we have done clean practice deployments.</p>\n  </li>\n  <li>\n    <p>Enhance our service monitoring to give us better feedback on when and how package download gets broken.</p>\n  </li>\n</ul>\n\n","Href":"http://blog.nuget.org/20130404/the-march-6-nuget-gallery-outage.html","RawContent":null},{"Title":"Improved search syntax on nuget.org and in NuGet Visual Studio extension","PublishedOn":"2013-03-25T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The NuGet team recently deployed a new and very useful search capability on nuget.org, which allows you to narrow your search to a pariticular attribute of a NuGet package. For example, if you want to search for packages which contain ‘elmah’ within the Id, you type ‘<strong><a href=\"https://nuget.org/packages?q=id%3Aelmah\" title=\"Search for packages with elmah in Id\">id:elmah</a></strong>’. (Note that this will execute a ‘contains’ search, not an exact match search. Which means it will return elmah, elmah.corelibrary, etc.)</p>\n\n<p>Similarly you can use the same syntax to search for other attributes in the package metadata. Here’s the complete list of supported attributes:</p>\n\n<table cellpadding=\"8\" border=\"1\">\n   <thead>\n      <tr>\n         <td>Attribute</td>\n         <td>Example</td>\n      </tr>\n   </thead>\n\n   <tbody>\n      <tr>\n         <td>id</td>\n         <td><strong>id:jQuery</strong></td>\n      </tr>\n\t  <tr>\n         <td>title</td>\n         <td><strong>title:Validation</strong></td>\n      </tr>\n      <tr>\n         <td>description</td>\n         <td><strong>description:dependency injection</strong></td>\n      </tr>\n      <tr>\n         <td>authors</td>\n         <td><strong>authors:Outercurve Foundation</strong></td>\n      </tr>\n      <tr>\n         <td>owners</td>\n         <td><strong>owners:dotnetjunky</strong></td>\n      </tr>\n      <tr>\n         <td>tags</td>\n         <td><strong>tags:silverlight</strong></td>\n      </tr>\n   </tbody>\n</table>\n\n<p>Note that when a search query contains spaces, the gallery will perform an OR search against words in the query. AND search is currently not supported.</p>\n\n<p>Even better, this feature is automatically available for any NuGet client that calls the Search service method from nuget.org. This can be seen in the Visual Studio Package Manager dialog as shown below.</p>\n\n<p><img src=\"/images/improved-search.png\" alt=\"\" /></p>\n\n<p>Happy searching!</p>\n","Href":"http://blog.nuget.org/20130325/improved-search-syntax.html","RawContent":null},{"Title":"Introducing Package Statistics","PublishedOn":"2013-02-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We have introduced a new feature on <a href=\"http://nuget.org\">http://nuget.org</a> where you can see download statistics for packages.  With this initial drop, we hope to whet your appetite and collect your input on further statistics features; it’s a mere fraction of what we can imagine.</p>\n\n<h2 id=\"statistics-tab\">Statistics Tab</h2>\n\n<p>At the top of the site, a new ‘Statistics’ tab is displayed.</p>\n\n<p><img src=\"/images/2013-02-26-Introducing-Package-Statistics/statistics-tab.png\" alt=\"statistics tab\" /></p>\n\n<p>This tab takes you to <a href=\"http://nuget.org/stats\">http://nuget.org/stats</a>, which shows the two high-level statistics reports we have at the moment.  While we expect this page will expand with more reports, the first two we’ve introduced are “Downloaded Packages (Last 6 Weeks)” and “Downloaded Package Versions (Last 6 Weeks).”</p>\n\n<h2 id=\"downloaded-packages\">Downloaded Packages</h2>\n\n<p>This report shows the total download numbers for all versions of a package.  The full report includes the top 100 packages over the last 6 weeks.  It’s no shock that packages like jQuery, Newtonsoft.Json, jQuery.Validation, and Microsoft.AspNet.Razor are at the top.  But since the report is based on the last 6 weeks, instead of all time, we expect to see more changes on this report than on the full list of packages.</p>\n\n<p><img src=\"/images/2013-02-26-Introducing-Package-Statistics/downloaded-packages.png\" alt=\"downloaded packages\" /></p>\n\n<h2 id=\"downloaded-package-versions\">Downloaded Package Versions</h2>\n\n<p>This report shows the download numbers for a single version of a package.  This full report includes the top 500 package versions over the last 6 weeks, and a package can show up multiple times if it has had more than one frequently downloaded version.  From here, we can learn more about which versions of packages developers are using and how long it takes a new version to overcome an older one.</p>\n\n<p><img src=\"/images/2013-02-26-Introducing-Package-Statistics/downloaded-package-versions.png\" alt=\"downloaded package versions\" /></p>\n\n<h2 id=\"version-breakdown-for-a-package\">Version Breakdown for a Package</h2>\n\n<p>On the ‘Downloaded Packages’ report, the download count is a hyperlink.  Following that hyperlink for a package will show you a report for the package’s downloads by version.  This package-specific report lets you see the recent (6 weeks) downloads for any package, to further identify download trends for a package’s versions.</p>\n\n<p><img src=\"/images/2013-02-26-Introducing-Package-Statistics/version-breakdown.png\" alt=\"version breakdown\" /></p>\n\n<h2 id=\"statistics-for-any-package\">Statistics for any Package</h2>\n\n<p>When viewing the detail page for any package, there’s a new ‘Package Statistics’ link on the left side.  This link takes you directly to the version breakdown for that package, showing the download statistics for the last 6 weeks.  This data will be different from the download counts displayed directly on the package page, where that is a total of downloads for all time, instead of just the last 6 weeks.</p>\n\n<p>Note that there are not any reports visible only to the package owner.  Everyone can see the package statistics for any package.</p>\n\n<p><img src=\"/images/2013-02-26-Introducing-Package-Statistics/package-statistics.png\" alt=\"package statistics\" /></p>\n\n<h2 id=\"availability\">Availability</h2>\n\n<p>As we first launch the package statistics feature, many packages will not have statistics available right away.  You may see a message that states, “Download statistics are not currently available for this package, please check back later.”  After the deployment of the feature, we are firing off the job to produce statistics reports for all packages.  We expect this to take about a day.  So if your package’s statistics aren’t yet available, just check back again later.</p>\n\n<p>After the initial release of the feature, there will be a job running nightly to refresh every package’s statistics reports.</p>\n\n<h2 id=\"feedback-and-input\">Feedback and Input</h2>\n\n<p>As mentioned, this is just the beginning of package statistics.  We expect other reports to highlight which NuGet operation caused the download, whether it was a fresh Install, an Update, or a Package Restore.  We are now collecting that data and in a handful of weeks we’ll be able to report on it.  We also expect reports that bring in dependency graph data, packages that have been recently updated, and more.</p>\n\n<p>If you have feedback or input for what statistics would be useful to you, either as a package consumer or package author, please let us know.  The best way is to file an issue <a href=\"https://github.com/nuget/nugetgallery\">on the repository</a>.</p>\n","Href":"http://blog.nuget.org/20130226/Introducing-Package-Statistics.html","RawContent":null},{"Title":"Workflow Changes for CodePlex Issues","PublishedOn":"2013-02-11T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>A couple weeks ago, some of you noticed that the core team closed a few issues on <a href=\"http://nuget.codeplex.com\">http://nuget.codeplex.com</a> that were in the “Soonish” release. The items that were closed were feature suggestions that, while not bad ideas, were things that the core team decided weren’t going to make the cut for the next few releases. \nThe pushback from the community in response was understandable. After all, if NuGet is an OSS project, why would the core team close good ideas simply because we weren’t going to act on them? \nFirstly, we’ve reopened the items that we had closed and moved them to the “Product Backlog” release (more on that momentarily). We also spent some time thinking about how we can do a better job balancing what feels like two competing interests in the same issue repository. The first is the interest of the core team to more efficiently manage its day to day work – and this means maintaining a high signal to noise ratio in the release buckets that we work from. The second interest is that of the community to actively participate in development of NuGet, whether that means filing new product ideas or pulling a new idea from the list which will ultimately find its way back into the product via a pull request.\nSo here’s how we’re planning to organize issues and perform triage going forward in an attempt to better satisfy both sets of interests:</p>\n\n<ol>\n  <li>Get rid of the “Soonish” release. We had originally created this as a way to identify things that were potential candidates for a near term release as opposed to items in “Product Backlog” – however, over the last several months, we’ve observed that items in this release have built up to a level where the core team isn’t going to be able to act on many of these either – resulting in effectively 2 different backlog buckets. In sum, it was a nice idea, but it hasn’t worked out in the way that we had hoped.</li>\n  <li>Rename “Product Backlog” to “Up For Grabs”. This release represents issues that we would accept as a pull request if someone from the community implemented it with sufficient quality. One of the reasons that we closed items in “Soonish” rather than moving them to backlog was that we believe “backlog” to imply that the core team will eventually get around to acting on the item, and we felt like this was misleading. Items in backlog are those that the core team has decided are good ideas but not ideas that we will likely revisit. We do periodically pull highly-voted items from the backlog into an active release, but this is not a part of our regular rhythm. As such, we want the name of the release to more accurately reflect how it’s being used.</li>\n  <li>Add an acknowledgements.txt file to the repository and insert this text into the release notes. In general, we want to figure out better ways to thank individuals who take their role in the NuGet community to the next step by submitting pull requests for the issues that they are passionate about. Adding this kind of recognition seems like an obvious step that we can take here to do better at encouraging and rewarding this kind of participation.</li>\n  <li>We triage issues a couple times per week. When considering a new issue, the decision flow will look like the following:\n    <ul>\n      <li>Is this something that we need to work on for the current release? If so, assign to the current release. The bar for this question changes based on the type of release (e.g. some releases are more focused on risk management, some on new feature development).</li>\n      <li>Is this something that the core team plans to work on? If so, assign to the next actual release.  No more of the revolving “Next” release as this would allow us to be passive about making decisions on issues that we repeatedly never get to.</li>\n      <li>Is this something that we think is a good idea, but know that the core team is not going to get around to working on in the foreseeable future? If so, assign to “Up For Grabs” release so that it can be voted on and <strong>ideally</strong> picked up by the community.</li>\n      <li>Is this something that we do not think is a good idea for NuGet? If so, close the issue with relevant explanation.</li>\n    </ul>\n  </li>\n  <li>The planning process for a new release will look like the following:\n    <ul>\n      <li>Ensure that roadmap features have been added to the upcoming release (e.g. ensure that all potential work for the release has been added in the form of a CodePlex issue).</li>\n      <li>Triage all of the unfinished items in the release that was just completed. For each item, either move it to the next release, move to “Up For Grabs”, or close.</li>\n      <li>If an issue has cascaded from release to release more than 2 times, move it to “Up For Grabs”</li>\n    </ul>\n  </li>\n</ol>\n\n<p>We’re sorry if the recent closing of issues on CodePlex gave you the impression that we were somehow making a move towards being less open and hope that the above steps give you a little more insight into how we think about our working and planning rhythms. The core team would love to be able to implement all of the good ideas that fit within the vision for NuGet - however, we are finite and can only get through a subset of the total items. With your help in grabbing issues from Up For Grabs, we’re looking forward to being able to get a lot more accomplished!</p>\n\n<p>The quality of issues filed on NuGet has historically been very high, and we appreciate that. In the same way, we want and appreciate your thoughts and comments on how we can continually improve our processes - hopefully that is evident in these changes. As such, we’ll hold off for a couple of days to collect your feedback on the new approach and then, assuming that there are no blocking issues raised, make the changes outlined above.</p>\n","Href":"http://blog.nuget.org/20130211/workflow-changes-for-codeplex-issues.html","RawContent":null},{"Title":"Managing Package Owners on nuget.org","PublishedOn":"2013-02-05T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>While each NuGet package’s <a href=\"http://docs.nuget.org/docs/reference/nuspec-reference\">nuspec metadata</a> defines the package’s owner(s), the NuGet gallery at nuget.org ignores that piece of nuspec metadata.  Instead, ownership of a package is defined by who publishes the package to the gallery.  Sometimes this metadata needs to be managed beyond the initial package publishing too, which means the owner metadata needs to be mutable while the package itself is not.</p>\n\n<h2 id=\"setting-a-packages-initial-owner\">Setting a Package’s Initial Owner</h2>\n<p>When a brand new package is published to nuget.org, its initial owner is defined by the user that published the package.</p>\n\n<ol>\n  <li>If the website’s ‘Upload Package’ page was used to publish the package, then the logged-on user is the package’s owner.</li>\n  <li>If <code class=\"highlighter-rouge\">nuget.exe push</code> was used to publish the package from the command-line, then the API key specified to nuget.exe will define the package’s owner.  This can be done by either including the API key in the <a href=\"http://docs.nuget.org/docs/reference/command-line-reference#Push_Command\">Push command</a>, or by using the <a href=\"http://docs.nuget.org/docs/reference/command-line-reference#Setapikey_Command\">SetApiKey command</a>.</li>\n</ol>\n\n<h2 id=\"specifying-additional-package-owners\">Specifying Additional Package Owners</h2>\n<p>It’s common for a package to have multiple developers; each developer can be listed as a co-owner of the package.  Packages can also utilize a convention for “organizations” to indicate company/group ownership of a package.  For example, the Microsoft ASP.NET packages are co-owned by <a href=\"http://nuget.org/profiles/microsoft\">microsoft</a>, <a href=\"http://nuget.org/profiles/aspnet\">aspnet</a>, and sometimes individuals on the feature team.  The ‘microsoft’ and ‘aspnet’ accounts are simply set up with a mailing list email address that reaches the teams that manage the accounts.</p>\n\n<p>Once a package has been published to nuget.org, it’s easy to invite additional users to become owners of the package.</p>\n\n<ol>\n  <li><a href=\"https://nuget.org/users/account/LogOn\">Log on</a> to nuget.org with the account that is the current owner of the package;</li>\n  <li>Navigate to the package page using the ‘Packages’ tab, searching, or clicking your username to and then ‘<a href=\"https://nuget.org/account/Packages\">Manage My Packages</a>’;</li>\n  <li>When logged on as the package’s owner, there is a ‘Manage Owners’ link on the left side to click;</li>\n  <li>Enter the username of the person to add as an owner and click ‘Add’;</li>\n  <li>An email is then sent to the new co-owner, as an invitation to become an owner of the package;</li>\n  <li>Once that user clicks the link, they are a full co-owner with full control over the package, including the ability to remove other users as owners.</li>\n</ol>\n\n<p>Until the new owner confirms ownership, they <em>will not</em> be listed as an owner of the package.  When viewing the ‘Manage Owners’ page, you will see a “pending approval” entry in the current owners.  That invitation can be removed, just as other owners can be removed.</p>\n\n<p>This process of invitations prevents users from falsely adding other users as owners of their packages.  Note that the “Authors” metadata is purely freeform text; only “Owners” are controlled.</p>\n\n<h2 id=\"removing-package-owners\">Removing Package Owners</h2>\n<p>All package owners are peers.  This means any package owner can publish a new version of the package.  It also means that any package owner can remove any other package owner.  No owner has more authority than other owners.</p>\n\n<p>When a package has multiple owners and one needs to be removed the process is simple:</p>\n\n<ol>\n  <li><a href=\"https://nuget.org/users/account/LogOn\">Log on</a> to nuget.org with the account that is the current owner of the package;</li>\n  <li>Navigate to the package page using the Packages tab, searching, or clicking your username to and then ‘<a href=\"https://nuget.org/account/Packages\">Manage My Packages</a>’;</li>\n  <li>When logged on as the package’s owner, there is a ‘Manage Owners’ link on the left side to click;</li>\n  <li>Click the ‘remove’ link next to the owner to be removed.</li>\n</ol>\n\n<h2 id=\"transfering-package-ownership\">Transfering Package Ownership</h2>\n<p>We sometimes get support requests to transfer package ownership from one user to another, but you can almost always accomplish this yourself.  Transfering ownership from one user to another is simply a combination of the two features above.</p>\n\n<ol>\n  <li>The current owner invites the new user to become a co-owner and the new user accepts the invite;</li>\n  <li>The new user removes the old user from the list of owners.</li>\n</ol>\n\n<p>This request has come in under a couple forms but the process works the same.</p>\n\n<ul>\n  <li>The package ownership is changing from one developer to another</li>\n  <li>The package was accidentally published using the wrong account</li>\n</ul>\n\n<h2 id=\"orphaned-packages\">Orphaned Packages</h2>\n<p>One last scenario has occurred, but not many times.  Packages have become orphans and the only package owner account cannot be used to add new owners.  Here are some examples of this scenario:</p>\n\n<ul>\n  <li>The owner’s account is associated with an email address that no longer exists and the user has forgotten their password</li>\n  <li>The registered owner has left the company that produces the package and cannot be reached to update the package ownership</li>\n  <li>Due to a bug that has only affected a handful of packages, the package is somehow ownerless on the gallery</li>\n</ul>\n\n<p>Some members of the NuGet team are in the ‘admin’ role on the gallery and can access the ‘Manage Owners’ link for any package.  If you are the rightful owner of a package and cannot reach the current owner to gain ownership permissions, then use the ‘Report Abuse’ link on the gallery to reach the NuGet team.  We will then follow a process to verify your ownership of the package.  If we determine you should be an owner of the package, we will use the ‘Manage Owners’ link for the package ourselves and send you the invite to become an owner.  We will only do this after verifying that you should be an owner and the process for this varies by circumstances.  Often times, we will use the package’s Project URL to find a way to contact the project owner, but we may also use Twitter, Email, or other means for contacting the project owner.</p>\n","Href":"http://blog.nuget.org/20130205/managing-package-owners.html","RawContent":null},{"Title":"A quick tutorial on the Update-Package command","PublishedOn":"2012-12-31T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Among the supported commands in NuGet’s Package Manager Console, <strong>Update-Package</strong> is arguably the most powerful in terms of its supported parameters and switches. The primary purpose of the command is to update package(s) in your projects to a higher (possibly latest) version. However, the provided parameters allow you to twist this behavior in many different ways. In this post, I’m going to give a quick tutorial on what possible ways you can invoke the command.</p>\n\n<p>In total, the <strong>Update-Package</strong> command offers eight parameters (in addition to the built-in PowerShell parameters):</p>\n\n<table cellspacing=\"0\" cellpadding=\"6\" border=\"1\">\n   <tr>\n      <th>Parameter</th>\n      <th>Type</th>\n      <th>Description</th>\n   </tr>\n\n   <tr>\n      <td>-Id</td>\n      <td>string</td>\n      <td>Specifies the Id of the package to be updated.</td>\n   </tr>\n\n   <tr>\n      <td>-ProjectName</td>\n      <td>string</td>\n      <td>Specifies the name of the project in which packages should be updated.</td>\n   </tr>\n\n   <tr>\n      <td>-Version</td>\n      <td>SemanticVersion*</td>\n      <td>Specifies the new target version of the package as a result of the update.</td>\n   </tr>\n\n   <tr>\n      <td>-Source</td>\n      <td>string</td>\n      <td>Specifies where to look for package updates, overriding the package sources that are specified in the Options dialog. This value can be either a url to a remote repository or a path to a local repository or the name of a package source specified in the Options dialog.</td>\n   </tr>\n\n   <tr>\n      <td>-IgnoreDependencies</td>\n      <td>Switch parameter</td>\n      <td>If set, NuGet will ignore dependency packages and only update the main package.</td>\n   </tr>\n\n   <tr>\n      <td>-Safe</td>\n      <td>Switch parameter</td>\n      <td>If set, NuGet will only update to a new version that has the same major and minor versions as the previous package. For example, if the old version is 1.2.0, NuGet will accept the update package with version of 1.2.1 or 1.2.9999  but it will <em>not</em> accept 1.3.0.</td>\n   </tr>\n\n   <tr>\n      <td>-IncludePrerelease</td>\n      <td>Switch parameter</td>\n      <td>If set, NuGet will consider prerelease packages as candidates for updates.</td>\n   </tr>\n\n   <tr>\n      <td>-Reinstall</td>\n      <td>Switch parameter</td>\n      <td>If set, instead of updating the package to the latest version, NuGet will uninstall the package and reinstall the same version. This is useful when, for example, you've updated the target framework of your project, e.g. from .NET 4.0 to .NET 4.5, and you want to reference .NET 4.5-specific assemblies in the package. You can't set this parameter together with the -Version parameter.</td>\n   </tr>\n</table>\n\n<p><code class=\"highlighter-rouge\">*</code>Although the type of the -Version parameter is <strong>SemanticVersion</strong>, which is a type declared by NuGet, you can just use string when you set it. PowerShell will automatically convert it for you, as long as the value can be parsed by the <strong>SemanticVersion</strong> class.</p>\n\n<p>With that, here are the common use cases for the Update-Package command:</p>\n\n<ul>\n  <li>\n    <p>Update a particular package in a project to the latest version:<br />\n<code><strong>Update-Package</strong> jQuery <strong>-ProjectName</strong> MyProject</code></p>\n  </li>\n  <li>\n    <p>Update a particular package in a project to the latest version, using safe update rule:<br />\n<code><strong>Update-Package</strong> jQuery <strong>-ProjectName</strong> MyProject <strong>-Safe</strong></code></p>\n  </li>\n  <li>\n    <p>Update a particular package in a project to a particular version:<br />\n<code><strong>Update-Package</strong> jQuery <strong>-ProjectName</strong> MyProject <strong>-Version</strong> 1.8</code></p>\n  </li>\n  <li>\n    <p>Update a particular package in <em>all</em> projects of the current solution to the latest version:<br />\n<code><strong>Update-Package</strong> jQuery</code></p>\n  </li>\n  <li>\n    <p>Update a particular package in <em>all</em> projects of the current solution to a particular version:<br />\n<code><strong>Update-Package</strong> jQuery <strong>-version</strong> 1.8</code></p>\n  </li>\n  <li>\n    <p>Reinstall a particular package in <em>all</em> projects of the current solution:<br />\n<code><strong>Update-Package</strong> jQuery <strong>-reinstall</strong></code></p>\n  </li>\n  <li>\n    <p>Update <em>all</em> packages in a project to the latest versions:<br />\n<code><strong>Update-Package</strong> <strong>-ProjectName</strong> MyProject</code></p>\n  </li>\n  <li>\n    <p>Reinstall <em>all</em> packages in a project:<br />\n<code><strong>Update-Package</strong> <strong>-ProjectName</strong> MyProject <strong>-reinstall</strong></code></p>\n  </li>\n  <li>\n    <p>Update <em>all</em> packages in <em>all</em> projects of the current solution to the latest versions:<br />\n<code><strong>Update-Package</strong></code></p>\n  </li>\n  <li>\n    <p>Reinstall <em>all</em> packages in <em>all</em> projects of the current solution:<br />\n<code><strong>Update-Package</strong> <strong>-Reinstall</strong></code></p>\n  </li>\n</ul>\n\n<p>Phew, that’s a lot of different combinations; but they are quite intuitive and easy to remember. To keep the list small, I left out the -IgnoreDependencies and -IncludePrelease parameters but you can add either (or both) of them to any of the example above (except that you can’t use -Version and -Reinstall together, remember?) to adjust the behavior of the command.</p>\n\n<p>Hope that helps. Happy New Year.</p>\n","Href":"http://blog.nuget.org/20121231/a-quick-tutorial-on-update-package-command.html","RawContent":null},{"Title":"Creating custom package rules for your build","PublishedOn":"2012-10-23T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>When you build your NuGet packages using <strong>nuget.exe</strong>, you may have noticed that sometimes you get a warning about the created package. Here’s one example:</p>\n\n<p><img src=\"/images/nuget-exe-warning.PNG\" alt=\"A package warning\" /></p>\n\n<p>This warning is generated by one of NuGet’s <em>package analysis rules</em>. Think of these as the NuGet equivalent of an FxCop rule. When <strong>nuget.exe</strong> creates a package, it automatically executes the package analysis step which in turn invokes all the registered rules. These rules will, one by one, examine the built package and emit the warnings as you see. You can disable this analysis step by supplying the <strong><code>-NoPackageAnalysis</code></strong> parameter to the ‘pack’ command, although we don’t recommend it.</p>\n\n<p>By default, <strong>nuget.exe</strong> includes a set of built-in rules. These are:</p>\n\n<ul>\n  <li><strong>InitScriptNotUnderToolsRule</strong>: detect whether there is an <em>init.ps1</em> file that is not placed directly under the <em>tools</em> directory.</li>\n  <li><strong>InvalidFrameworkFolderRule</strong>: detect whether there is an unrecognized framework folder name.</li>\n  <li><strong>MisplacedAssemblyRule</strong>: detect whether any assembly files are placed outside of the <em>lib</em> folder.</li>\n  <li><strong>MisplacedScriptFileRule</strong>: detect whether any Powershell .ps1 files are placed outside of the <em>tools</em> folder.</li>\n  <li><strong>MisplacedTransformFileRule</strong>: detect whether a transform file (<em>.pp</em> or <em>.transform</em>) is placed outside of the <em>content</em> folder.</li>\n  <li><strong>MissingSummaryRule</strong>: detect whether the Summary attribute is missing when the Description attribute is longer than 300 characters.</li>\n  <li><strong>WinRTNameIsObsoleteRule</strong>: detect the presence of a ‘WinRT’ framework folder. (Starting with NuGet 2.1, the ‘WinRT’ moniker is obsolete and we recommend people use ‘NetCore45’ or ‘Windows8’ instead.)</li>\n</ul>\n\n<p>What is not very well-known is that the rule set is extensible, meaning that you can write your own custom rules to cater to your needs. For example, the Microsoft ASP.NET team has written a rule to ensure that all packages that we ship have an Id that start with <code class=\"highlighter-rouge\">Microsoft.AspNet.*</code>. In this post, I will show you how easy it is to write a custom package analysis rule.</p>\n\n<h3 id=\"develop-rule-assembly\">Develop rule assembly</h3>\n\n<ol>\n  <li>\n    <p>First, create a class library project that targets .NET 4.0. You can add multiple rules in one assembly.</p>\n  </li>\n  <li>\n    <p>Add an assembly reference to <strong>nuget.exe</strong>. You need it for the package rule types. In the Properties window, set both <em>Copy Local</em> and <em>Specific Version</em> to <strong>False</strong>, because we don’t want to deploy <strong>nuget.exe</strong> together with our extension assembly.</p>\n  </li>\n  <li>\n    <p>Add another assembly reference to <strong>System.ComponentModel.Composition</strong>. You need this because the analysis mechanism is based on <strong><a href=\"http://mef.codeplex.com/\" title=\"MEF\">MEF</a></strong>.</p>\n  </li>\n  <li>\n    <p>Now add a class to your project for each rule you want to create. A rule class must derive from the <code>NuGet.IPackageRule</code> interface, and must export it using the MEF <code class=\"highlighter-rouge\">Export</code> attribute.</p>\n  </li>\n</ol>\n\n<pre>\n<code>\n[Export(typeof(IPackageRule))]\npublic class PackageIdRule : IPackageRule\n{\n\n}\n</code>\n</pre>\n\n<p>Here’s the definition of the <code>IPackageRule</code> interface:</p>\n\n<pre>\n<code>\npublic interface IPackageRule\n{\n    IEnumerable&lt;PackageIssue&gt; Validate(IPackage package);\n}\n</code>\n</pre>\n\n<p>As you can see, it has only one simple <code>Validate</code> method, which receives an instance of the package that has just been built. The method will examine the package and return all the issues that it finds. An issue is represented by an instance of the <code>PackageIssue</code> class.</p>\n\n<pre>\n<code>\npublic class PackageIssue\n{\n    public PackageIssue(string title, string description, string solution);\n    public PackageIssue(string title, string description, string solution, PackageIssueLevel level);\n\n    public string Description { get; }\n    public PackageIssueLevel Level { get; }\n    public string Solution { get; }\n    public string Title { get; }\n}\n</code>\n</pre>\n\n<p>Each issue has a Title, a Description, a Level, which can be either Warning or Error, and a proposed Solution. Note: currently, <strong>nuget.exe</strong> ignores the Level property and reports all issues as Warning.</p>\n\n<p>Here’s the <code>Validate</code> method that we wrote for the previously mentioned rule to enforce all package Ids start with <code class=\"highlighter-rouge\">Microsoft.AspNet.*</code>.</p>\n\n<pre>\n<code>\npublic IEnumerable&lt;PackageIssue&gt; Validate(IPackage package)\n{\n    if (!package.Id.StartsWith(\"Microsoft.AspNet.\", StringComparison.Ordinal))\n    {\n        yield return new PackageIssue(\n            title: \"Package Id is not valid\",\n            description: \"The Id of this package doesn't start with 'Microsoft.AspNet.*'\",\n            solution: \"Rename the Id attribute so that it starts with 'Microsoft.AspNet.*'\");\n    }\n}\n</code>\n</pre>\n\n<h3 id=\"deploy-rule-assembly\">Deploy rule assembly</h3>\n\n<p>After you’ve successfully compiled the project, you need to put the assembly into the right place. <strong>nuget.exe</strong> looks for extension assemblies in three places:</p>\n\n<ul>\n  <li>The <strong>%localappdata%\\nuget\\commands</strong> directory.</li>\n  <li>The current directory from which <strong>nuget.exe</strong> runs. Important: In this case, your assembly’s name must end with <strong>Extensions.dll</strong>, or else <strong>nuget.exe</strong> will ignore it.</li>\n  <li>A list of directories as specified by the <strong>NUGET_EXTENSIONS_PATH</strong> environment variable, separated by commas.</li>\n</ul>\n\n<h3 id=\"summary\">Summary</h3>\n\n<p>When <strong>nuget.exe</strong> builds a package, it runs a set of analysis rules to spot potential issues with the package. You can write your own custom rules to enforce additional requirements in your organization. A rule is simply a class that drives from the <code>IPackageRule</code> interface and is exported via MEF.</p>\n","Href":"http://blog.nuget.org/20121023/creating-custom-package-rules-for-your-build.html","RawContent":null},{"Title":"Invoking NuGet Services from inside Visual Studio","PublishedOn":"2012-09-26T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>One of the best kept secrets of the NuGet extension is that besides the UI that everyone has become familiar with, it also exports some useful services, via <a href=\"http://msdn.microsoft.com/en-us/library/dd460648.aspx\" title=\"MEF\">MEF</a>, which allow other components in VS to interact with NuGet. These include installing packages, uninstalling packages and querying for installed packages.</p>\n\n<p>Over the past year, the NuGet team has received many inquiries from various teams inside and outside Microsoft asking us how to perform such tasks from their components. We have solidified the guidance over time and wanted to share it broadly.</p>\n\n<p>As of the current version (2.0), NuGet exports six interfaces/services via MEF, all of which reside in the <strong>NuGet.VisualStudio</strong> namespace in the <strong>NuGet.VisualStudio.dll</strong> assembly:</p>\n\n<ul>\n  <li>\n    <p><strong>IVsPackageInstaller</strong> - \nContains methods to install NuGet packages into projects.</p>\n  </li>\n  <li>\n    <p><strong>IVsPackageInstallerEvents</strong> - Offers events which raise when packages are installed and uninstalled in the current solution.</p>\n  </li>\n  <li>\n    <p><strong>IVsPackageInstallerServices</strong> - Contains a method to retrieve installed packages in the current solution, as well as methods to check if a specified package Id is installed in a project.</p>\n  </li>\n  <li>\n    <p><strong>IVsPackageUninstaller</strong> - Contains methods to uninstall NuGet packages from projects.</p>\n  </li>\n  <li>\n    <p><strong>IConsoleInitializer</strong> - Trigger eager initialization of the NuGet Package Manager Console.</p>\n  </li>\n  <li>\n    <p><strong>IVsTemplateWizard</strong> - This interface is designed for project/item templates to include pre-installed packages, and is <em>not</em> meant to be invoked from code.</p>\n  </li>\n</ul>\n\n<p>Here I will not discuss the detailed APIs in each of the interfaces. You can easily explore those for yourself in the Object Browser window.</p>\n\n<p>Instead I will show you a step-by-step guide on how to reference the interfaces and use them in your code.</p>\n\n<ol>\n  <li>\n    <h4 id=\"first-install-the-nugetvisualstudio-nuget-package-into-your-project\">First, install the <strong>NuGet.VisualStudio</strong> nuget package into your project</h4>\n    <p>The <strong><a href=\"https://nuget.org/packages/NuGet.VisualStudio\" title=\"NuGet.VisualStudio package\">NuGet.VisualStudio</a></strong> package contains the NuGet.VisualStudio.dll assembly which includes all the above interfaces.<br /><br />\nWhen installed, the package will automatically set the <strong>Embed Interop Types</strong> property of the assembly reference to <strong>True</strong>. The reason it does so is to make your code  resilient against version changes when users update to newer versions of NuGet.<br /><br />\nFor the same reason, you must NOT use any other types besides the above interfaces in your code. You must NOT reference any other NuGet assemblies either, including <strong>NuGet.Core.dll</strong>.<br /><br />\n<img src=\"/images/embedinteroptypes.png\" alt=\"Embed Interop Types set to True\" /><br /><br /></p>\n  </li>\n  <li>####Obtain the services####\nWith the package installed, you are ready to obtain those services from your code. Because they are exported as MEF contracts, you can import them either via MEF’s Import attribute, or through the <a href=\"http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.componentmodelhost.icomponentmodel.aspx\" title=\"IComponentModel interface\">IComponentModel service</a> in code. Here’s a sample code snippet:<br /><br />\n<code class=\"highlighter-rouge\">var componentModel = (IComponentModel)GetService(typeof(SComponentModel));</code><br />\n<code class=\"highlighter-rouge\">IVsPackageInstallerServices installerServices = componentModel.GetService&lt;IVsPackageInstallerServices&gt;();</code><br />\n<code class=\"highlighter-rouge\">var installedPackages = installerServices.GetInstalledPackages();</code></li>\n</ol>\n\n<p>So there you have it. If you find yourself needing to do something that the above services do not provide, feel free to open a discussion on the <a href=\"http://nuget.codeplex.com/discussions/topics/5362/general\" title=\"NuGet Discussions Board\">NuGet discussions board</a>.</p>\n","Href":"http://blog.nuget.org/20120926/invoking-nuget-services-from-inside-visual-studio.html","RawContent":null},{"Title":"Recent Changes to Package Restore Consent","PublishedOn":"2012-09-07T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>When we released NuGet 2.0, one of the changes included the addition of a <a href=\"http://blog.nuget.org/20120518/package-restore-and-consent.html\">privacy-related constraint</a> to the package restore feature.  More specifically, NuGet 2.0 required that you provide explicit consent, via either a checkbox in the package manager configuration dialog or an environment variable, before it would successfully download required packages as a part of the package restore workflow.</p>\n\n<p>The constraint was added specifically with build scenarios in mind.  However, the implementation extended to other scenarios and as a result, added some unhappiness to the overall NuGet experience.  Therefore, we’ve revisited the implementation and limited its impact to only the scenario that it was designed to address and none other.</p>\n\n<p>The following changes have been made to the package restore workflow.</p>\n\n<ul>\n  <li>Added a ‘-RequireConsent’ command line flag to nuget.exe that, when present, causes NuGet to check for consent (this is the default behavior in NuGet 2.0)</li>\n  <li>Modified the NuGet targets file which is created by enabling package restore such that it passes the flag to nuget.exe when restoring packages during build</li>\n</ul>\n\n<p>The impact of this change is twofold.</p>\n\n<ul>\n  <li>The default package restore workflow will continue to check for consent as it does today</li>\n  <li>Calling nuget.exe will no longer check for consent unless you explicitly pass the flag to the executable</li>\n</ul>\n\n<p>The hope here is that while we need to continue checking for consent in the build scenario (since downloading is not a known or obvious build step), this change will eliminate any additional frustrations related to requiring consent when simply using nuget.exe by itself.</p>\n\n<p>Additionally, because of the <a href=\"http://docs.nuget.org/docs/workflows/using-nuget-without-committing-packages#Details\">mechanics behind package restore</a>, you won’t have to wait until the next NuGet release to take advantage of these changes.  They are already available today as a part of the <a href=\"http://nuget.codeplex.com/releases/view/58939\">nuget.exe CodePlex download</a> and the <a href=\"http://nuget.org/packages/nuget.bootstrapper\">NuGet.Bootstrapper package</a>.  The act of enabling package restore for a solution will cause the latest version of nuget.exe to be downloaded automatically, so no further action is needed in this scenario.  If you have an existing solution where package restore is already enabled, you can update it by doing the following:</p>\n\n<ul>\n  <li>Remove the .nuget folder from the solution in Visual Studio</li>\n  <li>Delete the .nuget folder from disk (keep Visual Studio open)</li>\n  <li>Right-click on the solution in the Visual Studio solution explorer and re-enable NuGet package restore</li>\n</ul>\n\n<p>The process of enabling package restore will then run again, which will in turn download the latest version of nuget.exe and nuget.targets.  Also, if you happened to close Visual Studio before deleting the .nuget folder from disk, you may notice that your projects fail to load when re-opening the solution.  In this case, simply right-click on the solution and re-enable NuGet package explorer, then right-click on each of the failed projects and reload them.</p>\n","Href":"http://blog.nuget.org/20120907/recent-changes-to-package-restore-consent.html","RawContent":null},{"Title":"Feed Performance Update","PublishedOn":"2012-08-24T09:30:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>As you might know, NuGet has been having some performance (and timeout) related issues recently.  Earlier this week, we <a href=\"http://blog.nuget.org/20120822/nuget-expected-downtime-completed.html\">completed a deployment</a> that helped, but it didn’t address everything.</p>\n\n<p>Many users are still seeing slow responses or even timeouts when trying to use the ‘Manage NuGet Packages’ dialog in Visual Studio.</p>\n\n<h2 id=\"ongoing-investigation\">Ongoing Investigation</h2>\n<p>The deployment earlier this week greatly improved the <a href=\"http://nuget.org/packages\">packages page</a> on the gallery, but it didn’t address the Visual Studio dialog performance as much as we had hoped.  Since that deployment, we’ve been focusing on the queries behind the Visual Studio dialog.</p>\n\n<p>We have found that the SQL queries that get executed from the ‘Manage NuGet Package’ dialog are not great.  While the execution plans look okay, the memory grants for the queries are HUGE–MUCH bigger than they need to be.  Because of the huge memory grants, the queries are stacking up behind each other waiting for memory to be granted.  This is leading to poor performance and also timeouts.</p>\n\n<p>We are working to get a different approach for these queries in place.  We will let you know when a fix is ready.  If you’re curious about what the queries look like, you can see the current and tentative rewritten queries <a href=\"https://gist.github.com/3442185\">here</a>.  The rewritten queries are using about 1/100th of the memory of the current queries.</p>\n\n<p>To stay in touch with us, follow <a href=\"http://twitter.com/nuget\">@nuget</a>, or the <a href=\"https://twitter.com/#!/search/%23nuget\">#nuget tag</a> on twitter for live updates.  You can also check in on JabbR’s <a href=\"http://jabbr.net/#/rooms/nuget\">#nuget room</a>.</p>\n","Href":"http://blog.nuget.org/20120824/nuget-feed-performance-update.html","RawContent":null},{"Title":"Upgrade Successful","PublishedOn":"2012-08-22T23:30:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Earlier this evening, <a href=\"http://blog.nuget.org/20120822/nuget-expected-downtime.html\">we announced</a> that the <a href=\"http://nuget.org\">NuGet Gallery</a> would be offline for about an hour during a scheduled upgrade.  That upgrade is now complete.</p>\n\n<p>We expect this deployment to help address <a href=\"http://blog.nuget.org/20120822/nuget-performance-issues.html\">performance issues</a> we’ve been experiencing for the past week.  We will continue to monitor the service and measure the results of this deployment.</p>\n\n<h2 id=\"cdn-re-enabled\">CDN Re-Enabled</h2>\n\n<p>As a bonus, this deployment has re-enabled <a href=\"http://msdn.microsoft.com/en-us/library/windowsazure/ee795176.aspx\">Windows Azure CDN</a> for NuGet packages.  We had initially enabled the CDN last week but some users around the globe <a href=\"http://nuget.codeplex.com/workitem/2503\">reported</a> the DNS name of the CDN host could not be resolved.  After a week, we trust that the DNS name has propagated and we can now all benefit from faster package downloads.</p>\n\n<p>Thank you once again for your patience.  If you encounter any issues with NuGet, feel free to report issues on <a href=\"http://nuget.codeplex.com/WorkItem/Create\">CodePlex</a>.</p>\n\n<p>To stay in touch with us, follow <a href=\"http://twitter.com/nuget\">@nuget</a>, or the <a href=\"https://twitter.com/#!/search/%23nuget\">#nuget tag</a> on twitter for live updates.  You can also check in on JabbR’s <a href=\"http://jabbr.net/#/rooms/nuget\">#nuget room</a>.</p>\n","Href":"http://blog.nuget.org/20120822/nuget-expected-downtime-completed.html","RawContent":null},{"Title":"Expected Downtime - August 22 11pm-12am PDT","PublishedOn":"2012-08-22T18:30:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>As mentioned in the <a href=\"http://blog.nuget.org/20120822/nuget-performance-issues.html\">previous post</a>, we’ve been working to address some performance problems on the <a href=\"http://nuget.org\">NuGet Gallery</a>.</p>\n\n<p>The fixes we have in place include some time-consuming database migrations.  During our dry run deployments, we found that virtually all requests to the database will time out while these migrations are running.  We have decided to take the precaution of shutting the gallery down during these migrations to ensure the best and fastest possible deployment.  We are sorry for the inconvenience this will cause.</p>\n\n<h2 id=\"timing\">Timing</h2>\n\n<p>The <a href=\"http://nuget.org\">nuget.org</a> website is expected to be down from 11pm-12am PDT tonight.  During this time, all requests to browse, search, install, or update packages will fail.  You will see errors in Visual Studio when you use the Online tab in the Manage NuGet Packages dialog.</p>\n\n<h2 id=\"live-updates\">Live Updates</h2>\n\n<p>Please follow <a href=\"http://twitter.com/nuget\">@nuget</a>, or the <a href=\"https://twitter.com/#!/search/%23nuget\">#nuget tag</a> on twitter for live updates.  You can also check in on JabbR’s <a href=\"http://jabbr.net/#/rooms/nuget\">#nuget room</a>.</p>\n\n<p>This blog will be updated once the deployment is completed.</p>\n\n<h2 id=\"workarounds\">Workarounds</h2>\n\n<p>Many users have found Scott Hanselman’s tips on <a href=\"http://www.hanselman.com/blog/HowToAccessNuGetWhenNuGetorgIsDownOrYoureOnAPlane.aspx\">How to access NuGet when NuGet.org is down (or you’re on a plane)</a> to be helpful.</p>\n\n<h2 id=\"deployment-process\">Deployment Process</h2>\n\n<p>During this downtime, we will be doing the following:</p>\n\n<ol>\n  <li>Creating a pre-migration database backup</li>\n  <li>Executing the database migrations against the database</li>\n  <li>Performing a post-migration database backup</li>\n  <li>Deploying changes to the gallery web application</li>\n  <li>Verifying the successful deployment within a Staging instance of our Web Role</li>\n</ol>\n\n<p>Once we have verified the successful staging deployment, we will swap the instances over to production.  At that time service will resume.</p>\n\n<p>If you’re curious about what is getting deployed, feel free to check out the <a href=\"https://github.com/NuGet/NuGetGallery/commits/master\">commit history on the master branch</a> in our GitHub repository at <a href=\"https://github.com/NuGet/NuGetGallery\">https://github.com/NuGet/NuGetGallery</a>.  The changes being deployed are from August 21st and 22nd.</p>\n\n<h2 id=\"feature-request\">Feature Request</h2>\n\n<p>Out of this situation comes a new feature request for the gallery: read-only mode.  Ideally, deployments of this type could be handled by putting the gallery into a read-only mode and performing the deployment to a new web role with a copy of the database while the read-only gallery stays online.  We will invest in setting up that model to be used in the future.</p>\n","Href":"http://blog.nuget.org/20120822/nuget-expected-downtime.html","RawContent":null},{"Title":"NuGet Gallery Performance Issues","PublishedOn":"2012-08-22T15:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Since August 16th, and especially since August 21st, the <a href=\"http://nuget.org\">NuGet Gallery</a> has been exhbiting intermittent performance issues.  Some users are reporting errors when attempting to browse or search for NuGet packages from Visual Studio or other clients.  Many users are reporting that browsing and searching are slow.  There have also been timeout errors when browsing <a href=\"http://nuget.org/packages\">the gallery’s packages page</a>.</p>\n\n<p>During this time, we have been communicating with many of you on twitter, under the <a href=\"https://twitter.com/#!/search/%23nuget\">#nuget tag</a>, as well as in JabbR’s <a href=\"http://jabbr.net/#/rooms/nuget\">#nuget room</a>.  We truly appreciate your patience and understanding with us.</p>\n\n<h2 id=\"status\">Status</h2>\n\n<p>We have been working to address these performance issues over the last several days, and we hope to have a deployment in place this evening (August 22nd, Pacific Time).  It looks like the deployment will cause a short outage though–we will post more information about that when the details are available.</p>\n\n<h2 id=\"root-cause\">Root Cause</h2>\n\n<p>The root cause of the performance issues boils down to some sub-optimal queries that are used when searching the gallery–especially when searching from Visual Studio.  There are a couple reasons these queries are slow:</p>\n\n<ol>\n  <li>Some missing indexes that could significantly aide the search queries.</li>\n  <li>Table columns that have <code class=\"highlighter-rouge\">nvarchar(max)</code> as their data type when a size constraint can be applied.  We are seeing that when these <code class=\"highlighter-rouge\">nvarchar(max)</code> columns are used in <code class=\"highlighter-rouge\">ORDER BY</code> clauses, it becomes a bottleneck.</li>\n</ol>\n\n<p>The deployment we’re preparing will address both of these issues by adding size constraints to many fields and then creating several new indexes.  Unfortunately, the process of altering the Packages and PackageRegistrations tables and then creating these new indexes is going to take some time to apply – during that time, the database will be rather unresponsive.  Again, when we know more about the timing of the outage, we’ll share the details.</p>\n\n","Href":"http://blog.nuget.org/20120822/nuget-performance-issues.html","RawContent":null},{"Title":"Results of NuGet CDN Experiment","PublishedOn":"2012-08-10T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>A little over a week ago, <a href=\"http://blog.nuget.org/20120802/help-us-test-nuget-cdn.html\">we asked for your help with an experimentt</a> that we were conducting to see whether there was value in enabling CDN support for our packages blob storage container.  Over 100 of you responded from all over the world, and the data that you provided made it pretty clear that there was sufficient justification for turning on CDN support for the production NuGet blob storage container.  So firstly, thank you to everyone who participated in the experiment!</p>\n\n<p>In addition to turning on CDN, we wanted to share the results of the data that you provided us.  First, the worldwide numbers look like the following:</p>\n\n<table>\n<tr>\n<td>&nbsp;</td>\n<td>No-CDN</td>\n<td>CDN</td>\n</tr>\n<tr>\n<td>Mean</td>\n<td>33.8252</td>\n<td>22.88007</td>\n</tr>\n<tr>\n<td>Variance</td>\n<td>601.3293</td>\n<td>440.8645</td>\n</tr>\n<tr>\n<td>Observations</td>\n<td>108</td>\n<td>108</td>\n</tr>\n<tr>\n<td>Pearson Correlation</td>\n<td>0.704394</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>Hypothesized Mean Difference</td>\n<td>6.8</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>df</td>\n<td>107</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>t Stat</td>\n<td>2.420113</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>P(T&lt;=t) one-tail</td>\n<td>0.0086</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>t Critical one-tail</td>\n<td>1.659219</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>P(T&lt;=t) two-tail</td>\n<td>0.0172</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>t Critical two-tail</td>\n<td>1.982383</td>\n<td>&nbsp;</td>\n</tr>\n</table>\n\n<p>As you can see, there are some additional tests that we included so that you statisticians out there can get a deeper sense of our methodology, but at a high level, you can see that the worldwide average time to download the top 25 NuGet packages <em>improved by over 10 seconds!</em></p>\n\n<p>The improvements are even more pronounced depending on the specific region being considered.  In the chart below, each vertical bar represents the range of values for the percentage of improvement and the horizontal line dividing each bar represents the average improvement.  As you can see, the greatest improvements were seen in Australia with an average improvement of over 40%.  Additionally, notable improvements can also be seen in each of the other regions from which we collected data.</p>\n\n<p><img src=\"/images/cdn-improvement.png\" alt=\"CDN improvements by region\" /></p>\n\n<p>You can anecdotally draw further conclusions to explain the latency numbers by looking at the landscape of Azure CDN nodes as it exists today.</p>\n\n<p><img src=\"http://www.microsoft.com/global/windowsazure/PublishingImages/cdn/950.gif\" alt=\"Azure CDN \" /></p>\n\n<p>All in all, the experiment was a great success, and we will be activating CDN in production very soon.  We couldn’t have collected this level of data without your help, so again, many thanks!</p>\n","Href":"http://blog.nuget.org/20120810/results-of-nuget-cdn-experiment.html","RawContent":null},{"Title":"Help Us Test CDN for NuGet.org","PublishedOn":"2012-08-02T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>Over the past few weeks, we’ve been investigating whether to turn on the <a href=\"http://www.windowsazure.com/en-us/home/features/caching/\">content delivery network (CDN)</a> feature of the Azure blob storage container for NuGet packages.  In theory, this would make package downloads faster – especially if you’re located outside of the United States.</p>\n\n<p>We want your help to conduct an experiment to measure the difference in downloading packages with CDN enabled verses disabled.  Our initial experiment deployed nuget.exe into different regions and measured the time to download a set of NuGet packages.  Unfortunately, in all of the regions we deployed to, we were still sitting on  an Internet backbone connection, so even our baseline measurements (with CDN disabled) showed a statistically insignificant difference between a deployment in northern Europe and a deployment in the USA.  As such, it would seem that enabling CDN wouldn’t yield any measurable benefit.</p>\n\n<p>We think that the reason for the inconclusive baseline is due to the fact that there’s no <a href=\"http://en.wikipedia.org/wiki/Last_mile\">“last mile”</a> involved in the measurements, and this is where the majority of the slowdown happens.  While we could try and simulate last mile time, we would rather change the experiment a bit and ask for your help.</p>\n\n<p>We’ve created a custom of NuGet.exe along with a batch file runner that you can download <a href=\"/images/NuGet-CDN.zip\">here</a>.  Just unpack the zip file and run NuGet-CDN.bat. This will download the top 25 NuGet packages from both the standard package URL and a CDN URL and then log the time it takes to perform the download operations.  You will then be asked to optionally provide your location, which will help us get a better sense of the global impact of using the CDN.</p>\n\n<p><img src=\"/images/use-cdn-test.png\" alt=\"Running the NuGet CDN batch file\" /></p>\n\n<p>The batch process will wrap the log files along with your location information into a new NuGet package.  Please email that package to <a href=\"mailto:nugetgallery@outercurve.org\">nugetgallery@outercurve.org</a>.</p>\n\n<p>Thanks in advance for your help!</p>\n","Href":"http://blog.nuget.org/20120802/help-us-test-nuget-cdn.html","RawContent":null},{"Title":"NuGet 2.0 Released","PublishedOn":"2012-06-19T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We’re happy to announce that we released NuGet 2.0 on 6/19/2012. This release includes support for grouping dependencies, tools and content by the target framework of the project. Additionally, we’ve dramatically improved the performance of tab completion in the package management console.</p>\n\n<h2 id=\"package-restore-consent-is-now-active\">Package restore consent is now active</h2>\n<p>As described in an <a href=\"http://blog.nuget.org/20120518/package-restore-and-consent.html\">earlier post on package restore consent</a>, NuGet 2.0 will now require that consent be given to enable package restore to go online to download packages. Please ensure that you have provided consent via either the package manager configuration dialog or the EnableNuGetPackageRestore environment variable.</p>\n\n<p>More details on NuGet 2.0 can be found on the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-2.0\">release notes</a>.  Finally, NuGet 2.0 fixed several bugs. For a full list of work items fixed in NuGet 2.0, please view the <a href=\"http://nuget.codeplex.com/workitem/list/advanced?keyword=&amp;status=Closed&amp;type=All&amp;priority=All&amp;release=NuGet%202.0&amp;assignedTo=All&amp;component=All&amp;sortField=Votes&amp;sortDirection=Descending&amp;page=0\">NuGet Issue Tracker</a> for this release.</p>\n","Href":"http://blog.nuget.org/20120619/nuget-2.0-released.html","RawContent":null},{"Title":"NuGet 1.8 Hotfix Released","PublishedOn":"2012-05-29T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>With the <a href=\"/20120525/nuget-1.8-released.html\">NuGet 1.8 release</a>, we found a breaking change that caused NuGet to fail on Windows XP machines.  Earlier today, we released a hotfix to NuGet 1.8 that addresses this.</p>\n\n<p>We apologize for any inconvenience this issue may have caused.  If you have further issues, please report them on <a href=\"http://nuget.codeplex.com/workitem/list/basic\">CodePlex</a>.</p>\n\n<p>For more information, there is a <a href=\"http://nuget.codeplex.com/discussions/356928\">CodePlex discussion thread</a> for this issue, which resulted in a <a href=\"http://nuget.codeplex.com/workitem/2240\">work item</a> to fix the regression.</p>\n\n","Href":"http://blog.nuget.org/20120529/nuget-1.8-hotfix-released.html","RawContent":null},{"Title":"NuGet 1.8 Released","PublishedOn":"2012-05-25T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We’re happy to announce that we released NuGet 1.8 on 5/23/2012. This release includes support for localized satellite assemblies, nuget.exe performance improvements, and 34 bug fixes. Details are in the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-1.8\">NuGet 1.8 Release Notes</a>.</p>\n\n<h2 id=\"known-issue-on-windows-xp\">Known issue on Windows XP</h2>\n<p>We would like to call out that shortly after NuGet 1.8 was released, we learned that a cryptography change in 1.8 broke users on Windows XP. Do not install NuGet 1.8 onto a Windows XP machine; if you have already installed NuGet 1.8, you can uninstall it and reinstall NuGet 1.7 using <a href=\"http://nuget.codeplex.com/downloads/get/382255\">this download link</a>.</p>\n\n<p>We are working on a NuGet 1.8.1 release to address the regression.  There is a <a href=\"http://nuget.codeplex.com/discussions/356928\">CodePlex discussion thread</a> for this issue, which resulted in a <a href=\"http://nuget.codeplex.com/workitem/2240\">work item</a> to fix the regression.</p>\n\n","Href":"http://blog.nuget.org/20120525/nuget-1.8-released.html","RawContent":null},{"Title":"Package Restore and Consent","PublishedOn":"2012-05-18T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>A little while back, our team had the pleasure of talking about NuGet with some privacy experts. These are folks who are passionate about your privacy and laws that protect your privacy.</p>\n\n<p>As we were describing NuGet’s package restore feature, the privacy experts became interested in the details surrounding the package restore workflow – particularly the part where NuGet goes online to the NuGet gallery to fetch missing packages.  Here’s the scenario that raised their interest:</p>\n\n<ol>\n  <li>Developer A creates a project, installs NuGet packages, and enables package restore</li>\n  <li>Developer A checks the project into version control. The NuGet packages aren’t included because of the package restore setting</li>\n  <li>Developer B checks the project out of source control and builds</li>\n  <li>Because package restore is enabled, NuGet goes online to the gallery, downloads and installs the required packages, and continues with the build.</li>\n</ol>\n\n<p>That last point is where the concern was raised.  In this scenario, Developer B has never said to NuGet, “Sure, you can go online on my behalf.”  This can be a big deal because the simple act of making a request over the Internet can reveal information about the user (for example, from the user’s IP address, we can approximate her location).  In some regions and countries, revealing this kind of information <a href=\"http://en.wikipedia.org/wiki/Data_Protection_Directive\">is a big no-no</a>.</p>\n\n<p>Now, none of us are lawyers and certainly not the type that work in international privacy issues. We just want to build a great product that developers can feel confident using, regardless of where they are.  Hence the package restore consent feature.</p>\n\n<h2 id=\"what-did-we-do-exactly\">What did we do exactly?</h2>\n<p>Our goal is that when someone builds a project that uses NuGet package restore, the person overseeing the build provides explicit consent to enable package restore to go online to download NuGet packages.</p>\n\n<p>You’ll note that I was specific about who needs to provide the consent. When we were initially brainstorming solutions, we had talked about simply writing the consent flag into the NuGet config file or into build targets.  However, these options would enable Developer A to effectively consent on behalf of Developer B, because these files are pulled down from version control, and that would defeat the purpose of requiring explicit consent.  Therefore, we’ve provided 2 ways to specify package restore consent. The first approach is to check the box in NuGet’s package manager configuration dialog box as follows:</p>\n\n<p><img src=\"/images/pr-consent-configdlg.png\" alt=\"Package restore consent in the package manager configuration dialog\" /></p>\n\n<p>Checking this box will write the following XML into your NuGet.Config file (in your user profile directory tree)</p>\n\n<pre>\n&lt;packageRestore&gt;\n  &lt;add key=\"enabled\" value=\"true\" /&gt;\n&lt;/packageRestore&gt;\n</pre>\n\n<p>For scenarios where developers are building on their own machines, this will be the way to provide consent for package restore.  However, there are cases where it’s not actually a person who’s doing the building and who therefore can’t provide consent this way. (And where Visual Studio isn’t even installed.) The prototypical example is a build server. In that case, NuGet will also look for an environment variable called EnableNuGetPackageRestore. To enable package restore for scenarios where the Visual Studio option is not practical, set this variable to true.</p>\n\n<h2 id=\"what-if-i-havent-given-consent\">What if I haven’t given consent?</h2>\n<p>If you try to build a project that uses package restore and you haven’t given consent to NuGet to download packages, you will get a build error that looks like the following:</p>\n\n<p><img src=\"/images/pr-consent-builderror.png\" alt=\"Build error when package restore consent is not given\" /></p>\n\n<p>The build error describes the issue and provides instructions for providing consent. As the package restore consent feature rolls out, you will probably see this error, particularly on build servers, so we wanted to give you advance warning in this post.</p>\n\n<h2 id=\"its-coming\">It’s coming</h2>\n<p>In NuGet 1.8, we’ve added all of the logic for supporting the consent requirement. However, we won’t start actively enforcing the constraint (that is, causing build failures) until NuGet 2.0.  This delay gives you time to provide consent for both your developer machines and your build infrastructure, and will help avoid sudden and unexpected build breaks when we release NuGet 2.0.</p>\n","Href":"http://blog.nuget.org/20120518/package-restore-and-consent.html","RawContent":null},{"Title":"NuGet's Sources Are Moving to Git","PublishedOn":"2012-04-19T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>At the end of April, we’ll be moving the NuGet sources hosted on <a href=\"http://codeplex.com\">CodePlex</a> from a Mercurial repository to a Git repository. This won’t impact or affect NuGet users, but NuGet contributors and those that follow NuGet’s development might need to act before this move.</p>\n\n<h2 id=\"forks\">Forks</h2>\n\n<p>All of the <a href=\"http://nuget.codeplex.com/SourceControl/network\">current NuGet forks on CodePlex</a> will be deleted as part of this move. If you have forked NuGet, and you need to keep that fork, you can clone the fork and keep it locally or you can find somewhere else to push it. Aren’t DVCS great?</p>\n\n<h2 id=\"pull-requests\">Pull Requests</h2>\n\n<p>The NuGet team will review all the <a href=\"http://nuget.codeplex.com/sourcecontrol/list/contributions\">currently active pull requests</a> before we move to Git. We will not be accepting any new pull requests until this move is complete. Please wait to initiate new pull requests until that time.</p>\n\n<h2 id=\"commit-history\">Commit History</h2>\n\n<p><a href=\"http://nuget.codeplex.com/SourceControl/list/changesets\">NuGet’s commit history</a> will be preserved. If you’ve contributed to NuGet, your contributions will still be included in the commit history.</p>\n\n<h2 id=\"codeplex-project\">CodePlex Project</h2>\n\n<p>All other areas of the <a href=\"http://nuget.codeplex.com\">NuGet CodePlex project</a> (the URL, issues, discussions, etc.) will remain as they are.</p>\n\n<p><em>If you have questions or concerns, please present them in the comments or <a href=\"http://nuget.codeplex.com/discussions/create?ProjectName=nuget\">start a discussion on CodePlex</a>.</em></p>\n","Href":"http://blog.nuget.org/20120419/nuget-sources-moving-to-git.html","RawContent":null},{"Title":"NuGet 1.7 Released","PublishedOn":"2012-04-04T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>We’re happy to announce that we released NuGet 1.7 today. This release includes several new features as well as over 75 bug fixes. Details are in the <a href=\"http://docs.nuget.org/docs/release-notes/nuget-1.7\">NuGet 1.7 Release Notes</a>.</p>\n","Href":"http://blog.nuget.org/20120404/nuget-1.7-released.html","RawContent":null},{"Title":"The NuGet Gallery Outage on March 9th","PublishedOn":"2012-03-14T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>The <a href=\"http://nuget.org\">NuGet Gallery</a> was unavailable on March 9th from approximately midnight until 7:52 A.M., nearly eight hours. During this time all HTTP requests to the gallery website failed. In addition to affecting website users, the outage affected all NuGet client programs (such as the Visual Studio extension and nuget.exe) and other software that relies on the NuGet Gallery’s feed and API.</p>\n\n<p>To start, we apologize for the disruption and inconvenience that this incident caused.  We know that many of our customers were affected by the outage and we want to be transparent about what happened, what issues we found, how we plan to address these issues, and how we are learning from the incident to prevent a similar occurrence in the future.</p>\n\n<p>The outage was caused by a NuGet Gallery application error, compounded by some shortcomings in our monitoring system and incident-response process for the NuGet gallery.</p>\n\n<h2 id=\"what-happened-exactly\">What Happened Exactly</h2>\n\n<p>Windows Azure rebooted the NuGet Gallery servers at midnight after performing a scheduled OS upgrade. After this reboot, the gallery’s web roles failed to initialize due to a previously unknown bug in a script we wrote that we execute in order to enable HTTP compression for the gallery’s feed. Because the web roles could not initialize, the website became unresponsive. \nOur monitoring service didn’t send any alerts about this situation. However, the team became aware of the problem around 7:30 A.M. and we were able to restore service by deleting the Azure deployment and creating a new one (bypassing the scripts’s bug, although we didn’t know about the bug yet).</p>\n\n<h2 id=\"how-we-failed\">How We Failed</h2>\n\n<p>As with most system failures of this severity, there was more than just one failure.</p>\n\n<h3 id=\"deployment-testing\">Deployment Testing</h3>\n\n<p>We continually and automatically test the process of deploying new versions of the gallery to Windows Azure by using a preview site. However, we missed testing reboot scenarios, and this masked a bug in our compression script.</p>\n\n<h3 id=\"monitoring-service\">Monitoring Service</h3>\n\n<p>As a result of this outage, we learned that our monitoring service had configuration issues that we did not know about. We understand that it’s crucially important to continually test all of the systems that keep our website running, including things like monitoring, backup, and restore. We test our backup and restore continually using our preview site, but as we’ve learned, we were not testing monitoring sufficiently.</p>\n\n<h3 id=\"inadequate-incident-response-process\">Inadequate Incident-Response Process</h3>\n\n<p>When the outage occurred, we didn’t have a robust enough incident-response process, with the result that the response time for this outage that was simply not fast enough. There has been no dedicated operations team for the NuGet Gallery, and the development team has been assuming all responsibility for operational activities.</p>\n\n<h3 id=\"bad-assumptions\">Bad Assumptions</h3>\n\n<p>One of the reasons we had not formalized our incident response process or had people on call was that the NuGet gallery has been very reliable. (As we’ve now been reminded, this is no excuse for lack of proper planning.)</p>\n\n<p>We have since also learned that two assumptions about how Windows Azure deployments work contributed to this issue.  First, we assumed that we would be notified that an OS upgrade requiring a reboot had been scheduled. We’ve learned that Windows Azure does not currently send notifications for scheduled OS upgrades, whether a reboot is required or not. We’ve recommended to the Azure team that they start sending notifications in these cases.</p>\n\n<p>Second, we assumed that OS upgrades (or other maintenance) would be performed on one instance at a time within a deployment, and that if an upgrade failed, Azure would not then try to upgrade the remaining instances, effectively causing the entire deployment to fail. This one-at-a-time approach is how Azure handles customer-initiated upgrades. We’ve recommended to the Azure team that they consider changing the Azure-initiated upgrade process accordingly, although we understand there are a lot challenges in doing this.</p>\n\n<h2 id=\"what-were-changing\">What We’re Changing</h2>\n\n<p>All applications can fail, which is why it’s crucial to have a proven, tested system in place to monitor the health of an application, and a proven, tested process in place to respond to incidents. To that end, we will:</p>\n\n<ul>\n  <li>Regularly test our monitoring service (for example, by periodically making the preview site unavailable).</li>\n  <li>Create a better incident-response process.</li>\n  <li>Expand the team of people who understand Azure deployment and know how to troubleshoot failures.</li>\n  <li>Always have at least one person on call to respond to incidents.</li>\n</ul>\n\n<p>We will also regularly test server reboots after a deployment, using our preview site.</p>\n\n<p>While we can’t guarantee that future incidents won’t happen (in fact, we know they will), we <em>can</em> guarantee that our response to any future incidents will be much more timely.</p>\n","Href":"http://blog.nuget.org/20120314/the-nuget-gallery-outage-on-march-9.html","RawContent":null},{"Title":"Introducing the NuGet Team Blog","PublishedOn":"2012-03-13T00:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"<p>For the last few months, the NuGet team has been considering starting a proper, official blog. <strong>This is that blog</strong>.</p>\n\n<p>How do we plan to use this blog? Here are a few ways we know we’ll use it (and I’m sure we’ll think of others as we go along):</p>\n\n<ul>\n  <li>Announcing new releases</li>\n  <li>Announcing upcoming breaking or very impactful changes</li>\n  <li>Pointing out particuarly important discussions on our CodePlex or GitHub sites</li>\n</ul>\n\n<p>Feel free to leave us a comment, letting us know what else you’d like to see here.</p>\n","Href":"http://blog.nuget.org/20120313/introducing-the-nuget-team-blog.html","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"6807590048","Type":"IssuesEvent","CreatedAt":"2017-11-03T20:32:43","Actor":"shishirx34","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4950","RelatedDescription":"Opened issue \"Deployment 2017-11-09\" (#4950) at NuGet/NuGetGallery","RelatedBody":"# Deployment 2017-11-09\r\n\r\n**Status**: Planned\r\n\r\n**Planned production date**: 2017-11-09\r\n\r\n**Focus**: \r\n\r\n**Hotfixes**:\r\n\r\n**Services to Deploy**:\r\n- [ ] Gallery (**including updated migrations and shims!**)\r\n  - Merge Shims from (DEV to MASTER) for prefix auditing changes\r\n\r\nRepo | Service | INT | PROD (primary) | PROD (secondary)\r\n--- | --- | --- | --- | ---\r\nNuGetGallery | Gallery | <ul><li>[ ] </li></ul> | <ul><li>[ ] </li></ul> | <ul><li>[ ] </li></ul>\r\n\r\n**Related blog posts/docs**:\r\n- N/A\r\n\r\n**Deployed commit**:  TBA\r\n\r\n**Gallery**\r\n*Functional:*\r\n-\r\n\r\n*Technical:*\r\n- Prefix auditing and telemetry: https://github.com/NuGet/NuGetGallery/issues/4549 (PR: https://github.com/NuGet/NuGetGallery/pull/4940)\r\n"},{"Id":"6807486692","Type":"PullRequestEvent","CreatedAt":"2017-11-03T20:06:29","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/4945","RelatedDescription":"Merged pull request \"Organization scope evaluation\" (#4945) at NuGet/NuGetGallery","RelatedBody":"Changes include:\r\n- ApiKeyAuthHandler updated to verify authenticated user matches the owner scope\r\n- ScopeEvaluator split into scope extensions which can evaluate individual scope parts\r\n- ApiController.CreatePackageVerificationKey creates temp key using same owner scope as original key\r\n- ApiController no longer calls PackagePermissionService, which was redundant with scope evaluation\r\n- ExtensionMethods refactoring, extracting APIs as I created more specific extensions classes"},{"Id":"6807447914","Type":"IssuesEvent","CreatedAt":"2017-11-03T19:56:31","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4949","RelatedDescription":"Opened issue \"Catalog resource is unavailable in China\" (#4949) at NuGet/NuGetGallery","RelatedBody":"Today, the catalog HTTP API is available globally under the following URL:\r\nhttps://api.nuget.org/v3/catalog0/index.json\r\n\r\nThis URL can be looked up in the global V3 service index using the `Catalog/3.0.0` `@type` value:\r\nhttps://api.nuget.org/v3/index.json\r\n\r\nUnfortunately, this is not available in China. The following response is returned when hitting the catalog index:\r\n```xml\r\n<Error>\r\n  <Code>ResourceNotFound</Code>\r\n  <Message>\r\n    The specified resource does not exist. RequestId:8e18a7af-001e-001b-1edd-54f8b9000000 Time:2017-11-03T19:53:38.6607730Z\r\n  </Message>\r\n</Error>\r\n```\r\n\r\nWe should make this resource available in China, now that is it [documented publicly](https://docs.microsoft.com/en-us/nuget/api/catalog-resource).\r\n\r\nThis URL works just fine anywhere else in the world. Note some hacky workarounds exist, but it's not an ideal scenario.\r\n\r\nAlso, if you are in China and need access to the catalog, please upvote this issue and contact support@nuget.org."},{"Id":"6806955310","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:58:07","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4946","RelatedDescription":"Closed issue \"Documentation: Angle brackets are encoded in inline code blocks\" (#4946) at NuGet/NuGetGallery","RelatedBody":"Related: #4783 \r\n\r\nStill doesn't work in inlined code segments with ` (i.e. `Hamster<T>` => Hamster&lt;T&gt;)\r\nFor example: https://www.nuget.org/packages/AsyncUtilities/0.5.0#"},{"Id":"6806923375","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:51:10","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4948","RelatedDescription":"Opened issue \"Documentation: Show more displayed even if no more lines\" (#4948) at NuGet/NuGetGallery","RelatedBody":"Can we determine if 'show more' is unnecessary?"},{"Id":"6806919485","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:50:18","Actor":"anangaur","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4947","RelatedDescription":"Opened issue \"Fix <, > etc. for inline code markdown \" (#4947) at NuGet/NuGetGallery","RelatedBody":"For details:\r\nhttps://github.com/NuGet/NuGetGallery/issues/4783#issuecomment-341778347\r\n>![image](https://user-images.githubusercontent.com/230581/32388262-88634528-c09d-11e7-94a2-725fea14f375.png)"},{"Id":"6806917191","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:49:47","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4946","RelatedDescription":"Opened issue \"Documentation: Angle brackets are encoded in inline code blocks\" (#4946) at NuGet/NuGetGallery","RelatedBody":"Related: #4783 \r\n\r\nStill doesn't work in inlined code segments with ` (i.e. `Hamster<T>` => Hamster&lt;T&gt;)\r\nFor example: https://www.nuget.org/packages/AsyncUtilities/0.5.0#"},{"Id":"6806859333","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:37:11","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4812","RelatedDescription":"Closed issue \"Clicking on \"Show more\" for Documentation has incorrect chevron\" (#4812) at NuGet/NuGetGallery","RelatedBody":"Feature discussion issue: https://github.com/NuGet/NuGetGallery/issues/2280\r\n\r\nInstead of ChevronDown it's ChevronRight\r\n\r\n![image](https://user-images.githubusercontent.com/14800916/31326318-d700a19e-ac7a-11e7-8d41-fe978f35e016.png)\r\n\r\n\r\n"},{"Id":"6806857292","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:36:42","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4783","RelatedDescription":"Closed issue \"< and > from imported markdown files display as &lt; and &gt;\" (#4783) at NuGet/NuGetGallery","RelatedBody":"The gallery does not display angle brackets in code blocks correctly in the package's documentation section comes from importing a markdown README file.\r\n\r\n# Repro\r\n1. Edit a package. E.g. https://www.nuget.org/packages/Yarn.MSBuild/1.0.1/Edit\r\n1. Add this URL to the \"Import Readme\" => \"URL\" box: https://raw.githubusercontent.com/natemcmaster/Yarn.MSBuild/v1.0.1/README.md. This file contains this section\r\n````md\r\n**Package Manager Console in Visual Studio**\r\n```\r\nPM> Install-Package Yarn.MSBuild\r\n```\r\n````\r\n\r\n# Expected result\r\n\r\n![image](https://user-images.githubusercontent.com/2696087/31050746-5801a22a-a609-11e7-9d56-9b9b32c4a37c.png)\r\n\r\n# Actual result\r\nIt displays brackets as `&gt;` and `&lt;`\r\n![image](https://user-images.githubusercontent.com/2696087/31050743-4536ea92-a609-11e7-8234-9b7d7ab6ca8e.png)\r\n\r\n"},{"Id":"6806853444","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:35:49","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4770","RelatedDescription":"Closed issue \"Markdown documentation do not show formatting propoerly\" (#4770) at NuGet/NuGetGallery","RelatedBody":"Feature discussion issue: https://github.com/NuGet/NuGetGallery/issues/2280\r\n\r\nAdd the following markdown to the documentation for a package:\r\n\r\n```\r\n**Bold text**\r\n\r\n*Italics*\r\n\r\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\r\n```\r\n\r\n**Note** the line breaks.\r\n\r\nExpected: \r\n1. The markdown formatting and line breaks should be rendered properly in the preview (without clicking on **Show more**)\r\n2. If all the text is shown in preview mode (without clicking on **Show more**), then \"Show more** option should **not** be shown to users.\r\n\r\nActual:\r\n1. The markdown formatting shows properly but line breaks are removed\r\n2. Even when all text is shown in preview mode, \"Show more** option is shown."},{"Id":"6806848746","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:34:48","Actor":"chenriksson","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4816","RelatedDescription":"Closed issue \"Header in documentation markdown is bigger than the \"Documentation\" label\" (#4816) at NuGet/NuGetGallery","RelatedBody":"We should limit the header. sub-header in markdown to be <= the font size of the Documentation label?\r\n\r\n![image](https://user-images.githubusercontent.com/14800916/31351331-86069770-acdf-11e7-9de5-d6721b0fdd57.png)\r\n"},{"Id":"6806831662","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:31:01","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4912","RelatedDescription":"Closed issue \"Document V3 API report abuse URL resource\" (#4912) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"6806831530","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:31:00","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4907","RelatedDescription":"Closed issue \"Document V3 API registration (metadata) resource\" (#4907) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"6806831228","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:30:57","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4909","RelatedDescription":"Closed issue \"Document V3 API search and autocomplete resources\" (#4909) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"6806831008","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:30:54","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4908","RelatedDescription":"Closed issue \"Document V3 API flat container resource\" (#4908) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"6806830836","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:30:52","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4910","RelatedDescription":"Closed issue \"Document V3 API service index\" (#4910) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"6806830643","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:30:49","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4911","RelatedDescription":"Closed issue \"Document V3 API push and delete resource\" (#4911) at NuGet/NuGetGallery","RelatedBody":""},{"Id":"6806830446","Type":"IssuesEvent","CreatedAt":"2017-11-03T17:30:47","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/4913","RelatedDescription":"Closed issue \"Document V3 API catalog resource\" (#4913) at NuGet/NuGetGallery","RelatedBody":""}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"6803966483","Type":"IssuesEvent","CreatedAt":"2017-11-03T05:19:34","Actor":"davkean","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/6139","RelatedDescription":"Opened issue \"NuGet.ProjectModel reads column/line information producing 15 MB of unneeded garbage\" (#6139) at NuGet/Home","RelatedBody":"In large solutions, allocating the LineInfoAnnotation object in NewtonSoft.Json is allocating about 15 MB (0.3%) of garbage:\r\n\r\n![image](https://user-images.githubusercontent.com/1103906/32361248-92271016-c0b2-11e7-9565-a5acc0d9c51d.png)\r\n\r\nWe shouldn't need the line info for build tasks - can we have an option to turn it off or turn it off always. "},{"Id":"6803939351","Type":"IssuesEvent","CreatedAt":"2017-11-03T05:04:11","Actor":"youngerier","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/6138","RelatedDescription":"Opened issue \"WARNING: Issue: Assembly outside lib folder \" (#6138) at NuGet/Home","RelatedBody":"when i try make a nuget package   i use nuget.exe  \r\n![image](https://user-images.githubusercontent.com/10486543/32360857-c61ab8b4-c094-11e7-8cce-0f6d27b1d4fc.png)\r\n my project has 3 reference\r\n![image](https://user-images.githubusercontent.com/10486543/32360875-e9f437f6-c094-11e7-86df-895e7e08d426.png)\r\nwhen i run nuget  pack *.csproj \r\n![image](https://user-images.githubusercontent.com/10486543/32360897-135b4832-c095-11e7-9d5e-f53acd9fd600.png)\r\nthe result is log4net.kafka.3.0.0.nupkg  and the .nupkg file is not the structure that i expected\r\n![image](https://user-images.githubusercontent.com/10486543/32360913-59ae1206-c095-11e7-8284-e9ec6e7cebb2.png)\r\nthat content folder should not be there  . the stracture should be like this other nupkg file \r\n![image](https://user-images.githubusercontent.com/10486543/32361047-1799acfc-c097-11e7-9f9b-38516f3a1b1e.png)\r\n\r\nhow could i do to fix this \r\nLook forward to your favourable reply"},{"Id":"6803767601","Type":"IssuesEvent","CreatedAt":"2017-11-03T03:32:11","Actor":"emgarten","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/5892","RelatedDescription":"Closed issue \"NuGet.exe pack file access is causing warnings in some build tools\" (#5892) at NuGet/Home","RelatedBody":"## Details about Problem\r\n\r\nNuGet product used: NuGet.exe\r\n\r\nNuGet version: 4.3.0.3\r\n\r\nVS version: Visual Studio 2017\r\n\r\nOS version: Windows 10\r\n\r\nWorked before? If so, with which NuGet version: No\r\n\r\n## Detailed repro steps so we can see the same problem\r\n\r\n1. NuGet.Config file is getting accesses when doing NuGet.exe pack. This violates rules in some build tools. \r\n\r\nC:\\Users\\\\[user]\\AppData\\Roaming\\NuGet\\NuGet.Config\r\nC:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config\r\n\r\nSee [Configuring NuGet behavior](https://docs.microsoft.com/en-us/nuget/consume-packages/configuring-nuget-behavior)\r\n\r\n## Other suggested things\r\n\r\n### Verbose Logs\r\n\r\nNot applicable\r\n\r\n### Sample Project\r\n\r\nNot applicable\r\n"},{"Id":"6803767587","Type":"IssuesEvent","CreatedAt":"2017-11-03T03:32:11","Actor":"emgarten","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/5900","RelatedDescription":"Closed issue \"Feature request: Improve NuGet pack error messages\" (#5900) at NuGet/Home","RelatedBody":"## Details about Problem\r\nFeature request (not a bug).\r\n\r\nNuGet product used: NuGet.exe\r\n\r\nNuGet version: 4.3.0.3\r\n\r\nVS version: Visual Studio 2017\r\n\r\nOS version: Windows 10\r\n\r\nWorked before? If so, with which NuGet version: Not applicable, New feature request\r\n\r\n## Detailed repro steps so we can see the same problem\r\n\r\nWould like errors to look like a standard compiler error to make parsing in wrapper tools easier.\r\n\r\nHere are some examples:\r\n\r\nFoo.cs(267,17): error CS0246: The type or namespace name 'foo' could not be found (are you missing a using directive or an assembly reference?)\r\nFoo.cs(269,17): error CS0128: A local variable or function named 'nuGetVersionsXmlBlock' is already defined in this scope\r\n\r\nThe basic format is this:\r\n<optional error location info>: error <unique error code>: <error message>\r\n\r\nAny of these should be valid errors:\r\nFoo.nuspec(10,1): error NU0001: Invalid XML tag <bar>\r\nerror NU0002: Unable to create a\\b\\c\\foo.nupkg. Directory not found.\r\nerror NU0003: Flux capacitor not charged. Please accelerate to 88 mph before attempting to see any “serious stuff”.\r\n\r\nThe “unique error code” is just something unique to any given tool (thus the suggested NU prefix) and unique per error message. The idea is that you can Bing for the eror code and find the docs for it, so you can find a fix.\r\n\r\n## Other suggested things\r\nSome tools use the error code numbers to give more info, such as the compiler. The first number aligns with the error level, so that C1xxx errors are all level 1 errors, C2xxx are all level 2, etc. IIRC, if they issue a warning or an error for the same issue, it has the same unique code, and just changes the initial bit from from “error” to “warning”.\r\n\r\n### Verbose Logs\r\n\r\nNot applicable\r\n\r\n### Sample Project\r\n\r\nNot applicable\r\n"},{"Id":"6803767583","Type":"IssuesEvent","CreatedAt":"2017-11-03T03:32:11","Actor":"emgarten","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/5893","RelatedDescription":"Closed issue \"Feature Request: Need the ability for NuGet.exe pack to create a nupkg without the version in the package name\" (#5893) at NuGet/Home","RelatedBody":"## Details about Problem\r\nFeature request (not a bug).\r\n\r\nNuGet product used: NuGet.exe\r\n\r\nNuGet version: 4.3.0.3\r\n\r\nVS version: Visual Studio 2017\r\n\r\nOS version: Windows 10\r\n\r\nWorked before? If so, with which NuGet version: Not applicable, New feature request\r\n\r\n## Detailed repro steps so we can see the same problem\r\n\r\nNeed the ability for NuGet.exe pack to create a nupkg without the version in the package name (and .sha512 when that feature is available). Some build tools require the file name to stay the same from build to build to support caching.\r\n\r\n## Other suggested things\r\n\r\nOne idea that was discussed is to pass in the PackageFileName:[NameWithoutExtension] parameter to nuget pack\r\n\r\n### Verbose Logs\r\n\r\nNot applicable\r\n\r\n### Sample Project\r\n\r\nNot applicable\r\n\r\n"},{"Id":"6803767569","Type":"IssuesEvent","CreatedAt":"2017-11-03T03:32:11","Actor":"emgarten","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/5850","RelatedDescription":"Closed issue \"Feature Request: NuGet.exe pack should drop resolved nuspec to support network share hosted Package Source\" (#5850) at NuGet/Home","RelatedBody":"## Details about Problem\r\n\r\nFeature request (not a bug).\r\n\r\nNuGet product used NuGet.exe\r\n\r\nNuGet version: 4.3.0.3\r\n\r\ndotnet.exe --version (if appropriate):\r\n\r\nVS version (if appropriate): Visual Studio 2017\r\n\r\nOS version (i.e. win10 v1607 (14393.321)): Windows 10\r\n\r\nWorked before? If so, with which NuGet version: Not applicable, New feature request\r\n\r\n## Detailed repro steps so we can see the same problem\r\n\r\n**Background:** Need to host nuget packages on an private internal network share. For fast indexing and low bandwidth consumption, the article [Accelerate your network share hosted Package Source](https://blog.nuget.org/20150922/Accelerate-Package-Source.html) solves a important problem for my team.\r\n\r\n**Issue**: The resolved nuspec file needs to be side by side with the nupkg according to the above documentation. We have many [properties,variables,tokens that need to be resolved and replaced](https://docs.microsoft.com/en-us/nuget/schema/nuspec). Pulling the nuspec out of the zip file would substantially increase our processing time for the volume of nupkgs we plan on creating. We also need the sha512 file.\r\n\r\nSo something like this in the output directory:\r\nyourpackage.0.0.1-beta.nupkg (current behavior)\r\nyourpackage.nuspec (new)\r\nyourpackage.0.0.1-beta.nupkg.sha512 (new)\r\n\r\n## Other suggested things\r\nWould like a switch in the nuget.exe pack command that drops the resolved nuspec file next to the nupkg, an exact mirror of what already exists in the nupkg but have the same name as the nupkg with a nuspec extension to follow the guidelines in [Accelerate your network share hosted Package Source](https://blog.nuget.org/20150922/Accelerate-Package-Source.html).\r\n\r\n### Verbose Logs\r\n\r\nNot applicable\r\n\r\n### Sample Project\r\n\r\nNot applicable\r\n\r\n"},{"Id":"6803479872","Type":"IssuesEvent","CreatedAt":"2017-11-03T01:18:48","Actor":"emgarten","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/6126","RelatedDescription":"Closed issue \"Feature Request: config file transform redirect configuration\" (#6126) at NuGet/Home","RelatedBody":"We have a custom configuration transform process which means that the web.config/app.config file that we use as a source is actually called web.seed.config/app.seed.config.  This allows us to use tokens in our config files that get replaced on build/deploy time depending on msbuild args.\r\n\r\nIt would be great if we could have a way of adding configuration to nuget to allow us to map transforms that target a config file to another file.\r\n\r\neg: instead of adding a binding redirect to web.config we could add a mapping like the following\r\n```\r\n<TargetFileRedirects>\r\n    <Redirect From=\"web.config\" To=\"Web.seed.config\" />\r\n</TargetFileredirects>\r\n```\r\nWhich would instead run the transform against web.seed.config.\r\n\r\nHope that makes sense,\r\n\r\nCheers."},{"Id":"6803474948","Type":"IssuesEvent","CreatedAt":"2017-11-03T01:16:28","Actor":"emgarten","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/6128","RelatedDescription":"Closed issue \"nuget VS 2017 DLL using profile 259\" (#6128) at NuGet/Home","RelatedBody":"Profile 259 is listed [here ](https://portablelibraryprofiles.stephencleary.com/) says the Nuget Target is `portable-net45+win8+wpa81+wp8` but when using WireShark to see the traffic between VS2017 and our Nexus server (see attachment) it asks for` portable45-net45+win8+wp8+wpa81`\r\n\r\nNote the extra **45** after `portable`!\r\n\r\n[Wireshark extract](https://github.com/NuGet/Home/files/1435640/Nuget.Bug.zip)\r\n\r\n"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6772094839","Type":"IssuesEvent","CreatedAt":"2017-10-26T21:21:33","Actor":"karann-msft","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/12","RelatedDescription":"Opened issue \"NuGet Account Deletion Workflow\" (#12) at NuGet/Announcements","RelatedBody":"The feature spec for the feature **NuGet Account Deletion Workflow** is ready for **review**:\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n|[NuGet/Home/wiki/NuGet-Account-Deletion-Workflow](https://github.com/NuGet/Home/wiki/NuGet-Account-Deletion-Workflow)|https://github.com/NuGet/NuGetGallery/issues/3204|"},{"Id":"6699223809","Type":"IssuesEvent","CreatedAt":"2017-10-10T21:19:56","Actor":"diverdan92","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/11","RelatedDescription":"Reopened issue \"Package ID Prefix Reservation\" (#11) at NuGet/Announcements","RelatedBody":"| Spec Wiki | Discussion | Documentation|\r\n|:------------|:-------------|:----------------|\r\n|[Spec](https://github.com/NuGet/Home/wiki/NuGet-Package-Identity-Verification)|[Issue 5307](https://github.com/NuGet/Home/issues/5307)|[NuGet Docs](https://docs.microsoft.com/nuget/reference/id-prefix-reservation)|\r\n\r\nPackage ID prefix reservation is now available on NuGet.org and in Visual Studio 2017 version 15.4 or later. \r\n\r\nTo learn more about package ID prefix reservation, including the application process, take a look at the documentation: https://docs.microsoft.com/nuget/reference/id-prefix-reservation"},{"Id":"6699221731","Type":"IssuesEvent","CreatedAt":"2017-10-10T21:19:27","Actor":"diverdan92","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Announcements/issues/11","RelatedDescription":"Closed issue \"Package ID Prefix Reservation\" (#11) at NuGet/Announcements","RelatedBody":"| Spec Wiki | Discussion | Documentation|\r\n|:------------|:-------------|:----------------|\r\n|[Spec](https://github.com/NuGet/Home/wiki/NuGet-Package-Identity-Verification)|[Issue 5307](https://github.com/NuGet/Home/issues/5307)|[NuGet Docs](https://docs.microsoft.com/nuget/reference/id-prefix-reservation)|\r\n\r\nPackage ID prefix reservation is now available on NuGet.org and in Visual Studio 2017 version 15.4 or later. \r\n\r\nTo learn more about package ID prefix reservation, including the application process, take a look at the documentation: https://docs.microsoft.com/nuget/reference/id-prefix-reservation"},{"Id":"6699221160","Type":"IssuesEvent","CreatedAt":"2017-10-10T21:19:19","Actor":"diverdan92","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/11","RelatedDescription":"Opened issue \"Package ID Prefix Reservation\" (#11) at NuGet/Announcements","RelatedBody":"| Spec Wiki | Discussion | Documentation|\r\n|:------------|:-------------|:----------------|\r\n|[Spec](https://github.com/NuGet/Home/wiki/NuGet-Package-Identity-Verification)|[Issue 5307](https://github.com/NuGet/Home/issues/5307)|[NuGet Docs](https://docs.microsoft.com/nuget/reference/id-prefix-reservation)|\r\n\r\nPackage ID prefix reservation is now available on NuGet.org and in Visual Studio 2017 version 15.4 or later. \r\n\r\nTo learn more about package ID prefix reservation, including the application process, take a look at the documentation: https://docs.microsoft.com/nuget/reference/id-prefix-reservation"},{"Id":"6645602469","Type":"IssuesEvent","CreatedAt":"2017-09-27T18:36:51","Actor":"anangaur","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/9","RelatedDescription":"Opened issue \"Markdown based documentation for packages\" (#9) at NuGet/Announcements","RelatedBody":"Announcing support for rich markdown based documentation for packages\r\n\r\nThis feature has following parts:\r\n**1. Ability to associate a markdown documentation to packages (and existing packages)\r\n2. Understand markdown and render it properly on NuGet.org package details page**\r\n3. Ability to associate markdown documentation content while packing the package, from clients\r\n4. Ability on VS client to show this markdown content.\r\n\r\n1 and 2 have been implemented as part of 2017 Interns project and released now. Please provide your feedback on the feature - both implemented and pending parts.\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n|https://github.com/NuGet/Home/wiki/Package-README.md-support|https://github.com/NuGet/NuGetGallery/issues/2280|"},{"Id":"6635971757","Type":"IssuesEvent","CreatedAt":"2017-09-26T02:01:49","Actor":"karann-msft","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/8","RelatedDescription":"Opened issue \"Updates to the NuGet.org Terms of Use\" (#8) at NuGet/Announcements","RelatedBody":"Today, we’re updating the NuGet.org Terms of Use and Privacy Statement. As we [announced](https://blog.nuget.org/20170907/Changes-to-NuGet-dot-org-service-management-and-performance-improvements-in-China.html) two weeks ago, the NuGet.org service is now a part of Microsoft. The NuGet open source codebase (both the NuGet gallery and the NuGet client) will remain open source and continue as .NET Foundation supported projects under the same terms as before.\r\n\r\nWe encourage you to read the full [Terms of Use](https://www.nuget.org/policies/Terms) and [Privacy Statement](https://go.microsoft.com/fwlink/?LinkId=521839), as well as the [blog post](https://blog.nuget.org/20170907/Changes-to-NuGet-dot-org-service-management-and-performance-improvements-in-China.html) about the changes. For your convenience, below is a quick summary.\r\n\r\nThere are no changes to the way you publish and consume packages from NuGet.org. The Terms of Use and Privacy Statement have been updated to reflect the change in ownership, as well as how Microsoft will process the data collected, and manage copyright and trademark infringement notices.\r\n\r\nOur goal is to provide an agile and reliable global service, and we remain fully committed to ensuring a healthy and open ecosystem around NuGet. The .NET Foundation and Microsoft want NuGet to meet the evolving needs of our community. For questions about our policies, please contact us by email at [feedback@nuget.org](mailto:feedback@nuget.org?subject=Regarding%20updates%20to%20the%20NuGet.org%20Terms%20of%20Use)."},{"Id":"6627163117","Type":"IssuesEvent","CreatedAt":"2017-09-22T23:24:56","Actor":"karann-msft","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/7","RelatedDescription":"Opened issue \"Package Immutability\" (#7) at NuGet/Announcements","RelatedBody":"The feature spec for the feature **Package Immutability** is ready for **review**:\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n|[NuGet/Home/wiki/Package-Immutability](https://github.com/NuGet/Home/wiki/Package-Immutability)|https://github.com/NuGet/Home/issues/5917|"},{"Id":"6593148392","Type":"IssuesEvent","CreatedAt":"2017-09-14T23:05:19","Actor":"karann-msft","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/6","RelatedDescription":"Opened issue \"Author Package Signing\" (#6) at NuGet/Announcements","RelatedBody":"The feature spec for the feature **Author Package Signing** is ready for **review**:\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n| [NuGet/Home/wiki/Author-Package-Signing](https://github.com/NuGet/Home/wiki/Author-Package-Signing) | https://github.com/NuGet/Home/issues/5889|"},{"Id":"6591956734","Type":"IssuesEvent","CreatedAt":"2017-09-14T17:58:22","Actor":"karann-msft","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/5","RelatedDescription":"Opened issue \"Feature: Package applicability in NuGet package manager UI\" (#5) at NuGet/Announcements","RelatedBody":"The feature spec for the feature **Package applicability in NuGet package manager UI** is ready for **review**:\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n| [NuGet/Home/wiki/Package-applicability-in-NuGet-package-manager-UI](https://github.com/NuGet/Home/wiki/Package-applicability-in-NuGet-package-manager-UI) | https://github.com/NuGet/Home/issues/5725|"},{"Id":"6581243956","Type":"IssuesEvent","CreatedAt":"2017-09-12T17:38:11","Actor":"anangaur","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/4","RelatedDescription":"Opened issue \"Feature: Organizations on NuGet.org\" (#4) at NuGet/Announcements","RelatedBody":"The feature spec for the feature **Organizations on NuGet.org** is ready for **review**:\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n| [NuGet/Home/wiki/Organizations-on-NuGet.org](https://github.com/NuGet/Home/wiki/Organizations-on-NuGet.org) | https://github.com/NuGet/NuGetGallery/issues/4627|"},{"Id":"6581236088","Type":"IssuesEvent","CreatedAt":"2017-09-12T17:36:22","Actor":"anangaur","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/3","RelatedDescription":"Opened issue \"Feature: 2 Factor Auth for NuGet.org sign in\" (#3) at NuGet/Announcements","RelatedBody":"The feature spec for the feature **2 Factor Auth for NuGet.org sign in** is ready for **review**:\r\n\r\n| Spec wiki| Discussion issue| \r\n| :------------- |:-------------| \r\n| [NuGet/Home/wiki/2-Factor-Auth-for-NuGet.org-sign-in](https://github.com/NuGet/Home/wiki/2-Factor-Auth-for-NuGet.org-sign-in) | https://github.com/NuGet/NuGetGallery/issues/3252|\r\n"},{"Id":"6567680066","Type":"IssuesEvent","CreatedAt":"2017-09-08T17:27:26","Actor":"anangaur","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/2","RelatedDescription":"Opened issue \"Changes to NuGet.org service management, and performance improvements in China\" (#2) at NuGet/Announcements","RelatedBody":"For details and discussions, please refer to the blog:\r\n[Changes to NuGet.org service management, and performance improvements in China](https://blog.nuget.org/20170907/Changes-to-NuGet-dot-org-service-management-and-performance-improvements-in-China.html)"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"926502698853154816","CreatedAt":"2017-11-03T17:33:51+00:00","UserScreenname":"nuget","Text":"More goodness - NuGet API documentation just went live: https://t.co/MB46AcJUOr\n\n/cc: @docsmsft","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":22,"FavoriteCount":13,"RawContent":null},{"Id":"926484269127446528","CreatedAt":"2017-11-03T16:20:37+00:00","UserScreenname":"nuget","Text":"Woohoo! 5 billion package downloads and counting... https://t.co/4ebMApvQC0","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":21,"FavoriteCount":11,"RawContent":null},{"Id":"923757712273371136","CreatedAt":"2017-10-27T03:46:15+00:00","UserScreenname":"nuget","Text":"https://t.co/F9kiKfdOWi email system will be undergoing maintenance at 10/27 4:00 pm PST. You can track the status @ https://t.co/Rr1hgeMAld","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":2,"FavoriteCount":3,"RawContent":null},{"Id":"918985517219291136","CreatedAt":"2017-10-13T23:43:15+00:00","UserScreenname":"nuget","Text":"https://t.co/F9kiKfdOWi email system maintenance has been postponed, and is operating normally.","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":3,"FavoriteCount":0,"RawContent":null},{"Id":"918944019752742913","CreatedAt":"2017-10-13T20:58:22+00:00","UserScreenname":"nuget","Text":"https://t.co/F9kiKfdOWi email system will be undergoing maintenance at 10/13 4pm PST. Track the status at https://t.co/Rr1hgeMAld","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":2,"FavoriteCount":2,"RawContent":null},{"Id":"908469327979962368","CreatedAt":"2017-09-14T23:15:40+00:00","UserScreenname":"nuget","Text":"Signed packages coming to NuGet soon - we'd love to hear your feedback! Read more - https://t.co/JkpD980gu0","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":45,"FavoriteCount":37,"RawContent":null}]}},"RunOn":"2017-11-03T21:24:51.9900077Z","RunDurationInMilliseconds":2476}