{"Data":{"Blog":{"FeedItems":[{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":30,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":9,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803)","PublishedOn":"2018-05-24T01:49:57+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/23/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-april-2018-update-version-1803/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update)","PublishedOn":"2018-05-21T22:44:05+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/21/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-1709-fall-creators-update/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10","PublishedOn":"2018-05-17T17:20:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1703 (Creators Update) and Windows 10 1607 (Anniversary Update). Quality and Reliability This release contains the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/17/net-framework-may-2018-preview-of-quality-rollup-for-windows-10/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup","PublishedOn":"2018-05-15T18:10:24+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup. Quality and Reliability This release contains the following quality and reliability improvements. CLR Resolves an issue in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/15/net-framework-may-2018-preview-of-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""},{"Id":"7697516495","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:04:23","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/101","RelatedDescription":"Merged pull request \"Create mlnet.md\" (#101) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7822272262","Type":"PullRequestEvent","CreatedAt":"2018-06-14T01:27:40","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18462","RelatedDescription":"Opened pull request \"ARM: increase small reg set for jitStressRegs=3\" (#18462) at dotnet/coreclr","RelatedBody":"We may need two registers (base + offset) to set up the target register for a virtual call.\r\n\r\nFix #18228"},{"Id":"7822260778","Type":"IssuesEvent","CreatedAt":"2018-06-14T01:22:56","Actor":"janvorli","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18439","RelatedDescription":"Closed issue \"Crash in coreclr when muxer/apphost path contains valid UTF-8 sequence\" (#18439) at dotnet/coreclr","RelatedBody":"## Steps to reproduce\r\n\r\nOn macOS 10.13 (with brew installed `wget`):\r\n\r\n```\r\n$ wget https://download.microsoft.com/download/8/8/5/88544F33-836A-49A5-8B67-451C24709A8F/dotnet-sdk-2.1.300-osx-x64.tar.gz\r\n$ mkdir 我能吞下玻璃而不傷身體\r\n$ cd 我能吞下玻璃而不傷身體\r\n$ tar xvzf ../dotnet-sdk-2.1.300-osx-x64.tar.gz\r\n$ ./dotnet --help\r\n```\r\n\r\n## Expected  behavior\r\n\r\n`dotnet` should print out the SDK help.\r\n\r\n## Actual behavior\r\n\r\n`dotnet` segfaults:\r\n\r\n```\r\n$ ./dotnet --help\r\n[1]    70062 segmentation fault  ./dotnet --help\r\n```\r\n\r\nBacktrace:\r\n```\r\n(lldb) bt\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\r\n  * frame #0: 0x0000000000000000\r\n    frame #1: 0x000000010204b51e libcoreclr.dylib`ClrAllocInProcessHeapBootstrap(unsigned int, unsigned long) + 30\r\n    frame #2: 0x000000010204b872 libcoreclr.dylib`operator new(unsigned long) + 18\r\n    frame #3: 0x000000010201b144 libcoreclr.dylib`DecoderReplacementFallback::CreateFallbackBuffer() + 20\r\n    frame #4: 0x000000010201b80e libcoreclr.dylib`UTF8Encoding::GetCharCount(unsigned char*, int) + 1102\r\n    frame #5: 0x000000010201b2f3 libcoreclr.dylib`UTF8ToUnicode + 179\r\n    frame #6: 0x0000000102018231 libcoreclr.dylib`Initialize(int, char const* const*, unsigned int) + 737\r\n    frame #7: 0x0000000102018872 libcoreclr.dylib`PAL_InitializeCoreCLR + 34\r\n    frame #8: 0x000000010204ad35 libcoreclr.dylib`coreclr_initialize + 37\r\n    frame #9: 0x0000000100476cfc libhostpolicy.dylib`___lldb_unnamed_symbol946$$libhostpolicy.dylib + 172\r\n    frame #10: 0x000000010045f48c libhostpolicy.dylib`___lldb_unnamed_symbol750$$libhostpolicy.dylib + 32428\r\n    frame #11: 0x0000000100466af9 libhostpolicy.dylib`___lldb_unnamed_symbol773$$libhostpolicy.dylib + 297\r\n    frame #12: 0x000000010038b3a3 libhostfxr.dylib`___lldb_unnamed_symbol931$$libhostfxr.dylib + 451\r\n    frame #13: 0x00000001003af16e libhostfxr.dylib`___lldb_unnamed_symbol1000$$libhostfxr.dylib + 18606\r\n    frame #14: 0x00000001003b1d42 libhostfxr.dylib`___lldb_unnamed_symbol1009$$libhostfxr.dylib + 1602\r\n    frame #15: 0x00000001003b1ed5 libhostfxr.dylib`___lldb_unnamed_symbol1011$$libhostfxr.dylib + 309\r\n    frame #16: 0x00000001003b157b libhostfxr.dylib`___lldb_unnamed_symbol1008$$libhostfxr.dylib + 4891\r\n    frame #17: 0x00000001003b0151 libhostfxr.dylib`___lldb_unnamed_symbol1007$$libhostfxr.dylib + 1809\r\n    frame #18: 0x000000010038c419 libhostfxr.dylib`___lldb_unnamed_symbol934$$libhostfxr.dylib + 297\r\n    frame #19: 0x000000010000d052 dotnet`___lldb_unnamed_symbol58$$dotnet + 7842\r\n    frame #20: 0x000000010000d645 dotnet`___lldb_unnamed_symbol60$$dotnet + 165\r\n    frame #21: 0x00007fff75d4f015 libdyld.dylib`start + 1\r\n    frame #22: 0x00007fff75d4f015 libdyld.dylib`start + 1\r\n```\r\n\r\n## Additional information\r\n\r\nI've verified the argument to `UTF8ToUnicode` is valid UTF-8:\r\n\r\n```\r\n(lldb) mem read -c 69 0x0000000100231170\r\n0x100231170: 2f 55 73 65 72 73 2f 70 65 74 65 72 68 75 65 6e  /Users/peterhuen\r\n0x100231180: 65 2f 44 6f 77 6e 6c 6f 61 64 73 2f e6 88 91 e8  e/Downloads/�..�\r\n0x100231190: 83 bd e5 90 9e e4 b8 8b e7 8e bb e7 92 83 e8 80  .��..�.�.��..�.\r\n0x1002311a0: 8c e4 b8 8d e5 82 b7 e8 ba ab e9 ab 94 2f 64 6f  .�.�.�身�./do\r\n0x1002311b0: 74 6e 65 74 00                                   tnet.\r\n```\r\n\r\nwhich is the expected `argv[0]` of:\r\n\r\n```\r\n/Users/peterhuene/Downloads/我能吞下玻璃而不傷身體/dotnet\r\n```\r\n\r\nIt appears that it is treating part of the sequence as invalid UTF-8 and attempting to count or add a fallback character, but the fallback buffer can't be allocated yet (initialization issue I assume?).\r\n\r\n## Environment data\r\n```\r\n$ dotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300\r\n Commit:    adab45bf0c\r\n\r\nRuntime Environment:\r\n OS Name:     Mac OS X\r\n OS Version:  10.13\r\n OS Platform: Darwin\r\n RID:         osx.10.13-x64\r\n Base Path:   /usr/local/share/dotnet/sdk/2.1.300/\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0\r\n  Commit:  caa7b7e2ba\r\n\r\n.NET Core SDKs installed:\r\n  2.1.300 [/usr/local/share/dotnet/sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n```\r\n\r\n"},{"Id":"7822169338","Type":"PullRequestEvent","CreatedAt":"2018-06-14T00:47:04","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18461","RelatedDescription":"Opened pull request \"Update CoreClr to preview1-26614-01 (master)\" (#18461) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"7821957662","Type":"PullRequestEvent","CreatedAt":"2018-06-13T23:28:03","Actor":"tarekgh","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18456","RelatedDescription":"Merged pull request \"Added ISOWeek to System.Globalization\" (#18456) at dotnet/coreclr","RelatedBody":"Part of https://github.com/dotnet/corefx/issues/28933\r\n\r\n// @tarekgh"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7822716631","Type":"IssuesEvent","CreatedAt":"2018-06-14T04:19:52","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9487","RelatedDescription":"Closed issue \"Application will not start even with HOME variable set\" (#9487) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nI am aware that this issue has been seen before, but I have my home directory set to the correct location. Whenever I try to run my application(via dotnet _[Path to Application]_), it will not start and I receive the error below. I ran `echo $HOME` and it gives me the correct location `/home/ubuntu`.\r\n\r\n## Expected  behavior\r\nThe application should run.\r\n\r\n## Actual behavior\r\n```\r\nApplication startup exception: System.ArgumentNullException: Value cannot be null.\r\nParameter name: path1\r\n   at System.IO.Path.Combine(String path1, String path2)\r\n   at Vulnerabilities.io.Startup.Configure(IApplicationBuilder app, IHostingEnvironment env) in /home/ubuntu/test/Vulnerabilities.io/Vulnerabilities.io/Startup.cs:line 55\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at Microsoft.AspNetCore.Hosting.ConventionBasedStartup.Configure(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.HostFilteringStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.Hosting.Internal.AutoRequestServicesStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()\r\ncrit: Microsoft.AspNetCore.Hosting.Internal.WebHost[6]\r\n      Application startup exception\r\nSystem.ArgumentNullException: Value cannot be null.\r\nParameter name: path1\r\n   at System.IO.Path.Combine(String path1, String path2)\r\n   at Vulnerabilities.io.Startup.Configure(IApplicationBuilder app, IHostingEnvironment env) in /home/ubuntu/test/Vulnerabilities.io/Vulnerabilities.io/Startup.cs:line 55\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at Microsoft.AspNetCore.Hosting.ConventionBasedStartup.Configure(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.HostFilteringStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.Hosting.Internal.AutoRequestServicesStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()\r\n\r\nUnhandled Exception: System.ArgumentNullException: Value cannot be null.\r\nParameter name: path1\r\n   at System.IO.Path.Combine(String path1, String path2)\r\n   at Vulnerabilities.io.Startup.Configure(IApplicationBuilder app, IHostingEnvironment env) in /home/ubuntu/test/Vulnerabilities.io/Vulnerabilities.io/Startup.cs:line 55\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at Microsoft.AspNetCore.Hosting.ConventionBasedStartup.Configure(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.HostFilteringStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.Hosting.Internal.AutoRequestServicesStartupFilter.<>c__DisplayClass0_0.<Configure>b__0(IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.StartAsync(CancellationToken cancellationToken)\r\n   at Microsoft.AspNetCore.Hosting.WebHostExtensions.RunAsync(IWebHost host, CancellationToken token, String shutdownMessage)\r\n   at Microsoft.AspNetCore.Hosting.WebHostExtensions.RunAsync(IWebHost host, CancellationToken token)\r\n   at Microsoft.AspNetCore.Hosting.WebHostExtensions.Run(IWebHost host)\r\n   at Vulnerabilities.io.Program.Main(String[] args) in /home/ubuntu/test/Vulnerabilities.io/Vulnerabilities.io/Program.cs:line 11\r\nAborted (core dumped)\r\n```\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n```\r\n OS Name:     ubuntu\r\n OS Version:  18.04\r\n OS Platform: Linux\r\n RID:         ubuntu.18.04-x64\r\n Base Path:   /usr/share/dotnet/sdk/2.1.300/\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0\r\n  Commit:  caa7b7e2ba\r\n\r\n.NET Core SDKs installed:\r\n  2.1.300 [/usr/share/dotnet/sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"7822714346","Type":"IssuesEvent","CreatedAt":"2018-06-14T04:18:51","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9486","RelatedDescription":"Closed issue \"Request: Add a param to emit structured data (for third-party tooling)\" (#9486) at dotnet/cli","RelatedBody":"This is a very general, wide-reaching request.\r\n\r\nI envision an invocation similar to the following:\r\n\r\n```shell\r\n$ dotnet build --message-format json\r\n```\r\n\r\nWhich, upon error CS0539 (for example), would emit such a structure:\r\n\r\n```json\r\n{\r\n    \"status\": \"error\",\r\n    \"errors\": [{\r\n        \"code\": \"CS0539\",\r\n        \"message\": \"The type or namespace 'Foo' could not be found\",\r\n        \"notes\": [{\r\n            \"message\": \"Are you missing a using directive or an assembly reference?\",\r\n            \"span\": null,\r\n        }],\r\n        \"origin\": {\r\n            \"file\": \"rel/path/to/file.cs\",\r\n            \"span\": { // a byte range\r\n                \"start\": 123,\r\n                \"end\": 456\r\n            }\r\n        }\r\n    }]\r\n}\r\n```\r\n\r\nThe resulting structured data could be used by foundation- and community-built tooling for many things (one example is error messages that include source code).\r\n\r\nThis request is inspired by [`cargo`](https://github.com/rust-lang/cargo) `--message-format` functionality.\r\n\r\nI fully realize that this is a *very large* request and the above structure is a minimal, illustrative example."},{"Id":"7822586094","Type":"IssuesEvent","CreatedAt":"2018-06-14T03:25:38","Actor":"sanisoclem","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9488","RelatedDescription":"Opened issue \"Is there a way to package a binary as a global tool\" (#9488) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\nI have native binaries (one for each platform) that I want to package as global CLI tools to make it available in my dotnet projects. I would prefer not to rewrite the code base in C#. I know that there are non .net projects in nuget like https://github.com/edenhill/librdkafka  but can't find any native dotnet tool.\r\nIs this possible? \r\n\r\nI also raised this question in [SO](https://stackoverflow.com/questions/50838079/how-can-i-package-a-native-binary-as-a-global-dotnet-tool)\r\n\r\n## Expected  behavior\r\n\r\nPackaging a set of native binaries with metadata (entry point, supported platforms) in a .nupkg will be installable with `dotnet tool install -g`. It would choose the appropriate binaries based on the platform and `~/.dotnet/tools`. \r\n\r\n## Actual behavior\r\n\r\nCan't find a way to do this in the documentation. \r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300\r\n Commit:    adab45bf0c\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  6.3.9600\r\n OS Platform: Windows\r\n RID:         win81-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.300\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0\r\n  Commit:  caa7b7e2ba\r\n\r\n.NET Core SDKs installed:\r\n  1.0.0-preview4-004233 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.4 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.201 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n```\r\n\r\n\r\n\r\n\r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7819553637","Type":"PullRequestEvent","CreatedAt":"2018-06-13T15:18:33","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/773","RelatedDescription":"Merged pull request \"Add diagnostic logging to trimming\" (#773) at dotnet/standard","RelatedBody":"Enable diagnostic logging to help understand the state of the task if a failure occurs.\r\n\r\nAlso guard against unpopulated dependencies."},{"Id":"7815209945","Type":"IssuesEvent","CreatedAt":"2018-06-12T21:33:08","Actor":"GoldenCrystal","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/774","RelatedDescription":"Opened issue \"Idea/Proposal: Split .NET Standard into multiple smaller standards by relying on tooling\" (#774) at dotnet/standard","RelatedBody":"First, let me start by saying that this is not supposed to be a final proposal, but more like a rough draft / general idea, that I hope to tranform into a valid proposal with the help of everyone here.\r\nI fear this is going to be a controversial topic, but I've had this idea in the back of my head for a few days now, and I'd like to at least try explaining it there, so as to have your feedback.\r\nSo, please bear with me until the end of this topic. 😅\r\n\r\n# Abstract\r\n\r\n[Like many others](https://github.com/dotnet/standard/issues/682), I do wish .NET Standard 2.1 was already a thing.\r\nBut I do also perfectly understand the concerns about .NET Core 2.1 being the only implementation already ahead in the standard. And because of that I do fear that .NET Standard 2.0 will be the last .NET Standard version ever. (But at the same time, I'm kinda going to propose replacing it by something else here… 😒)\r\n\r\nAside of that, the fact that .NET Standard 2.0 is not compatible with .NET 4.5 can sometimes be an obstacle in the migration process to .NET Core. (That's something we are faced with everyday in my current job)\r\n\r\nSo I wondered, what if, instead of having *one unique standard*, there were *many smaller standards* that could be implemented à-la-carte by runtimes/frameworks/NuGet ?\r\nWhat if we could already define something such as a \"Span Standard 1.0\" ?\r\n\r\nAnd yes, I know that the original design of DNX / .NET Standard 1.0 was more modular, I know that there were once such a thing as Assembly Neutral Interfaces, and I know all of this did not work out that well. This did obviously lead to the acceptable compromise that is .NET Standard 2.0.\r\n\r\nBut, I assure you, I am *not* proposing to reiterate the exact same mistakes as in .NET Standard 1 era. (Which is not to say that I'm not taking strong inspiration on what has/had already been done. 😉)\r\n\r\nWhat I'm thinking of is a mechanism that should help reduce coupling **without** requiring changes in the existing runtimes, and could work reasonably well with support in the tooling.\r\n\r\n# The general idea\r\n\r\nWe would define many ````feature```` sets that can overlap eachother. At the begining, features would likely be defined based on current .NET Standard 1.0~2.0 APIs, by splitting unrelated features away from eachother. (Basically what I call a ````feature```` here is like a much smaller .NET Standard) \r\n\r\nA ````feature```` would be defined very *similarly* to a reference assembly (i.e. no implementation), and define what API a consumer should expect when **depending** on the ````feature````.\r\n\r\nI'll take as an example the current hot topic of ````Span<T>```` and .NET Standard 2.0/2.1 to illustrate how ````features```` could help:\r\n````Span<T>```` is available to altmost anyone, but only .NET Core 2.1 supports the fast ````Span<T>```` and the new Span-based APIs:\r\n\r\n - Assume that there is no such thing as ````.NET Standard````\r\n - We could define ````Feature.Span, Version=1.0```` for the portable span, as implemented in ````System.Memory````\r\n - We could define ````Feature.Span, Version=1.1```` for the fast span, as implemented in .NET Core 2.1\r\n - Let's assume that we already have ````Feature.Sockets, Version=2.0```` representing the ````System.Net.Sockets```` feature from .NET Framework 2.0.\r\n - We could define ````Feature.Span.Sockets, Version=1.0````:\r\n   - This feature would have a feature dependecy on both ````Feature.Span, Version=1.0```` and ````Feature.Net.Sockets, Version=2.0````\r\n   - This feature would define all the new Span-related members introduced on Sockets\r\n - Let's assume that we have ````Feature.IO, Version=4.5```` representing the ````System.IO```` subset from the NuGet package with the same name.\r\n - We could define ````Feature.Span.Streams, Version=1.0````:\r\n   - This feature would have a feature dependecy on both ````Feature.Span, Version=1.0```` and ````Feature.IO, Version=4.5````\r\n   - This feature would define all the new Span-related members introduced on System.IO.Stream\r\n - We could go on with all the other places where Span-related API were introduced, but I'm sure you get the idea…\r\n\r\nℹ️ Note: Don't pay too much attention about the fictional boundaries of the features yet, I'm pretty sure I wouldn't want the feature to be shaped _exactly_ like described above. 😉\r\n\r\nWith such ````features```` defined, I could write a database client library, and declare that it depends on ````Feature.Runtime````, ````Feature.CSharp, Version=7.3````, ````Feature.Net.Sockets````, ````Feature.Span.Sockets````, ````Feature.Collections````, and ````Feature.Data.Common````.\r\nThis would allow my library to run on any runtime, provided that it at least supports all the ````features```` I used.\r\n\r\n# The (Draft) Proposal\r\n\r\n## Defining features\r\n\r\nA ````feature```` is an API shape, or contract (similar to .NET Standard), whose concrete implementation is provided by either a runtime (e.g. .NET Core) **or** by NuGet packages.\r\n\r\nWe would ideally reserve a prefix on NuGet for official .NET features. (e.g. ````Feature.````)\r\n\r\n - In the initial version, features would only ever be created by Microsoft / .NET Foundation\r\n - A ````feature```` is represented as a **single** assembly, typically exposed as a NuGet package.\r\n - A ````feature```` assembly contains only metadata (no implementation), like would any reference assembly.\r\n - A ````feature```` assembly contains only public types and members. (public types, public members and protected members)\r\n - A ````feature```` assembly can (will) have dependencies on other ````feature```` assemblies. (Dependencies would be supported via NuGet packages)\r\n - A ````feature```` assembly defines only the exact API surface that it supports\r\n   - A ````feature```` can only provide complete interface definitions. (Interface versioning problem: it is not possible to add or remove interface members)\r\n   - A ````feature```` can provide delegates. (Complete definition, not that any other form would be valid anyway)\r\n   - A ````feature```` provides only partial type definitions for structs, classes, and enums: Only publicly visible members that are provided by the ````feature````, are included in the metadata.\r\n   - ````features```` don't need to provide public constructors to type they augment\r\n   - A ````feature```` cannot add an abstract method to a pre-existing type (TBD: How can this be enforced ? Maybe based on the presence of a public constructor ?)\r\n   - (Obvious) Every type that is referenced in the ````feature```` assembly must exist either in the ````feature```` assembly itself or in one of its dependent ````feature```` assemblies.\r\n - Multiple ````features```` can provide the same member on the same type, if they both provide it for different reasons\r\n - Across ````feature```` assemblies, type identity is only determined by their full name \r\n - ````features```` follow Semantic Versioning (TBD)\r\n   - A ````feature```` of minor version M > N must always depend on the ````feature```` version N (Version M should only include the new types and members)\r\n   - A ````feature```` of major version M > N can depend on ````feature```` version N if it doesn't include breaking changes (In the current state of affairs, I expect that there would never be breaking changes)\r\n\r\nI expect that ````feature```` assemblies will never be referenced by concrete runtime, library or application assemblies.\r\n\r\nFor the rest of this proposal, I will address the proposed feature (sorry 😑) as ````feature````:\r\nA ````feature```` is either ````provided```` or ````depended upon````. Usage of any other term is likely a mistake on my part.\r\n\r\n## Wiring up features\r\n\r\n### Within libraries\r\n\r\nA new TFM ````features```` is created, acting similarly to ````netstandard```` TFMs.\r\nLibrary projects can target the TFM ````features```` like they would target .NET Standard, .NET FX, .NET Core or other TFMs.\r\n\r\nWhen targeting the TFM ````features````, the library project must reference all features it depends on:\r\n\r\n - We could assume that the TFM ````features```` provide **zero** API by default. (But maybe it provide some kind of minimal subset ?)\r\n - Features could be bundled in larger feature packages to avoid referencing hundreds of feature packages. (Similar to ````Microsoft.AspNetCore.All````)\r\n - The project can reference other libraries that are based on the ````features```` TFM, and will transitively inherit feature dependencies.\r\n\r\nAt build time, the toochain will load all ````feature```` assemblies and construct a model of the global feature set required by the library by merging all type definitions in the feature assemblies.\r\nThis can be done in the compiler or before calling the compiler, via an external tool. (I feel it might be easier to add this in the MSBuild build process than in Roslyn.)\r\n\r\nAll metadata references to ````features```` would be mapped to a non-existant and well-known ````features```` assembly (possibly signed, and in that case, the signing key would have to be public).\r\n\r\n⚠️ Important: The feature dependencies still need to be stored somewhere inside the resulting assembly… But I don't know how they should be stored. (Custom attributes, or regular .NET assembly references ?)\r\n\r\n### Within applications\r\n\r\nWhat is true today will still hold true with features: Applications are expected to target a concrete framework.\r\nHowever, application projects would gain the ability to reference features-based projects and libraries.\r\n\r\nWhen an application references a features-based project, the toolchain (NuGet & MSBuild) must always validate that the current TFMs for the project support all of the required ````features````, directly, or via compatibility NuGet packages.\r\n\r\nAt build time, the toochain will load all ````feature```` assemblies indirectly referenced by the project and construct a **shim** assembly covering all of the required ````features````:\r\n\r\n - This assembly will have the well-known name ````features```` (identical to what is referenced by ````feature````-based library projects)\r\n - This assembly will contain ````TypeForwardedToAttribute```` attributes for each and every type referenced by the features. (That's assuming that feature support has already verified for the project, so that all the members of forwarded types are guaranteed to exist)\r\n - The assembly is (likely) signed with the well-known signing key.\r\n\r\nThe generated ````features```` **shim** assembly will be bundled with the application, and act as the glue between features-based libraries and the underlying framework. (This should be very similar to how .NET Standard works, if I'm not mistaken)\r\n\r\nℹ️ NB: In the end, what I propose is that, rather than the runtime(s), the **application** is responsible for **providing** (wire-up) the features that the libraries depend upon. (But that this is handled by the toolchain)\r\n\r\n## Providing features (i.e. Concrete implementations)\r\n\r\nSplitting type definitions across multiple reference-like assemblies should not break typical .NET expectations:\r\n\r\n - A concrete type implementation can only be provided by **one** assembly\r\n - Where the concrete type implementation ends up being (i.e. in which assembly) is dependent on the runtime, and *should not matter to the library developer*\r\n - The runtime is never aware of the partial type definitions that were used to build libraries\r\n\r\nThere must exist a mapping between runtimes/frameworks and features, and features could likely be always provided via NuGet packages.\r\nThis would provide a single source of metadata for the toolchain to generate its shim assemblies.\r\n\r\nThis is basically what we could expect:\r\n\r\n - A NuGet package can declare a list of implemented ````features````.\r\n - If a NuGet package claims to **provide** a ````feature````, it must **provide** this ````feature```` entirely, even if that means that some method would throw ````NotImplementedException````\r\n   - Implementation of the feature could, however, rely on other dependencies (via ````TypeForwardedToAttribute````)\r\n   - Implementation of a feature is always relative to a valid TFM that **is not** ````features```` (but it could be ````netstandard2.0````)\r\n - For each framework, a NuGet package with the correct Major.Minor version would exist. (e.g. ````Framework.NETCoreApp, Version=2.1.0````)\r\n   - Framework NuGet packages would **not** contain the framework itself\r\n   - Framework NuGet packages would define which features the framework supports, and how they are mapped\r\n   - Framework NuGet packages could be updated incrementally to add features as they are standardized\r\n   - Framework NuGet packages would be flagged specifically\r\n\r\n## Features on the NuGet side\r\n\r\nAll of the above requirements would likely require adaptations on the NuGet side:\r\n\r\n - As said earlier, Microsoft or .NET Foundation should reserve a NuGet prefix for features (e.g. ````Feature.````) to ease discovery of features and avoid pollution\r\n - Microsoft or .NET Foundation should reserve a NuGet prefix for frameworks (e.g. ````Framework.````) to ease discovery of framework-feature mappings\r\n - A NuGet package must be identifiable as a ````feature````\r\n   - ````features```` are to be always considered framework agnostic\r\n   - ````feature```` packages should only contain one reference assembly (Named the same as the feature ?)\r\n   - ````feature```` packages should be ignored by older NuGet implementations\r\n - A NuGet package must be able to **depend on** a ````feature````\r\n   - That might be as simple as declaring a regular package dependency\r\n - A NuGet package must be able to **provide** a ````feature````\r\n   - The features which are provided must be listed in the package… (How ?)\r\n   - A NuGet package implementing one ore more feature must contain, for each TFM where it applies, exactly **one** well-known assembly named ````features````, signed with a well-known key, and containing/forwarding the implementation of all the features.\r\n - A NuGet package must be identifiable as a ````framework````\r\n   - Framework NuGet packages are not considered framework agnostic (they… are… applying to themselves, somehow)\r\n   - Framework NuGet packages follow the same rules as NuGet packages that **provide** ````features````\r\n\r\n# Remarks\r\n\r\n## How should ````features```` be sliced from .NET Standard ?\r\n\r\nThe goal of this proposal is not (yet) to propose how ````features```` should be sliced, but to propose how to allow them to be sliced.\r\nHowever, it must be noted, that there are many ways to slice an API with the feature proposed here.\r\nWhile most types will not require any special treatment, some types may be better sliced into multiple separate features, rather than exported as a single feature.\r\n\r\nWe could consider, for example, that the ````Stream```` class could be exported in a ````Feature.IO.Stream.Sync```` and ````Feature.IO.Stream.Async````, with possibly even a common feature ````Feature.IO.Stream.Core````.\r\n\r\nI'm sure that would generate a lot of discussions anyway… 🙂\r\n\r\n## Possible uses of ````features````\r\n\r\nApart from the obvious modularization of the standard, ````features```` could also be used in the following scenarios:\r\n\r\n - For framework dependencies of a .NET language such as C#: The ````feature```` for the language would be versioned in parallel with the language version, and, for each version, declare every type and member needed to fully support that version of the language.\r\n - For defining an optional standardized .NET UI API. (Whose implementation might be tied to the runtime)\r\n - Defining a new ````feature```` over a third party API, for allowing developers to more easily swap the implementation (because ````features```` apply to any .NET type, and not just only interfaces)\r\n\r\n ## Finding how ````features```` are provided\r\n\r\n While ````features```` provided by the runtime can be easy to discover (the user only would only need to import the corresponding package, and the tools might even do it automatically), it might be much harder to find that a package for supporting a feature exists on a given runtime.\r\n\r\n Given that the responsibility for ensuring that à ````feature```` is **provided** is delegated to the final user (user of the library(ies) depending on ````features````), there might be a need for some sort of mechanism helping to discover feature implementations.\r\n\r\n It would be great if NuGet coult auto import default feature-providing packages, based on some kind of repository… So that everything goes smoothly on the end-user side.\r\n\r\n# (Supposed) pros and cons of this proposal\r\n\r\n## Pros\r\n\r\n - More fine grained control over dependencies (looser coupling, maybe recovering some of the possibilities that were lost by removing Assembly Neutral Interfaces)\r\n - Ability to standardize small parts of the API surface rather than a whole framework (e.g. new Span APIs could be standardized faster on their own)\r\n - Ability to make some newer APIs compatible with old .NET versions again (That is an important scenario in some migration paths)\r\n - Ability to standardize things such as UI APIs (e.g. Windows Forms) without redefining \".NET Standard\"\r\n - This proposal does not require modifying existing runtimes\r\n\r\n## Cons\r\n\r\n - This proposal adds yet another layer of complexity to the already complicated world of framework compatibility\r\n - Consuming libraries implemented over ````features```` requires upgrading the toolchain (that is not a problem for everyone, but it can be for some)\r\n - This proposal may requires non-trivial additions to NuGet (let's hope not)\r\n - Slicing the .NET Standard API in a potentially large number of fine-grained features must be done very carefully, and may take quite a bit of time\r\n\r\n# Conclusion\r\n\r\nThank you very much for reading this to the end !\r\n\r\nI'm waiting for your feedback. 😉"},{"Id":"7813817261","Type":"PullRequestEvent","CreatedAt":"2018-06-12T17:02:16","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/773","RelatedDescription":"Opened pull request \"Add diagnostic logging to trimming\" (#773) at dotnet/standard","RelatedBody":"Enable diagnostic logging to help understand the state of the task if a failure occurs.\r\n\r\nAlso guard against unpopulated dependencies."},{"Id":"7813802040","Type":"PullRequestEvent","CreatedAt":"2018-06-12T16:59:30","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/766","RelatedDescription":"Merged pull request \"Fix typo in FileNode 'Polulate'\" (#766) at dotnet/standard","RelatedBody":"/cc @nil4"},{"Id":"7803009293","Type":"IssuesEvent","CreatedAt":"2018-06-10T18:49:51","Actor":"gehnster","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/772","RelatedDescription":"Opened issue \"New HttpStatusCodes\" (#772) at dotnet/standard","RelatedBody":"Would it be possible to get these added to the next release of .NET Standard, from .NET Core.\r\n\r\nhttps://github.com/dotnet/corefx/issues/4382"},{"Id":"7802771531","Type":"IssuesEvent","CreatedAt":"2018-06-10T16:13:31","Actor":"Lexcess","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/771","RelatedDescription":"Opened issue \"[Proposal] Add GC.GetAllocatedBytesForCurrentThread in .Net Standard vNext\" (#771) at dotnet/standard","RelatedBody":"Given the recent focus on reducing allocations in .Net (e.g. the introduction of `Span<>`). I think it would be useful to have a simple tool for tracking allocations on the current thread. I would categorise this similarly to the `Stopwatch `class; yes I could use an external profiler, but having an in process solution is so much more flexible. I want to use something like this for monitoring, unit tests and even sanity-checking refactorings.  \r\n\r\nThe good news is that `GetAllocatedBytesForCurrentThread` was added to .Net Core CLR a while back now (see dotnet/corefx#10157 and https://github.com/dotnet/corefx/pull/12489 ), and it offers a robust model to follow.\r\n\r\nThe bad news is that the other runtime GC's don't currently have similar implementations and given GC differences the code probably can't be ported straight over. \r\n\r\nI understand that there is a higher cost implied by adding API's to the Standard that don't currently have obvious implementations for each runtime, but I do think this is an area where there will be growing interest in such an API. For example on Mono where allocations are critical to the performance of games and mobile apps.\r\n\r\nFurthermore there are already some people in the wild attempting cross runtime solutions, but it is a lot of hoops even when .Net Core is in play. See for example what Benchmark.Net is having to do right now: [Benchmark.Net/GCStats.cs](https://github.com/dotnet/BenchmarkDotNet/blob/master/src/BenchmarkDotNet/Engines/GcStats.cs)). Adding `GetAllocatedBytesForCurrentThread` to the standard would ease this immediate issue and give the opportunity for the other runtimes to add valuable diagnostic information in the future (with `PlatformNotSupportedException`s perhaps being the cost in the interim)."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7822768166","Type":"IssuesEvent","CreatedAt":"2018-06-14T04:43:05","Actor":"bartonjs","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/issues/29825","RelatedDescription":"Reopened issue \"Variation of EnvelopedCmsTests.Tests.DecryptTests.Decrypt_SignedWithinEnveloped fails cross platform\" (#29825) at dotnet/corefx","RelatedBody":"This is a variation of EnvelopedCmsTests.Tests.DecryptTests.Decrypt_SignedWithinEnveloped test which checks roundtripping between Windows 10 and Ubuntu 16.04 (very likely any Windows vs any non-Windows).\r\n\r\nFull repro in point 2, point 1 shows how was the doc generated in case it is useful. Guessing that some of the encryption parameters might not be the same (i.e. different default IV) but requires more investigation.\r\n\r\n## 1. Generate encrypted document on Windows and Ubuntu\r\n<details><summary>Expand to see code and outputs</summary>\r\n\r\n```csharp\r\n            byte[] content =\r\n                 (\"3082032506092a864886f70d010702a082031630820312020101310b300906052b0e03021a0500301206092a864886f70d01\"\r\n                + \"0701a0050403010203a08202103082020c30820179a00302010202105d2ffff863babc9b4d3c80ab178a4cca300906052b0e\"\r\n                + \"03021d0500301e311c301a060355040313135253414b65795472616e736665724361706931301e170d313530343135303730\"\r\n                + \"3030305a170d3235303431353037303030305a301e311c301a060355040313135253414b65795472616e7366657243617069\"\r\n                + \"3130819f300d06092a864886f70d010101050003818d0030818902818100aa272700586c0cc41b05c65c7d846f5a2bc27b03\"\r\n                + \"e301c37d9bff6d75b6eb6671ba9596c5c63ba2b1af5c318d9ca39e7400d10c238ac72630579211b86570d1a1d44ec86aa8f6\"\r\n                + \"c9d2b4e283ea3535923f398a312a23eaeacd8d34faaca965cd910b37da4093ef76c13b337c1afab7d1d07e317b41a336baa4\"\r\n                + \"111299f99424408d0203010001a3533051304f0603551d0104483046801015432db116b35d07e4ba89edb2469d7aa120301e\"\r\n                + \"311c301a060355040313135253414b65795472616e73666572436170693182105d2ffff863babc9b4d3c80ab178a4cca3009\"\r\n                + \"06052b0e03021d05000381810081e5535d8eceef265acbc82f6c5f8bc9d84319265f3ccf23369fa533c8dc1938952c593166\"\r\n                + \"2d9ecd8b1e7b81749e48468167e2fce3d019fa70d54646975b6dc2a3ba72d5a5274c1866da6d7a5df47938e034a075d11957\"\r\n                + \"d653b5c78e5291e4401045576f6d4eda81bef3c369af56121e49a083c8d1adb09f291822e99a4296463181d73081d4020101\"\r\n                + \"3032301e311c301a060355040313135253414b65795472616e73666572436170693102105d2ffff863babc9b4d3c80ab178a\"\r\n                + \"4cca300906052b0e03021a0500300d06092a864886f70d010101050004818031a718ea1483c88494661e1d3dedfea0a3d97e\"\r\n                + \"eb64c3e093a628b257c0cfc183ecf11697ac84f2af882b8de0c793572af38dc15d1b6f3d8f2392ba1cc71210e177c146fd16\"\r\n                + \"b77a583b6411e801d7a2640d612f2fe99d87e9718e0e505a7ab9536d71dbde329da21816ce7da1416a74a3e0a112b86b33af\"\r\n                + \"336a2ba6ae2443d0ab\").HexToByteArray();\r\n\r\n            ContentInfo contentInfo = new ContentInfo(new Oid(Oids.Pkcs7Signed), content);\r\n            CertLoader certLoader = Certificates.RSAKeyTransferCapi1;\r\n            string algorithmOidValue = Oids.Aes256;\r\n            SubjectIdentifierType type = SubjectIdentifierType.IssuerAndSerialNumber;\r\n            string certSubjectName;\r\n            byte[] encodedMessage;\r\n            using (X509Certificate2 certificate = certLoader.GetCertificate())\r\n            {\r\n                certSubjectName = certificate.Subject;\r\n                AlgorithmIdentifier alg = new AlgorithmIdentifier(new Oid(algorithmOidValue));\r\n                EnvelopedCms ecms = new EnvelopedCms(contentInfo, alg);\r\n                CmsRecipient cmsRecipient = new CmsRecipient(type, certificate);\r\n                ecms.Encrypt(cmsRecipient);\r\n                encodedMessage = ecms.Encode();\r\n            }\r\n\r\n            Console.WriteLine(Convert.ToBase64String(encodedMessage, Base64FormattingOptions.InsertLineBreaks));\r\n```\r\n\r\nExample Ubuntu output:\r\n\r\n```\r\nMIIERwYJKoZIhvcNAQcDoIIEODCCBDQCAQAxgcwwgckCAQAwMjAeMRwwGgYDVQQDExNSU0FLZXlU\r\ncmFuc2ZlckNhcGkxAhBdL//4Y7q8m008gKsXikzKMA0GCSqGSIb3DQEBAQUABIGAWSteC3DpgylV\r\nMTLUdUy6Yz4dnHALkKQxB3i10K/LHi6nTRu9IBfyZoukCIV6mHpC9y3s1YVkTgoEa1t8BfOw/3Eu\r\nD1TmdELJk+i9g341YL/M6B2JYFBui5ZYOxiOT/MiqiMLXOj58OS/qgkulJJ0/LEgr4dzXIk4jC00\r\nONtNEIgwggNeBgkqhkiG9w0BBwIwHQYJYIZIAWUDBAEqBBCCiF/uBuUUWB18cGguTMnJgIIDMOuR\r\ndWReQHAc7T3nTKzh5vOAuLc7+SWGUQUXOCszjEPaSRWRwpi95kvQHEaskC+rQYm1Y806Tl9PnY1g\r\nip+N0dAVgYyRFpe5Mm6V1EjgvvA+G5JPrhF1ux/uRw2pAKtJgPWKU3FyO/S5Agd1SBhXSDfbi5AT\r\nFwkZuNiDT2tohWxgVX9ysv3TsyXCaRersm4v+i4Az44HdHXg6mroK2N9cmd2UV1MhDF3paAROifl\r\ndsVFqLMhR384lPYTgw/EHE/H4ygb/wRx/PxKCuFl1bkbkZau925CPi3kBhqj0Ev3dizeYOdABr0Q\r\n6T8Q/eiTWawiT1LeJzAUdanu523voMK3n4SS/mABd7kFeCFsI0EAAEyydby8ftf7vmE0e1dLBzCW\r\nZ/3aXRrAIuQFl89OrSlQu2OaasKus2q4MCWQjm4X7r+F2xZfQdccSImFChiH2yspOOIlKVmPLnrC\r\nDxFZLkJ2oBL77vbutqYBJ3XeOHUt6e/r/PT1gAXuMt4XMw1y1lWxmE0pLG08hF23nTD00GEZl+jm\r\n8KnDqsSc6cwPv8vu3LIYOHqyGX5pahcOhAIG/hLzPPBzveqj+FWDR/b/WCgoDW8GXK+uwz99Ebdg\r\n+Onym0Xh/PahYLdVprAqtekn0qR6zABXDqVsNG1GzxAhPkrm7ZWuCRFZxL8InBmnC0oUS8z4+5JH\r\nJQoG661wT/o1HUbm0FWWHG6dz12urMSMEFktKqGCu9VfUrf56P43+mErAYz9VWl7h0BV8kt/WOcZ\r\nrmHuBHLliUanfKDGgF3JBl9Zlw/SJPuryeFikx7jj3FQm3B0e/1I+d2izPbANzBZH8s+/ayy+aLC\r\nsNQNZhKJCbSKUL8RiUc8w1YOS2yauHJNC2cM+p2e7//jouzTegpOBZlTNYn6hif/FVj45I3SMYZj\r\nJ947GiPR8tPa8RUByOqmel4g6yOpAsREQ1oQ/JwBS5JefdJ1EfZvXhqvOFkaJzov2mAnmDFwq8jA\r\nT5VYDXNCCOmQOlP9OHpORTW4ZX7fSwxIJtiBWs/7HVxgniRI93v+gNg2doe80K0yJb5IB3kh7krQ\r\nbo5Du6/623f7IzCOyVHXDg==\r\n\r\n```\r\n\r\nExample Windows output:\r\n\r\n```\r\nMIIERwYJKoZIhvcNAQcDoIIEODCCBDQCAQAxgcwwgckCAQAwMjAeMRwwGgYDVQQDExNSU0FLZXlU\r\ncmFuc2ZlckNhcGkxAhBdL//4Y7q8m008gKsXikzKMA0GCSqGSIb3DQEBAQUABIGApbrDSzyaaJWl\r\ncBGSA9iGchDZ3GcdHtGNwC80ov2mBZ5QApcIeD+QBa0kfhKbOGWVjZuxMeiWKQLumTRLjlYMWyGG\r\nVr1vH2vogWylJzOHgl4a1SzBU512e0kJAj4X/+rxTc3J1BA++zqQwKc2ZMNwBpzwHAr8R9f/0Yqi\r\n6g4cF3cwggNeBgkqhkiG9w0BBwIwHQYJYIZIAWUDBAEqBBCYvXFZhIoVjFhstITvI1eogIIDMDpN\r\nUrvypCXSpPMd0NAsgphvXCnQHnipOKak/hZNA0epyN+HK/YtX6h7YrdTsR1lpbV5oZJGbkKdYuC2\r\nnepkedh1acwNbxa5PbeRJOgpeM/OB4Q/SEANUd00+fn+AteuBvmWTV6EBUQJMpnKlaiAM0rJrdir\r\n8wRyDB/hWQaU4c26yKoYNBzXCp2q6ml/DtPF1i9W9w7VTe3gPjHVTWejqeZHAJ/5CHrL86TImSdU\r\nCf22W2g9jG2VEoFw3gRg6sliDAdDfazBI7koXyqu8kRBPJHPfh5c30UGkFmfUREWhVfI/uldWF7p\r\n3lmHbg7wZKBjbOKZs7lGwRomx7NKp252WHg8mzG1vNZeCKDweKU4lZMBn7YyYfmt3AYFs+dDYVAn\r\n3UUylBEPNHXJCYkDeQNyPcemD15IsKEKOAOnmFNphu3Ra/0SBZKhopqeY+g3BEXJrA8VmNh1Yx3o\r\noOk2ruW94oPD4gLvMYgqelezuYXAZ6/r3vvNvgWTDiaDrjnf9C6hbn381iAjEThooFaRhK0c3TY7\r\nsvahOLQ6aNrp88yoaTLeD9eT9l/ZMyMgvyZxTxsdN5320tM015CTuObsVusKK721ZeMWOsc407xu\r\nl02vLbOU/hejdoZu7XCe0VdzjWmmoTZrbFVZQyJHYmmC3+aWIvrIUSsuxIrATnUkWfpRBqEpAvLu\r\nhELYX6oFN7Xej9pcX3JQVWYMF1pbeV755ckSNqapYLCct0Yjedd8AI5pKolok9q2Be0ablIfRSL/\r\n7vhMyB7nGAdm9iEAnz7CGgLMayE5fApl5Z9MmgOQKB5N8XvHuzhdvypBXoV4WigAiarRMBOhhnMz\r\neEOak8tsXag/lWsyvqr05Khl5SwCVEr/OQafAhkuB//r9LrUOJAy1KTiAlRRckB1wyC4buidS/wI\r\nFUuZ83Zc9dLnJhWGEvCb4QvSgnVFxfgetDOf56HlDwk6Jkna/ox0PhqMgZCORK4BGg9L7WENSuL8\r\n1Dh33SoT4L6BEwF3Zrdu4f475KxcUyv34vaa2w4hcNVl/iYYcKW6L7V9wE9xVtfxSecfBK7khD1U\r\nV19xndleslZ5fSjhrv4s/Q==\r\n```\r\n\r\n</details>\r\n\r\n## 2. Try decrypt document on the platform which it was not generated on\r\n\r\n<details><summary>Test cases (one of those test case passes on any platform, the other one fails)</summary>\r\n\r\n```csharp\r\n        [Fact]\r\n        public static void ReproWindows()\r\n        {\r\n            byte[] expectedContent =\r\n                 (\"3082032506092a864886f70d010702a082031630820312020101310b300906052b0e03021a0500301206092a864886f70d01\"\r\n                + \"0701a0050403010203a08202103082020c30820179a00302010202105d2ffff863babc9b4d3c80ab178a4cca300906052b0e\"\r\n                + \"03021d0500301e311c301a060355040313135253414b65795472616e736665724361706931301e170d313530343135303730\"\r\n                + \"3030305a170d3235303431353037303030305a301e311c301a060355040313135253414b65795472616e7366657243617069\"\r\n                + \"3130819f300d06092a864886f70d010101050003818d0030818902818100aa272700586c0cc41b05c65c7d846f5a2bc27b03\"\r\n                + \"e301c37d9bff6d75b6eb6671ba9596c5c63ba2b1af5c318d9ca39e7400d10c238ac72630579211b86570d1a1d44ec86aa8f6\"\r\n                + \"c9d2b4e283ea3535923f398a312a23eaeacd8d34faaca965cd910b37da4093ef76c13b337c1afab7d1d07e317b41a336baa4\"\r\n                + \"111299f99424408d0203010001a3533051304f0603551d0104483046801015432db116b35d07e4ba89edb2469d7aa120301e\"\r\n                + \"311c301a060355040313135253414b65795472616e73666572436170693182105d2ffff863babc9b4d3c80ab178a4cca3009\"\r\n                + \"06052b0e03021d05000381810081e5535d8eceef265acbc82f6c5f8bc9d84319265f3ccf23369fa533c8dc1938952c593166\"\r\n                + \"2d9ecd8b1e7b81749e48468167e2fce3d019fa70d54646975b6dc2a3ba72d5a5274c1866da6d7a5df47938e034a075d11957\"\r\n                + \"d653b5c78e5291e4401045576f6d4eda81bef3c369af56121e49a083c8d1adb09f291822e99a4296463181d73081d4020101\"\r\n                + \"3032301e311c301a060355040313135253414b65795472616e73666572436170693102105d2ffff863babc9b4d3c80ab178a\"\r\n                + \"4cca300906052b0e03021a0500300d06092a864886f70d010101050004818031a718ea1483c88494661e1d3dedfea0a3d97e\"\r\n                + \"eb64c3e093a628b257c0cfc183ecf11697ac84f2af882b8de0c793572af38dc15d1b6f3d8f2392ba1cc71210e177c146fd16\"\r\n                + \"b77a583b6411e801d7a2640d612f2fe99d87e9718e0e505a7ab9536d71dbde329da21816ce7da1416a74a3e0a112b86b33af\"\r\n                + \"336a2ba6ae2443d0ab\").HexToByteArray();\r\n\r\n            ContentInfo expectedContentInfo = new ContentInfo(new Oid(Oids.Pkcs7Signed), expectedContent);\r\n\r\n            byte[] encodedMessage = Convert.FromBase64String(\r\n                \"MIIERwYJKoZIhvcNAQcDoIIEODCCBDQCAQAxgcwwgckCAQAwMjAeMRwwGgYDVQQDExNSU0FLZXlU\" +\r\n                \"cmFuc2ZlckNhcGkxAhBdL//4Y7q8m008gKsXikzKMA0GCSqGSIb3DQEBAQUABIGAWSteC3DpgylV\" +\r\n                \"MTLUdUy6Yz4dnHALkKQxB3i10K/LHi6nTRu9IBfyZoukCIV6mHpC9y3s1YVkTgoEa1t8BfOw/3Eu\" +\r\n                \"D1TmdELJk+i9g341YL/M6B2JYFBui5ZYOxiOT/MiqiMLXOj58OS/qgkulJJ0/LEgr4dzXIk4jC00\" +\r\n                \"ONtNEIgwggNeBgkqhkiG9w0BBwIwHQYJYIZIAWUDBAEqBBCCiF/uBuUUWB18cGguTMnJgIIDMOuR\" +\r\n                \"dWReQHAc7T3nTKzh5vOAuLc7+SWGUQUXOCszjEPaSRWRwpi95kvQHEaskC+rQYm1Y806Tl9PnY1g\" +\r\n                \"ip+N0dAVgYyRFpe5Mm6V1EjgvvA+G5JPrhF1ux/uRw2pAKtJgPWKU3FyO/S5Agd1SBhXSDfbi5AT\" +\r\n                \"FwkZuNiDT2tohWxgVX9ysv3TsyXCaRersm4v+i4Az44HdHXg6mroK2N9cmd2UV1MhDF3paAROifl\" +\r\n                \"dsVFqLMhR384lPYTgw/EHE/H4ygb/wRx/PxKCuFl1bkbkZau925CPi3kBhqj0Ev3dizeYOdABr0Q\" +\r\n                \"6T8Q/eiTWawiT1LeJzAUdanu523voMK3n4SS/mABd7kFeCFsI0EAAEyydby8ftf7vmE0e1dLBzCW\" +\r\n                \"Z/3aXRrAIuQFl89OrSlQu2OaasKus2q4MCWQjm4X7r+F2xZfQdccSImFChiH2yspOOIlKVmPLnrC\" +\r\n                \"DxFZLkJ2oBL77vbutqYBJ3XeOHUt6e/r/PT1gAXuMt4XMw1y1lWxmE0pLG08hF23nTD00GEZl+jm\" +\r\n                \"8KnDqsSc6cwPv8vu3LIYOHqyGX5pahcOhAIG/hLzPPBzveqj+FWDR/b/WCgoDW8GXK+uwz99Ebdg\" +\r\n                \"+Onym0Xh/PahYLdVprAqtekn0qR6zABXDqVsNG1GzxAhPkrm7ZWuCRFZxL8InBmnC0oUS8z4+5JH\" +\r\n                \"JQoG661wT/o1HUbm0FWWHG6dz12urMSMEFktKqGCu9VfUrf56P43+mErAYz9VWl7h0BV8kt/WOcZ\" +\r\n                \"rmHuBHLliUanfKDGgF3JBl9Zlw/SJPuryeFikx7jj3FQm3B0e/1I+d2izPbANzBZH8s+/ayy+aLC\" +\r\n                \"sNQNZhKJCbSKUL8RiUc8w1YOS2yauHJNC2cM+p2e7//jouzTegpOBZlTNYn6hif/FVj45I3SMYZj\" +\r\n                \"J947GiPR8tPa8RUByOqmel4g6yOpAsREQ1oQ/JwBS5JefdJ1EfZvXhqvOFkaJzov2mAnmDFwq8jA\" +\r\n                \"T5VYDXNCCOmQOlP9OHpORTW4ZX7fSwxIJtiBWs/7HVxgniRI93v+gNg2doe80K0yJb5IB3kh7krQ\" +\r\n                \"bo5Du6/623f7IzCOyVHXDg==\");\r\n\r\n            CertLoader certLoader = Certificates.RSAKeyTransferCapi1;\r\n            VerifySimpleDecrypt(encodedMessage, certLoader, expectedContentInfo);\r\n        }\r\n\r\n        [Fact]\r\n        public static void ReproUbuntu()\r\n        {\r\n            byte[] expectedContent =\r\n                 (\"3082032506092a864886f70d010702a082031630820312020101310b300906052b0e03021a0500301206092a864886f70d01\"\r\n                + \"0701a0050403010203a08202103082020c30820179a00302010202105d2ffff863babc9b4d3c80ab178a4cca300906052b0e\"\r\n                + \"03021d0500301e311c301a060355040313135253414b65795472616e736665724361706931301e170d313530343135303730\"\r\n                + \"3030305a170d3235303431353037303030305a301e311c301a060355040313135253414b65795472616e7366657243617069\"\r\n                + \"3130819f300d06092a864886f70d010101050003818d0030818902818100aa272700586c0cc41b05c65c7d846f5a2bc27b03\"\r\n                + \"e301c37d9bff6d75b6eb6671ba9596c5c63ba2b1af5c318d9ca39e7400d10c238ac72630579211b86570d1a1d44ec86aa8f6\"\r\n                + \"c9d2b4e283ea3535923f398a312a23eaeacd8d34faaca965cd910b37da4093ef76c13b337c1afab7d1d07e317b41a336baa4\"\r\n                + \"111299f99424408d0203010001a3533051304f0603551d0104483046801015432db116b35d07e4ba89edb2469d7aa120301e\"\r\n                + \"311c301a060355040313135253414b65795472616e73666572436170693182105d2ffff863babc9b4d3c80ab178a4cca3009\"\r\n                + \"06052b0e03021d05000381810081e5535d8eceef265acbc82f6c5f8bc9d84319265f3ccf23369fa533c8dc1938952c593166\"\r\n                + \"2d9ecd8b1e7b81749e48468167e2fce3d019fa70d54646975b6dc2a3ba72d5a5274c1866da6d7a5df47938e034a075d11957\"\r\n                + \"d653b5c78e5291e4401045576f6d4eda81bef3c369af56121e49a083c8d1adb09f291822e99a4296463181d73081d4020101\"\r\n                + \"3032301e311c301a060355040313135253414b65795472616e73666572436170693102105d2ffff863babc9b4d3c80ab178a\"\r\n                + \"4cca300906052b0e03021a0500300d06092a864886f70d010101050004818031a718ea1483c88494661e1d3dedfea0a3d97e\"\r\n                + \"eb64c3e093a628b257c0cfc183ecf11697ac84f2af882b8de0c793572af38dc15d1b6f3d8f2392ba1cc71210e177c146fd16\"\r\n                + \"b77a583b6411e801d7a2640d612f2fe99d87e9718e0e505a7ab9536d71dbde329da21816ce7da1416a74a3e0a112b86b33af\"\r\n                + \"336a2ba6ae2443d0ab\").HexToByteArray();\r\n\r\n            ContentInfo expectedContentInfo = new ContentInfo(new Oid(Oids.Pkcs7Signed), expectedContent);\r\n\r\n            byte[] encodedMessage = Convert.FromBase64String(\r\n                \"MIIERwYJKoZIhvcNAQcDoIIEODCCBDQCAQAxgcwwgckCAQAwMjAeMRwwGgYDVQQDExNSU0FLZXlU\" +\r\n                \"cmFuc2ZlckNhcGkxAhBdL//4Y7q8m008gKsXikzKMA0GCSqGSIb3DQEBAQUABIGApbrDSzyaaJWl\" +\r\n                \"cBGSA9iGchDZ3GcdHtGNwC80ov2mBZ5QApcIeD+QBa0kfhKbOGWVjZuxMeiWKQLumTRLjlYMWyGG\" +\r\n                \"Vr1vH2vogWylJzOHgl4a1SzBU512e0kJAj4X/+rxTc3J1BA++zqQwKc2ZMNwBpzwHAr8R9f/0Yqi\" +\r\n                \"6g4cF3cwggNeBgkqhkiG9w0BBwIwHQYJYIZIAWUDBAEqBBCYvXFZhIoVjFhstITvI1eogIIDMDpN\" +\r\n                \"UrvypCXSpPMd0NAsgphvXCnQHnipOKak/hZNA0epyN+HK/YtX6h7YrdTsR1lpbV5oZJGbkKdYuC2\" +\r\n                \"nepkedh1acwNbxa5PbeRJOgpeM/OB4Q/SEANUd00+fn+AteuBvmWTV6EBUQJMpnKlaiAM0rJrdir\" +\r\n                \"8wRyDB/hWQaU4c26yKoYNBzXCp2q6ml/DtPF1i9W9w7VTe3gPjHVTWejqeZHAJ/5CHrL86TImSdU\" +\r\n                \"Cf22W2g9jG2VEoFw3gRg6sliDAdDfazBI7koXyqu8kRBPJHPfh5c30UGkFmfUREWhVfI/uldWF7p\" +\r\n                \"3lmHbg7wZKBjbOKZs7lGwRomx7NKp252WHg8mzG1vNZeCKDweKU4lZMBn7YyYfmt3AYFs+dDYVAn\" +\r\n                \"3UUylBEPNHXJCYkDeQNyPcemD15IsKEKOAOnmFNphu3Ra/0SBZKhopqeY+g3BEXJrA8VmNh1Yx3o\" +\r\n                \"oOk2ruW94oPD4gLvMYgqelezuYXAZ6/r3vvNvgWTDiaDrjnf9C6hbn381iAjEThooFaRhK0c3TY7\" +\r\n                \"svahOLQ6aNrp88yoaTLeD9eT9l/ZMyMgvyZxTxsdN5320tM015CTuObsVusKK721ZeMWOsc407xu\" +\r\n                \"l02vLbOU/hejdoZu7XCe0VdzjWmmoTZrbFVZQyJHYmmC3+aWIvrIUSsuxIrATnUkWfpRBqEpAvLu\" +\r\n                \"hELYX6oFN7Xej9pcX3JQVWYMF1pbeV755ckSNqapYLCct0Yjedd8AI5pKolok9q2Be0ablIfRSL/\" +\r\n                \"7vhMyB7nGAdm9iEAnz7CGgLMayE5fApl5Z9MmgOQKB5N8XvHuzhdvypBXoV4WigAiarRMBOhhnMz\" +\r\n                \"eEOak8tsXag/lWsyvqr05Khl5SwCVEr/OQafAhkuB//r9LrUOJAy1KTiAlRRckB1wyC4buidS/wI\" +\r\n                \"FUuZ83Zc9dLnJhWGEvCb4QvSgnVFxfgetDOf56HlDwk6Jkna/ox0PhqMgZCORK4BGg9L7WENSuL8\" +\r\n                \"1Dh33SoT4L6BEwF3Zrdu4f475KxcUyv34vaa2w4hcNVl/iYYcKW6L7V9wE9xVtfxSecfBK7khD1U\" +\r\n                \"V19xndleslZ5fSjhrv4s/Q==\");\r\n\r\n            CertLoader certLoader = Certificates.RSAKeyTransferCapi1;\r\n            VerifySimpleDecrypt(encodedMessage, certLoader, expectedContentInfo);\r\n        }\r\n```\r\n\r\nError on Windows:\r\n\r\n```\r\n   System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.ReproWindows [FAIL]\r\n      Assert.Equal() Failure\r\n      Expected: Byte[] [48, 130, 3, 37, 6, ...]\r\n      Actual:   Byte[] [48, 130, 3, 41, 48, ...]\r\n      Stack Trace:\r\n         F:\\src\\corefx4\\src\\System.Security.Cryptography.Pkcs\\tests\\EnvelopedCms\\DecryptTests.cs(692,0): at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.VerifySimpleDecrypt(Byte[] encodedMessage, CertLoader certLoader, ContentInfo expectedContent)\r\n         F:\\src\\corefx4\\src\\System.Security.Cryptography.Pkcs\\tests\\EnvelopedCms\\DecryptTests.cs(84,0): at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.ReproWindows()\r\n```\r\n\r\nError on Ubuntu:\r\n\r\n```\r\n     System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.ReproUbuntu [FAIL]\r\n        Assert.Equal() Failure\r\n        Expected: Byte[] [48, 130, 3, 37, 6, ...]\r\n        Actual:   Byte[] [6, 9, 42, 134, 72, ...]\r\n        Stack Trace:\r\n           /home/krwq/src/corefx/src/System.Security.Cryptography.Pkcs/tests/EnvelopedCms/DecryptTests.cs(717,0): at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.VerifySimpleDecrypt(Byte[] encodedMessage, CertLoader certLoader, ContentInfo expectedContent)\r\n           /home/krwq/src/corefx/src/System.Security.Cryptography.Pkcs/tests/EnvelopedCms/DecryptTests.cs(248,0): at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.ReproUbuntu()\r\n\r\n```\r\n\r\n</details>\r\n\r\ncc: @bartonjs @AlexGhiondea @joshfree \r\n\r\nEDIT: Also seeing similar issue with: `ContentInfo expectedContentInfo = new ContentInfo(new Oid(Oids.Pkcs7SignedEnveloped), content);` (EnvelopedWithinEnveloped)\r\n"},{"Id":"7822755869","Type":"PullRequestEvent","CreatedAt":"2018-06-14T04:37:45","Actor":"bartonjs","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30381","RelatedDescription":"Opened pull request \"[release/2.1] Fix SignedCms handling of negative certificate serial numbers.\" (#30381) at dotnet/corefx","RelatedBody":"The AsnSerializer normalized ReadOnlyMemory versions of Integer values to\r\nunsigned interpretations on Serialize, but Deserialize read values as-is.  So\r\nsigning a SignedCms with a negative-valued certificate serial, or creating an\r\nEnvelopedCms with a negative-valued recipient serial changed the\r\nrepresentation of the serial number in the encoded file.\r\n\r\nThis change fixes the serializer to do a pass-through by adding the missing\r\n\"just use these bytes\" method to AsnWriter.  Then fixes the one place counting\r\non this behavior, and adds a number of tests to prevent regressions.\r\n\r\nFixes #29691."},{"Id":"7822417930","Type":"PullRequestEvent","CreatedAt":"2018-06-14T02:21:44","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30378","RelatedDescription":"Merged pull request \"Move #pragma warning disable BCL0015 to baseline files\" (#30378) at dotnet/corefx","RelatedBody":"This makes it easy to see which libraries are not safe on OneCore based SKU's by making them all consistently use the baseline files. This also makes it easy to see what the violations are, without building. Plus baseline files can be made target group specific.\r\n\r\nI spent some time debugging Roslyn before realizing this was why violations in DirectoryServices were not failing the build. 😊 "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7822819251","Type":"IssuesEvent","CreatedAt":"2018-06-14T05:04:43","Actor":"davkean","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/27820","RelatedDescription":"Opened issue \"[Regression] Visual Studio crashes if you reopen Options with the code style page open\" (#27820) at dotnet/roslyn","RelatedBody":"**Version Used**: \r\nVersion 15.8.0 Preview 3.0 [27807.3004.d15.8stg]\r\n\r\nThis does not repo in 15.8 Preview 2.0, however, is a 100% repro in the build above.\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Tools -> Options -> Text Editor -> C# -> Code Style\r\n2. Click OK\r\n3. Tools -> Options\r\n\r\n-- Crash --\r\n\r\nsrc\\Editor\\Text\\Impl\\WpfView\\WpfTextView.cs\r\n\r\n``` C#\r\n       IWpfTextViewLine IWpfTextView.GetTextViewLineContainingBufferPosition(SnapshotPoint bufferPosition)\r\n        {\r\n            if (_textViewLinesCollection == null)\r\n                throw new InvalidOperationException(\"GetTextViewLineContainingBufferPosition called before view is fully initialized.\");\r\n\r\n            if (_isClosed)\r\n                throw new InvalidOperationException(\"GetTextViewLineContainingBufferPosition called after the view is closed\"); <!-- Throws\r\n```\r\n\r\n```\r\n>\tMicrosoft.VisualStudio.Platform.VSEditor.dll!Microsoft.VisualStudio.Text.Editor.Implementation.WpfTextView.Microsoft.VisualStudio.Text.Editor.IWpfTextView.GetTextViewLineContainingBufferPosition(Microsoft.VisualStudio.Text.SnapshotPoint bufferPosition) Line 942\tC#\r\n \tMicrosoft.VisualStudio.Platform.VSEditor.dll!Microsoft.VisualStudio.Text.Editor.Implementation.WpfTextView.GetTextViewLineContainingBufferPosition(Microsoft.VisualStudio.Text.SnapshotPoint bufferPosition) Line 933\tC#\r\n \tMicrosoft.VisualStudio.Platform.VSEditor.dll!Microsoft.VisualStudio.Text.MultiSelection.Implementation.SelectionUIProperties.ContainingTextViewLine.get() Line 77\tC#\r\n \tMicrosoft.VisualStudio.Platform.VSEditor.dll!Microsoft.VisualStudio.Text.MultiSelection.Implementation.SelectionUIProperties.IsWithinViewport.get() Line 112\tC#\r\n \tMicrosoft.VisualStudio.Platform.VSEditor.dll!Microsoft.VisualStudio.Text.MultiSelection.Implementation.UI.AccessibleCaret.OnViewVisibilityChanged(object sender, System.Windows.DependencyPropertyChangedEventArgs e) Line 109\tC#\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseDependencyPropertyChanged(System.Windows.EventPrivateKey key, System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tMicrosoft.VisualStudio.Platform.VSEditor.dll!Microsoft.VisualStudio.Text.Editor.Implementation.WpfTextView.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e) Line 1567\tC#\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.InvalidateForceInheritPropertyOnChildren(System.Windows.Media.Visual v, System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.InvalidateForceInheritPropertyOnChildren(System.Windows.DependencyProperty property)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnIsVisibleChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)\tUnknown\r\n \tWindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.UpdateIsVisibleCache()\tUnknown\r\n \tPresentationCore.dll!System.Windows.PresentationSource.RootChanged(System.Windows.Media.Visual oldRoot, System.Windows.Media.Visual newRoot)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\tUnknown\r\n \tWindowsFormsIntegration.dll!System.Windows.Forms.Integration.ElementHost.OnHandleCreated.AnonymousMethod__54_0()\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Invoke(System.Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, System.TimeSpan timeout)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Invoke(System.Action callback)\tUnknown\r\n \tWindowsFormsIntegration.dll!System.Windows.Forms.Integration.ElementHost.OnHandleCreated(System.EventArgs e)\tUnknown\r\n \tMicrosoft.VisualStudio.Shell.15.0.dll!Microsoft.VisualStudio.Shell.UIElementDialogPage.DialogPageElementHost.OnHandleCreated(System.EventArgs e)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.Control.WmCreate(ref System.Windows.Forms.Message m)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.Control.WndProc(ref System.Windows.Forms.Message m)\tUnknown\r\n \tWindowsFormsIntegration.dll!System.Windows.Forms.Integration.ElementHost.WndProc(ref System.Windows.Forms.Message m)\tUnknown\r\n \tMicrosoft.VisualStudio.Shell.15.0.dll!Microsoft.VisualStudio.Shell.UIElementDialogPage.DialogPageElementHost.WndProc(ref System.Windows.Forms.Message m)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.Control.ControlNativeWindow.OnMessage(ref System.Windows.Forms.Message m)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.Control.ControlNativeWindow.WndProc(ref System.Windows.Forms.Message m)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.NativeWindow.DebuggableCallback(System.IntPtr hWnd, int msg, System.IntPtr wparam, System.IntPtr lparam)\tUnknown\r\n \t[Native to Managed Transition]\t\r\n \tuser32.dll!738bbe6b()\tUnknown\r\n \t[Frames below may be incorrect and/or missing, no symbols loaded for user32.dll]\tUnknown\r\n \tuser32.dll!738b833a()\tUnknown\r\n \tuser32.dll!738b7eda()\tUnknown\r\n \tuser32.dll!738baad3()\tUnknown\r\n \tntdll.dll!_KiUserCallbackDispatcher@12() Line 517\tUnknown\r\n \twin32u.dll!74d1321c()\tUnknown\r\n \tuser32.dll!738b273d()\tUnknown\r\n \tntdll.dll!_ZwQueryAttributesFile@8() Line 585\tUnknown\r\n \tntdll.dll!LdrpGetNtPathFromDosPath(const _UNICODE_STRING * DosPath, _LDRP_FILENAME_BUFFER * NtPath) Line 2880\tC\r\n \tSystem.Windows.Forms.ni.dll!52131b7f()\tUnknown\r\n \t[Managed to Native Transition]\t\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.UnsafeNativeMethods.CreateWindowEx(int dwExStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, System.Runtime.InteropServices.HandleRef hWndParent, System.Runtime.InteropServices.HandleRef hMenu, System.Runtime.InteropServices.HandleRef hInst, object pvParam)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams cp)\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.Control.CreateHandle()\tUnknown\r\n \tSystem.Windows.Forms.dll!System.Windows.Forms.Control.Handle.get()\tUnknown\r\n \tMicrosoft.VisualStudio.Shell.15.0.dll!Microsoft.VisualStudio.Shell.DialogPage.System.Windows.Forms.IWin32Window.Handle.get()\tUnknown\r\n \tMicrosoft.VisualStudio.Shell.15.0.dll!Microsoft.VisualStudio.Shell.Package.Microsoft.VisualStudio.Shell.Interop.IVsPackage.GetPropertyPage(ref System.Guid rguidPage, Microsoft.VisualStudio.Shell.Interop.VSPROPSHEETPAGE[] ppage)\tUnknown\r\n\r\n```"}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7822674732","Type":"PullRequestEvent","CreatedAt":"2018-06-14T04:01:05","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5938","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5938) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7822404960","Type":"PullRequestEvent","CreatedAt":"2018-06-14T02:16:59","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corert/pull/5920","RelatedDescription":null,"RelatedBody":""},{"Id":"7822404863","Type":"PullRequestEvent","CreatedAt":"2018-06-14T02:16:57","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5920","RelatedDescription":"Closed pull request \"Update RyuJIT\" (#5920) at dotnet/corert","RelatedBody":""},{"Id":"7822403579","Type":"PullRequestEvent","CreatedAt":"2018-06-14T02:16:28","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corert/pull/5920","RelatedDescription":null,"RelatedBody":""},{"Id":"7822403481","Type":"PullRequestEvent","CreatedAt":"2018-06-14T02:16:26","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5920","RelatedDescription":"Closed pull request \"Update RyuJIT\" (#5920) at dotnet/corert","RelatedBody":""},{"Id":"7822312255","Type":"PullRequestEvent","CreatedAt":"2018-06-14T01:42:50","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5938","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5938) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7821601899","Type":"PullRequestEvent","CreatedAt":"2018-06-13T21:49:20","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5592","RelatedDescription":"Merged pull request \"Dwarf: add support for static members\" (#5592) at dotnet/corert","RelatedBody":"- change CU lang from C89 to C_plus_plus\r\n\r\n- ungroup gc, non-gc and thread statics in debuginfo"},{"Id":"7821489450","Type":"IssuesEvent","CreatedAt":"2018-06-13T21:24:46","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5905","RelatedDescription":"Closed issue \"Can't build native UWP app. ILC.exe, always a 32-bit image, fails with: Internal compiler error: Exception of type 'System.OutOfMemoryException' was thrown.\" (#5905) at dotnet/corert","RelatedBody":"I'm trying to build a UWP unit test app in Release mode using the **Compile with .NET Native tool chain** option enabled. My UWP app's minimum and target versions are both set to Windows 10 build 16299. I'm using Visual Studio 15.7.3, and the build always fails because ILC.exe runs out of memory: \r\n\r\n> `Internal compiler error: Exception of type 'System.OutOfMemoryException' was thrown.`\r\n\r\nI could see that the ILC.exe executable is a 32-bit image and isn't able to take advantage of most of the 32GB memory available on my box. ILC.exe failed after allocating about 3.4GB memory.\r\n\r\nI tried to get Visual Studio to invoke a 64-bit ILC.exe using in each of the following ways, but ILC.exe is, according to Process Explorer, always running as a 32-bit process.\r\n\r\n1. I tried adding `<UseNativeEnvironment>true</UseNativeEnvironment>` to my UWP project's default `<PropertyGroup>` element. I found a mention of this in relation to Visual C++, so I might have been barking up the wrong tree for a C# app on UWP.\r\n\r\n2. I tried adding `<Use64BitCompiler>true</Use64BitCompiler>` to my UWP project's default `<PropertyGroup>` element. I had found this mentioned at https://github.com/dotnet/corert/issues/5604. \r\n\r\n3. I tried explicitly referencing the package `runtime.win10-x64.Microsoft.Net.Native.Compiler` v2.1.8 in my UWP project. The package description says:\r\n\r\n    > .Net Native Compilers package. Referencing this package will cause the project to be built using the specific version of the .NET Native compiler contained in the package, as opposed to any system installed version.\r\n\r\nWhile it *does* appear that the correct package folder is referenced and a `tools\\x64\\ilc\\ilc.exe` image is being executed by Visual Studio, **the ILC.exe process remains a 32-bit process** even despite the `x64` claimed by parent folder naming. Here's what Process Explorer shows:\r\n\r\n![ilc_not_x64](https://user-images.githubusercontent.com/3652107/41055051-33d05b46-698e-11e8-8cce-c91876c81376.png)\r\n\r\nAm I doing something wrong?\r\n\r\nOr is the ILC.exe that is shipped as part of `runtime.win10-x64.Microsoft.Net.Native.Compiler` actually a 32-bit program image and not a 64-bit program image? And if it is actually a 32-bit program image, is that by design, or an oversight?\r\n\r\nHow can I get my UWP app building with the native tool chain? Thank you."},{"Id":"7821474471","Type":"PullRequestEvent","CreatedAt":"2018-06-13T21:21:35","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5937","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5937) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1007054749512814592","CreatedAt":"2018-06-14T00:18:57+00:00","UserScreenname":"dotnet","Text":"Using .NET and Docker Together – DockerCon 2018 Update https://t.co/ZYju7lEGqz","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":55,"FavoriteCount":32,"RawContent":null},{"Id":"1007012327353454594","CreatedAt":"2018-06-13T21:30:22+00:00","UserScreenname":"dotnet","Text":"Join @csharpfritz tomorrow to learn how to use @AppInsights with your #ASP.NET Core project. https://t.co/pSofjdde2Y","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":13,"FavoriteCount":7,"RawContent":null},{"Id":"1005426264029753345","CreatedAt":"2018-06-09T12:27:55+00:00","UserScreenname":"dotnet","Text":"Tune in today at 10a ET / 7a PT / 14:00 UTC / 8p IST and learn about global tools along with Jeff. https://t.co/hqxNjfqPMq","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":5,"RawContent":null},{"Id":"1005082168442449920","CreatedAt":"2018-06-08T13:40:37+00:00","UserScreenname":"dotnet","Text":"Tune in with Jeff as he works through the tutorials to learn F#.  Ask questions, and learn along with him https://t.co/rntL0szWYX","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":34,"FavoriteCount":16,"RawContent":null},{"Id":"1004145068381331456","CreatedAt":"2018-06-05T23:36:55+00:00","UserScreenname":"dotnet","Text":"Cool retro game built with #dotnet #monogame. Clone the repo, play the game, and you could win some serious money!… https://t.co/iHu2MQ1bME","Source":"<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>","RetweetCount":70,"FavoriteCount":20,"RawContent":null}]}},"RunOn":"2018-06-14T05:30:33.8293571Z","RunDurationInMilliseconds":7718}