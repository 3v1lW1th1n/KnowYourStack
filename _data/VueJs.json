{"Data":{"Vue":{"Events":[{"Id":"7059661484","Type":"IssuesEvent","CreatedAt":"2018-01-05T03:10:17","Actor":"chenfengjw163","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue/issues/7386","RelatedDescription":"Opened issue \"父组件中部分组件发生状态改变，会引发子slot组件render两次\" (#7386) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://codepen.io/chenfeng163/pen/VyMrQy](https://codepen.io/chenfeng163/pen/VyMrQy)\r\n\r\n### Steps to reproduce\r\n父组件中部分组件发生状态改变，会引发子slot组件render两次\r\n\r\n### What is expected?\r\n父组件其他组件状态更新的时候不要影响slot组件的render\r\n\r\n### What is actually happening?\r\n子组件渲染两次\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7059531266","Type":"IssuesEvent","CreatedAt":"2018-01-05T02:17:27","Actor":"trusktr","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue/issues/7385","RelatedDescription":"Opened issue \"Generated style not passing through shadow root boundary.\" (#7385) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://codepen.io/anon/pen/ppWdEX?editors=1010](https://codepen.io/anon/pen/ppWdEX?editors=1010)\r\n\r\n### Steps to reproduce\r\nI'm trying to \"incrementally adopt\" Vue into a project again.\r\n\r\nSeems that Vue doesn't consider what happens when a Vue component is mounted inside of a shadow root.\r\n\r\nThe component's style gets placed into the `<head>` of the web app, and therefore the style is not able to style the elements generated by the Vue component that are inside the shadow root.\r\n\r\nIs there a way to configure Vue to place the `<style>` element as a sibling of the rendered output, or somewhere else? I need the generated `style` to be placed inside the shadow root, otherwise it has no effect (`scoped` or not).\r\n\r\n---\r\n\r\nHere's a reproduction:\r\n\r\nThis pen works:\r\n\r\nhttps://codepen.io/saawsan/pen/jayzeq\r\n\r\nand this one doesn't:\r\n\r\nhttps://codepen.io/anon/pen/ppWdEX\r\n\r\nAs you can see the app works (click the buttons) but nothing is styled.\r\n\r\n### What is expected?\r\nThe app should be styled.\r\n\r\n### What is actually happening?\r\nIt isn't because the styles are placed in the `<head>` and they don't propagate into the shadow root.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"},"Router":{"Events":[{"Id":"7056175833","Type":"IssuesEvent","CreatedAt":"2018-01-04T11:37:28","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1954","RelatedDescription":"Closed issue \"<router-link> scroll issue\" (#1954) at vuejs/vue-router","RelatedBody":"### Version\r\n3.0.1\r\n\r\n### Reproduction link\r\n[https://jsfiddle.net/u8egqj0q/](https://jsfiddle.net/u8egqj0q/)\r\n\r\n### Steps to reproduce\r\nClick to \"router-link to Thirteen\"\r\n\r\n### What is expected?\r\nThe same behavior as when clicking <a href>(scroll to element, change window.location)\r\n\r\n### What is actually happening?\r\nOnly App.$route changed\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7055700266","Type":"IssuesEvent","CreatedAt":"2018-01-04T09:33:26","Actor":"vue-issue-bot","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1963","RelatedDescription":"Closed issue \"vue-router 无论是hash模式还是history模式在ios微信浏览器中进入哪个页面复制链接或选择safari打开都是第一次进入的那个页面\" (#1963) at vuejs/vue-router","RelatedBody":"在ios微信浏览器中，vue+vue-router的项目无论点击哪个页面跳转到其他路由，选择复制链接或是用safari打开都是第一次访问的页面。之前的issues提到可以每次进入url用jssdk重新获取签名，实践发现：\r\n\r\n1.ios每次访问变化的url，用该url调wx.config报错：invalid signature。\r\n2.只在页面首次打开config一次也并不能解决。\r\n3.每次打开变化的url，用第一次打开的url去调wx.config不会报签名无效的错误，但是复制链接依然是第一次打开的url。"},{"Id":"7055677303","Type":"IssuesEvent","CreatedAt":"2018-01-04T09:27:39","Actor":"vue-issue-bot","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1962","RelatedDescription":"Closed issue \"vue-router 无论是hash模式还是history模式在ios微信浏览器中无论进入哪个页面复制链接或选择safari打开都是第一次进入的那个页面\" (#1962) at vuejs/vue-router","RelatedBody":"项目测试地址 [http://h5.tianbula.com](http://h5.tianbula.com)\r\n无论点击哪个页面跳转到其他路由，选择复制链接或是用safari打开都是第一次访问的页面。之前的issues提到可以每次进入url用jssdk重新获取签名，实践发现：\r\n1. ios每次访问变化的url，用该url调wx.config报错：invalid signature。\r\n2.只在页面首次打开config一次也并不能解决。\r\n3.每次打开变化的url，用第一次打开的url去调wx.config不会报签名无效的错误，但是复制链接依然是第一次打开的url。\r\n"},{"Id":"7055677266","Type":"IssuesEvent","CreatedAt":"2018-01-04T09:27:39","Actor":"inmWang","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1962","RelatedDescription":"Opened issue \"vue-router 无论是hash模式还是history模式在ios微信浏览器中无论进入哪个页面复制链接或选择safari打开都是第一次进入的那个页面\" (#1962) at vuejs/vue-router","RelatedBody":"项目测试地址 [http://h5.tianbula.com](http://h5.tianbula.com)\r\n无论点击哪个页面跳转到其他路由，选择复制链接或是用safari打开都是第一次访问的页面。之前的issues提到可以每次进入url用jssdk重新获取签名，实践发现：\r\n1. ios每次访问变化的url，用该url调wx.config报错：invalid signature。\r\n2.只在页面首次打开config一次也并不能解决。\r\n3.每次打开变化的url，用第一次打开的url去调wx.config不会报签名无效的错误，但是复制链接依然是第一次打开的url。\r\n"}],"ResultType":"GitHubEvent"},"Vuex":{"Events":[{"Id":"7059324092","Type":"IssuesEvent","CreatedAt":"2018-01-05T00:50:08","Actor":"gdelazzari","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/1123","RelatedDescription":"Opened issue \"Getters proposal\" (#1123) at vuejs/vuex","RelatedBody":"### What problem does this feature solve?\r\nBetter API consistency, IMHO.\r\n\r\nThere are getters, mutations and actions.\r\nAs for mutations, you use the `$store.commit('mutation-name', stuff)` syntax while for actions you do `$store.dispatch('action-name', stuff)`, which is really nice. But, as for getters, the current approach is `$store.getters.getter-name`.\r\n\r\nFrom a user perspective, I think there's a nicer option that wouldn't also break backwards compatibility since both ways could coexist without any problem.\r\n\r\n### What does the proposed API look like?\r\nSimilar to mutations and actions, I think `$store.getter('getter-name')` could be a better way to call getters.\r\n\r\nThis way the syntax for getters, mutations and actions would be more similar:\r\n\r\n```js\r\n$store.getter('name')\r\n$store.commit('name', data)\r\n$store.dispatch('name', data)\r\n```\r\n\r\n**Note:** I'm not specifically proposing `.getter('name')`. It may be something else like `.fetch(...)` or `.pull(...)` or whatever (the best thing would have been `$store.get('name')` in my opinion, but `.get` is already a JavaScript method on objects so... no way I guess). What I mean is to use a function call like what happens to \"use\" mutations and actions.\r\n\r\nI understand this is totally subjective and I am not expecting everyone to agree on this proposal, but I see this approach as a much cleaner and consistent one.\r\n\r\nAlso, I understand this is just a minor \"thing\" (not even a problem) but I wanted to express my idea anyway in case someone else would find this interesting and/or having any sense.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7059180929","Type":"IssuesEvent","CreatedAt":"2018-01-04T23:53:59","Actor":"TheJaredWilcurt","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/1122","RelatedDescription":"Opened issue \"Some code examples in documentation are mentally exhausting\" (#1122) at vuejs/vuex","RelatedBody":"### What problem does this feature solve?\r\nThere are many code examples in the documentation that are mentally exhausting. The first chunk of the documentation is okay. Once you start into the \"Core Concepts\" section though, the code examples begin to wreak of \"I-am-so-clever\" syndrome. The goal of these sections (State, Getters, Mutations, etc) should be to help the reader understand the *concepts*. When doing so, there should be simple, easy to parse code examples to act as more concrete forms of the concepts being taught.\r\n\r\nBut the examples are optimized for fewest lines of code when they should be optimized for ease of readability. I'm having to mentally break down what each one is doing because they don't follow the \"one idea per line\" rule. And at some point I just get so tired and exhausted that I can't understand it anymore.\r\n\r\nSo the examples being shown end up draining me of mental energy so I can't proceed any further into the concepts I actually came for.\r\n\r\n### What does the proposed API look like?\r\nHere is an existing example I'd like to dissect:\r\n\r\n```js\r\ngetters: {\r\n    // ...\r\n    getTodoById: (state) => (id) => {\r\n        return state.todos.find(todo => todo.id === id)\r\n    }\r\n}\r\n```\r\n\r\nFirst off, why is there a `// ...`???? What is that there for? I assume it's meant to say \"In the real world, there would be other getters too\". Not needed, get rid of it.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: (state) => (id) => {\r\n        return state.todos.find(todo => todo.id === id)\r\n    }\r\n}\r\n```\r\n\r\nNext, little rocket ships going into other little rocket ships is hard to parse both visually and mentally. The problem here lies in over abuse of arrow functions. They are designed with phantom words and exformation. Let's put those phantom words (function, return) back in so we are being clear and verbose about what is trying to be conveyed.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: function (state) {\r\n        return function (id) {\r\n            return state.todos.find(function (todo) {\r\n                return todo.id === id\r\n            })\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe above is no different than before, it's just functions with all the words put back in, but suddenly it starts to look off. This is a sign of arrow function abuse.\r\n\r\nLet's try an experiment where we make the code as verbose as possible, naming every variable and having no shortcuts.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: function (state) {\r\n        function findTodoWithMatchingId (id) {\r\n            const todos = state.todos\r\n            const matchingTodo = todos.find(function (todo) {\r\n                if (todo.id === id) {\r\n                    return true\r\n                }\r\n                return false\r\n            })\r\n            return matchingTodo\r\n        }\r\n        return findTodoWithMatchingId\r\n    }\r\n}\r\n```\r\n\r\nSo, from this experiment we can see that someone thought \"I'm so clever, I bet I can squeeze 15 lines into 5!\". Now, some squeezing is fine, some usage of arrow functions can make sense. Like with `.find`, or `.filter`, or other simple similar prototype methods. So, let's squeeze that verbose version down, but only a little, to get us somewhere between the two extremes.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: (state) => {\r\n        function findTodoWithMatchingId (id) {\r\n            const todos = state.todos\r\n            const matchingTodo = todos.find(todo => todo.id === id)\r\n            return matchingTodo\r\n        }\r\n        return findTodoWithMatchingId\r\n    }\r\n}\r\n```\r\n\r\nWith this approach, we prioritize naming variables to give meaning, and separating ideas out to individual lines to make skimming/parsing easier. There's definitely wiggle room around what should/shouldn't be compressed when aiming for ease of reading.\r\n\r\nNow the downside of this approach is that you lose some hipster cred. But the upside is that it's verbose and clear, and can be skimmed to understand what is happening. You don't need to mentally unpack 15 lines of meaning out of the 5 lines given. There is no guesswork going on while trying to keep track of the obscured meaning.\r\n\r\nAnyone can look at the last example shown and see ways to compress it and write it differently. If a reader copies that code as the basis of their own code, they'll likely modify it to match the style of their existing code. Which is fine, but as a source of documentation aimed at teaching concepts, it should be the priority of the code to be easily understood.\r\n\r\nThis process of having to mentally translate the code wastes mental energy on tasks unrelated to the goal of understanding the concepts.\r\n\r\n**Note:** My point isn't \"fix this one example\", it's \"most of your examples are like this and it becomes exhausting\".\r\n\r\nI'm sure the code wasn't written by someone literally saying \"look at me, I'm clever, I can do *this*\". I'm sure there's some style guide or linter that is enforcing consistency. But my point is that following it religiously leads to hard to read code, or that it's settings are too strict in ES6 enforcement and don't lend themselves to easily parsable example snippets.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7058622182","Type":"PullRequestEvent","CreatedAt":"2018-01-04T21:10:08","Actor":"Demivan","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vuex/pull/1105","RelatedDescription":"Closed pull request \"Use keyof to improve type inference in helpers\" (#1105) at vuejs/vuex","RelatedBody":"Using map helpers (`mapState`, `mapMutations`, `mapGetters` or `mapActions`) breaks type checking in Vue components.\r\nThis pull request uses `keyof` Typescript 2.1 feature to fix this.\r\nBefore change:\r\n![beforechangethis](https://user-images.githubusercontent.com/2339406/34364035-72720f58-ea8a-11e7-864e-22a3c3794946.png)\r\n![beforechange](https://user-images.githubusercontent.com/2339406/34364036-742542f2-ea8a-11e7-9cd7-151734482cdb.png)\r\nAfter change:\r\n![afterchangethis](https://user-images.githubusercontent.com/2339406/34364039-78e47f92-ea8a-11e7-99ab-72015d1e70d2.png)\r\n![afterchange](https://user-images.githubusercontent.com/2339406/34364040-7a6e293a-ea8a-11e7-888f-d82da9e6ec8f.png)\r\nBreaking change: When using functions as mappings, first parameter (`Commit`, `Dispatch`) type is not inferred, but it is type-checked only."},{"Id":"7057496055","Type":"PullRequestEvent","CreatedAt":"2018-01-04T16:39:10","Actor":"ktsn","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/pull/1121","RelatedDescription":"Opened pull request \"feat: improve helper types for more type safety\" (#1121) at vuejs/vuex","RelatedBody":"This typings update allows to use typed getters/actions/mutations out of the box if they are used in the following manner.\r\n\r\n**1. Declare each store assets types as interfaces.**\r\n\r\n```ts\r\n// State\r\nexport interface CounterState {\r\n  count: number\r\n}\r\n\r\n// Getters\r\n// key: getter name\r\n// value: return type of getter\r\nexport interface CounterGetters {\r\n  power: number\r\n}\r\n\r\n// Mutations\r\n// key: mutation name\r\n// value: payload type of mutation\r\nexport interface CounterMutations {\r\n  increment: { amount: number }\r\n}\r\n\r\n// Actions\r\n// key: action name\r\n// value: payload type of action\r\nexport interface CounterActions {\r\n  incrementAsync: { amount: number, delay: number }\r\n}\r\n```\r\n\r\n**2. annotate each module assets types with `DefineGetters`, `DefineMutations`, `DefineActions` utility types.**\r\n\r\nThe annotated assets must fulfill specified names and return type (getters) / payload type (actions, mutations). Also the assets types will be inferred.\r\n\r\nThe type in the following example should be fully inferred:\r\n\r\n```ts\r\nimport { DefineGetters, DefineMutations, DefineActions } from 'vuex'\r\n\r\nconst state: CounterState = {\r\n  count: 0\r\n}\r\n\r\nconst getters: DefineGetters<CounterGetters, CounterState> = {\r\n  power: state => state.count * state.count\r\n}\r\n\r\nconst mutations: DefineMutations<CounterMutations, CounterState> = {\r\n  increment (state, payload) {\r\n    state.count += payload.amount\r\n  }\r\n}\r\n\r\nconst actions: DefineActions<CounterActions, CounterState, CounterGetters, CounterMutations> = {\r\n  incrementAsync ({ commit }, payload) {\r\n    setTimeout(() => {\r\n      commit('increment', { amount: payload.amount })\r\n    }, payload.delay)\r\n  }\r\n}\r\n```\r\n\r\n**3. set `namespaced: true` and create namespaced helpers with `createNamespacedHelpers`.**\r\n\r\nThen, we can acquire typed mapXXX helpers for the defined namespaced module.\r\n\r\n```ts\r\nexport const counterHelpers = createNamespacedHelpers<CounterState, CounterGetters, CounterMutations, CounterActions>('counter')\r\n\r\nexport default {\r\n  namespaced: true,\r\n  state,\r\n  getters,\r\n  actions,\r\n  mutations\r\n}\r\n```\r\n\r\n**4. use the namespaced helpers in a component.**\r\n\r\n```ts\r\nimport { counterHelpers } from '@/store/modules/counter'\r\n\r\nexport default Vue.extend({\r\n  computed: counterHelpers.mapState({\r\n    value: 'count'\r\n  }),\r\n\r\n  methods: counterHelpers.mapMutations({\r\n    inc: 'increment'\r\n  }),\r\n\r\n  created () {\r\n    // These are correctly typed!\r\n    this.inc({ amount: 1 })\r\n    console.log(this.value)\r\n  }\r\n})\r\n```\r\n\r\n## Caveats\r\n\r\n### Store is still not typed\r\n\r\nI think it is probably impossible to infer the entire store type correctly since we cannot concat getter/actions/mutations names with namespace on type level. So this PR focuses how we do not use `$store` directly but use typed helpers instead.\r\n\r\n### It does not infer the types completely if passing functions to mapXXX helpers.\r\n\r\nFor example:\r\n```ts\r\ncounterHelpers.mapState({\r\n  foo: state => state.count\r\n})\r\n\r\ncounterHelpers.mapMutations({\r\n  bar (commit) {\r\n    commit('increment', { amount: 1 })\r\n  }\r\n})\r\n```\r\n\r\nWe can write the above code with inferred `state` and `commit` types but the component will have a type of `foo: any` and `bar: (...args: any[]) => any`.\r\n\r\nIt can be easily rewrite with a combination of object form mapXXX helpers and normal methods, so I think it would not be a problem.\r\n\r\n### Using root assets\r\n\r\nThe default mapXXX helpers still accepts any asset names and returns record of `any` type. To manually annotate them, I leave a 1st type parameter as a customizable asset type - If we specify the 1st type parameter, mapXXX helper uses it for type inference.\r\n\r\nBut in current TypeScript, we only can pass an array if we provide a type parameter:\r\n\r\n```ts\r\ninterface RootState {\r\n  foo: string\r\n  bar: boolean\r\n}\r\n\r\nmapState<RootState>(['foo', 'bar']) // This passes type check\r\n\r\n// This fails type check\r\nmapState<RootState>({\r\n  foo: 'test1',\r\n  bar: 'test2'\r\n})\r\n```\r\n\r\nTo support the latter syntax, we need to wait that TypeScript implements [optional generic inference](https://github.com/Microsoft/TypeScript/issues/14400).\r\n\r\nfix #532 \r\nfix #564 \r\n\r\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2018-01-05T05:30:34.2971258Z","RunDurationInMilliseconds":2071}