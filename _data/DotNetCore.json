{"Data":{"Blog":{"FeedItems":[{"Title":".NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog","PublishedOn":"2018-07-10T19:03:38+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are happy to announce the Microsoft .NET Framework 4.7.2 is available on Windows Update, Windows Server Update Services (WSUS) and Microsoft Update (MU) Catalog. This release includes...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-framework-4-7-2-is-available-on-windows-update-wsus-and-mu-catalog/","RawContent":null},{"Title":".NET Core July 2018 Update","PublishedOn":"2018-07-10T17:50:29+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core July 2018 Update. This update includes .NET Core 1.0.12, .NET Core 1.1.9, .NET Core 2.0.9 and .NET Core 2.1.2. Security .NET Core Security Feature Bypass...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-core-july-2018-update/","RawContent":null},{"Title":"Announcing ML.NET 0.3","PublishedOn":"2018-07-09T18:30:19+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Two months ago, at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework for .NET developers. We’ve gotten great feedback so far and would like to thank the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/09/announcing-ml-net-0-3/","RawContent":null},{"Title":"System.IO.Pipelines: High performance IO in .NET","PublishedOn":"2018-07-09T16:02:10+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"System.IO.Pipelines is a new library that is designed to make it easier to do high performance IO in .NET. It&#8217;s a library targeting .NET Standard that works on all .NET implementations....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/09/system-io-pipelines-high-performance-io-in-net/","RawContent":null},{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":34,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7939112505","Type":"PullRequestEvent","CreatedAt":"2018-07-09T17:43:55","Actor":"slide","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/105","RelatedDescription":"Opened pull request \"Add DLR/IronPython2/IronPython3\" (#105) at dotnet/home","RelatedBody":"Add DLR/IronPython2/IronPython3 to project list."},{"Id":"7896820874","Type":"IssuesEvent","CreatedAt":"2018-06-29T09:52:53","Actor":"tomkerkhove","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/104","RelatedDescription":"Opened issue \"About still mentions CodePlex\" (#104) at dotnet/home","RelatedBody":"About still mentions CodePlex which is now in archive mode.\r\n\r\n![image](https://user-images.githubusercontent.com/4345663/42086259-e0b7d008-7b92-11e8-96c9-02ee61ddc457.png)\r\n\r\nIs this something that I can PR?"},{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7945147887","Type":"IssuesEvent","CreatedAt":"2018-07-10T17:00:38","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/73","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-8356: .NET Core Security Feature Bypass Vulnerability\" (#73) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-8356: .NET Core Security Feature Bypass Vulnerability\r\n\r\n## <a name=\"executive-summary\"></a>Executive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in .NET Core. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nMicrosoft is aware of a security feature bypass vulnerability that exists when .NET Core does not correctly validate certificates. An attacker who successfully exploited this vulnerability could present an expired certificate when challenged.\r\n\r\nThe update addresses the vulnerability by correcting how .NET Core applications handle certificate validation.\r\n\r\n## Discussion\r\n\r\nDiscussion for this issue can be found at https://github.com/dotnet/wcf/ **TBD**\r\n\r\n### <a name=\"mitigation-factors\"></a>Mitigation factors\r\n\r\n* If an application does use Windows Communication Foundation you are not affected.\r\n\r\n## <a name=\"affected-software\"></a>Affected software\r\n\r\nAny .NET Core, or ASP.NET Core based application that uses System.Private.ServiceModel with a version of 4.5.1 or earlier.\r\n\r\nPackage name | Vulnerable versions | Secure versions\r\n------------ | ---------------- | -------------------------\r\nSystem.Private.ServiceModel | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 |  4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Duplex | 4.0.0, 4.0.1, 4.0.2 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.0.3 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Http | 4.0.0, 4.0.10, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.NetTcp | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Primitives | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Security | 4.0.0, 4.0.1, 4.0.2 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.0.3 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\n\r\n## <a name=\"advisory-faq\"></a>Advisory FAQ\r\n### <a name=\"how-affected\"></a>How do I know if I am affected?\r\n\r\n.NET Core projects have two types of dependencies: direct and transitive. You must update your projects using the following instructions to address both types of dependency.\r\n\r\n### <a name=\"project-format\"></a>.NET Core Project formats\r\n\r\n.NET Core has two different project file formats, depending on what software created the project.\r\n\r\n1. `project.json` is the format used in .NET Core 1.0 and Microsoft Visual Studio 2015.\r\n2. `csproj` is the format used in .NET Core 1.1, .NET Core 2.0 and Microsoft Visual Studio 2017.\r\n\r\n#### Direct dependencies\r\n\r\nDirect dependencies are discoverable by examining your `csproj` file or your `project.json` file. They can be fixed by [editing the project file](#direct-dependencies) or using NuGet to update the dependency.\r\n\r\n The `System.Private.ServiceModel` package is not meant to be directly depended on and will not appear in your direct dependency list.\r\n\r\n#### Transitive dependencies\r\n\r\nTransitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.\r\n\r\nTransitive dependencies are reviewable in three ways, depending on your [project format](#project-format):\r\n\r\n* In the Visual Studio Solution Explorer window, which supports searching.\r\n* By examining the `project.assets.json` file contained in the obj directory of your project for `csproj` based projects *OR*.\r\n* By examining the `project.lock.json` file contained in the root directory of your project for `project.json` based projects.\r\n\r\nThe `project.assets.json` and `project.lock.json` files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.\r\n\r\n#### <a name=\"direct-dependencies-vs2017\"></a>Fixing direct dependencies in a csproj based project / Visual Studio 2017\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.4.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nThe preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.\r\nThe package version number is in the `Version` attribute. The previous example shows a single direct dependency on `System.ServiceModel.Http` version 4.4.0.\r\n\r\nTo update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).\r\nIn this example, update `System.ServiceModel.Http` to the appropriate [fixed package number](#affected-software) for your major version. Save the *csproj* file. The example *csproj* now looks as follows:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.4.3\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nIf you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.\r\n\r\nNow recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.\r\n\r\n#### <a name=\"direct-dependencies-vs2015\"></a> Fixing Direct Dependencies in project.json based project / Visual Studio 2015\r\n\r\nOpen your `project.json` file in your editor. Look for the dependencies section. Below is an example dependencies section:\r\n\r\n``` json\r\n    \"dependencies\": {\r\n      \"Microsoft.NETCore.App\": {\r\n        \"version\": \"1.0.1\",\r\n        \"type\": \"platform\"\r\n      },\r\n     \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n     \"System.ServiceModel.Http\" : \"4.0.0\"\r\n    }\r\n```\r\n\r\nThis example has three direct dependencies: `Microsoft.NETCore.App`, `Microsoft.AspNetCore.Mvc.Core` and `System.ServiceModel.Http`.\r\n\r\n`Microsoft.NetCore.App` is the platform the application targets, you should ignore this. The other packages expose their version to the right of the package name. In our example, our non-platform packages are version 1.0.1.\r\n\r\nReview your direct dependencies for any instance of the packages and versions listed above. In the example above, there is a direct dependency on a vulnerable package, `System.ServiceModel.Http` version 4.4.0.\r\n\r\nTo update to the fixed package, change the version number to be the appropriate package for your release. In the example, this would be updating `System.ServiceModel.Http` to 4.4.3.\r\n\r\nAfter updating the vulnerable package versions, save your `project.json` file.\r\n\r\nThe dependencies section in our example `project.json` would now look as follows:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n    \"System.ServiceModel.Http \": \"4.4.3\"\r\n  }\r\n```\r\n\r\nIf you are using Visual Studio and save your updated `project.json` file, Visual Studio will restore the new package version. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependency.\r\n\r\nAfter you have addressed all of your direct dependencies, you must also review your transitive dependencies.\r\n\r\nAfter you've addressed all of your direct dependencies, you must review your transitive dependencies.\r\n\r\n#### Discovering and fixing transitive dependencies\r\n\r\nThere are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can review [the `project.assets.json` file](#project-assets-json) or the [the `project.lock.json` file](#project-lock-json).\r\n\r\n##### <a name=\"vs-solution-explorer\"></a>Using Visual Studio Solution Explorer\r\n\r\nTo use Solution Explorer, open the project in Visual Studio, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.\r\n\r\nFor example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:\r\n\r\n![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)\r\n\r\nThe search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.\r\n\r\nUnder the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.\r\nIn screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.\r\nThe `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\n##### <a name=\"project-assets-json\"></a> Manually reviewing project.assets.json (csproj/VS2017)\r\n\r\nOpen the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.\r\nVisual Studio and Visual Studio Code provide JSON friendly editing.\r\n\r\nSearch the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:\r\n\r\n* Examine the line on which they are found, the version number is after the `/`.\r\n* Compare to the [vulnerable versions table](#affected-software).\r\n\r\nFor example, a search result that shows `System.ServiceModel.Http/4.3.0` is a reference to version 4.3.0 of `System.ServiceModel.Http`.\r\n\r\nIf your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to any vulnerable packages, this means either\r\n\r\n* None of your direct dependencies depend on any vulnerable packages, or\r\n* You have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.\r\nLook for `PackageReference` nodes, for example:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nYou must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.\r\nYou do this by adding a new line to the dependencies section, referencing the fixed version.\r\nFor example, if your search showed a transitive reference to a vulnerable `System.ServiceModel.Http` version, you'd add a reference to the [fixed package number](#affected-software).\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.3.2\" />\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nAfter you've added the direct dependency reference, save your *csproj* file.\r\n\r\nIf you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.\r\n\r\n##### <a name=\"project-lock-json\"></a> Manually reviewing project.lock.json (project.json/VS2015)\r\n\r\nOpen the `project.lock.json` file in your editor. We suggest you use an editor that understands json and allows you to collapse and expand nodes to review this file; both Visual Studio and Visual Studio Code provide this functionality.\r\n\r\nIf you are using Visual Studio the `project.lock.json` file is “under” the `project.json` file. Click the right pointing triangle, ▷, to the left of the `project.json` file to expand the solution tree to expose the `project.lock.json` file. The following image shows a project with the `project.json` file expanded to show the `project.lock.json` file.\r\n\r\n![project lock json](https://cloud.githubusercontent.com/assets/796298/25858179/f6e01200-348f-11e7-8a77-7176d8dd3f03.png)\r\n\r\nSearch the `project.lock.json` file for the vulnerable packages, using the format `packagename/`, using each of the package names from the table above. If you find any vulnerable assembly name in your search examine the line on which they are found, the version number is after the `/` and compare to the vulnerable versions table above. For example a search result that shows `System.ServiceModel.Http/4.0.1` is a reference to v4.0.1 of `System.ServiceModel.Http`.   If your `project.lock.json` file includes references to any of the package versions shown above then you will need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to a vulnerable version of `System.ServiceModel.Http` this means none of your direct dependencies depend on any vulnerable packages or you have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to any of the vulnerable packages you must add a direct dependency to the updated package to your `project.json` file to override the transitive dependency. Open your `project.json` and find the dependencies section. For example:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nFor each of the vulnerable packages your search returned you must add a direct dependency to the updated version by adding it to the `project.json` file. You do this by adding a new line to the dependencies section, referring the fixed version. For example, if your search showed a transitive reference to the vulnerable `System.ServiceModel.Http` version 1.0.0 you would add a reference to the appropriate fixed version, 1.0.6. Edit the `project.json` file as follows:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"System.ServiceModel.Http\": \"4.1.2\",\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nAfter you have added direct dependencies to the fixed packages, save your `project.json` file.\r\n\r\nIf you are using Visual Studio save your updated `project.json` file and Visual Studio will restore the new package versions. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependencies.\r\n\r\n#### Rebuilding your application\r\n\r\nFinally you must rebuild your application, test, and redeploy.\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \"as is\" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### External Links\r\n\r\n[CVE-2018-8356](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2018-8356)\r\n\r\n### Revisions\r\n\r\nV1.0 (July 10, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2018-07-10_\r\n"},{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7947703421","Type":"PullRequestEvent","CreatedAt":"2018-07-11T04:31:44","Actor":"noahfalk","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18864","RelatedDescription":"Opened pull request \"Add no tiered compilation test jobs\" (#18864) at dotnet/coreclr","RelatedBody":"With the upcoming switch to make tiered compilation on by default we want to preserve some JIT testing that will not enable tiered compilation.\r\n1) Add 'no_tiered_compilation_pri0' jit stress job, logically the non-tiered variant of current 'Innerloop' jobs\r\n   - This job runs on all PRs for Checked x (Windows x86, Windows x64, Ubuntu arm)\r\n2) Add 'no_tiered_compilation' jit stress job, logically the non-tiered variant of the current 'normal' job\r\n   - This job has the same periodic schedule as other jit stress jobs\r\n3) Add 'r2r_no_tiered_compilation' r2r stress job, logically the non-tiered variant of the current 'r2r' job\r\n   - This job has the same periodic schedule as other r2r stress jobs\r\n\r\nMisc adjustments:\r\na) Added isPri0TestScenario because 'innerloop' is no longer the only scenario name which has this property + eliminated various comments that implied 'innerloop' IFF pri0\r\nb) updated the contxtString generation for arm jobs to make it more consistent with the naming computed for other architectures\r\n\r\nThis is a continuation of the work that started in #18828"},{"Id":"7947685252","Type":"IssuesEvent","CreatedAt":"2018-07-11T04:24:07","Actor":"Zhentar","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18863","RelatedDescription":"Opened issue \"JIT Hints- Parameter conditional inlining directives\" (#18863) at dotnet/coreclr","RelatedBody":"In dotnet/corefx/#30934 we have this code:\r\n\r\n```cs\r\n        public static bool TryParse(ReadOnlySpan<byte> source, out int value, out int bytesConsumed, char standardFormat = default)\r\n        {\r\n            switch (standardFormat)\r\n            {\r\n                case default(char):\r\n                case 'g':\r\n                case 'G':\r\n                case 'd':\r\n                case 'D':\r\n                    return TryParseInt32D(source, out value, out bytesConsumed);\r\n\r\n                case 'n':\r\n                case 'N':\r\n                    return TryParseInt32N(source, out value, out bytesConsumed);\r\n\r\n                case 'x':\r\n                case 'X':\r\n                    value = default;\r\n                    return TryParseUInt32X(source, out Unsafe.As<int, uint>(ref value), out bytesConsumed);\r\n\r\n                default:\r\n                    return ThrowHelper.TryParseThrowFormatException(out value, out bytesConsumed);\r\n            }\r\n        }\r\n```\r\n\r\nIf the `standardFormat` parameter has a constant value at the callsite, we definitely want this function inlined; it can be entirely evaluated by the JIT and inlined to a call slightly smaller than the original. But if it's not, it's not a particularly small function to be inlining; it's going to be the wrong choice in at least some cases. `[MethodImpl(MethodImplOptions.AggressiveInlining)]` is a rather blunt tool for this kind of scenario. It would be much better if we could do something like `public static bool TryParse(ReadOnlySpan<byte> source, out int value, out int bytesConsumed, [ParamImpl(ParamImplOptions.InlineMethodWhenConstant)] char standardFormat = default)` to give more nuance to the JIT hints."},{"Id":"7947617247","Type":"PullRequestEvent","CreatedAt":"2018-07-11T03:55:41","Actor":"BruceForstall","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18861","RelatedDescription":"Merged pull request \"Fix ShowLocallocAlignment test for x86\" (#18861) at dotnet/coreclr","RelatedBody":"The required localloc alignment differs by platform. Teach the test\r\nwhat the per-platform alignment requirement is.\r\n\r\nFixes #7163"},{"Id":"7947617230","Type":"IssuesEvent","CreatedAt":"2018-07-11T03:55:41","Actor":"BruceForstall","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/7163","RelatedDescription":"Closed issue \"x86: ShowLocallocAlignment test failure\" (#7163) at dotnet/coreclr","RelatedBody":"test:\nJIT\\Regression\\Dev11\\External\\dev11_239804\\ShowLocallocAlignment\\ShowLocallocAlignment.cmd\n\nresults:\nAddress1: Misaligned (0000000002abde04)\nAddress2: Misaligned (0000000002abde04)\n\nTest failed.\nExpected: 100\nActual: 101\n"},{"Id":"7947615720","Type":"PullRequestEvent","CreatedAt":"2018-07-11T03:55:03","Actor":"BruceForstall","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18860","RelatedDescription":"Merged pull request \"Re-enable tests for #13731 which was closed long ago\" (#18860) at dotnet/coreclr","RelatedBody":""},{"Id":"7947244216","Type":"PullRequestEvent","CreatedAt":"2018-07-11T01:33:58","Actor":"noahfalk","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18828","RelatedDescription":"Merged pull request \"Adjust JIT automated testing for tiered compilation\" (#18828) at dotnet/coreclr","RelatedBody":""},{"Id":"7947121871","Type":"IssuesEvent","CreatedAt":"2018-07-11T00:46:07","Actor":"BruceForstall","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/4944","RelatedDescription":"Closed issue \"ARM64 GCStress: Assert in StackWalk of Funclet\" (#4944) at dotnet/coreclr","RelatedBody":"Part of  #3825\n\nSeveral tests failing with this symptom, for example: `JIT\\jit64\\opt\\cse\\HugeArray\\HugeArray`\n\n```\nBEGIN EXECUTION\n \"D:\\coreclr\\bin\\tests\\Windows_NT.arm64.Debug\\Tests\\Core_Root\\corerun.exe\" HugeArray.exe  \n\nAssert failure(PID 7540 [0x00001d74], Thread: 2664 [0x0a68]): EHCount > 0\n\nCORECLR! IJitManager::IsFilterFunclet + 0x31C (0x00007ffb`f76c12e4)\nCORECLR! CrawlFrame::IsFilterFunclet + 0xAC (0x00007ffb`f742464c)\nCORECLR! ExceptionTracker::FindParentStackFrameForStackWalk + 0x1C (0x00007ffb`f74a91ac)\nCORECLR! StackFrameIterator::Filter + 0x4A8 (0x00007ffb`f7420120)\nCORECLR! StackFrameIterator::Next + 0xD4 (0x00007ffb`f7425584)\nCORECLR! Thread::StackWalkFramesEx + 0x1AC (0x00007ffb`f7428d6c)\nCORECLR! Thread::StackWalkFrames + 0x350 (0x00007ffb`f7428ba8)\nCORECLR! ScanStackRoots + 0x37C (0x00007ffb`f7a4360c)\nCORECLR! GCToEEInterface::GcScanRoots + 0x26C (0x00007ffb`f7a41f4c)\nCORECLR! GCScan::GcScanRoots + 0x2C (0x00007ffb`f79f2fe4)\n    File: d:\\coreclr\\src\\vm\\codeman.cpp Line: 1102\n    Image: D:\\coreclr\\bin\\tests\\Windows_NT.arm64.Debug\\Tests\\Core_Root\\CoreRun.exe\n```\n"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7947016430","Type":"PullRequestEvent","CreatedAt":"2018-07-11T00:05:09","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/796","RelatedDescription":"Merged pull request \"Breakdown APIs by namespace\" (#796) at dotnet/standard","RelatedBody":"We don't want to have all the .NET Standard APIs in a single C# file as GitHub really doesn't like huge files. That's why the API set is split into multiple files.\r\n\r\nPreviously, the contents of the .NET Standard reference assembly was split by the corresponding assembly in .NET Framework, i.e. it had filenames like \"mscorlib.cs\" and \"System.Core.cs\". This isn't very useful as the assembly factoring of .NET Framework is really completely irrelevant for the API surface of .NET Standard.\r\n\r\nThis splits the APIs by namespace (done with a [small Roslyn based rewrite](https://gist.github.com/terrajobst/b5403d74b0511149a70d6b98eec53216)).\r\n\r\nAlso, I diffed the resulting `netstandard.dll` with the current one to ensure this introduces no API differences."},{"Id":"7946924545","Type":"PullRequestEvent","CreatedAt":"2018-07-10T23:31:49","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/796","RelatedDescription":"Opened pull request \"Breakdown APIs by namespace\" (#796) at dotnet/standard","RelatedBody":"We don't want to have all the .NET Standard APIs in a single C# file as GitHub really doesn't like huge files. That's why the API set is split into multiple files.\r\n\r\nPreviously, the contents of the .NET Standard reference assembly was split by the corresponding assembly in .NET Framework, i.e. it had filenames like \"mscorlib.cs\" and \"System.Core.cs\". This isn't very useful as the assembly factoring of .NET Framework is really completely irrelevant for the API surface of .NET Standard.\r\n\r\nThis splits the APIs by namespace."},{"Id":"7938907741","Type":"IssuesEvent","CreatedAt":"2018-07-09T17:02:13","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/786","RelatedDescription":"Closed issue \"[Question] Using UWP APIs from .NET Standard\" (#786) at dotnet/standard","RelatedBody":"I have a PCL targeting .NET Framework 4.6 & UWP 10.0.10240 that I'm trying to convert to .NET Standard. It is actually used to share code that uses some UWP APIs that are available on desktop as well. I currently have these references in the project file:\r\n\r\n```xml\r\n<Reference Include=\"System.Runtime.WindowsRuntime\">\r\n  <HintPath>$(MSBuildProgramFiles32)\\Reference Assemblies\\Microsoft\\Framework\\.NETCore\\v4.5\\System.Runtime.WindowsRuntime.dll</HintPath>\r\n</Reference>\r\n<Reference Include=\"Windows\">\r\n  <HintPath>$(MSBuildProgramFiles32)\\Windows Kits\\10\\UnionMetadata\\Windows.winmd</HintPath>\r\n</Reference>\r\n```\r\n\r\nBased on the target frameworks, I figured that my desired version of .NET Standard would be 1.3. However I'm getting compilation errors about missing mscorlib whenever I use any of the UWP APIs.\r\n\r\nThis is the new csproj:\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netstandard1.3</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <Reference Include=\"System.Runtime.WindowsRuntime\">\r\n      <HintPath>$(MSBuildProgramFiles32)\\Reference Assemblies\\Microsoft\\Framework\\.NETCore\\v4.5\\System.Runtime.WindowsRuntime.dll</HintPath>\r\n    </Reference>\r\n    <Reference Include=\"Windows\">\r\n      <HintPath>$(MSBuildProgramFiles32)\\Windows Kits\\10\\UnionMetadata\\Windows.winmd</HintPath>\r\n    </Reference>\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nand a small example:\r\n```c#\r\nusing Windows.Storage;\r\n\r\nclass C\r\n{\r\n    void M()\r\n    {\r\n        var folder = KnownFolders.PicturesLibrary; // error CS0012: The type 'Object' is defined in an assembly that is not referenced. You must add a reference to assembly 'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.\r\n    }\r\n}\r\n```\r\n\r\nI noticed that if I target `netstandard2.0` instead, the compilation succeeds. But since I'm trying to target all versions of UWP, I can't afford that. Is it impossible to use these APIs from 1.3? Are PCLs the only option? Thank you (Sorry if this is not the appropriate repo)"},{"Id":"7936811887","Type":"IssuesEvent","CreatedAt":"2018-07-09T10:39:53","Actor":"stijnherreman","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/795","RelatedDescription":"Opened issue \"It's not possible to make a .NET Standard project depend on a .NET Framework project, to ensure build order\" (#795) at dotnet/standard","RelatedBody":"I have a .NET Standard project that needs to depend on a .NET Framework project, to ensure build order of the projects. The .NET Framework project generates a file in an `AfterTargets=\"Build\"` target (using [NSwag.MSBuild](https://github.com/RSuter/NSwag/wiki/MSBuild)), and this file is added as a *linked file* in the .NET Standard project.\r\n\r\n**Solution1.sln**\r\n```\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio 15\r\nVisualStudioVersion = 15.0.27703.2035\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ClassLibrary1\", \"ClassLibrary1\\ClassLibrary1.csproj\", \"{CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8}\"\r\nEndProject\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ClassLibrary2\", \"ClassLibrary2\\ClassLibrary2.csproj\", \"{82F74C55-84D7-4C10-86A8-F04BE16DCB78}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{82F74C55-84D7-4C10-86A8-F04BE16DCB78}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{82F74C55-84D7-4C10-86A8-F04BE16DCB78}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{82F74C55-84D7-4C10-86A8-F04BE16DCB78}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{82F74C55-84D7-4C10-86A8-F04BE16DCB78}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {DC8EDB39-5B76-4A28-BC1A-351F2CA1269C}\r\n\tEndGlobalSection\r\nEndGlobal\r\n```\r\n\r\n**ClassLibrary1\\ClassLibrary1.csproj**\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFramework>net471</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n</Project>\r\n```\r\n\r\n**ClassLibrary2\\ClassLibrary2.csproj**\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFramework>netstandard2.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n</Project>\r\n```\r\n\r\nWhen running `dotnet build .\\Solution1.sln`, the solution builds as expected.\r\n\r\nNow make ClassLibrary2 depend on ClassLibrary1:\r\n\r\n**Solution1.sln**\r\n```\r\n...\r\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"ClassLibrary2\", \"ClassLibrary2\\ClassLibrary2.csproj\", \"{82F74C55-84D7-4C10-86A8-F04BE16DCB78}\"\r\n\tProjectSection(ProjectDependencies) = postProject\r\n\t\t{CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8} = {CCF4D537-E3DF-4172-9B3F-D3B06DAAC1F8}\r\n\tEndProjectSection\r\nEndProject\r\n...\r\n```\r\n\r\nWhen running `dotnet build .\\Solution1.sln`, the following error is thrown:\r\n\r\n> C:\\Program Files\\dotnet\\sdk\\2.1.300\\Microsoft.Common.CurrentVersion.targets(1656,5): error : Project 'C:\\...\\Solution1\\ClassLibrary1\\ClassLibrary1.csproj' targets 'net471'. It cannot be referenced by a project that targets '.NETStandard,Version=v2.0'. [C:\\...\\Solution1\\ClassLibrary2\\ClassLibrary2.csproj]\r\n\r\nClassLibrary2 doesn't reference ClassLibrary1 in a way that is technically impossible, so I expect this to work instead of throwing an error."},{"Id":"7934327248","Type":"IssuesEvent","CreatedAt":"2018-07-08T17:53:27","Actor":"Pilchie","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/760","RelatedDescription":"Closed issue \"Unable to properly debug a netstandard project when starting a external executable\" (#760) at dotnet/standard","RelatedBody":"### Summary\r\n\r\nDebugging doesnt seem to work properly when you start a net framework exe from a netstandard project through the Debug Launch setting. Everything else seems to be working fine.\r\n\r\nWhen testing inside a game engine called duality I noticed this behavior. Latter on I found out that I can reproduce this in a separate project as well.\r\n\r\nSome background info: In duality you add functionality through plugins which currently are portable projects. We want to eventually change this to netstandard projects. Plugins themselves are not runnable but instead we run duality itself when you try to run a plugin in VS. This will load all the plugins so you can proceed to debugging your plugin.\r\n\r\nNote: the attached test project was simplified as much as possible to isolate the problem and thus does not include duality.\r\n\r\n### How to reproduce\r\n\r\n- Download and open the attached test project.\r\n- RebuildBuild the solution and start `ClassLibrary1`. This will actually start the exe generated by `NetStandardDebugTest`. Note that it will run properly.\r\n- Now set a breakpoint and run it again. Note that the break point will not work.\r\n- Now try to pause the execution. You will get a Unknown error 0x80004005\r\n\r\n### Attachments\r\n\r\n- [NetStandardDebugTest.zip](https://github.com/AdamsLair/duality/files/2048379/NetStandardDebugTest.zip)\r\n"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7947741703","Type":"PullRequestEvent","CreatedAt":"2018-07-11T04:48:47","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30981","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#30981) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7947646744","Type":"PullRequestEvent","CreatedAt":"2018-07-11T04:07:37","Actor":"morganbr","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30980","RelatedDescription":"Opened pull request \"Add netcoreappaot target group\" (#30980) at dotnet/corefx","RelatedBody":"Adds a netcoreappaot target group intended for CoreRT/.NET Native working with the netcoreapp framework. For the most part, netcoreappaot should be similar to netcoreapp, but it builds against the .NET Native core libraries. A couple of libraries, such as System.Linq.Expressions, have aot-specific definitions that are enabled for netcoreappaot. \r\n\r\nI've verified that a couple of netcoreappaot tests pass, but haven't attempted a full test pass locally."},{"Id":"7947564236","Type":"IssuesEvent","CreatedAt":"2018-07-11T03:33:52","Actor":"davidsh","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30979","RelatedDescription":"Opened issue \"Unable to receive HTTP responses from www.nasdaq.com\" (#30979) at dotnet/corefx","RelatedBody":".NET Core is unable to handle HTTP responses from www.nasdaq.com.  It seems there is some non-standard HTTP response formatting from this website.\r\n\r\nRepro:\r\n\r\n```c#\r\nusing System;\r\nusing System.IO;\r\nusing System.Net;\r\nusing System.Net.Http;\r\n\r\nnamespace httptest\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine($\"(Framework: {Path.GetDirectoryName(typeof(object).Assembly.Location)})\");\r\n\r\n            try\r\n            {\r\n                var client = new HttpClient();\r\n                HttpResponseMessage response = client.GetAsync(\"https://www.nasdaq.com\").GetAwaiter().GetResult();\r\n                Console.WriteLine($\"{(int)response.StatusCode} {response.ReasonPhrase}\");\r\n\r\n                string body = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();\r\n                Console.WriteLine(body);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n.NET Core 2.1 (Windows - uses SocketsHttpHandler):\r\n\r\n```\r\nD:\\dotnet\\httptest>dotnet run netcoreapp2.1\r\n(Framework: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\2.1.1)\r\nSystem.Net.Http.HttpRequestException: An error occurred while sending the request. ---> System.IO.IOException: The server returned an invalid or unrecognized response.\r\n   at System.Net.Http.HttpConnection.FillAsync()\r\n   at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean foldedHeadersAllowed)\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   --- End of inner exception stack trace ---\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)\r\n   at httptest.Program.Main(String[] args) in D:\\dotnet\\httptest\\Program.cs:line 14\r\n```\r\n\r\n.NET Core 2.0 (Windows - use WinHttpHandler):\r\n```\r\nD:\\dotnet\\httptest>dotnet run -f netcoreapp2.0\r\n(Framework: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\2.0.9)\r\nSystem.Net.Http.HttpRequestException: An error occurred while sending the request. ---> System.Net.Http.WinHttpException: The server returned an invalid or unrecognized response\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Threading.Tasks.RendezvousAwaitable`1.GetResult()\r\n   at System.Net.Http.WinHttpHandler.<StartRequest>d__105.MoveNext()\r\n   --- End of inner exception stack trace ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()\r\n   at System.Net.Http.HttpClient.<FinishSendAsyncBuffered>d__58.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()\r\n   at httptest.Program.Main(String[] args) in D:\\dotnet\\httptest\\Program.cs:line 14\r\n```\r\n\r\nEven .NET Framework has problems.\r\n\r\n.NET Framework 4.7:\r\n```\r\nD:\\dotnet\\httptest>dotnet run -f net47\r\n(Framework: C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319)\r\nSystem.Net.Http.HttpRequestException: An error occurred while sending the request. ---> System.Net.WebException: The underlying connection was closed: The connection was closed unexpectedly.\r\n   at System.Net.HttpWebRequest.EndGetResponse(IAsyncResult asyncResult)\r\n   at System.Net.Http.HttpClientHandler.GetResponseCallback(IAsyncResult ar)\r\n   --- End of inner exception stack trace ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()\r\n   at httptest.Program.Main(String[] args)\r\n```\r\n\r\nHowever, if you add this to the app.config:\r\n\r\n```xml\r\n  <system.net>\r\n    <settings>\r\n      <httpWebRequest useUnsafeHeaderParsing=\"true\"/>\r\n    </settings>\r\n  </system.net>\r\n```\r\n\r\nand run under .NET Framework, it will work.\r\n\r\nAlso, UWP .NET Core (which uses WinRT Windows.Web.Http and native WinINet) work ok.  The browsers (Chrome, IE, Edge) also work ok."},{"Id":"7947385740","Type":"PullRequestEvent","CreatedAt":"2018-07-11T02:27:44","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30977","RelatedDescription":"Merged pull request \"[release/2.1] Fix handle double-free in recently added WindowsIdentity test (#30731)\" (#30977) at dotnet/corefx","RelatedBody":"- Port of https://github.com/dotnet/corefx/pull/30731 to release/2.1\r\n- Changes are to test code only\r\n- Test issue was introduced with https://github.com/dotnet/corefx/pull/30379"},{"Id":"7947206313","Type":"IssuesEvent","CreatedAt":"2018-07-11T01:19:06","Actor":"AArnott","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30978","RelatedDescription":"Opened issue \"System.IO.Pipelines nuget package does not carry .xml file\" (#30978) at dotnet/corefx","RelatedBody":"The System.IO.Pipelines 4.5.0 nuget package (as found in the `C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\\system.io.pipelines\\4.5.0` folder) does not contain .xml API documentation for the assembly. This, combined with the lack of any useful documentation online for the assembly, makes it guesswork to understand how to properly use this library. \r\n\r\nIt's an awesome library, but it took me half a day to figure out why it was hanging in a particular scenario. (I later found it to be #30689, BTW)."}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7947745208","Type":"PullRequestEvent","CreatedAt":"2018-07-11T04:50:20","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6086","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6086) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7947745132","Type":"PullRequestEvent","CreatedAt":"2018-07-11T04:50:18","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6085","RelatedDescription":"Opened pull request \"Fix unnecessary thread-static handle reallocation\" (#6085) at dotnet/corert","RelatedBody":""},{"Id":"7947013992","Type":"PullRequestEvent","CreatedAt":"2018-07-11T00:04:12","Actor":"nattress","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6084","RelatedDescription":"Opened pull request \"Merge remote-tracking branch 'dotnet/master' into r2r\" (#6084) at dotnet/corert","RelatedBody":""},{"Id":"7946811571","Type":"PullRequestEvent","CreatedAt":"2018-07-10T22:54:32","Actor":"pentp","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6083","RelatedDescription":"Opened pull request \"Optimize Decimal calculations for 32-bit platforms\" (#6083) at dotnet/corert","RelatedBody":"Contributes to https://github.com/dotnet/coreclr/issues/18249.\r\nAfter these changes only multiplication is slower (1.15x) than the current native code. I've got a version using SSE2 intrinsics that's 1.09x slower than native, but I think it's not worth the additional complexity.\r\nBelow are the x86 stats. There are some minor improvements on x64 also.\r\n\r\n|  CMP |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 16.72 ns | 0.0208 ns | 0.0074 ns |   1.00 |\r\n| CoreRT2 | 14.52 ns | 0.0186 ns | 0.0067 ns |   0.87 |\r\n\r\n|  ADD |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 28.54 ns | 0.1237 ns | 0.0441 ns |   1.00 |\r\n| CoreRT2 | 28.20 ns | 0.1221 ns | 0.0435 ns |   0.99 |\r\n\r\n|  MUL |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 19.60 ns | 0.9202 ns | 0.3282 ns |   1.00 |\r\n| CoreRT2 | 22.17 ns | 0.0437 ns | 0.0156 ns |   1.15 |\r\n\r\n|  DIV |     Mean |     Error |    StdDev | Scaled |\r\n|-------- |---------:|----------:|----------:|-------:|\r\n|  Native | 116.7 ns | 0.1891 ns | 0.0674 ns |   1.00 |\r\n| CoreRT2 | 106.7 ns | 0.1221 ns | 0.0435 ns |   0.91 |\r\n"},{"Id":"7944984595","Type":"IssuesEvent","CreatedAt":"2018-07-10T16:30:26","Actor":"christianscheuer","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/6082","RelatedDescription":"Closed issue \"Question: Feasibility of having a pure-compute thread with no GC for realtime use\" (#6082) at dotnet/corert","RelatedBody":"While working on narrowing down the macOS threading issue and digging through some GC and threading code in the runtime, I was wondering if there might be a solution to the problem of having a realtime thread (such as an audio thread that can't have dropouts) in a GC environment.\r\n\r\nFirst, let me say I'm not completely up to date about the various newer GC variants - concurrent, etc. But I haven't come across any of these GC implementations that support having a single thread opt completely out of being stopped/hijacked for GC.\r\n\r\nTo explore the scenario I'm thinking about a little further... For realtime audio processing, you could implement your realtime audio thread purely with pinned objects (you would need to be careful of course). But largely it's already a compute only thread, so you could probably implement it completely without p/invokes and allocations. Only thing is it would be based upon a reverse p/invoke frame which would get called quite often.\r\n\r\nSo my question is, would it be feasible (for now just as a completely undocumented experiment of course), to change a few lines somewhere in the runtime to make a thread able to opt completely out of GC? Of couse all memory access from that thread would need to only happen on pinned objects. This would also mean we'd need to restrict access to framework objects, since they could not be pinned by user code, but maybe it would be enough to simply pin the object references accessed from the GC-free thread.\r\nMy assumption here is, that if all the objects accessed from the compute-only thread were pinned, then the GC would not need to stop the thread to be able to relocate it's references or to walk its roots, since because they're all pinned, they wouldn't relocate and their roots would already be in the handle tables.\r\n\r\nThe idea is then, that if the data structure needed by the GC-free thread needed updating, the objects could be unpinned, data rearranged, GC.Collect invoked and objects pinned again. That would mean controlled downtime of the realtime thread, which would be acceptable because it would be due to user input.\r\n\r\nIs this completely off or is there something important I have forgotten?"},{"Id":"7943627353","Type":"IssuesEvent","CreatedAt":"2018-07-10T12:59:49","Actor":"christianscheuer","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/6082","RelatedDescription":"Opened issue \"Question: Feasibility of having a pure-compute thread with no GC for realtime use\" (#6082) at dotnet/corert","RelatedBody":"While working on narrowing down the macOS threading issue and digging through some GC and threading code in the runtime, I was wondering if there might be a solution to the problem of having a realtime thread (such as an audio thread that can't have dropouts) in a GC environment.\r\n\r\nFirst, let me say I'm not completely up to date about the various newer GC variants - concurrent, etc. But I haven't come across any of these GC implementations that support having a single thread opt completely out of being stopped/hijacked for GC.\r\n\r\nTo explore the scenario I'm thinking about a little further... For realtime audio processing, you could implement your realtime audio thread purely with pinned objects (you would need to be careful of course). But largely it's already a compute only thread, so you could probably implement it completely without p/invokes and allocations. Only thing is it would be based upon a reverse p/invoke frame which would get called quite often.\r\n\r\nSo my question is, would it be feasible (for now just as a completely undocument experiment of course), to change a few lines somewhere in the runtime to make a thread able to opt completely out of GC? Of couse all memory access from that thread would need to only happen on pinned objects. This would also mean we'd need to restrict access to framework objects, since they could not be pinned by user code, but maybe it would be enough to simply pin the object references accessed from the GC-free thread.\r\nMy assumption here is, that if all the objects accessed from the compute-only thread were pinned, then the GC would not need to stop the thread to be able to relocate it's references or to walk its roots, since because they're all pinned, they wouldn't relocate and their roots would already be in the handle tables.\r\n\r\nThe idea is then, that if the data structure needed by the GC-free thread needed updating, the objects could be unpinned, data rearranged, GC.Collect invoked and objects pinned again. That would mean controlled downtime of the realtime thread, which would be acceptable because it would be due to user input.\r\n\r\nIs this completely off or is there something important I have forgotten?"},{"Id":"7942276619","Type":"PullRequestEvent","CreatedAt":"2018-07-10T08:35:03","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6067","RelatedDescription":"Merged pull request \"Regression test for inlined PInvoke with marshalling data\" (#6067) at dotnet/corert","RelatedBody":"Extracted from #6060"},{"Id":"7941520750","Type":"IssuesEvent","CreatedAt":"2018-07-10T05:14:33","Actor":"tiandian","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/6072","RelatedDescription":"Closed issue \"It is possible make writing rd.xml easier by write a log in GetType()?\" (#6072) at dotnet/corert","RelatedBody":"When I publish a asp.net core app to corert, it often runs error,  i reference many third party libraries,\r\nI don't know which code generate the error, and I can't change the code in the third party libraries,\r\nbut I know it is most possible be a reflection error,   and it is most possible Type.GetType() return null,\r\n\r\nso I want ask it is possible let Type.GetType to write to a log file when it return null when publish to corert?\r\nchange Type.GetType's code to below:\r\n\r\n```\r\n        public static Type GetType(String typeName)\r\n        {\r\n            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;\r\n            Type t = return RuntimeType.GetType(typeName, false, false, false, ref stackMark);\r\n\r\n#if LOG\r\n            if (t == null)\r\n            {\r\n                Writelog(\"ReflectionError.txt\", string.Format(\"GetType: typeName = {0} return null.\", typeName));\r\n            }\r\n#endif\r\n\r\n            return t;\r\n        }\r\n```\r\n\r\nthen when i run `dotnet publish -r win-x64 -c release --LOG=1`, when i run the published exe, it will write a ReflectionError.txt file, I don't need know which line code in the third library generate the error, I just need add the error type in the ReflectionError.txt to rd.xml to resolve the problem.\r\n\r\nthanks!\r\n"},{"Id":"7941167135","Type":"PullRequestEvent","CreatedAt":"2018-07-10T02:52:47","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6056","RelatedDescription":"Merged pull request \"Add back most CreateInstance APIs to AppDomain and Activator\" (#6056) at dotnet/corert","RelatedBody":"Contributes to  https://github.com/dotnet/corefx/issues/30190\r\n\r\nAs advised by @jkotas  https://github.com/dotnet/corefx/pull/30809#issuecomment-402680660 we need to add new Activator.CreateInstance apis to allow compilation.\r\n"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1016825199109423104","CreatedAt":"2018-07-10T23:23:13+00:00","UserScreenname":"dotnet","Text":".NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog https://t.co/oBwPB86Pxf","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":52,"FavoriteCount":42,"RawContent":null},{"Id":"1016742094671507456","CreatedAt":"2018-07-10T17:53:00+00:00","UserScreenname":"dotnet","Text":".NET Core July 2018 Update https://t.co/1zcc6ep8AC","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":67,"FavoriteCount":57,"RawContent":null},{"Id":"1016363772737273856","CreatedAt":"2018-07-09T16:49:41+00:00","UserScreenname":"dotnet","Text":"https://t.co/EpnUCQtOJb.Pipelines: High performance IO in .NET https://t.co/LLJUxPVWlC","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":338,"FavoriteCount":151,"RawContent":null},{"Id":"1016363637726797824","CreatedAt":"2018-07-09T16:49:09+00:00","UserScreenname":"dotnet","Text":"Announcing https://t.co/XkD7piEeFS 0.3 https://t.co/dLw78XRgcE","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":124,"FavoriteCount":87,"RawContent":null},{"Id":"1013052742326280192","CreatedAt":"2018-06-30T13:32:50+00:00","UserScreenname":"dotnet","Text":"Tune in for Jeff's Saturday show, learn how to use C# and @ASPNET Core.  Always a good time https://t.co/KJoRPYHnHt","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":32,"FavoriteCount":8,"RawContent":null}]}},"RunOn":"2018-07-11T05:30:32.5276501Z","RunDurationInMilliseconds":6730}