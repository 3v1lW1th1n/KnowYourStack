{"Data":{"Blog":{"FeedItems":[{"Title":"Advisory on July 2018 .NET Framework Updates","PublishedOn":"2018-07-21T00:55:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"The July 2018 Security and Quality Rollup updates for .NET Framework was released earlier this month. We have received multiple customer reports of applications that fail to start or don&#8217;t run...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/20/advisory-on-july-2018-net-framework-updates/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3632","PublishedOn":"2018-07-19T00:30:16+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"We released the first Early Access build for the .NET Framework 4.8 last month (June-2018) and are happy to announce the next build (3632) for your feedback. This is one of the in-development builds...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/18/announcing-net-framework-4-8-early-access-build-3632/","RawContent":null},{"Title":"IL Linker — Help us build the best experience!","PublishedOn":"2018-07-11T16:44:27+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"We are currently working on the IL Linker and would love to get your feedback. Please fill out the brief survey below and help shape the future of the IL Linker by telling us about your current...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/11/il-linker-help-us-build-the-best-experience/","RawContent":null},{"Title":".NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog","PublishedOn":"2018-07-10T19:03:38+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Today, we are happy to announce the Microsoft .NET Framework 4.7.2 is available on Windows Update, Windows Server Update Services (WSUS) and Microsoft Update (MU) Catalog. This release includes...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-framework-4-7-2-is-available-on-windows-update-wsus-and-mu-catalog/","RawContent":null},{"Title":".NET Core July 2018 Update","PublishedOn":"2018-07-10T17:50:29+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core July 2018 Update. This update includes .NET Core 1.0.12, .NET Core 1.1.9, .NET Core 2.0.9 and .NET Core 2.1.2. Security .NET Core Security Feature Bypass...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-core-july-2018-update/","RawContent":null},{"Title":"Announcing ML.NET 0.3","PublishedOn":"2018-07-09T18:30:19+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Two months ago, at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework for .NET developers. We’ve gotten great feedback so far and would like to thank the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/09/announcing-ml-net-0-3/","RawContent":null},{"Title":"System.IO.Pipelines: High performance IO in .NET","PublishedOn":"2018-07-09T16:02:10+00:00","CommentsCount":34,"FacebookCount":0,"Summary":"System.IO.Pipelines is a new library that is designed to make it easier to do high performance IO in .NET. It&#8217;s a library targeting .NET Standard that works on all .NET implementations....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/09/system-io-pipelines-high-performance-io-in-net/","RawContent":null},{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":34,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7951838452","Type":"IssuesEvent","CreatedAt":"2018-07-11T18:28:16","Actor":"Eilon","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/107","RelatedDescription":"Opened issue \"Links to .NET Foundation web site use HTTP instead of HTTPS\" (#107) at dotnet/home","RelatedBody":"It appears that HTTPS works just fine: https://www.dotnetfoundation.org/\r\n\r\nBut the links at these places use HTTP:\r\n1. The link in the header of https://github.com/dotnet/home\r\n2. The link in the header of https://github.com/dotnet\r\n3. Some links in https://github.com/dotnet/home/blob/master/README.md (both to .NET Foundation, and a GitHub link to another project)\r\n\r\nThese links should all change to HTTPS."},{"Id":"7948314683","Type":"IssuesEvent","CreatedAt":"2018-07-11T07:41:25","Actor":"glatzert","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/106","RelatedDescription":"Opened issue \"Updates are not requested from local WSUS\" (#106) at dotnet/home","RelatedBody":"The Team somewhen Mention, that fixes should be installed automatically, if .NET Core is on a Windows Server.\r\nThis seems not to work. What are the prerequisits for this to be working?"},{"Id":"7939112505","Type":"PullRequestEvent","CreatedAt":"2018-07-09T17:43:55","Actor":"slide","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/105","RelatedDescription":"Opened pull request \"Add DLR/IronPython2/IronPython3\" (#105) at dotnet/home","RelatedBody":"Add DLR/IronPython2/IronPython3 to project list."},{"Id":"7896820874","Type":"IssuesEvent","CreatedAt":"2018-06-29T09:52:53","Actor":"tomkerkhove","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/104","RelatedDescription":"Opened issue \"About still mentions CodePlex\" (#104) at dotnet/home","RelatedBody":"About still mentions CodePlex which is now in archive mode.\r\n\r\n![image](https://user-images.githubusercontent.com/4345663/42086259-e0b7d008-7b92-11e8-96c9-02ee61ddc457.png)\r\n\r\nIs this something that I can PR?"},{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7999286881","Type":"IssuesEvent","CreatedAt":"2018-07-21T22:29:06","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/76","RelatedDescription":"Opened issue \"July 2018 .NET Updates\" (#76) at dotnet/announcements","RelatedBody":"# July 2018 .NET Updates\r\n\r\nThe following .NET updates were released in June 2018. This issue will be updated if there are any additional updates during the month.\r\n\r\n## .NET Framework \r\n\r\n* [.NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog](https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-framework-4-7-2-is-available-on-windows-update-wsus-and-mu-catalog/)\r\n* [Announcing .NET Framework 4.8 Early Access build 3632](https://blogs.msdn.microsoft.com/dotnet/2018/07/18/announcing-net-framework-4-8-early-access-build-3632/)\r\n* [Advisory on July 2018 .NET Framework Updates](https://blogs.msdn.microsoft.com/dotnet/2018/07/20/advisory-on-july-2018-net-framework-updates/)\r\n\r\n## .NET Core\r\n\r\n* [.NET Core July 2018 Update](https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-core-july-2018-update/)\r\n\r\n## .NET Core Support Documents\r\n\r\n* [Microsoft Support for .NET Core](https://github.com/dotnet/core/blob/master/microsoft-support.md)\r\n* [.NET Core Supported OS Lifecycle Policy](https://github.com/dotnet/core/blob/master/os-lifecycle-policy.md)\r\n\r\n## Previous Updates\r\n\r\n* [June 2018](https://github.com/dotnet/announcements/issues/75)\r\n* [May 2018](https://github.com/dotnet/announcements/issues/68)\r\n* [April 2018](https://github.com/dotnet/announcements/issues/64)\r\n"},{"Id":"7997769217","Type":"IssuesEvent","CreatedAt":"2018-07-21T00:56:48","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/74","RelatedDescription":"Opened issue \"Advisory on July 2018 .NET Framework Updates\" (#74) at dotnet/announcements","RelatedBody":"# Advisory on July 2018 .NET Framework Updates\r\n\r\nThe [July 2018 Security and Quality Rollup updates for .NET Framework](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8356) was released earlier this month. We have received multiple customer reports of applications that fail to start or don't run correctly after installing the July 2018 update. These reports are specific to applications that initialize a COM component and run with restricted permissions.\r\n\r\nWe have stopped distributing the .NET Framework July 2018 updates on Windows Update and are actively working on fixing and re-shipping this month's updates. If you installed the July 2018 update and have not yet seen any negative behavior, we recommend that you leave your systems as-is but closely monitor them and ensure that you apply upcoming .NET Framework updates.\r\n\r\nAs a team, we regret that this release was shipped with this flaw. This release was tested using our regular and extensive testing process. We discovered while investigating this issue that we have a test hole for the specific combination of COM activation and restricted permissions, including impersonation. We will be mitigating that gap going forward. Again, we are sorry for any inconvenience that this product flaw has caused.\r\n\r\nWe will continue to update this issue and [post](https://blogs.msdn.microsoft.com/dotnet/2018/07/20/advisory-on-july-2018-net-framework-updates/) as we have new information.\r\n\r\nDiscussion\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [microsoft/dotnet #811](https://github.com/Microsoft/dotnet/issues/811)\r\n\r\n## Technical Context\r\n\r\nThe .NET Framework runtime uses the process token to determine whether the process is being run within an elevated context. These system calls can fail if the required process inspection permissions are not present. This causes an “access denied\" error.\r\n\r\n## Workaround\r\n\r\nTemporarily uninstall the [July 2018 Security and Quality Rollup updates for .NET Framework](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8356) to restore functionality until a new update has been released to correct this problem. \r\n\r\n## Symptoms\r\n\r\nA COM component fails to load because of “access denied,” “class not registered,” or “internal failure occurred for unknown reasons” errors. \r\n\r\nThe most commonly reported failure results in the following error message:\r\n\r\n```console\r\nException type: System.UnauthorizedAccessException\r\nMessage: Access is denied. (Exception from HRESULT: 0x80070005 (E_ACCESSDENIED))\r\n```\r\n\r\n### Sharepoint\r\n\r\nWhen users browse to a SharePoint site they may see the following HTTP 403 message:\r\n\r\n```console\r\n\"The Web Site declined to show this webpage\"\r\n```\r\n\r\nThe SharePoint ULS Logs will contain a message like the following:  \r\n\r\n```console\r\nw3wp.exe (0x1894)         0x0B94  SharePoint Foundation  General 0000       High                UnauthorizedAccessException for the request. 403 Forbidden will be returned. Error=An error occurred creating the configuration section handler for system.serviceModel/extensions: Could not load file or assembly <AssemblySignature>  or one of its dependencies. Access is denied. (C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\Config\\machine.config line 180)    \r\n\r\nw3wp.exe (0x1894)         0x0B94  SharePoint Foundation  General b6p2      VerboseEx                Sending HTTP response 403:403 FORBIDDEN.      \r\n\r\nw3wp.exe (0x1894)         0x0B94  SharePoint Foundation  General 8nca       Verbose                Application error when access /, Error=Access is denied. (Exception from HRESULT: 0x80070005 (E_ACCESSDENIED))\r\n```\r\n\r\nWhen crawling a people content source, the request may fail with the following entry logged to the SharePoint ULS Log: \r\n\r\n```console\r\nmssearch.exe (0x118C) 0x203C SharePoint Server Search Crawler:Gatherer Plugin cd11 Warning The start address sps3s://<URLtoSite> cannot be crawled.  Context: Application 'Search_Service_Application', Catalog 'Portal_Content'  Details:  Class not registered   (0x80040154)  \r\n\r\nIIS Hosted Classic ASP calling CreateObject for .NET COM objects may receive error \"ActiveX component can't create object\" \r\n\r\n.NET Application creates instance of .NET COM application within an Impersonation Context may receive error \"0x80040154 (REGDB_E_CLASSNOTREG)\"\r\n```\r\n\r\n### BizTalk Server Administration Console\r\n\r\nBizTalk Server Administration Console fails to launch properly with the following errors: \r\n\r\n```console\r\nAn internal failure occurred for unknown reasons. (WinMgmt) \r\n\r\nProgram Location:  \r\n\r\n   at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) \r\n\r\n   at System.Management.ManagementObject.Get() \r\n\r\n   at Microsoft.BizTalk.SnapIn.Framework.WmiProvider.SelectInstance\r\n```\r\n\r\nUse the following guidance as a workaround:\r\n\r\n* Add “NETWORK SERVICE” to the local Administrators group. \r\n\r\n### IIS with Classic ASP\r\n\r\nIIS Hosted Classic ASP calling CreateObject for .NET COM objects may receive the following error: \"ActiveX component can't create object\". Use the following guidance as a workaround.\r\n\r\n* If your web site uses Anonymous Authentication, change the Web Site Anonymous Authentication credentials to use the \"Application pool identity\"\r\n* If your site uses Basic Authentication, log into the application once as the application pool identity and then create an instance of the .NET COM component. All subsequent activations for that .NET COM component should succeed, for any user.\r\n\r\n### .NET applications using COM and impersonation\r\n\r\n.NET Applications that creates instances of .NET COM application within an Impersonation Context may receive the following error: \"0x80040154 (REGDB_E_CLASSNOTREG)\". Use the following guidance as a workaround.\r\n\r\n* Create an instance of the .NET COM component prior to the impersonation context call. Later impersonated create instance calls should work as expected.\r\n* Run the .NET Application in the context of the impersonated user\r\n* Avoid using Impersonation when creating the .NET COM object\r\n"},{"Id":"7945147887","Type":"IssuesEvent","CreatedAt":"2018-07-10T17:00:38","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/73","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-8356: .NET Core Security Feature Bypass Vulnerability\" (#73) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-8356: .NET Core Security Feature Bypass Vulnerability\r\n\r\n## <a name=\"executive-summary\"></a>Executive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in .NET Core. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nMicrosoft is aware of a security feature bypass vulnerability that exists when .NET Core does not correctly validate certificates. An attacker who successfully exploited this vulnerability could present an expired certificate when challenged.\r\n\r\nThe update addresses the vulnerability by correcting how .NET Core applications handle certificate validation.\r\n\r\n## Discussion\r\n\r\nDiscussion for this issue can be found at https://github.com/dotnet/wcf/ **TBD**\r\n\r\n### <a name=\"mitigation-factors\"></a>Mitigation factors\r\n\r\n* If an application does use Windows Communication Foundation you are not affected.\r\n\r\n## <a name=\"affected-software\"></a>Affected software\r\n\r\nAny .NET Core, or ASP.NET Core based application that uses System.Private.ServiceModel with a version of 4.5.1 or earlier.\r\n\r\nPackage name | Vulnerable versions | Secure versions\r\n------------ | ---------------- | -------------------------\r\nSystem.Private.ServiceModel | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 |  4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Duplex | 4.0.0, 4.0.1, 4.0.2 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.0.3 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Http | 4.0.0, 4.0.10, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.NetTcp | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Primitives | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Security | 4.0.0, 4.0.1, 4.0.2 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.0.3 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\n\r\n## <a name=\"advisory-faq\"></a>Advisory FAQ\r\n### <a name=\"how-affected\"></a>How do I know if I am affected?\r\n\r\n.NET Core projects have two types of dependencies: direct and transitive. You must update your projects using the following instructions to address both types of dependency.\r\n\r\n### <a name=\"project-format\"></a>.NET Core Project formats\r\n\r\n.NET Core has two different project file formats, depending on what software created the project.\r\n\r\n1. `project.json` is the format used in .NET Core 1.0 and Microsoft Visual Studio 2015.\r\n2. `csproj` is the format used in .NET Core 1.1, .NET Core 2.0 and Microsoft Visual Studio 2017.\r\n\r\n#### Direct dependencies\r\n\r\nDirect dependencies are discoverable by examining your `csproj` file or your `project.json` file. They can be fixed by [editing the project file](#direct-dependencies) or using NuGet to update the dependency.\r\n\r\n The `System.Private.ServiceModel` package is not meant to be directly depended on and will not appear in your direct dependency list.\r\n\r\n#### Transitive dependencies\r\n\r\nTransitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.\r\n\r\nTransitive dependencies are reviewable in three ways, depending on your [project format](#project-format):\r\n\r\n* In the Visual Studio Solution Explorer window, which supports searching.\r\n* By examining the `project.assets.json` file contained in the obj directory of your project for `csproj` based projects *OR*.\r\n* By examining the `project.lock.json` file contained in the root directory of your project for `project.json` based projects.\r\n\r\nThe `project.assets.json` and `project.lock.json` files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.\r\n\r\n#### <a name=\"direct-dependencies-vs2017\"></a>Fixing direct dependencies in a csproj based project / Visual Studio 2017\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.4.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nThe preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.\r\nThe package version number is in the `Version` attribute. The previous example shows a single direct dependency on `System.ServiceModel.Http` version 4.4.0.\r\n\r\nTo update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).\r\nIn this example, update `System.ServiceModel.Http` to the appropriate [fixed package number](#affected-software) for your major version. Save the *csproj* file. The example *csproj* now looks as follows:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.4.3\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nIf you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.\r\n\r\nNow recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.\r\n\r\n#### <a name=\"direct-dependencies-vs2015\"></a> Fixing Direct Dependencies in project.json based project / Visual Studio 2015\r\n\r\nOpen your `project.json` file in your editor. Look for the dependencies section. Below is an example dependencies section:\r\n\r\n``` json\r\n    \"dependencies\": {\r\n      \"Microsoft.NETCore.App\": {\r\n        \"version\": \"1.0.1\",\r\n        \"type\": \"platform\"\r\n      },\r\n     \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n     \"System.ServiceModel.Http\" : \"4.0.0\"\r\n    }\r\n```\r\n\r\nThis example has three direct dependencies: `Microsoft.NETCore.App`, `Microsoft.AspNetCore.Mvc.Core` and `System.ServiceModel.Http`.\r\n\r\n`Microsoft.NetCore.App` is the platform the application targets, you should ignore this. The other packages expose their version to the right of the package name. In our example, our non-platform packages are version 1.0.1.\r\n\r\nReview your direct dependencies for any instance of the packages and versions listed above. In the example above, there is a direct dependency on a vulnerable package, `System.ServiceModel.Http` version 4.4.0.\r\n\r\nTo update to the fixed package, change the version number to be the appropriate package for your release. In the example, this would be updating `System.ServiceModel.Http` to 4.4.3.\r\n\r\nAfter updating the vulnerable package versions, save your `project.json` file.\r\n\r\nThe dependencies section in our example `project.json` would now look as follows:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n    \"System.ServiceModel.Http \": \"4.4.3\"\r\n  }\r\n```\r\n\r\nIf you are using Visual Studio and save your updated `project.json` file, Visual Studio will restore the new package version. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependency.\r\n\r\nAfter you have addressed all of your direct dependencies, you must also review your transitive dependencies.\r\n\r\nAfter you've addressed all of your direct dependencies, you must review your transitive dependencies.\r\n\r\n#### Discovering and fixing transitive dependencies\r\n\r\nThere are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can review [the `project.assets.json` file](#project-assets-json) or the [the `project.lock.json` file](#project-lock-json).\r\n\r\n##### <a name=\"vs-solution-explorer\"></a>Using Visual Studio Solution Explorer\r\n\r\nTo use Solution Explorer, open the project in Visual Studio, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.\r\n\r\nFor example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:\r\n\r\n![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)\r\n\r\nThe search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.\r\n\r\nUnder the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.\r\nIn screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.\r\nThe `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\n##### <a name=\"project-assets-json\"></a> Manually reviewing project.assets.json (csproj/VS2017)\r\n\r\nOpen the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.\r\nVisual Studio and Visual Studio Code provide JSON friendly editing.\r\n\r\nSearch the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:\r\n\r\n* Examine the line on which they are found, the version number is after the `/`.\r\n* Compare to the [vulnerable versions table](#affected-software).\r\n\r\nFor example, a search result that shows `System.ServiceModel.Http/4.3.0` is a reference to version 4.3.0 of `System.ServiceModel.Http`.\r\n\r\nIf your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to any vulnerable packages, this means either\r\n\r\n* None of your direct dependencies depend on any vulnerable packages, or\r\n* You have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.\r\nLook for `PackageReference` nodes, for example:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nYou must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.\r\nYou do this by adding a new line to the dependencies section, referencing the fixed version.\r\nFor example, if your search showed a transitive reference to a vulnerable `System.ServiceModel.Http` version, you'd add a reference to the [fixed package number](#affected-software).\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.3.2\" />\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nAfter you've added the direct dependency reference, save your *csproj* file.\r\n\r\nIf you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.\r\n\r\n##### <a name=\"project-lock-json\"></a> Manually reviewing project.lock.json (project.json/VS2015)\r\n\r\nOpen the `project.lock.json` file in your editor. We suggest you use an editor that understands json and allows you to collapse and expand nodes to review this file; both Visual Studio and Visual Studio Code provide this functionality.\r\n\r\nIf you are using Visual Studio the `project.lock.json` file is “under” the `project.json` file. Click the right pointing triangle, ▷, to the left of the `project.json` file to expand the solution tree to expose the `project.lock.json` file. The following image shows a project with the `project.json` file expanded to show the `project.lock.json` file.\r\n\r\n![project lock json](https://cloud.githubusercontent.com/assets/796298/25858179/f6e01200-348f-11e7-8a77-7176d8dd3f03.png)\r\n\r\nSearch the `project.lock.json` file for the vulnerable packages, using the format `packagename/`, using each of the package names from the table above. If you find any vulnerable assembly name in your search examine the line on which they are found, the version number is after the `/` and compare to the vulnerable versions table above. For example a search result that shows `System.ServiceModel.Http/4.0.1` is a reference to v4.0.1 of `System.ServiceModel.Http`.   If your `project.lock.json` file includes references to any of the package versions shown above then you will need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to a vulnerable version of `System.ServiceModel.Http` this means none of your direct dependencies depend on any vulnerable packages or you have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to any of the vulnerable packages you must add a direct dependency to the updated package to your `project.json` file to override the transitive dependency. Open your `project.json` and find the dependencies section. For example:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nFor each of the vulnerable packages your search returned you must add a direct dependency to the updated version by adding it to the `project.json` file. You do this by adding a new line to the dependencies section, referring the fixed version. For example, if your search showed a transitive reference to the vulnerable `System.ServiceModel.Http` version 1.0.0 you would add a reference to the appropriate fixed version, 1.0.6. Edit the `project.json` file as follows:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"System.ServiceModel.Http\": \"4.1.2\",\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nAfter you have added direct dependencies to the fixed packages, save your `project.json` file.\r\n\r\nIf you are using Visual Studio save your updated `project.json` file and Visual Studio will restore the new package versions. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependencies.\r\n\r\n#### Rebuilding your application\r\n\r\nFinally you must rebuild your application, test, and redeploy.\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \"as is\" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### External Links\r\n\r\n[CVE-2018-8356](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2018-8356)\r\n\r\n### Revisions\r\n\r\nV1.0 (July 10, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2018-07-10_\r\n"},{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"8001679996","Type":"PullRequestEvent","CreatedAt":"2018-07-23T04:50:14","Actor":"AaronRobinsonMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/19079","RelatedDescription":"Opened pull request \"Remove hosthook api\" (#19079) at dotnet/coreclr","RelatedBody":"cc @luqunl @jkotas "},{"Id":"8001563764","Type":"PullRequestEvent","CreatedAt":"2018-07-23T03:56:43","Actor":"sywhang","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18762","RelatedDescription":"Merged pull request \"Enable profiler attach on Windows\" (#18762) at dotnet/coreclr","RelatedBody":"This is an ongoing work to enable profiler attach on CoreCLR. This PR enables the profiler attach feature on Windows. I am in process of working on Unix port. "},{"Id":"8001545090","Type":"IssuesEvent","CreatedAt":"2018-07-23T03:48:18","Actor":"Zhentar","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/19078","RelatedDescription":"Opened issue \"JIT: multiply & add not optimized to LEA when destination is a different register\" (#19078) at dotnet/coreclr","RelatedBody":"```cs\r\ni = i * sizeof(uint) + 3;\r\nrefDestination = i;\r\n```\r\nJITs down to\r\n```asm\r\nlea     eax,[rdx*4+3]\r\nmov     dword ptr [rcx],eax\r\n```\r\nall well and good. But if I cut out the intermediate set....\r\n```cs\r\nrefDestination = i * sizeof(uint) + 3\r\n```\r\nJIT gives me\r\n```asm\r\n\tmov     eax,edx\r\n\tshl     eax,2\r\n\tadd     eax,3\r\n\tmov     dword ptr [rcx],eax\r\n```\r\n\r\nIt's bit unfortunate that `lea` isn't getting used in the scenario where it could also cut out an additional instruction."},{"Id":"8000582003","Type":"PullRequestEvent","CreatedAt":"2018-07-22T17:36:05","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/19077","RelatedDescription":"Opened pull request \"JIT: some lclvars related cleanup\" (#19077) at dotnet/coreclr","RelatedBody":"Consolidate various compiler globals used when setting local var ref\r\ncounts by folding them into the visitor:\r\n* lvaMarkRefsCurBlock\r\n* lvaMarkRefsCurStmt\r\n* lvaMarkRefsWeight\r\n\r\nRemove the largely vestigial `lvPrefReg` and associated methods to set\r\nor modify this field. Haven't verified but this is likely a remmant of\r\nthe legacy backend.\r\n\r\nIn the one remaning use (lcl var sorting predicates), swap in `lvIsRegArg`\r\ninstead, which gets most of the same cases."},{"Id":"8000463301","Type":"PullRequestEvent","CreatedAt":"2018-07-22T16:12:11","Actor":"AndyAyersMS","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/19068","RelatedDescription":"Merged pull request \"JIT: stateful local ref counts and weights\" (#19068) at dotnet/coreclr","RelatedBody":"Introduce a notion of state for local var ref counts and weighted ref counts.\r\nAccesses and current state must agree.\r\n\r\nState is invalid initially, enabled for an early period around bits of morph,\r\ninvalid again for a time, and then enabled normally once lvaMarkRefs is called.\r\n\r\nAccesses normally specify RCS_NORMAL as the desired state, but in the accesses\r\nof selected ref counts in morph, specify RCS_EARLY.\r\n\r\nRevise how we decide if normal ref counting is active by changing\r\n`lvaLocalVarRefCounted` into a method.\r\n\r\nUpdate `gtIsLikelyRegVar` to not access ref counts when they're not in a valid\r\nstate."},{"Id":"7999649725","Type":"IssuesEvent","CreatedAt":"2018-07-22T05:05:58","Actor":"Zhentar","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/19076","RelatedDescription":"Opened issue \"JIT: Stack zeroed with rep stosd\" (#19076) at dotnet/coreclr","RelatedBody":"C# source in this gist: https://gist.github.com/Zhentar/4ffb0a5d597c4c1e788d6007f1602b21\r\n\r\nAccording to vTune, 5% of my execution time is in my function's prologue. This was unexpected because it hadn't been in previous iterations (and my function body had unfortunately not improved at all).\r\nLooking at the the disassembly, I see:\r\n```asm\r\nLineEnumerator.MoveNext()\r\n\tpush    rdi\r\n\tpush    rsi\r\n\tsub     rsp,48h\r\n\tmov     rsi,rcx\r\n\tlea     rdi,[rsp+28h]\r\n\tmov     ecx,8\r\n\txor     eax,eax\r\n\trep     stos dword ptr [rdi]\r\n\tmov     rcx,rsi\r\n\tmov     rax,0F1CD0434ED23h\r\n\tmov     qword ptr [rsp+40h],rax\r\n```\r\n\r\nThe `rep stos dword` in there seems rather odd - at the very least, it should be a `rep stos qword` with half as many iterations (although I'm not sure it would be any faster on my Skylake). But also I don't think there's any x86 architecture for which a 32 byte `rep stos` is faster than a reasonable unrolled version and the unrolled version wouldn't even be particularly large. And some of the comments in the JIT code seem to suggest that `rep stos` shouldn't ever be getting emitted."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"8001629939","Type":"IssuesEvent","CreatedAt":"2018-07-23T04:27:13","Actor":"davkean","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9721","RelatedDescription":"Opened issue \"global.json sdk preference doesn't appear to be respected\" (#9721) at dotnet/cli","RelatedBody":"_From @flcdrg on July 22, 2018 12:1_\n\nI have a global.json with the following content:\r\n\r\n```\r\n{\r\n    \"sdk\": {\r\n      \"version\": \"2.1.300\"\r\n    }\r\n}\r\n```\r\n\r\nAnd a project with the following header:\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFramework>net471</TargetFramework>\r\n```\r\n\r\nOn my system, running `dotnet --info` gives the following output:\r\n\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.302\r\n Commit:    9048955601\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17134\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.302\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.2\r\n  Commit:  811c3ce6c0\r\n\r\n.NET Core SDKs installed:\r\n  2.1.4 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100-preview-007326 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100-preview-007354 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100-preview-007363 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.100 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.101 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.103 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.104 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200-preview-007474 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200-preview-007517 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200-preview-007576 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200-preview-007597 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.201 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.400-preview-009063 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n```\r\n\r\nBut when I run msbuild, the following is displayed:\r\n\r\n```\r\nMicrosoft (R) Build Engine version 15.7.180.61344 for .NET Framework\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nC:\\Program Files\\dotnet\\sdk\\2.1.400-preview-009063\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.RuntimeIdentifierInfere\r\nnce.targets(143,5): message NETSDK1057: You are working with a preview version of the .NET Core SDK. You can define the\r\n SDK version via a global.json file in the current project. More at https://go.microsoft.com/fwlink/?linkid=869452\r\n```\r\n\r\nWhy is it saying it's using the preview version of .NET Core SDK if global.json specifies 2.1.300?\n\n_Copied from original issue: dotnet/project-system#3769_"},{"Id":"8001233376","Type":"PullRequestEvent","CreatedAt":"2018-07-23T01:27:14","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/9720","RelatedDescription":"Merged pull request \"Merge release/2.1.4xx to release/2.2.1xx\" (#9720) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into release/2.2.1xx.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-release/2.2.1xx\ngit reset --hard upstream/release/2.2.1xx\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-release/2.2.1xx --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"8001232446","Type":"PullRequestEvent","CreatedAt":"2018-07-23T01:26:43","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/9719","RelatedDescription":"Merged pull request \"Merge release/2.1.4xx to release/2.1.401\" (#9719) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into release/2.1.401.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-release/2.1.401\ngit reset --hard upstream/release/2.1.401\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-release/2.1.401 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"8001095181","Type":"PullRequestEvent","CreatedAt":"2018-07-23T00:00:55","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9720","RelatedDescription":"Opened pull request \"Merge release/2.1.4xx to release/2.2.1xx\" (#9720) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into release/2.2.1xx.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-release/2.2.1xx\ngit reset --hard upstream/release/2.2.1xx\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-release/2.2.1xx --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"8001095145","Type":"PullRequestEvent","CreatedAt":"2018-07-23T00:00:53","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9719","RelatedDescription":"Opened pull request \"Merge release/2.1.4xx to release/2.1.401\" (#9719) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into release/2.1.401.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-release/2.1.401\ngit reset --hard upstream/release/2.1.401\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-release/2.1.401 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"8001081694","Type":"IssuesEvent","CreatedAt":"2018-07-22T23:50:39","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9713","RelatedDescription":"Closed issue \"Unable to install templates on Ubuntu 18.04 after upgrading to 2.1.302\" (#9713) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nTry installing any dotnet template with dotnet version 2.1.302 on Ubuntu 18.04.  For example, `dotnet new -i \"Amazon.Lambda.Templates::*\"`.  But it happens with any of them.\r\n\r\n## Expected  behavior\r\nThe templates should install without any issues.\r\n\r\n## Actual behavior\r\nYou'll get an error like:\r\n```\r\nnathaniel@nelknet:~/Projects$ dotnet new -i \"Amazon.Lambda.Templates::*\"\r\n  Restoring packages for /home/nathaniel/.templateengine/dotnetcli/v2.1.302/scratch/restore.csproj...\r\n/usr/share/dotnet/sdk/2.1.302/NuGet.targets(114,5): error : Unable to load the service index for source https://api.nuget.org/v3/index.json. [/home/nathaniel/.templateengine/dotnetcli/v2.1.302/scratch/restore.csproj]\r\n/usr/share/dotnet/sdk/2.1.302/NuGet.targets(114,5): error :   The type initializer for 'System.Net.Http.HttpConnectionPool' threw an exception. [/home/nathaniel/.templateengine/dotnetcli/v2.1.302/scratch/restore.csproj]\r\n/usr/share/dotnet/sdk/2.1.302/NuGet.targets(114,5): error :   Version's parameters must be greater than or equal to zero. [/home/nathaniel/.templateengine/dotnetcli/v2.1.302/scratch/restore.csproj]\r\n/usr/share/dotnet/sdk/2.1.302/NuGet.targets(114,5): error :   Parameter name: revision [/home/nathaniel/.templateengine/dotnetcli/v2.1.302/scratch/restore.csproj]\r\n\r\n```\r\nand the templates will not be installed.\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n```\r\nnathaniel@nelknet:~/Projects$ dotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.302\r\n Commit:    9048955601\r\n\r\nRuntime Environment:\r\n OS Name:     ubuntu\r\n OS Version:  18.04\r\n OS Platform: Linux\r\n RID:         ubuntu.18.04-x64\r\n Base Path:   /usr/share/dotnet/sdk/2.1.302/\r\n\r\nHost (useful for support):\r\n  Version: 2.1.2\r\n  Commit:  811c3ce6c0\r\n\r\n.NET Core SDKs installed:\r\n  2.0.2 [/usr/share/dotnet/sdk]\r\n  2.1.4 [/usr/share/dotnet/sdk]\r\n  2.1.302 [/usr/share/dotnet/sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.2 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.0 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.5 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n```\r\n\r\n\r\n\r\n\r\n"},{"Id":"8001066959","Type":"IssuesEvent","CreatedAt":"2018-07-22T23:39:05","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9718","RelatedDescription":"Closed issue \"Runtime resolution to more recent for FDD published apps broken in some circumstances (e.g. 2.1.0-preview2 -> 2.1.1)\" (#9718) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n1) Make sure no runtimes/sdks/shared frameworks are installed (in my case I had a 1.0.0 installed still, but that I did not expect to be used)\r\n2) Install 2.1.0-preview2 SDK Install on Win x64 in my case (URL: https://www.microsoft.com/net/download/thank-you/dotnet-sdk-2.1.300-preview2-windows-x64-installer) (<-- others may fail too, but 2.1.1 e.g. -> 2.1.2 does not)\r\n3) Create a new console app with \"dotnet new console\" in a folder called myapp\r\n4) Publish an FDD version with \"dotnet publish\"\r\n5) Confirm this runs by doing \"dotnet bin/Debug/netcoreapp2.1/publish/myapp.dll\" (You should see \"Hello World\"\r\n6) Uninstall SDK just installed from add/remove programs\r\n7) Install 2.1.1 (2.1.301 SDK) from https://www.microsoft.com/net/download/thank-you/dotnet-sdk-2.1.301-windows-x64-installer (2.1.2 will also have the same issue)\r\n8) run \"dotnet --info\" and confirm that 2.1.1 is the only one installed (remove (if necessary) shared frameworks from Program Files\\dotnet\\shared\\{folders}\\version (as listed by info other than 2.1.1 (or 2.1.2 if you chose that in step 7\r\n9) go back to myapp folder and run \"dotnet bin/Debug/netcoreapp2.1/publish/myapp.dll\"\r\n\r\n## Expected  behavior\r\nSee \"Hello World\" as in step 5 as 2.1.1 is clearly a more recent (more supported and more secure) version than 2.1.0-preview2\r\n\r\nI have been unable to find any statement anywhere that preview versions (while unsupported) would not support resolution to a more recent version.\r\n\r\n## Actual behavior\r\n(To be clear I had 1.0.0 installed also despite my steps, which is why it is listed below and used 2.1.2 in this case, but have tried without 1.0.0 and tried with 2.1.1 from preview2 also)\r\n\r\nError Output:\r\nIt was not possible to find any compatible framework version\r\nThe specified framework 'Microsoft.NETCore.App', version '2.1.0-preview2-26406-04' was not found.\r\n  - Check application dependencies and target a framework version installed at:\r\n      C:\\Program Files\\dotnet\\\r\n  - Installing .NET Core prerequisites might help resolve this problem:\r\n      http://go.microsoft.com/fwlink/?LinkID=798306&clcid=0x409\r\n  - The .NET Core framework and SDK can be installed from:\r\n      https://aka.ms/dotnet-download\r\n  - The following versions are installed:\r\n      1.0.0 at [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n      2.1.2 at [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.302\r\n Commit:    9048955601\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17134\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.302\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.2\r\n  Commit:  811c3ce6c0\r\n\r\n.NET Core SDKs installed:\r\n  1.0.0-preview2-003121 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.NETCore.App 1.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"8000911098","Type":"IssuesEvent","CreatedAt":"2018-07-22T21:37:49","Actor":"mirkogeffken","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9718","RelatedDescription":"Opened issue \"Runtime resolution to more recent for FDD published apps broken in some circumstances (e.g. 2.1.0-preview2 -> 2.1.1)\" (#9718) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n1) Make sure no runtimes/sdks/shared frameworks are installed (in my case I had a 1.0.0 installed still, but that I did not expect to be used)\r\n2) Install 2.1.0-preview2 SDK Install on Win x64 in my case (URL: https://www.microsoft.com/net/download/thank-you/dotnet-sdk-2.1.300-preview2-windows-x64-installer) (<-- others may fail too, but 2.1.1 e.g. -> 2.1.2 does not)\r\n3) Create a new console app with \"dotnet new console\" in a folder called myapp\r\n4) Publish an FDD version with \"dotnet publish\"\r\n5) Confirm this runs by doing \"dotnet bin/Debug/netcoreapp2.1/publish/myapp.dll\" (You should see \"Hello World\"\r\n6) Uninstall SDK just installed from add/remove programs\r\n7) Install 2.1.1 (2.1.301 SDK) from https://www.microsoft.com/net/download/thank-you/dotnet-sdk-2.1.301-windows-x64-installer (2.1.2 will also have the same issue)\r\n8) run \"dotnet --info\" and confirm that 2.1.1 is the only one installed (remove (if necessary) shared frameworks from Program Files\\dotnet\\shared\\{folders}\\version (as listed by info other than 2.1.1 (or 2.1.2 if you chose that in step 7\r\n9) go back to myapp folder and run \"dotnet bin/Debug/netcoreapp2.1/publish/myapp.dll\"\r\n\r\n## Expected  behavior\r\nSee \"Hello World\" as in step 5 as 2.1.1 is clearly a more recent (more supported and more secure) version than 2.1.0-preview2\r\n\r\nI have been unable to find any statement anywhere that preview versions (while unsupported) would not support resolution to a more recent version.\r\n\r\n## Actual behavior\r\n(To be clear I had 1.0.0 installed also despite my steps, which is why it is listed below and used 2.1.2 in this case, but have tried without 1.0.0 and tried with 2.1.1 from preview2 also)\r\n\r\nError Output:\r\nIt was not possible to find any compatible framework version\r\nThe specified framework 'Microsoft.NETCore.App', version '2.1.0-preview2-26406-04' was not found.\r\n  - Check application dependencies and target a framework version installed at:\r\n      C:\\Program Files\\dotnet\\\r\n  - Installing .NET Core prerequisites might help resolve this problem:\r\n      http://go.microsoft.com/fwlink/?LinkID=798306&clcid=0x409\r\n  - The .NET Core framework and SDK can be installed from:\r\n      https://aka.ms/dotnet-download\r\n  - The following versions are installed:\r\n      1.0.0 at [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n      2.1.2 at [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.302\r\n Commit:    9048955601\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17134\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.302\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.2\r\n  Commit:  811c3ce6c0\r\n\r\n.NET Core SDKs installed:\r\n  1.0.0-preview2-003121 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.NETCore.App 1.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"8000608755","Type":"IssuesEvent","CreatedAt":"2018-07-22T17:56:17","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9717","RelatedDescription":"Closed issue \"Failed to load the dll from [C:\\Program Files\\dotnet\\host\\fxr\\2.0.9\\hostfxr.dll] , HRESULT: 0x7D4A8\" (#9717) at dotnet/cli","RelatedBody":"Getting Error when running dotnet --help or other dotnet command\r\nFailed to load the dll from [C:\\Program Files\\dotnet\\host\\fxr\\2.0.9\\hostfxr.dll]\r\n, HRESULT: 0x7D4A8\r\nThe library hostfxr.dll was found, but loading it from C:\\Program Files\\dotnet\\h\r\nost\\fxr\\2.0.9\\hostfxr.dll failed\r\n\r\nEnvironment: \r\nOS: Windows 7 Ultimate SP1  (32 bit)\r\n\r\nFollowing things installed \r\n\r\ndotnet-sdk-2.1.202-win-x86\r\nKB2999226\r\nKB2533623\r\nMicrosoft Visual C++ 2015 Redistributable Update 3\r\n\r\n\r\n\r\n\r\n\r\n\r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7997726371","Type":"IssuesEvent","CreatedAt":"2018-07-21T00:27:56","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/774","RelatedDescription":"Closed issue \"Idea/Proposal: Split .NET Standard into multiple smaller standards by relying on tooling\" (#774) at dotnet/standard","RelatedBody":"First, let me start by saying that this is not supposed to be a final proposal, but more like a rough draft / general idea, that I hope to tranform into a valid proposal with the help of everyone here.\r\nI fear this is going to be a controversial topic, but I've had this idea in the back of my head for a few days now, and I'd like to at least try explaining it there, so as to have your feedback.\r\nSo, please bear with me until the end of this topic. 😅\r\n\r\n# Abstract\r\n\r\n[Like many others](https://github.com/dotnet/standard/issues/682), I do wish .NET Standard 2.1 was already a thing.\r\nBut I do also perfectly understand the concerns about .NET Core 2.1 being the only implementation already ahead in the standard. And because of that I do fear that .NET Standard 2.0 will be the last .NET Standard version ever. (But at the same time, I'm kinda going to propose replacing it by something else here… 😒)\r\n\r\nAside of that, the fact that .NET Standard 2.0 is not compatible with .NET 4.5 can sometimes be an obstacle in the migration process to .NET Core. (That's something we are faced with everyday in my current job)\r\n\r\nSo I wondered, what if, instead of having *one unique standard*, there were *many smaller standards* that could be implemented à-la-carte by runtimes/frameworks/NuGet ?\r\nWhat if we could already define something such as a \"Span Standard 1.0\" ?\r\n\r\nAnd yes, I know that the original design of DNX / .NET Standard 1.0 was more modular, I know that there were once such a thing as Assembly Neutral Interfaces, and I know all of this did not work out that well. This did obviously lead to the acceptable compromise that is .NET Standard 2.0.\r\n\r\nBut, I assure you, I am *not* proposing to reiterate the exact same mistakes as in .NET Standard 1 era. (Which is not to say that I'm not taking strong inspiration on what has/had already been done. 😉)\r\n\r\nWhat I'm thinking of is a mechanism that should help reduce coupling **without** requiring changes in the existing runtimes, and could work reasonably well with support in the tooling.\r\n\r\n# The general idea\r\n\r\nWe would define many ````feature```` sets that can overlap eachother. At the begining, features would likely be defined based on current .NET Standard 1.0~2.0 APIs, by splitting unrelated features away from eachother. (Basically what I call a ````feature```` here is like a much smaller .NET Standard) \r\n\r\nA ````feature```` would be defined very *similarly* to a reference assembly (i.e. no implementation), and define what API a consumer should expect when **depending** on the ````feature````.\r\n\r\nI'll take as an example the current hot topic of ````Span<T>```` and .NET Standard 2.0/2.1 to illustrate how ````features```` could help:\r\n````Span<T>```` is available to altmost anyone, but only .NET Core 2.1 supports the fast ````Span<T>```` and the new Span-based APIs:\r\n\r\n - Assume that there is no such thing as ````.NET Standard````\r\n - We could define ````Feature.Span, Version=1.0```` for the portable span, as implemented in ````System.Memory````\r\n - We could define ````Feature.Span, Version=1.1```` for the fast span, as implemented in .NET Core 2.1\r\n - Let's assume that we already have ````Feature.Sockets, Version=2.0```` representing the ````System.Net.Sockets```` feature from .NET Framework 2.0.\r\n - We could define ````Feature.Span.Sockets, Version=1.0````:\r\n   - This feature would have a feature dependecy on both ````Feature.Span, Version=1.0```` and ````Feature.Net.Sockets, Version=2.0````\r\n   - This feature would define all the new Span-related members introduced on Sockets\r\n - Let's assume that we have ````Feature.IO, Version=4.5```` representing the ````System.IO```` subset from the NuGet package with the same name.\r\n - We could define ````Feature.Span.Streams, Version=1.0````:\r\n   - This feature would have a feature dependecy on both ````Feature.Span, Version=1.0```` and ````Feature.IO, Version=4.5````\r\n   - This feature would define all the new Span-related members introduced on System.IO.Stream\r\n - We could go on with all the other places where Span-related API were introduced, but I'm sure you get the idea…\r\n\r\nℹ️ Note: Don't pay too much attention about the fictional boundaries of the features yet, I'm pretty sure I wouldn't want the feature to be shaped _exactly_ like described above. 😉\r\n\r\nWith such ````features```` defined, I could write a database client library, and declare that it depends on ````Feature.Runtime````, ````Feature.CSharp, Version=7.3````, ````Feature.Net.Sockets````, ````Feature.Span.Sockets````, ````Feature.Collections````, and ````Feature.Data.Common````.\r\nThis would allow my library to run on any runtime, provided that it at least supports all the ````features```` I used.\r\n\r\n# The (Draft) Proposal\r\n\r\n## Defining features\r\n\r\nA ````feature```` is an API shape, or contract (similar to .NET Standard), whose concrete implementation is provided by either a runtime (e.g. .NET Core) **or** by NuGet packages.\r\n\r\nWe would ideally reserve a prefix on NuGet for official .NET features. (e.g. ````Feature.````)\r\n\r\n - In the initial version, features would only ever be created by Microsoft / .NET Foundation\r\n - A ````feature```` is represented as a **single** assembly, typically exposed as a NuGet package.\r\n - A ````feature```` assembly contains only metadata (no implementation), like would any reference assembly.\r\n - A ````feature```` assembly contains only public types and members. (public types, public members and protected members)\r\n - A ````feature```` assembly can (will) have dependencies on other ````feature```` assemblies. (Dependencies would be supported via NuGet packages)\r\n - A ````feature```` assembly defines only the exact API surface that it supports\r\n   - A ````feature```` can only provide complete interface definitions. (Interface versioning problem: it is not possible to add or remove interface members)\r\n   - A ````feature```` can provide delegates. (Complete definition, not that any other form would be valid anyway)\r\n   - A ````feature```` provides only partial type definitions for structs, classes, and enums: Only publicly visible members that are provided by the ````feature````, are included in the metadata.\r\n   - ````features```` don't need to provide public constructors to type they augment\r\n   - A ````feature```` cannot add an abstract method to a pre-existing type (TBD: How can this be enforced ? Maybe based on the presence of a public constructor ?)\r\n   - (Obvious) Every type that is referenced in the ````feature```` assembly must exist either in the ````feature```` assembly itself or in one of its dependent ````feature```` assemblies.\r\n - Multiple ````features```` can provide the same member on the same type, if they both provide it for different reasons\r\n - Across ````feature```` assemblies, type identity is only determined by their full name \r\n - ````features```` follow Semantic Versioning (TBD)\r\n   - A ````feature```` of minor version M > N must always depend on the ````feature```` version N (Version M should only include the new types and members)\r\n   - A ````feature```` of major version M > N can depend on ````feature```` version N if it doesn't include breaking changes (In the current state of affairs, I expect that there would never be breaking changes)\r\n\r\nI expect that ````feature```` assemblies will never be referenced by concrete runtime, library or application assemblies.\r\n\r\nFor the rest of this proposal, I will address the proposed feature (sorry 😑) as ````feature````:\r\nA ````feature```` is either ````provided```` or ````depended upon````. Usage of any other term is likely a mistake on my part.\r\n\r\n## Wiring up features\r\n\r\n### Within libraries\r\n\r\nA new TFM ````features```` is created, acting similarly to ````netstandard```` TFMs.\r\nLibrary projects can target the TFM ````features```` like they would target .NET Standard, .NET FX, .NET Core or other TFMs.\r\n\r\nWhen targeting the TFM ````features````, the library project must reference all features it depends on:\r\n\r\n - We could assume that the TFM ````features```` provide **zero** API by default. (But maybe it provide some kind of minimal subset ?)\r\n - Features could be bundled in larger feature packages to avoid referencing hundreds of feature packages. (Similar to ````Microsoft.AspNetCore.All````)\r\n - The project can reference other libraries that are based on the ````features```` TFM, and will transitively inherit feature dependencies.\r\n\r\nAt build time, the toochain will load all ````feature```` assemblies and construct a model of the global feature set required by the library by merging all type definitions in the feature assemblies.\r\nThis can be done in the compiler or before calling the compiler, via an external tool. (I feel it might be easier to add this in the MSBuild build process than in Roslyn.)\r\n\r\nAll metadata references to ````features```` would be mapped to a non-existant and well-known ````features```` assembly (possibly signed, and in that case, the signing key would have to be public).\r\n\r\n⚠️ Important: The feature dependencies still need to be stored somewhere inside the resulting assembly… But I don't know how they should be stored. (Custom attributes, or regular .NET assembly references ?)\r\n\r\n### Within applications\r\n\r\nWhat is true today will still hold true with features: Applications are expected to target a concrete framework.\r\nHowever, application projects would gain the ability to reference features-based projects and libraries.\r\n\r\nWhen an application references a features-based project, the toolchain (NuGet & MSBuild) must always validate that the current TFMs for the project support all of the required ````features````, directly, or via compatibility NuGet packages.\r\n\r\nAt build time, the toochain will load all ````feature```` assemblies indirectly referenced by the project and construct a **shim** assembly covering all of the required ````features````:\r\n\r\n - This assembly will have the well-known name ````features```` (identical to what is referenced by ````feature````-based library projects)\r\n - This assembly will contain ````TypeForwardedToAttribute```` attributes for each and every type referenced by the features. (That's assuming that feature support has already verified for the project, so that all the members of forwarded types are guaranteed to exist)\r\n - The assembly is (likely) signed with the well-known signing key.\r\n\r\nThe generated ````features```` **shim** assembly will be bundled with the application, and act as the glue between features-based libraries and the underlying framework. (This should be very similar to how .NET Standard works, if I'm not mistaken)\r\n\r\nℹ️ NB: In the end, what I propose is that, rather than the runtime(s), the **application** is responsible for **providing** (wire-up) the features that the libraries depend upon. (But that this is handled by the toolchain)\r\n\r\n## Providing features (i.e. Concrete implementations)\r\n\r\nSplitting type definitions across multiple reference-like assemblies should not break typical .NET expectations:\r\n\r\n - A concrete type implementation can only be provided by **one** assembly\r\n - Where the concrete type implementation ends up being (i.e. in which assembly) is dependent on the runtime, and *should not matter to the library developer*\r\n - The runtime is never aware of the partial type definitions that were used to build libraries\r\n\r\nThere must exist a mapping between runtimes/frameworks and features, and features could likely be always provided via NuGet packages.\r\nThis would provide a single source of metadata for the toolchain to generate its shim assemblies.\r\n\r\nThis is basically what we could expect:\r\n\r\n - A NuGet package can declare a list of implemented ````features````.\r\n - If a NuGet package claims to **provide** a ````feature````, it must **provide** this ````feature```` entirely, even if that means that some method would throw ````NotImplementedException````\r\n   - Implementation of the feature could, however, rely on other dependencies (via ````TypeForwardedToAttribute````)\r\n   - Implementation of a feature is always relative to a valid TFM that **is not** ````features```` (but it could be ````netstandard2.0````)\r\n - For each framework, a NuGet package with the correct Major.Minor version would exist. (e.g. ````Framework.NETCoreApp, Version=2.1.0````)\r\n   - Framework NuGet packages would **not** contain the framework itself\r\n   - Framework NuGet packages would define which features the framework supports, and how they are mapped\r\n   - Framework NuGet packages could be updated incrementally to add features as they are standardized\r\n   - Framework NuGet packages would be flagged specifically\r\n\r\n## Features on the NuGet side\r\n\r\nAll of the above requirements would likely require adaptations on the NuGet side:\r\n\r\n - As said earlier, Microsoft or .NET Foundation should reserve a NuGet prefix for features (e.g. ````Feature.````) to ease discovery of features and avoid pollution\r\n - Microsoft or .NET Foundation should reserve a NuGet prefix for frameworks (e.g. ````Framework.````) to ease discovery of framework-feature mappings\r\n - A NuGet package must be identifiable as a ````feature````\r\n   - ````features```` are to be always considered framework agnostic\r\n   - ````feature```` packages should only contain one reference assembly (Named the same as the feature ?)\r\n   - ````feature```` packages should be ignored by older NuGet implementations\r\n - A NuGet package must be able to **depend on** a ````feature````\r\n   - That might be as simple as declaring a regular package dependency\r\n - A NuGet package must be able to **provide** a ````feature````\r\n   - The features which are provided must be listed in the package… (How ?)\r\n   - A NuGet package implementing one ore more feature must contain, for each TFM where it applies, exactly **one** well-known assembly named ````features````, signed with a well-known key, and containing/forwarding the implementation of all the features.\r\n - A NuGet package must be identifiable as a ````framework````\r\n   - Framework NuGet packages are not considered framework agnostic (they… are… applying to themselves, somehow)\r\n   - Framework NuGet packages follow the same rules as NuGet packages that **provide** ````features````\r\n\r\n# Remarks\r\n\r\n## How should ````features```` be sliced from .NET Standard ?\r\n\r\nThe goal of this proposal is not (yet) to propose how ````features```` should be sliced, but to propose how to allow them to be sliced.\r\nHowever, it must be noted, that there are many ways to slice an API with the feature proposed here.\r\nWhile most types will not require any special treatment, some types may be better sliced into multiple separate features, rather than exported as a single feature.\r\n\r\nWe could consider, for example, that the ````Stream```` class could be exported in a ````Feature.IO.Stream.Sync```` and ````Feature.IO.Stream.Async````, with possibly even a common feature ````Feature.IO.Stream.Core````.\r\n\r\nI'm sure that would generate a lot of discussions anyway… 🙂\r\n\r\n## Possible uses of ````features````\r\n\r\nApart from the obvious modularization of the standard, ````features```` could also be used in the following scenarios:\r\n\r\n - For framework dependencies of a .NET language such as C#: The ````feature```` for the language would be versioned in parallel with the language version, and, for each version, declare every type and member needed to fully support that version of the language.\r\n - For defining an optional standardized .NET UI API. (Whose implementation might be tied to the runtime)\r\n - Defining a new ````feature```` over a third party API, for allowing developers to more easily swap the implementation (because ````features```` apply to any .NET type, and not just only interfaces)\r\n\r\n ## Finding how ````features```` are provided\r\n\r\n While ````features```` provided by the runtime can be easy to discover (the user only would only need to import the corresponding package, and the tools might even do it automatically), it might be much harder to find that a package for supporting a feature exists on a given runtime.\r\n\r\n Given that the responsibility for ensuring that à ````feature```` is **provided** is delegated to the final user (user of the library(ies) depending on ````features````), there might be a need for some sort of mechanism helping to discover feature implementations.\r\n\r\n It would be great if NuGet coult auto import default feature-providing packages, based on some kind of repository… So that everything goes smoothly on the end-user side.\r\n\r\n# (Supposed) pros and cons of this proposal\r\n\r\n## Pros\r\n\r\n - More fine grained control over dependencies (looser coupling, maybe recovering some of the possibilities that were lost by removing Assembly Neutral Interfaces)\r\n - Ability to standardize small parts of the API surface rather than a whole framework (e.g. new Span APIs could be standardized faster on their own)\r\n - Ability to make some newer APIs compatible with old .NET versions again (That is an important scenario in some migration paths)\r\n - Ability to standardize things such as UI APIs (e.g. Windows Forms) without redefining \".NET Standard\"\r\n - This proposal does not require modifying existing runtimes\r\n\r\n## Cons\r\n\r\n - This proposal adds yet another layer of complexity to the already complicated world of framework compatibility\r\n - Consuming libraries implemented over ````features```` requires upgrading the toolchain (that is not a problem for everyone, but it can be for some)\r\n - This proposal may requires non-trivial additions to NuGet (let's hope not)\r\n - Slicing the .NET Standard API in a potentially large number of fine-grained features must be done very carefully, and may take quite a bit of time\r\n\r\n# Conclusion\r\n\r\nThank you very much for reading this to the end !\r\n\r\nI'm waiting for your feedback. 😉"},{"Id":"7997675587","Type":"IssuesEvent","CreatedAt":"2018-07-20T23:58:06","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/705","RelatedDescription":"Closed issue \"System.Web.HttpUtility.HtmlDecode can't decode &hairsp;\" (#705) at dotnet/standard","RelatedBody":"Hello,\r\ni have a problem with the HtmlDecode Method of System.Web.HttpUtility:\r\nIt can't decode the \"`&hairsp;`\" Entity. I was wondering if there is a reason for it, because it's defined by the w3.org (see here: [https://www.w3.org/TR/WD-math-970710/fnewtable05.html](https://www.w3.org/TR/WD-math-970710/fnewtable05.html))\r\n\r\nGreetings from Germany,\r\nTachionstrahl"},{"Id":"7997661242","Type":"IssuesEvent","CreatedAt":"2018-07-20T23:50:21","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/724","RelatedDescription":"Closed issue \"Consider a more open-ended compatibilty mapping with .NET Framework\" (#724) at dotnet/standard","RelatedBody":"@Petermarcu suggested that we might desire a more open ended behavior rather than what we currently have (.NET 4.6.1).  Opening this on his behalf."},{"Id":"7997099004","Type":"IssuesEvent","CreatedAt":"2018-07-20T20:41:42","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/791","RelatedDescription":"Closed issue \"When Building a UWP app with .netstandard 2.0 and Compile With Native Tool Chain, Build Hangs forever\" (#791) at dotnet/standard","RelatedBody":"I have a project that I have released into the windows app store and have an update which included porting from xamarin forms project to a .net standard solution.\r\n\r\nAfter porting the project I have found that any time I build the app (release mode, for the app store) with the:\r\n\r\n\"Compile with .NET Native tool chain\" checked the build hangs forever. It will hang on any platform that I select when this item is checked.\r\n\r\nI have tried the following flags in an attempt to fix it in my project build settings:\r\n\r\n```XML\r\n<ShortcutGenericAnalysis>true</ShortcutGenericAnalysis>\r\n<SingleThreadNUTC>true</SingleThreadNUTC>\r\n<Use64BitCompiler>true</Use64BitCompiler>\r\n```\r\n\r\nI have tried deleting obj and bin folders, no success.\r\nI have all of the latest VS updates and the latest package updates. "}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"8001492430","Type":"IssuesEvent","CreatedAt":"2018-07-23T03:24:40","Actor":"shravan2x","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/31264","RelatedDescription":"Closed issue \"Reverse() extension missing for IReadOnlyList<T>\" (#31264) at dotnet/corefx","RelatedBody":"The `Reverse()` method is available in two forms today - An O(1) memory version for `List<T>` and an O(N) version for generic `IEnumerable`s.\r\n\r\nHowever, the optimized version does not seem to be defined on `IReadOnlyList<T>`. Is there a reason for this?"},{"Id":"8001422495","Type":"IssuesEvent","CreatedAt":"2018-07-23T02:54:14","Actor":"shravan2x","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/31264","RelatedDescription":"Opened issue \"Reverse() extension missing for IReadOnlyList<T>\" (#31264) at dotnet/corefx","RelatedBody":"The `Reverse()` method is available in two forms today - An O(1) memory version for `List<T>` and an O(N) version for generic `IEnumerable`.\r\n\r\nHowever, the optimized version does not seem to be defined on `IReadOnlyList<T>`. Is there a reason for this?"},{"Id":"8001391683","Type":"IssuesEvent","CreatedAt":"2018-07-23T02:40:46","Actor":"ViktorHofer","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/31263","RelatedDescription":"Opened issue \"OpenCover code coverage broken with xunit 2.4.0\" (#31263) at dotnet/corefx","RelatedBody":"See the warnings. Testing with xunit 2.4.0. cc @pjanotti.\r\nRelates to https://github.com/dotnet/corefx/pull/31260\r\n\r\n```msbuild\r\nC:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests>dotnet msbuild /t:RebuildAndTest /p:Coverage=true\r\nMicrosoft (R) Build Engine version 15.8.160-preview+gaf9d27ba72 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  RemoteExecutorConsoleApp -> C:\\git\\corefx\\bin\\AnyOS.AnyCPU.Debug\\RemoteExecutorConsoleApp\\netstandard\\RemoteExecutorConsoleApp.exe\r\n  System.Text.RegularExpressions.Tests -> C:\\git\\corefx\\bin\\AnyOS.AnyCPU.Debug\\System.Text.RegularExpressions.Tests\\netcoreapp\\System.Text.RegularExpressions.Tests.dll\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning : SymUnmanagedWriterException: Specified method is not supported. [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :    at Microsoft.DiaSymReader.SymUnmanagedWriterFactory.CreateWriter(ISymWriterMetadataProvider metadataProvider, SymUnmanagedWriterCreationOptions options) in /_/src/Microsoft.DiaSymReader/Writer/SymUnmanagedWriterFactory.cs:line 86 [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :    at Microsoft.DiaSymReader.Tools.PdbConverter.ConvertPortableToWindows(PEReader peReader, MetadataReader pdbReader, Stream targetPdbStream, PortablePdbConversionOptions options) in /_/src/Microsoft.DiaSymReader.Converter/PdbConverter.cs:line 169 [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :    at Microsoft.DiaSymReader.Tools.PdbConverter.ConvertPortableToWindows(PEReader peReader, Stream sourcePdbStream, Stream targetPdbStream, PortablePdbConversionOptions options) in /_/src/Microsoft.DiaSymReader.Converter/PdbConverter.cs:line 143 [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :    at Microsoft.DotNet.Build.Tasks.ConvertPortablePdbsToWindowsPdbs.ConvertPortableToWindows(ITaskItem file, PdbConverter converter, PortablePdbConversionOptions parsedConversionOptions) [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :    at Microsoft.DotNet.Build.Tasks.ConvertPortablePdbsToWindowsPdbs.Execute() [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning : NotSupportedException: Specified method is not supported. [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :    at Microsoft.DiaSymReader.SymUnmanagedWriterFactory.CreateWriter(ISymWriterMetadataProvider metadataProvider, SymUnmanagedWriterCreationOptions options) in /_/src/Microsoft.DiaSymReader/Writer/SymUnmanagedWriterFactory.cs:line 81 [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\nC:\\git\\corefx\\bin/testhost/netcoreapp-Windows_NT-Debug-x64/shared/Microsoft.NETCore.App/10.10.10/System.Text.RegularExpressions.dll : warning :  [C:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests\\System.Text.RegularExpressions.Tests.csproj]\r\n  Replacing Portable PDB with Windows Pdb in place!\r\n  Using C:\\git\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Debug-x64\\ as the test runtime folder.\r\n  Executing in C:\\git\\corefx\\bin\\tests\\System.Text.RegularExpressions.Tests\\netcoreapp-Windows_NT-Debug-x64\\\r\n  ----- start  4:38:12.62 ===============  To repro directly: =====================================================\r\n  pushd C:\\git\\corefx\\bin\\tests\\System.Text.RegularExpressions.Tests\\netcoreapp-Windows_NT-Debug-x64\\\r\n  call C:\\git\\corefx\\packages/OpenCover\\4.6.519\\tools\\OpenCover.Console.exe -oldStyle -filter:\"+[System.Text.RegularExpressions]*\" -excludebyfile:\"*\\Common\\src\\System\\SR.*\" -nodefaultfilters -excludebyattribute:*.ExcludeFromCodeCoverage* -skipautoprops -hideskipped:All -threshold:1 -returntargetcode -register:user -target:C:\\git\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Debug-x64\\\\dotnet.exe -output:C:\\git\\corefx\\bin/tests/coverage\\System.Text.RegularExpressions.Tests.coverage.xml -targetargs:\"xunit.console.dll System.Text.RegularExpressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=OuterLoop -notrait category=failing  -notrait Benchmark=true\"\r\n  popd\r\n  ===========================================================================================================\r\n  Executing: C:\\git\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Debug-x64\\dotnet.exe\r\n  xUnit.net Console Runner v2.4.0 (64-bit .NET Core 4.6.26720.05)\r\n    Discovering: System.Text.RegularExpressions.Tests\r\n    Discovered:  System.Text.RegularExpressions.Tests\r\n    Starting:    System.Text.RegularExpressions.Tests\r\n    Finished:    System.Text.RegularExpressions.Tests\r\n  === TEST EXECUTION SUMMARY ===\r\n     System.Text.RegularExpressions.Tests  Total: 1498, Errors: 0, Failed: 0, Skipped: 0, Time: 5.963s\r\n  Committing...\r\n  No results, this could be for a number of reasons. The most common reasons are:\r\n      1) missing PDBs for the assemblies that match the filter please review the\r\n      output file and refer to the Usage guide (Usage.rtf) about filters.\r\n      2) the profiler may not be registered correctly, please refer to the Usage\r\n      guide and the -register switch.\r\n  ----- end  4:38:20.71 ----- exit code 0 ----------------------------------------------------------\r\n  Loading report 'C:\\git\\corefx\\bin\\tests\\coverage\\System.Text.RegularExpressions.Tests.coverage.xml'\r\n   Preprocessing report\r\n   Initiating parser for OpenCover\r\n  Initializing report builders for report types: Html, Badges\r\n  Analyzing 0 classes\r\n   Creating summary\r\n  Report generation took 0.4 seconds\r\n\r\nC:\\git\\corefx\\src\\System.Text.RegularExpressions\\tests>\r\n``´"},{"Id":"8001334919","Type":"IssuesEvent","CreatedAt":"2018-07-23T02:16:03","Actor":"michaeljfarr","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/31262","RelatedDescription":"Opened issue \"Q: Log warning for large numbers of HttpClient/SocketsHttpHandler?\" (#31262) at dotnet/corefx","RelatedBody":"I have just discovered the cause of an annoying memory leak was that one of our libraries what creating a new HttpClient in every request and not disposing it (gaah).  When using WinHttpHandler, the cost was a few hundred managed bytes per HttpClient.  With SocketsHttpHandler, the cost was more like 22KB and some increasingly long TimerQueueTimer chains in HttpConnectionPoolManager (that showed up in the memory snapshot.\r\n\r\nI have some suggestions to help detect/minimise such leaks in the future.  I couldn't really come up with anything solid, but hopefully, you can.\r\n\r\n1. Do you think it would be possible for the DiagnosticsHandler or some other component to track the number of HttpClients instances and log a warning if the number gets above a certain level?  \r\n\r\n2. Instead of creating an Infinite timer (see below), would it be better to just dispose the timer entirely when it isn't in use?  I'm not 100% sure why unreferenced handlers aren't being released from memory but this is probably holding the reference.  _cleaningTimer = new Timer(s => ((HttpConnectionPoolManager)s).RemoveStalePools(), this, Timeout.Infinite, Timeout.Infinite);  (I imagine there is a performance cost to this, but I am not sure how much)\r\n               \r\n3. Would it be ok for HttpMessageInvoker to have a Finalizer that tidies up the HttpMessageHandler (if _disposeHandler is true)?\r\n\r\nhopefully, some of that is helpful, but I am not sure there is any proper solution to this other than just having everyone dispose their objects properly (or not create loads of HttpClients to begin with).  thanks ;-)\r\n\r\nbtw: for testing this my TargetFramework is netcoreapp2.1"},{"Id":"8001229364","Type":"PullRequestEvent","CreatedAt":"2018-07-23T01:25:03","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/31261","RelatedDescription":"Opened pull request \"Handle overflow in uname -r\" (#31261) at dotnet/corefx","RelatedBody":"Fixes https://github.com/dotnet/corefx/issues/31259"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"8001289931","Type":"PullRequestEvent","CreatedAt":"2018-07-23T01:56:02","Actor":"jnm2","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28779","RelatedDescription":"Opened pull request \"Generate constructor vertical member selection\" (#28779) at dotnet/roslyn","RelatedBody":"Fixes #28774."},{"Id":"8001247400","Type":"PullRequestEvent","CreatedAt":"2018-07-23T01:34:51","Actor":"agocke","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28778","RelatedDescription":"Opened pull request \"Add cache for GetTypeByMetadataName\" (#28778) at dotnet/roslyn","RelatedBody":"This seems to be a popular call among analyzers, especially XUnit. It's a\r\nreasonable way to acquire a well-known analyzer type, but analyzers often\r\ndon't save the resulting symbol. This causes significant CPU work to be done\r\nrepeatedly as XUnit looks for the same symbol over and over, passing in the\r\nsame type name each time.\r\n\r\nA very small, simple cache seems to solve the problem without requiring any\r\nchanges on the XUnit side."},{"Id":"8001098882","Type":"PullRequestEvent","CreatedAt":"2018-07-23T00:03:32","Actor":"CyrusNajmabadi","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28777","RelatedDescription":"Opened pull request \"Prioritize NavigateTo searches to care most about the current actives docs/project.\" (#28777) at dotnet/roslyn","RelatedBody":"This is valuable for people who would like to search, knowing something is in the files they have opened.  Instead of blindly searching everything, we prioritize their opened work, and then search everything else after that."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"8000342616","Type":"IssuesEvent","CreatedAt":"2018-07-22T14:52:33","Actor":"Happypig375","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/6131","RelatedDescription":"Opened issue \"Explicitly installing System.Numerics.Vectors causes build to fail\" (#6131) at dotnet/corert","RelatedBody":"In Release mode (aka .NET Native used), the following error occurs.\r\n\r\n[See sample](https://github.com/Happypig375/NetNativeError)\r\n\r\nNormal build log:\r\n```\r\n1>------ Build started: Project: NetNativeError.Control, Configuration: Release x86 ------\r\n1>  NetNativeError.Control -> C:\\Users\\user\\Source\\Repos\\NetNativeError\\NetNativeError.Control\\bin\\x86\\Release\\NetNativeError.Control.exe\r\n1>  Processing application code\r\n1>  Computing application closure and generating interop code\r\n1>    Loading 56 modules...\r\n1>    Generating code...\r\n1>    Interop code generated.\r\n1>  Generating serialization code\r\n1>  Compiling interop code\r\n1>  Generating System.Reflection.DispatchProxy proxy code.\r\n1>  Cleaning up unreferenced code\r\n1>  Generating native code\r\n1>  Generating fixups for native code\r\n========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========\r\n```\r\n\r\nBuild log after explicitly installing the System.Numerics.Vectors NuGet package (4.1.1 and 4.5.0 tested; 4.1.1 used in sample):\r\n```\r\n1>------ Build started: Project: NetNativeError.Error, Configuration: Release x86 ------\r\n1>  NetNativeError.Error -> C:\\Users\\user\\Source\\Repos\\NetNativeError\\NetNativeError.Error\\bin\\x86\\Release\\NetNativeError.Error.exe\r\n1>  Processing application code\r\n1>  Computing application closure and generating interop code\r\n1>    Loading 56 modules...\r\n1>    Generating code...\r\n1>    Interop code generated.\r\n1>  Generating serialization code\r\n1>  Compiling interop code\r\n1>  Generating System.Reflection.DispatchProxy proxy code.\r\n1>  Cleaning up unreferenced code\r\n1>  Generating native code\r\n1>C:\\Users\\user\\.nuget\\packages\\microsoft.net.native.compiler\\1.7.3\\tools\\Microsoft.NetNative.targets(697,5): error : Error: NUTC301B:Internal Compiler Error: Assembly 'C:\\Users\\user\\Source\\Repos\\NetNativeError\\NetNativeError.Error\\obj\\x86\\Release\\ilc\\intermediate\\ILTransformed\\NetNativeError.Error.ilexe' not found\r\n1>C:\\Users\\user\\.nuget\\packages\\microsoft.net.native.compiler\\1.7.3\\tools\\Microsoft.NetNative.targets(697,5): error : ILT0005: 'C:\\Users\\user\\.nuget\\packages\\microsoft.net.native.compiler\\1.7.3\\tools\\x86\\ilc\\Tools\\nutc_driver.exe @\"C:\\Users\\user\\Source\\Repos\\NetNativeError\\NetNativeError.Error\\obj\\x86\\Release\\ilc\\intermediate\\MDIL\\NetNativeError.Error.rsp\"' returned exit code 1\r\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\r\n```"},{"Id":"7998384655","Type":"PullRequestEvent","CreatedAt":"2018-07-21T10:12:10","Actor":"trylek","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6130","RelatedDescription":"Opened pull request \"WIP: Remaining CPAOT changes rebased to my latest changes\" (#6130) at dotnet/corert","RelatedBody":"This change represents the remainder of my CoreRT R2R bring-up changes\r\nfrom the last two weeks. Amy, Simon and myself managed to gradually\r\nsiphon parts of the complex change off to separate commits so that the\r\nremaining bits have become easier to manage and review.\r\n\r\nThe only way to further split this remaining change, if desired, would\r\nbe basically by replicating the bring-up process - enabling just a\r\nsubset of the import cells and taking the appropriate parts of the\r\nRTRNF / CII.RTR changes; but I don't think the change is that complex\r\nas is to merit what would otherwise be just busywork.\r\n\r\nFeel free to leave out the map file emission if you want to even though\r\nI find it quite useful myself. I want to improve it in the future by\r\nmaking it a full-fledged map file - storing the entries until the\r\nfinal relocation phase and then outputting them in section order and\r\nwith the full RVA's, that would be much easier for looking up the\r\nvarious indirection cells. Of course we should probably produce the file\r\nunder some switch, I haven't wired that up yet as I'm using the map\r\nall the time.\r\n\r\nTo expedite the review process, I'm sending this change out for PR\r\nas WIP even though I most likely won't be able to finish the review\r\nprocess. The main purpose of this review is to solicit early feedback\r\nfrom Jan and Michal.\r\n\r\nOne potentially problematic thing is the modification to\r\nMultiFileCompilationModuleGroup. Michal and / or Jan should say whether\r\nwe need to derive a new ReadyToRunCompilationModuleGroup and move this\r\nfunctionality there.\r\n\r\nPlease note that, while the code has been refactored to avoid\r\nusing MethodCodeNode, it still does use IMethodCodeNode\r\nas we need this contract to fill in the various fields once the method\r\ngets compiled - I don't see what should be different here in R2R.\r\nPerhaps we should move IMethodCodeNode to some common\r\nlocation as a cleanup change - why not into JitInterface considering\r\nit's in fact a CorInfoImpl contract?\r\n\r\nThe GC info is still unfinished - in particular, I don't know how to\r\nget to the unwind info. IIRC the code today emits something like an\r\nulong(0) which should mean \"no unwind info\" before the GC info. This\r\nis something we'll need to look into soon to unblock larger-scale\r\ntesting - not necessarily saying it needs fixing in this change.\r\n\r\nAs for the conditional directives in getCallInfo / getFieldInfo,\r\nit seems to me that they use just about 2-3 different constructs so\r\nthat we might be able to further simplify this by creating\r\nforked helpers for them in the two files CII.RJ / CII.RTR and\r\nremove the conditional compilations.\r\n\r\nI leave it up to Simon / Amy to decide whether they want to finish\r\nthe review I started by pushing additional commits into my remote\r\nGIT repository and by removing the WIP status or whether they'll\r\nstart their own review (or series of reviews) in case of more\r\nsubstantial modifications to my changes.\r\n\r\nIn its current form the change also still includes the change to the\r\nrepro Program.cs making it the \"R2R unit test suite\". This shouldn't\r\nbe merged in to the repro location. We need to figure out where\r\nto put it, I would definitely love to not throw it away, certainly\r\nnot before we have some other testing up and running. For bringing\r\nup the individual helpers it's just awesome.\r\n\r\nThanks\r\n\r\nTomas"},{"Id":"7998315204","Type":"PullRequestEvent","CreatedAt":"2018-07-21T09:10:00","Actor":"trylek","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6117","RelatedDescription":"Merged pull request \"Preparatory changes for R2R node factory refactoring\" (#6117) at dotnet/corert","RelatedBody":"I managed to identify several hopefully non-controversial parts\r\nof my complex change I might be able to review and merge in\r\nbefore I leave on vacation. This basically adds two new\r\npartial ports from CoreCLR native code (NibbleWriter and\r\nSignatureBuilder), moves two files into the ReadyToRun folder\r\n(FixupConstants and RvaEmbeddedPointerIndirectionNode),\r\nimplements the changes to [non-thread] static non-GC\r\nplacement needed for R2R plus a few tiny miscellanous fixes.\r\n\r\nThanks\r\n\r\nTomas"},{"Id":"7997486424","Type":"PullRequestEvent","CreatedAt":"2018-07-20T22:33:51","Actor":"stephentoub","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6129","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6129) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @stephentoub"},{"Id":"7997237263","Type":"PullRequestEvent","CreatedAt":"2018-07-20T21:16:38","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6129","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6129) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7997047386","Type":"PullRequestEvent","CreatedAt":"2018-07-20T20:28:55","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6128","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6128) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7997033666","Type":"PullRequestEvent","CreatedAt":"2018-07-20T20:25:34","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6128","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6128) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1020476243089608704","CreatedAt":"2018-07-21T01:11:10+00:00","UserScreenname":"dotnet","Text":"Advisory on July 2018 .NET Framework Updates https://t.co/nMiUiov4NS #sorry #psa","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":46,"FavoriteCount":31,"RawContent":null},{"Id":"1019942507344482305","CreatedAt":"2018-07-19T13:50:18+00:00","UserScreenname":"dotnet","Text":"Our @csharpfritz is hosting another workshop tomorrow, and his guest at 12 ET / 11 CT / 9 PT is @jbogard.  Tune in… https://t.co/0aqBYfhA08","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":9,"RawContent":null},{"Id":"1019598416861544453","CreatedAt":"2018-07-18T15:03:00+00:00","UserScreenname":"dotnet","Text":"#dotNETConf is back for 2018! 3 days of free #dotnet #developer content streaming live around the globe. Save the d… https://t.co/tloJwxPMb9","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":517,"FavoriteCount":358,"RawContent":null},{"Id":"1019283191507582981","CreatedAt":"2018-07-17T18:10:24+00:00","UserScreenname":"dotnet","Text":"Check out the replay and learn about building reusable business objects in your applications from @RockyLhotka and… https://t.co/VnbmnXt31C","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":14,"FavoriteCount":7,"RawContent":null},{"Id":"1019254182673436672","CreatedAt":"2018-07-17T16:15:08+00:00","UserScreenname":"dotnet","Text":"Code refactoring support in Visual Studio 2017 with @kuhlenhuth https://t.co/HkaG7b6Ac3","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":59,"FavoriteCount":26,"RawContent":null},{"Id":"1019207783844139010","CreatedAt":"2018-07-17T13:10:46+00:00","UserScreenname":"dotnet","Text":"Always a great time, and two experts that are wonderful to learn from.  Tune in at 10a ET / 7a PT / 14:00 UTC / 8p… https://t.co/PQsuqaJQY4","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":11,"FavoriteCount":3,"RawContent":null},{"Id":"1018952801953681411","CreatedAt":"2018-07-16T20:17:33+00:00","UserScreenname":"dotnet","Text":"Rocky's got great insight into building Enterprise applications.  Be sure to tune in tomorrow when he pair-programs… https://t.co/cdQT99n8kk","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":10,"FavoriteCount":4,"RawContent":null},{"Id":"1018877434584817664","CreatedAt":"2018-07-16T15:18:04+00:00","UserScreenname":"dotnet","Text":"Our Jeff Fritz will be hosting another one of his FREE workshops this Friday.  This week, tune in and learn about s… https://t.co/06laByebWA","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":33,"FavoriteCount":13,"RawContent":null},{"Id":"1017101058773053445","CreatedAt":"2018-07-11T17:39:23+00:00","UserScreenname":"dotnet","Text":"Learn more about writing games with C#, .NET, and Unity right NOW on Twitch... https://t.co/UHRZk39EWG","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":68,"FavoriteCount":21,"RawContent":null},{"Id":"1016825199109423104","CreatedAt":"2018-07-10T23:23:13+00:00","UserScreenname":"dotnet","Text":".NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog https://t.co/oBwPB86Pxf","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":109,"FavoriteCount":96,"RawContent":null}]}},"RunOn":"2018-07-23T05:30:35.4065032Z","RunDurationInMilliseconds":8128}