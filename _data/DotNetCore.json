{"Data":{"Blog":{"FeedItems":[{"Title":"Announcing the Windows Compatibility Pack for .NET Core","PublishedOn":"2017-11-17T04:59:32+00:00","CommentsCount":52,"FacebookCount":0,"Summary":"Porting existing code to .NET Core used to be quite hard because the available API set was very small. In .NET Core 2.0, we already made this much easier, thanks to .NET Standard 2.0. Today,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/","RawContent":null},{"Title":"UPDATE – Microservices and Docker containers: Architecture, Patterns and Development guidance (Updated for .NET Core 2.0)","PublishedOn":"2017-11-16T22:00:06+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published this eBook/guide and sample application offering guidance for architecting microservices and Docker containers based applications. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-microservices-and-docker-containers-architecture-patterns-and-development-guidance-updated-for-net-core-2-0/","RawContent":null},{"Title":"UPDATE – Web Applications with ASP.NET Core Architecture and Patterns guidance (Updated for ASP.NET Core 2)","PublishedOn":"2017-11-16T21:00:05+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published an eBook/Guide and sample application offering guidance named Architecting Modern Web Applications with ASP.NET Core and Microsoft Azure. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-web-applications-with-asp-net-core-architecture-and-patterns-guidance-updated-for-asp-net-core-2/","RawContent":null},{"Title":"Introducing Tensor for multi-dimensional Machine Learning and AI data","PublishedOn":"2017-11-15T22:00:18+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Overview Tensor is an exchange type for homogenous multi-dimensional data for 1 to N dimensions. The motivation behind introducing Tensor&#60;T&#62; is to make it easy for Machine Learning library...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/introducing-tensor-for-multi-dimensional-machine-learning-and-ai-data/","RawContent":null},{"Title":"Introducing Nullable Reference Types in C#","PublishedOn":"2017-11-15T20:00:47+00:00","CommentsCount":203,"FacebookCount":0,"Summary":"Today we released a prototype of a C# feature called &#8220;nullable reference types&#8220;, which is intended to help you find and fix most of your null-related bugs before they blow up at runtime....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/","RawContent":null},{"Title":"Announcing F# support for .NET Core and .NET Standard projects in Visual Studio","PublishedOn":"2017-11-15T19:00:49+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"We&#8217;re pleased to announce that Visual Studio 2017 15.5 Preview 4 now supports F# projects targeting .NET Core, .NET Standard, and .NET Framework through the .NET Core SDK. Some of you have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/announcing-f-support-for-net-core-and-net-standard-projects-in-visual-studio/","RawContent":null},{"Title":"Welcome to C# 7.2 and Span","PublishedOn":"2017-11-15T19:00:26+00:00","CommentsCount":22,"FacebookCount":0,"Summary":"C# 7.2 is the latest point release of C#, and adds a number of small but useful features. All the features are described in wonderful detail in the docs. Start with the overview, What&#8217;s new in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/welcome-to-c-7-2-and-span/","RawContent":null},{"Title":".NET Core November 2017 Update","PublishedOn":"2017-11-15T05:25:23+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core November Update. This includes .NET Core 1.0.8, 1.1.5 and 2.0.1 and .NET Core SDK 1.1.5 and 2.0.3. Details regarding the security issues addressed by this release...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-core-november-2017-update/","RawContent":null},{"Title":".NET Framework November 2017 Security and Quality Rollup","PublishedOn":"2017-11-15T03:54:36+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"Today, we are releasing the November 2017 Security and Quality Rollup. Security This release contains no new security updates. The most recent .NET security updates were shipped with the September...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-framework-november-2017-security-and-quality-rollup/","RawContent":null},{"Title":"Modernize existing .NET apps with Windows Containers and Azure","PublishedOn":"2017-11-01T23:14:48+00:00","CommentsCount":22,"FacebookCount":0,"Summary":"As part of the series of posts announced at this initial blog post (.NET Application Architecture Guidance) that explores each of the architecture areas currently covered by our team, this current...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/01/modernize-existing-net-apps-with-windows-containers-and-azure/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6934052963","Type":"PullRequestEvent","CreatedAt":"2017-12-02T15:19:09","Actor":"rprouse","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Opened pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"6872255902","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:01:26","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Merged pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6872252909","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:00:44","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Merged pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6868854916","Type":"PullRequestEvent","CreatedAt":"2017-11-17T09:04:03","Actor":"AndreyAkinshin","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Opened pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6816687850","Type":"IssuesEvent","CreatedAt":"2017-11-06T20:30:07","Actor":"Petermarcu","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Closed issue \"File system watcher crash\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."},{"Id":"6797468573","Type":"PullRequestEvent","CreatedAt":"2017-11-01T23:04:17","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Opened pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6886438076","Type":"IssuesEvent","CreatedAt":"2017-11-21T19:28:57","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/49","RelatedDescription":"Opened issue \".NET Core Alpine Image Ready for Testing\" (#49) at dotnet/announcements","RelatedBody":"# .NET Core Alpine Image Ready for Testing\r\n\r\nAn [Alpine](https://hub.docker.com/_/alpine/)-based Docker image is now available for .NET Core. Alpine is much smaller than Debian, which we have used for the .NET Core base image to date. There have been many requests for an Alpine image. We are pleased to make it available. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image.\r\n\r\nWe have added two new images:\r\n\r\n- `2.1-runtime-alpine`\r\n- `2.1-runtime-deps-alpine`\r\n\r\nAlpine support is part of the .NET Core 2.1 release. .NET Core 2.1 images are currently provided at the [microsoft/dotnet-nightly](https://hub.docker.com/r/microsoft/dotnet-nightly/) repo, including the new Alpine images. .NET Core 2.1 images will be promoted to the [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) repo when .NET Core 2.1 is shipped as a Preview, expected to be early 2018.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet/dotnet-docker-nightly #500](https://github.com/dotnet/dotnet-docker-nightly/issues/500)\r\n\r\n## Details\r\n\r\n* [dotnet/dotnet-docker-nightly #480](https://github.com/dotnet/dotnet-docker-nightly/pull/480)\r\n* [dotnet/announcements #20](https://github.com/dotnet/announcements/issues/20)\r\n* [dotnet/dotnet-docker-samples #94](https://github.com/dotnet/dotnet-docker-samples/pull/94)\r\n\r\nThe primary goal of Alpine is very small deployments. We have been considering various design decisions to make .NET Core Alpine base images as small as possible to align with that. In this first iteration, we enabled [.NET Core 2.0 Globalization Invariant Mode](https://github.com/dotnet/announcements/issues/20) in order to reduce the default size of the image. This change reduced the image by ~30MB. You can see the reduction in size for .NET Core images relative to Debian in the following table.\r\n\r\n|2.1 Image|Debian|Alpine|\r\n|-----    |------|------|\r\n|`-deps`   |153MB (68MB compressed) |13.8 MB (6MB compressed)|\r\n|`-runtime`|222MB (96MB compressed) |82.5 (34MB compressed)|\r\n\r\nNote: The compressed size is what you will see in a [registry](https://hub.docker.com/r/microsoft/dotnet-nightly/tags/) and is the wire-size cost.\r\n\r\nWe are also considering saving more space by native-compiling fewer assemblies. .NET Core runtime assemblies are native-compiled with the [crossgen tool](https://github.com/dotnet/coreclr/blob/master/Documentation/building/crossgen.md) in the [Ready2Run format](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md). Native-compiled code delivers superior startup performance but at the cost of 2-3x larger files. We have the opportunity to compile less, skipping compiling assemblies in part or in whole. We believe that we can save at least another 10MB through compiling less without a material drop in performance. For scenarios that value size over startup or where wire cost is significant, it may be valuable to aggressively reduce the number/% of compilation.\r\n\r\nAlpine images are only available for .NET Core 2.1. At the current time, only Runtime images are available. We intend to offer SDK images at a later date.\r\n\r\nUse cases that cannot tolerate Globalization invariant mode can reset the `DOTNET_SYSTEM_GLOBALIZATION_INVARIANT` environment variable and install the ICU package. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image with and without Globalization Invariant Mode enabled.\r\n\r\n## Call to Action\r\n\r\nPlease test your workloads with the new Alpine image. In particular, we want to know if enabling .NET Core Globalization Invariant Mode is acceptable/appreciated.\r\n"},{"Id":"6854176970","Type":"IssuesEvent","CreatedAt":"2017-11-14T18:00:49","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Reopened issue \"Microsoft Security Advisory CVE-2017-11770 : Malformed Certificate can cause Denial of Service\" (#44) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-11770 \r\n## Malformed Certificate can cause Denial of Service\r\n### Executive Summary \r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1, and 2.0. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed certificate or other ASN.1 formatted data could lead to a denial of service via an infinite loop on Linux and macOS.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.8, 1.1.5 and 2.0.1. Developers are advised to update their .NET Core SDK to version 2.0.3 or 1.1.5.\r\n### Discussion\r\n\r\nPlease use **** TODO: FILL IN ISSUE LINK *** for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n.NET Core applications running on Windows are not affected by this vulnerability. \r\n\r\n## Affected Software\r\nThe vulnerabilities affect any Microsoft .NET Core project if it uses any of affected runtime versions listed blow and is running on Linux.\r\n\r\nPlatform  | Runtime Version | Fixed runtime version\r\n----------------|----------------| -------------------------\r\nLinux | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.7<br />1.1.0, 1.1.1, 1.1.2, 1.1.4<br />2.0.0 |  1.0.8<br />1.1.5<br />2.0.1\r\nmacOS | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.7<br />1.1.0, 1.1.1, 1.1.2, 1.1.4 |  1.0.8<br />1.1.5\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.7 or lower, or 1.1.2 or lower, or 2.0.0 is affected. The default version of the .NET core runtime can be listed by running `dotnet --info`, which should produce output in the form of \r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n\r\n```\r\n\r\nAs this only displays the latest version of the runtime installed it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. By default these are\r\n\r\n| Operating System          | Location          |\r\n|---------------------------|-------------------|\r\n| macOS | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/       |\r\n| Supported Linux platforms | /usr/share/dotnet/shared/Microsoft.NETCore.App/       |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you do not have a directory for 1.0.8, 1.1.5 or 2.0.1 then any applications targeting .NET Core will be vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest runtimes or SDKs. Typically application servers only install a runtime package, developer machines install SDKs. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). Version 1.1.5 will also install version 1.0.8 of the runtime.\r\n\r\nIf you have built a [self-contained application](https://docs.microsoft.com/en-us/dotnet/core/deploying/#self-contained-deployments-scd) you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n## Other Information\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including Terms and Conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue where you can ask questions.\r\n\r\n### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [application.runtime.config](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application and editing the framework version and setting `rollForward` to `false`. This should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nNote that this file is optional, you may need to create it for each application alongside the executable.\r\n\r\n### Acknowledgments\r\n\r\nThanks to Bachraty Gergely for reporting this issue.\r\n\r\n### External Links\r\n\r\n[CVE-2017-11770](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8585)\r\n\r\n### Revisions\r\n\r\nV1.0 (Nov 14, 2017): Advisory published.\r\n\r\n_Version 1.0_\r\n_Last Updated 2017-11-14_"},{"Id":"6853282986","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:23:02","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/48","RelatedDescription":"Closed issue \"Reserved\" (#48) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853280485","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:35","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/47","RelatedDescription":"Closed issue \"Reserved\" (#47) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n\r\n"},{"Id":"6853280272","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:33","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/47","RelatedDescription":"Opened issue \"Reserved\" (#47) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n\r\n"},{"Id":"6853278942","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:20","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/46","RelatedDescription":"Closed issue \"Reserved\" (#46) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853278548","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/46","RelatedDescription":"Opened issue \"Reserved\" (#46) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853276874","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:58","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/45","RelatedDescription":"Closed issue \"Reserved\" (#45) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853274106","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:28","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Closed issue \"Reserved\" (#44) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853272527","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:12","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Opened issue \"Reserved\" (#44) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6935773341","Type":"PullRequestEvent","CreatedAt":"2017-12-03T13:22:11","Actor":"mikedn","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15351","RelatedDescription":"Opened pull request \"[WIP] Do not assign SSA numbers to excluded vars\" (#15351) at dotnet/coreclr","RelatedBody":"Saves a bit of memory and 0.37% instruction retired\r\n\r\nPIN data: https://1drv.ms/x/s!Av4baJYSo5pjgrsOjE-3c5Tow10lFw\r\n\r\nMemStats diff: https://gist.github.com/mikedn/9c9d6d7b40306d9fff18109c3a4b5e9c"},{"Id":"6935451384","Type":"PullRequestEvent","CreatedAt":"2017-12-03T09:07:20","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15350","RelatedDescription":"Opened pull request \"Update PgoData to master-20171203-0049 (master)\" (#15350) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6937391701","Type":"IssuesEvent","CreatedAt":"2017-12-04T04:32:35","Actor":"bjnoel","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8155","RelatedDescription":"Opened issue \"Problems publishing dotnet 4.6.2 console app\" (#8155) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\n* Create .NET Framework 4.6.2 console app in Visual studio\r\n* Run dotnet build from command line (success)\r\n* Run dotnet publish from command line, error: C:\\Program Files\\dotnet\\sdk\\2.0.3\\Microsoft.Common.CurrentVersion.targets(3861,5): error MSB4062: The \"Microsoft.Build.Tasks.ResolveManifestFiles\" task could not be loaded from the assembly Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a.  Confirm that the <UsingTask> declaration is correct, that the assembly and all its dependencies are available, and that the task contains a public class that implements Microsoft.Build.Framework.ITask.\r\n\r\nI have a sample project [here]: (https://github.com/bjnoel/ConsoleTest) with a 4.6.2 class library and 4.6.2 console app. The class library builds/publishes fine, the console app only builds.\r\n\r\nI have tried publishing with the -f net462 flag and it makes no difference.\r\n\r\n## Expected  behavior\r\n\r\nThe console app publishes or gives a meaningful error.\r\n\r\n## Actual behavior\r\n\r\nerror MSB4062 as above.\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n.NET Command Line Tools (2.0.3)\r\n\r\nProduct Information:\r\n Version:            2.0.3\r\n Commit SHA-1 hash:  12f0c7efcc\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.3\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.3\r\n  Build    : a9190d4a75f4a982ae4b4fa8d1a24526566c69df\r\n\r\n## Other information\r\n\r\nWe have a large solution that mostly contains .NET core 2, .Net standard 2 libraries, this legacy .net framework console app is causing issues with our CI server. Publishing through visual studio works ok.\r\n\r\n\r\n\r\n\r\n"},{"Id":"6937209242","Type":"PullRequestEvent","CreatedAt":"2017-12-04T03:10:25","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8154","RelatedDescription":"Opened pull request \"ToolCommand tests\" (#8154) at dotnet/cli","RelatedBody":"Require https://github.com/dotnet/cli/pull/8132 checked in\r\n\r\nOnly 88de0e9 is new. But it is still too big. Add simulator to adapter layer. So InstallToolCommand can be test in memory. InstallToolCommand will get more complicated, so it's worth the effort.\r\n\r\nFollowing this: https://blogs.msdn.microsoft.com/ericgu/2014/12/01/unit-test-success-using-ports-adapters-and-simulators/\r\n"},{"Id":"6936249274","Type":"PullRequestEvent","CreatedAt":"2017-12-03T18:15:45","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8151","RelatedDescription":"Merged pull request \"Use rhel docker image with sudo built in\" (#8151) at dotnet/cli","RelatedBody":"So we do not need to download sudo from the internet every time we build\r\n\r\nI checked in the docker file change a while a ago."},{"Id":"6935468457","Type":"IssuesEvent","CreatedAt":"2017-12-03T09:21:29","Actor":"garthtee","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8153","RelatedDescription":"Opened issue \"Getting an error when running dotnet publish\" (#8153) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nNode version: `9.2.0`\r\nNPM version:  `5.5.1`\r\nLinux Ubuntu 16.04\r\nRunning command `sudo dotnet publish`\r\n\r\n## Expected  behavior\r\n\r\nPublish the application to specified path.\r\n\r\n## Actual behavior\r\n\r\nError **MSB3073**: The command \"node node_modules/webpack/bin/webpack.js --env.prod\" exited with code 2.\r\n\r\nERROR in /home/ubuntu/[solution_name]/[project_name]/$$_gendir/ClientApp/app/components/crypto/crypto.component.ngfactory.ts (22,42): Property 'hash' does not exist on type 'string'.\r\n\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n\r\n.NET Command Line Tools (2.0.0)\r\n\r\nProduct Information:\r\n Version:            2.0.0\r\n Commit SHA-1 hash:  cdcd1928c9\r\n\r\nRuntime Environment:\r\n OS Name:     ubuntu\r\n OS Version:  16.04\r\n OS Platform: Linux\r\n RID:         ubuntu.16.04-x64\r\n Base Path:   /usr/share/dotnet/sdk/2.0.0/\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"6933389646","Type":"IssuesEvent","CreatedAt":"2017-12-02T06:12:55","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/7889","RelatedDescription":"Closed issue \"dotnet add package String reference error\" (#7889) at dotnet/cli","RelatedBody":"_From @gregdegruy on October 10, 2017 21:12_\n\n# String reference error\r\n\r\nNotice how there is no proper string replacement done below.\r\n```\r\nError while adding package '{0}' to project '{1}'\r\n```\r\n\r\nWould like to help fix, but not sure where the repo or if it is open source for the ERROR handling in the dotnet CLI.\r\n\r\n## Error\r\n```\r\nC:\\GitHub\\_mr.robot\\DYN.Gamification\\DYN.Gamification [master ≡ +2 ~2 -0 !]> dotnet add package Microsoft.CrmSdk.CoreAssemblies --version 8.2.0.2\r\n  Writing C:\\Users\\grdegr\\AppData\\Local\\Temp\\tmp399F.tmp\r\ninfo : Adding PackageReference for package 'Microsoft.CrmSdk.CoreAssemblies' into project 'C:\\GitHub\\_mr.robot\\DYN.Gamification\\DYN.Gamification\\DYN.Gamification.csproj'.\r\nerror: Error while adding package '{0}' to project '{1}'. dotnet add package command supports adding package to one project at a time. But no project was found at the project path '{0}'.\r\nC:\\GitHub\\_mr.robot\\DYN.Gamification\\DYN.Gamification [master ≡ +2 ~2 -0 !]>\r\n```\r\n\r\n\n\n_Copied from original issue: dotnet/docs#3368_"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6934208277","Type":"IssuesEvent","CreatedAt":"2017-12-02T16:58:57","Actor":"jeremyVignelles","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/595","RelatedDescription":"Opened issue \"Add UnmanagedType.LPUTF8Str marshalling in .net standard\" (#595) at dotnet/standard","RelatedBody":"Hi,\r\nI'm currently writing a .net standard wrapper around libvlc, and I need to marshall strings from/to UTF-8.\r\n\r\nFor that, It would be really helpful to have the `UnmanagedType.LPUTF8Str` enumeration available.\r\n\r\nFrom https://apisof.net/catalog/System.Runtime.InteropServices.UnmanagedType.LPUTF8Str, it looks like everything is there in .net core and .net framework.\r\n\r\nWould it be possible to add that UTF8 support in the upcoming releases of .net standard?"},{"Id":"6932629749","Type":"PullRequestEvent","CreatedAt":"2017-12-01T22:41:14","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/593","RelatedDescription":"Merged pull request \"Update BuildTools to prerelease-02301-01 (master)\" (#593) at dotnet/standard","RelatedBody":""},{"Id":"6923175027","Type":"PullRequestEvent","CreatedAt":"2017-11-30T07:52:30","Actor":"wstaelens","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/594","RelatedDescription":"Opened pull request \"Update versions.md\" (#594) at dotnet/standard","RelatedBody":"quick link to .NET Framework system requirements to easily check which OS is supported."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6937353035","Type":"IssuesEvent","CreatedAt":"2017-12-04T04:13:26","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25671","RelatedDescription":"Opened issue \"API Request: Type.IsCollectible\" (#25671) at dotnet/corefx","RelatedBody":"We may wish to treat a collectible type differently to a non-collectible. Most obviously, we might want to avoid caching a collectible type for a long time and preventing that possible collection. The internal `RuntimeType` has an `IsCollectible()` method, but it is not exposed on `Type`.\r\n\r\nProposed API:\r\n\r\n```C#\r\npublic abstract class Type\r\n{\r\n    public bool IsCollectible { get; }\r\n}\r\n```"},{"Id":"6937339535","Type":"PullRequestEvent","CreatedAt":"2017-12-04T04:06:33","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25670","RelatedDescription":"Opened pull request \"Dependably determine collectibility in S.L.Expression's CanCache\" (#25670) at dotnet/corefx","RelatedBody":"Use `RuntimeType.IsCollectible()` to determine collectibility of types rather than only assuming those in mscorlib are not, which has many false positives (over 99% false positives in the uses Microsoft.CSharp makes of expressions).\r\n\r\nBuild a delegate to make the call when IL generation is available, or use reflection directly when it is not.\r\n\r\n* Use collectible dynamic assemblies within System.Linq.Expressions.Tests\r\n\r\nAllows for the paths where `CanCache` returns false to be exercised, along letting the dynamic assemblies be collected, anyway."},{"Id":"6937298761","Type":"IssuesEvent","CreatedAt":"2017-12-04T03:47:48","Actor":"xenocons","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25669","RelatedDescription":"Opened issue \"[System.Memory] Embedded Reference Types compiler bug\" (#25669) at dotnet/corefx","RelatedBody":"\r\nCode that was previously working (on 4.5.0-preview2-25707-02 , which seems to have disappeared!?) breaks on the latest preview: 4.5.0-preview1-26002-01, this is breaking deployment of new CI infrastructure as the working package is not obtainable. I have tried to hunt down the the issue, but it is beyond my understanding.\r\n\r\n#### Repro steps\r\n\r\n1. dotnet new console\r\n\r\n2. dotnet add package System.Memory -v 4.5.0-preview1-26002-01  -s https://dotnet.myget.org/F/aspnetcore-dev/api/v3/index.json\r\n3. Edit Program.cs and insert `ReadOnlySpan<char> x = \"hello\".AsReadOnlySpan();` before the print statement\r\n4. Run `dotnet build`\r\n\r\n#### Project file (repo.csproj)\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Memory\" Version=\"4.5.0-preview1-26002-01\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n#### Source file (Program.cs)\r\n```\r\n﻿using System;\r\n\r\nnamespace repo\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ReadOnlySpan<char> x = \"hello\".AsReadOnlySpan();\r\n            Console.WriteLine(\"Hello World!\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### Expected behavior\r\n\r\nExpected that the above code works, the usage was taken from the Span doco (https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md)\r\n\r\n#### Actual behavior\r\nCompiler error:\r\nProgram.cs(10,12): error CS0619: 'ReadOnlySpan<char>' is obsolete: 'Types with embedded references are not supported in this version of your compiler.' [/tmp/repo/repo.csproj]\r\n\r\n#### Known workarounds\r\nIf you have a cached version of 4.5.0-preview2-25707-02 , you can use this and there will be no errors\r\n\r\n#### Related information \r\nOutput of dotnet --info\r\n```\r\n.NET Command Line Tools (2.0.3)\r\n\r\nProduct Information:\r\n Version:            2.0.3\r\n Commit SHA-1 hash:  eb1d5ee318\r\n\r\nRuntime Environment:\r\n OS Name:     debian\r\n OS Version:  9\r\n OS Platform: Linux\r\n RID:         linux-x64\r\n Base Path:   /usr/share/dotnet/sdk/2.0.3/\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.3\r\n  Build    : a9190d4a75f4a982ae4b4fa8d1a24526566c69df\r\n```\r\n\r\n"},{"Id":"6937207388","Type":"IssuesEvent","CreatedAt":"2017-12-04T03:09:36","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/25663","RelatedDescription":"Closed issue \"Soundness feedback requested: Increasing cache success in S.L.Expressions\" (#25663) at dotnet/corefx","RelatedBody":"Expressions contains a `CanCache(Type)` method that reports on the safety of caching a delegate or information about a method based on whether the type is a mscrolib type that (if generic) has only mscorlib type parameters.\r\n\r\nThe netfx version allows not just mscorlib types to be considered safe, but also those in System.Core where the cache lives. While there aren't as many types in corefx's S.L.Expressions as there are in netfx's S.Core, this basic principle seems sound to me.\r\n\r\nIt also seems worth doing, tracking hits and misses (of the outer calls only, ignoring its recursive calls on generic parameters except as they affect the final result) has the tests for Microsoft.CSharp go from 0.05% hits to 54.40% and the tests for System.Dynamic.Runtime go from 0.27% to 41.87%. (S.L.Expressions itself goes from 49.59% to 54.34%, and if anything I was expecting it to be an unfair comparison in explicitly using Expressions types more than other tests would, but it it also does a lot of permutations on the primitive types that would have a high hit rate). That would seem to be enough to suggest that dynamic is attempting to cache with so low a success rate as to maybe not be worth trying, but with the change to include Expressions' types it becomes much more useful.\r\n\r\nAnd it **seems** safe to me, as surely if the types in Expressions were collectible then collecting would also make the static cache collected.\r\n\r\nQuestion 1: Am I wrong in this? Could a type in Expressions be collectible without the `TypeUtils` type becoming collectible (unreachable at least, even if not yet collected) and making the static cache collectible? Because if I am wrong, then this idea isn't safe.\r\n\r\nQuestion 2: If I'm correct in this, and caching uses of these types would be safe, would it also be safe to consider types in assemblies referenced by Expressions (transitively) safe to cache?\r\n\r\nQuestion 3: Iff the answer to the first question is \"safe\" and to the second is \"not safe\", would the assemblies of types that are base types or implemented interfaces of safe types, also be safe (probably too much of a burden to check that to pay off anyway, but figuring out an efficient way to check on this is a separate investigation)."},{"Id":"6937205585","Type":"PullRequestEvent","CreatedAt":"2017-12-04T03:08:49","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/25668","RelatedDescription":"Closed pull request \"Have System.Linq.Expressions consider its own types safe for caching\" (#25668) at dotnet/corefx","RelatedBody":"Since the cache is in that assembly, it's as collectible or not as the types are, so they're safe to cache.\r\n\r\nIncreases `CanCache` true returns from  0.05% to 54.40% during the Microsoft.CSharp tests and 0.27% to 41.87% during the System.Dynamic.Runtime tests (a more moderate 49.59% to 54.34% for S.L.Expressions itself)."},{"Id":"6937133950","Type":"PullRequestEvent","CreatedAt":"2017-12-04T02:38:34","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25668","RelatedDescription":null,"RelatedBody":"Since the cache is in that assembly, it's as collectible or not as the types are, so they're safe to cache.\r\n\r\nIncreases `CanCache` true returns from  0.05% to 54.40% during the Microsoft.CSharp tests and 0.27% to 41.87% during the System.Dynamic.Runtime tests (a more moderate 49.59% to 54.34% for S.L.Expressions itself)."},{"Id":"6937125346","Type":"PullRequestEvent","CreatedAt":"2017-12-04T02:34:41","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/25668","RelatedDescription":"Closed pull request \"Have System.Linq.Expressions consider its own types safe for caching\" (#25668) at dotnet/corefx","RelatedBody":"Since the cache is in that assembly, it's as collectible or not as the types are, so they're safe to cache.\r\n\r\nIncreases `CanCache` true returns from  0.05% to 54.40% during the Microsoft.CSharp tests and 0.27% to 41.87% during the System.Dynamic.Runtime tests (a more moderate 49.59% to 54.34% for S.L.Expressions itself)."},{"Id":"6937118344","Type":"PullRequestEvent","CreatedAt":"2017-12-04T02:31:30","Actor":"ViktorHofer","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24168","RelatedDescription":null,"RelatedBody":""},{"Id":"6937050699","Type":"PullRequestEvent","CreatedAt":"2017-12-04T02:00:59","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25668","RelatedDescription":"Opened pull request \"Have System.Linq.Expressions consider its own types safe for caching\" (#25668) at dotnet/corefx","RelatedBody":"Since the cache is in that assembly, it's as collectible or not as the types are, so they're safe to cache.\r\n\r\nIncreases `CanCache` true returns from  0.05% to 54.40% during the Microsoft.CSharp tests and 0.27% to 41.87% during the System.Dynamic.Runtime tests (a more moderate 49.59% to 54.34% for S.L.Expressions itself)."}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6937048049","Type":"PullRequestEvent","CreatedAt":"2017-12-04T01:59:51","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23524","RelatedDescription":"Merged pull request \"Adjust language feature status for recursive patterns.\" (#23524) at dotnet/roslyn","RelatedBody":"- Identify the branch\r\n- Identify a secondary developer\r\n- Change state to Prototype\r\n"},{"Id":"6937046022","Type":"PullRequestEvent","CreatedAt":"2017-12-04T01:58:58","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23526","RelatedDescription":"Merged pull request \"Skip flaky test TestImplicitCacheMonitoring\" (#23526) at dotnet/roslyn","RelatedBody":"Related to #14592\r\n\r\nThis test has been flaky, and this PR skips the test while it is investigated (and possibly deleted) to resolve the problem.\r\n\r\n@jasonmalinowski @dotnet/roslyn-infrastructure Can I have a review, please?\r\n"},{"Id":"6936941708","Type":"IssuesEvent","CreatedAt":"2017-12-04T01:07:20","Actor":"jaredpar","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23547","RelatedDescription":"Opened issue \"Need to embrace SDK defaults for output paths\" (#23547) at dotnet/roslyn","RelatedBody":"The Roslyn adoption of the SDK suppresses a couple aspects of how output paths are generated by default. In particular it suppresses the addition of the target framework and runtime identifier directories.\r\n\r\nThis was initially done to smooth the adoption of the SDK. It was an enormous change and trying to adopt it at the same time as restructuring our output directories made it that much harder.\r\n\r\nWhile it is possible to suppress these elements it does add some complexity to our build. For example not appending the runtime directory means we need to hand manipulate publish directory names. This represents a bit of a tax on our infrastructure and can slow adoption of new SDKs.\r\n\r\nNow that everything is mostly settled on the new SDK we should embraces the output. It's comparatively a fairly small change at this point. \r\n"},{"Id":"6936616975","Type":"IssuesEvent","CreatedAt":"2017-12-03T21:51:51","Actor":"alrz","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23546","RelatedDescription":"Opened issue \"SyntaxKind.VarKeyword is missing\" (#23546) at dotnet/roslyn","RelatedBody":"Because of that we always check for \"var\" string instead of ContextualKind. Is there any reason why is that?\r\n"},{"Id":"6936570518","Type":"IssuesEvent","CreatedAt":"2017-12-03T21:25:16","Actor":"jamesqo","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23545","RelatedDescription":"Opened issue \"SemanticModel.GetTypeInfo().Type is null for array initializers without \" (#23545) at dotnet/roslyn","RelatedBody":"**Version Used**: latest\r\n\r\n**Steps to Reproduce**:\r\n\r\n```cs\r\nbyte[] arr = { };\r\n```\r\n\r\n1. Find the `InitializerExpression` node correspoding to `{ }`.\r\n2. Evaluate `semanticModel.GetTypeInfo(node, ct).Type` with this node.\r\n\r\n**Expected Behavior**: Returns an `ITypeSymbol` corresponding to `System.Byte[]`.\r\n\r\n**Actual Behavior**: Returns `null`. However, `ConvertedType` is `System.Byte[]`.\r\n\r\nFiled on request of @mavasani, https://github.com/dotnet/roslyn-analyzers/pull/1339#issuecomment-347002451"},{"Id":"6936561904","Type":"PullRequestEvent","CreatedAt":"2017-12-03T21:20:13","Actor":"pentp","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23544","RelatedDescription":"Opened pull request \"Reduce async overhead in CodeAnalysis\" (#23544) at dotnet/roslyn","RelatedBody":"This removes unnecessary async state machines from functions that forward to other async functions."},{"Id":"6936519981","Type":"IssuesEvent","CreatedAt":"2017-12-03T20:56:26","Actor":"MkazemAkhgary","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23543","RelatedDescription":"Opened issue \"suggestion : replace property with field\" (#23543) at dotnet/roslyn","RelatedBody":"**Version Used**: 15.4.5\r\n\r\n**Actual Behavior**:\r\n\r\nWhen clicking on property, lightbulb only suggests to replace auto property with a method.\r\n\r\n**Expected Behavior**:\r\n\r\nadd another suggestion to replace auto properties with fields and sort out naming (prefix with `_`), and replace get only auto properties with readonly fields.\r\n"},{"Id":"6936366390","Type":"IssuesEvent","CreatedAt":"2017-12-03T19:27:41","Actor":"kfrajtak","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23542","RelatedDescription":"Opened issue \"No projects found when building a solution in memory\" (#23542) at dotnet/roslyn","RelatedBody":"Hi,\r\n\r\nI am trying to compile a solution in memory using the Roslyn compiler. I am using the latest stable Nuget packages (version 2.4.0), the project that is compiling the solution is a .Net 4.6.1 class library.\r\n\r\nThe problem is that the project graph does not contain any projects.\r\n\r\n````\r\nvar workspace = MSBuildWorkspace.Create();\r\nvar solution = workspace.OpenSolutionAsync(solutionUrl).Result;\r\nvar projectGraph = solution.GetProjectDependencyGraph();\r\nvar projects = projectGraph.GetTopologicallySortedProjects();\r\nif (!projects.Any())\r\n{\r\n   Console.WriteLine($\"{projects.Count()} projects :(\");\r\n   return false;\r\n}\r\n````\r\n\r\nI might be missing some point. I have created a MVP solution in case you'd like to help me. Any help will be appreciated.\r\n\r\nThanks, Karel\r\n\r\n**Version Used**: \r\n2.4.0 (Nuget packages)\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Get the repo from https://github.com/kfrajtak/DotIntrospection\r\n2. Set the path to a SLN file\r\n3. Run\r\n\r\n**Expected Behavior**:\r\n`projects` not empty\r\n\r\n**Actual Behavior**:\r\n`projects` is empty"},{"Id":"6936276706","Type":"IssuesEvent","CreatedAt":"2017-12-03T18:33:01","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23512","RelatedDescription":"Closed issue \"[c# Feature Request] CallerUniqueIdAttribute\" (#23512) at dotnet/roslyn","RelatedBody":"The Caller(Members/File/Line) Attributes are very useful in \"restricted to class\" scenarios like \"INotifyChanged\" interfaces or exceptions.\r\n\r\nBut It is not complete in a \"per application/library\" scenario. (Example \"Static variables\", \"Persistent Variables\", etc.)\r\n\r\nStackoverflow has an example of \"StaticLocal<T>\" implementation showing the problem:\r\nhttps://stackoverflow.com/questions/2393156/does-c-sharp-support-the-use-of-static-local-variables\r\n\r\n```\r\npublic static class StaticLocal<T>\r\n{\r\n    static StaticLocal()\r\n    {\r\n        dictionary = new Dictionary<int, Dictionary<string, Access>>();\r\n    }\r\n\r\n    public class Access\r\n    {\r\n        public T Value { get; set; }\r\n\r\n        public Access(T value)\r\n        {\r\n            Value = value;\r\n        }\r\n\r\n    }\r\n\r\n    public static Access Init(T value, [CallerFilePath]string callingFile = \"\",\r\n                                       [CallerMemberName]string callingMethod = \"\",\r\n                                       [CallerLineNumber]int lineNumber = -1)\r\n    {\r\n        var secondKey = callingFile + '.' + callingMethod;\r\n        if (!dictionary.ContainsKey(lineNumber))\r\n            dictionary.Add(lineNumber, new Dictionary<string, Access>());\r\n        if (!dictionary[lineNumber].ContainsKey(secondKey))\r\n            dictionary[lineNumber].Add(secondKey, new Access(value));\r\n        return dictionary[lineNumber][secondKey];\r\n    }\r\n\r\n    private static Dictionary<int, Dictionary<string, Access>> dictionary;\r\n\r\n}\r\n//It can be implemented within a method like this:\r\n\r\nvar myVar = StaticLocal<int>.Init(1);\r\nConsole.Writeline(++myVar.Value);\r\n\r\n```\r\nA real solution with a \"CallerUniqueIdAttribute\" simplifies that kind of variables:\r\n\r\n```\r\npublic static class StaticLocal<T>\r\n{\r\n    private static Dictionary<int,Access> dictionary=new Dictionary<int,Access>();\r\n    public class Access\r\n    {\r\n        public T Value { get; set; }\r\n        public Access(T value)\r\n        {\r\n            Value = value;\r\n        }\r\n    }\r\n    public static Access Init(T value, [CallerUniqueId]int callingUniqueId = -1)\r\n    {\r\n        if (!dictionary.ContainsKey(callingUniqueId))\r\n            dictionary.Add(callingUniqueId,new Access(value));\r\n        return dictionary[callingUniqueId];\r\n    }\r\n}\r\n\r\n[...]\r\nvar myVar = StaticLocal<int>.Init(1);\r\nConsole.Writeline(myVar.Value);\r\n[..]\r\n\r\n```\r\n\r\nI think, it is very simple to the compiler to have a simple counter giving an unique interger value for each [CallerUniqueId] attribute instance when appears.\r\n\r\n\r\n\r\n"}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6936597743","Type":"PullRequestEvent","CreatedAt":"2017-12-03T21:40:51","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5065","RelatedDescription":"Opened pull request \"Overhaul ToString in the type system\" (#5065) at dotnet/corert","RelatedBody":"Fixes #1276.\r\n\r\nThis is fixing several problems with how we did `ToString`:\r\n* The existing scheme required every `TypeDesc`/`MethodDesc`/`FieldDesc` descendant to override `ToString`. Of course we were not consistent with this and as a result, most of our synthetic type system entities had non-existent representation in the debugger. Overriding is a lot of boilerplate.\r\n* We were not flexible with the stringified names. E.g. instantiated types became too long because we were module- and namespace- qualifying everything.\r\n* (Minor) The runtime type loader was shipping with ToString support in retail configuration that was largely unused.\r\n\r\nWith the new scheme, besides fixing the problems above, I'm adding a bunch of conveniences:\r\n* `MethodDesc` now also have signatures in their `ToString`.\r\n* Well-known primitive types have short aliases\r\n* System.Private prefix is shortened to S.P.\r\n\r\nI tested that the `TYPE_LOADER_TRACE` still works after this. The runtime type loader overrides the `ToString` in all the places that matter.\r\n"},{"Id":"6935972598","Type":"PullRequestEvent","CreatedAt":"2017-12-03T15:28:00","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5061","RelatedDescription":"Merged pull request \"Rename the method FloorLog2 to be more clear & fix spelling (dotnet/coreclr#15349)\" (#5061) at dotnet/corert","RelatedBody":""},{"Id":"6935972303","Type":"PullRequestEvent","CreatedAt":"2017-12-03T15:27:46","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5064","RelatedDescription":"Merged pull request \"Make scanner failures easier to troubleshoot\" (#5064) at dotnet/corert","RelatedBody":"Making the internal compiler error a bit more self-serviceable.\r\n\r\nThis doesn't cover the case when a slot wasn't computed, but those are typically more rare."},{"Id":"6935517271","Type":"PullRequestEvent","CreatedAt":"2017-12-03T10:02:11","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5064","RelatedDescription":"Opened pull request \"Make scanner failures easier to troubleshoot\" (#5064) at dotnet/corert","RelatedBody":"Making the internal compiler error a bit more self-serviceable.\r\n\r\nThis doesn't cover the case when a slot wasn't computed, but those are typically more rare."},{"Id":"6935515881","Type":"PullRequestEvent","CreatedAt":"2017-12-03T10:01:02","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5063","RelatedDescription":"Merged pull request \"Avoid calling type loader from waithandle subsystem\" (#5063) at dotnet/corert","RelatedBody":"Fixes #5062."},{"Id":"6935515880","Type":"IssuesEvent","CreatedAt":"2017-12-03T10:01:02","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5062","RelatedDescription":"Closed issue \"BasicThreading tests fails intermittently in the CI\" (#5062) at dotnet/corert","RelatedBody":"Looks like another case of bad recursion through TypeLoader: \r\n\r\n```\r\n22:17:12    at Internal.Runtime.Augments.EnvironmentAugments.get_StackTrace() + 0x70\r\n22:17:12    at System.Diagnostics.Debug.Assert(Boolean, String, String) + 0x45\r\n22:17:12    at System.Diagnostics.Debug.Assert(Boolean) + 0x46\r\n22:17:12    at System.Threading.LowLevelLock.VerifyIsNotLocked() + 0x43\r\n22:17:12    at System.Threading.LowLevelLock.TryAcquire() + 0x2d\r\n22:17:12    at System.Threading.LowLevelLock.Acquire() + 0x20\r\n22:17:12    at System.Threading.WaitSubsystem.WaitableObject.Wait(WaitSubsystem.ThreadWaitInfo, Int32, Boolean, Boolean) + 0x9d\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(WaitSubsystem.WaitableObject, Int32, Boolean, Boolean) + 0x9a\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(IntPtr, Int32, Boolean) + 0x5d\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(IntPtr, Int32, Boolean) + 0x26\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(Int32, Boolean) + 0xbd\r\n22:17:12    at System.Threading.WaitHandle.WaitOne(Int32) + 0x85\r\n22:17:12    at System.Threading.Lock.TryAcquireContended(IntPtr, Int32) + 0x29d\r\n22:17:12    at System.Threading.Lock.Acquire() + 0xbe\r\n22:17:12    at System.Threading.LockHolder.Hold(Lock) + 0x2f\r\n22:17:12    at Internal.Runtime.TypeLoader.TypeLoaderEnvironment.TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle, RuntimeTypeHandle[], RuntimeTypeHandle&) + 0x8b\r\n22:17:12    at Internal.Runtime.TypeLoader.Callbacks.TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle, RuntimeTypeHandle[], RuntimeTypeHandle&) + 0x68\r\n22:17:12    at Internal.IntrinsicSupport.EqualityComparerHelpers.GetComparer(RuntimeTypeHandle) + 0x3c3\r\n22:17:12    at Internal.IntrinsicSupport.EqualityComparerHelpers.GetUnknownEquatableComparer[T]() + 0x7a\r\n22:17:12    at System.Collections.Generic.EqualityComparer`1.Create() + 0x2a\r\n22:17:12    at BasicThreading!<BaseAddress>+0x45d97d\r\n22:17:12    at System.Threading.WaitHandleArray`1.VerifyElementsAreDefault() + 0x4f\r\n22:17:12    at System.Threading.WaitSubsystem.ThreadWaitInfo.GetWaitedObjectArray(Int32) + 0x82\r\n22:17:12    at System.Threading.WaitSubsystem.WaitableObject.Wait_Locked(WaitSubsystem.ThreadWaitInfo, Int32, Boolean, Boolean) + 0x29d\r\n22:17:12    at System.Threading.WaitSubsystem.WaitableObject.Wait(WaitSubsystem.ThreadWaitInfo, Int32, Boolean, Boolean) + 0x125\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(WaitSubsystem.WaitableObject, Int32, Boolean, Boolean) + 0x9a\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(IntPtr, Int32, Boolean) + 0x5d\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(IntPtr, Int32, Boolean) + 0x26\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(Int32, Boolean) + 0xbd\r\n22:17:12    at System.Threading.WaitHandle.WaitOne(Int32) + 0x85\r\n22:17:12    at System.Threading.Lock.TryAcquireContended(IntPtr, Int32) + 0x29d\r\n22:17:12    at System.Threading.Lock.TryAcquire(Int32) + 0x110\r\n22:17:12    at System.Runtime.CompilerServices.ClassConstructorRunner.DeadlockAwareAcquire(ClassConstructorRunner.CctorHandle, IntPtr) + 0xcf\r\n22:17:12    at System.Runtime.CompilerServices.ClassConstructorRunner.EnsureClassConstructorRun(StaticClassConstructionContext*) + 0xec\r\n22:17:12    at System.Runtime.CompilerServices.ClassConstructorRunner.CheckStaticClassConstructionReturnGCStaticBase(StaticClassConstructionContext*, Object) + 0x22\r\n22:17:12    at System.Threading.ClrThreadPool.WorkerThread.WorkerThreadStart() + 0x26\r\n22:17:12    at BasicThreading!<BaseAddress>+0x48c19a\r\n22:17:12    at Internal.Runtime.Augments.RuntimeThread.StartThread(IntPtr) + 0x11f\r\n22:17:12    at Internal.Runtime.Augments.RuntimeThread.ThreadEntryPoint(IntPtr) + 0x36\r\n```"},{"Id":"6935362462","Type":"PullRequestEvent","CreatedAt":"2017-12-03T07:49:56","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5063","RelatedDescription":"Opened pull request \"Avoid calling type loader from waithandle subsystem\" (#5063) at dotnet/corert","RelatedBody":"Fixes #5062."},{"Id":"6935344612","Type":"IssuesEvent","CreatedAt":"2017-12-03T07:32:44","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5062","RelatedDescription":"Opened issue \"BasicThreading tests fails intermittently in the CI\" (#5062) at dotnet/corert","RelatedBody":"Looks like another case of bad recursion through TypeLoader: \r\n\r\n```\r\n22:17:12    at Internal.Runtime.Augments.EnvironmentAugments.get_StackTrace() + 0x70\r\n22:17:12    at System.Diagnostics.Debug.Assert(Boolean, String, String) + 0x45\r\n22:17:12    at System.Diagnostics.Debug.Assert(Boolean) + 0x46\r\n22:17:12    at System.Threading.LowLevelLock.VerifyIsNotLocked() + 0x43\r\n22:17:12    at System.Threading.LowLevelLock.TryAcquire() + 0x2d\r\n22:17:12    at System.Threading.LowLevelLock.Acquire() + 0x20\r\n22:17:12    at System.Threading.WaitSubsystem.WaitableObject.Wait(WaitSubsystem.ThreadWaitInfo, Int32, Boolean, Boolean) + 0x9d\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(WaitSubsystem.WaitableObject, Int32, Boolean, Boolean) + 0x9a\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(IntPtr, Int32, Boolean) + 0x5d\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(IntPtr, Int32, Boolean) + 0x26\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(Int32, Boolean) + 0xbd\r\n22:17:12    at System.Threading.WaitHandle.WaitOne(Int32) + 0x85\r\n22:17:12    at System.Threading.Lock.TryAcquireContended(IntPtr, Int32) + 0x29d\r\n22:17:12    at System.Threading.Lock.Acquire() + 0xbe\r\n22:17:12    at System.Threading.LockHolder.Hold(Lock) + 0x2f\r\n22:17:12    at Internal.Runtime.TypeLoader.TypeLoaderEnvironment.TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle, RuntimeTypeHandle[], RuntimeTypeHandle&) + 0x8b\r\n22:17:12    at Internal.Runtime.TypeLoader.Callbacks.TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle, RuntimeTypeHandle[], RuntimeTypeHandle&) + 0x68\r\n22:17:12    at Internal.IntrinsicSupport.EqualityComparerHelpers.GetComparer(RuntimeTypeHandle) + 0x3c3\r\n22:17:12    at Internal.IntrinsicSupport.EqualityComparerHelpers.GetUnknownEquatableComparer[T]() + 0x7a\r\n22:17:12    at System.Collections.Generic.EqualityComparer`1.Create() + 0x2a\r\n22:17:12    at BasicThreading!<BaseAddress>+0x45d97d\r\n22:17:12    at System.Threading.WaitHandleArray`1.VerifyElementsAreDefault() + 0x4f\r\n22:17:12    at System.Threading.WaitSubsystem.ThreadWaitInfo.GetWaitedObjectArray(Int32) + 0x82\r\n22:17:12    at System.Threading.WaitSubsystem.WaitableObject.Wait_Locked(WaitSubsystem.ThreadWaitInfo, Int32, Boolean, Boolean) + 0x29d\r\n22:17:12    at System.Threading.WaitSubsystem.WaitableObject.Wait(WaitSubsystem.ThreadWaitInfo, Int32, Boolean, Boolean) + 0x125\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(WaitSubsystem.WaitableObject, Int32, Boolean, Boolean) + 0x9a\r\n22:17:12    at System.Threading.WaitSubsystem.Wait(IntPtr, Int32, Boolean) + 0x5d\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(IntPtr, Int32, Boolean) + 0x26\r\n22:17:12    at System.Threading.WaitHandle.WaitOneCore(Int32, Boolean) + 0xbd\r\n22:17:12    at System.Threading.WaitHandle.WaitOne(Int32) + 0x85\r\n22:17:12    at System.Threading.Lock.TryAcquireContended(IntPtr, Int32) + 0x29d\r\n22:17:12    at System.Threading.Lock.TryAcquire(Int32) + 0x110\r\n22:17:12    at System.Runtime.CompilerServices.ClassConstructorRunner.DeadlockAwareAcquire(ClassConstructorRunner.CctorHandle, IntPtr) + 0xcf\r\n22:17:12    at System.Runtime.CompilerServices.ClassConstructorRunner.EnsureClassConstructorRun(StaticClassConstructionContext*) + 0xec\r\n22:17:12    at System.Runtime.CompilerServices.ClassConstructorRunner.CheckStaticClassConstructionReturnGCStaticBase(StaticClassConstructionContext*, Object) + 0x22\r\n22:17:12    at System.Threading.ClrThreadPool.WorkerThread.WorkerThreadStart() + 0x26\r\n22:17:12    at BasicThreading!<BaseAddress>+0x48c19a\r\n22:17:12    at Internal.Runtime.Augments.RuntimeThread.StartThread(IntPtr) + 0x11f\r\n22:17:12    at Internal.Runtime.Augments.RuntimeThread.ThreadEntryPoint(IntPtr) + 0x36\r\n```"},{"Id":"6935337195","Type":"PullRequestEvent","CreatedAt":"2017-12-03T07:26:23","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5058","RelatedDescription":"Merged pull request \"Do not throw if default assembly can't be found\" (#5058) at dotnet/corert","RelatedBody":"Fixes #5051."},{"Id":"6935337194","Type":"IssuesEvent","CreatedAt":"2017-12-03T07:26:23","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5051","RelatedDescription":"Closed issue \"TypeInitializationException caused by Mono.Runtime type\" (#5051) at dotnet/corert","RelatedBody":"Repro steps: \r\n\r\n1. Run `dotnet publish -r win-x64 -c debug` the sample app found here - https://github.com/A-And/corert/tree/ILCompilerPackageSampleApp/samples/WebApi \r\n2. Run the published .exe \r\n3. Execute wget localhost:xxxx/api/values/3 \r\n\r\nResult: \r\n\r\n> System.TypeInitializationException: A type initializer threw an exception. To determine which type, inspect the InnerException's StackTrace property. ---> System.IO.FileNotFoundException: Cannot load assembly 'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'. No metadata found for this assembly.\r\n\r\nDigging into this points to the culprit being the cctor() of `Microsoft.AspNetCore.Mvc.ModelBinding.Validation.ValidationStateDictionary.ReferenceEqualityComparer`, which attempts to load `Mono.Runtime` and its required version of mscorlib.dll (?), which are not found.  "},{"Id":"6935256138","Type":"PullRequestEvent","CreatedAt":"2017-12-03T06:08:46","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5061","RelatedDescription":"Opened pull request \"Rename the method FloorLog2 to be more clear & fix spelling (dotnet/coreclr#15349)\" (#5061) at dotnet/corert","RelatedBody":""},{"Id":"6934219490","Type":"IssuesEvent","CreatedAt":"2017-12-02T17:05:52","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5060","RelatedDescription":"Opened issue \"Make PEVerify output useful\" (#5060) at dotnet/corert","RelatedBody":"_From @ygoe on November 10, 2015 17:45_\n\nI'm generating or manipulating assemblies at the IL level with Mono Cecil. This can lead to all sorts of errors and I use PEVerify to find them. But when the full output of PEVerify is just \"The method does not exist.\" (or whatever the text is in English) then it's not helpful at all. No token number, no affected type, no nothing. Where should I even start to look for the problem? What does the detected problem look like? Why is a method missing, who wants to have it? The program doesn't run properly and I can see where it produces wrong results, but I don't see anything strange in that area.\n\nI could provide you a broken assembly for reference but I can't upload it here.\n\n\n_Copied from original issue: dotnet/coreclr#2005_"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"6933814056","Type":"IssuesEvent","CreatedAt":"2017-12-02T12:21:22","Actor":"dustinmoris","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/1788","RelatedDescription":"Opened issue \"Error FS1108: The type 'Object' is required here and is unavailable\" (#1788) at dotnet/sdk","RelatedBody":"If I pull the latest [Giraffe source code](https://github.com/dustinmoris/Giraffe) on Windows it builds totally fine, but when I pull the same code on macOS I am getting the following error:\r\n\r\n```\r\nerror FS1108: The type 'Object' is required here and is unavailable. You must add a reference to assembly 'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'\r\n```\r\n\r\nReproduction steps:\r\n\r\n1. Pull repo\r\n2. Run `./build.sh`\r\n\r\nI can fix this error by adding the following to the `Giraffe.fsproj` file:\r\n\r\n```\r\n<ItemGroup>\r\n    <Reference Include=\"netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\" />\r\n</ItemGroup>\r\n```\r\n\r\n... but I don't understand why I have to do this on macOS. Shouldn't it work the same on both environments?"},{"Id":"6933471923","Type":"IssuesEvent","CreatedAt":"2017-12-02T07:27:19","Actor":"huoyaoyuan","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/1787","RelatedDescription":"Opened issue \"FastUpToDate always complains not up to date\" (#1787) at dotnet/sdk","RelatedBody":"`MyProject.runtimeconfig.json` won't change if not modifying the target framework, and `FastUpToDate` says it's an output and wrote earlier than input.\r\nBy the way, the build log uses UTC time. Consider to print local time please."},{"Id":"6932225099","Type":"PullRequestEvent","CreatedAt":"2017-12-01T20:52:44","Actor":"nguerrera","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1785","RelatedDescription":"Merged pull request \"LOC CHECKIN | dotnet/sdk-master | 20171201\" (#1785) at dotnet/sdk","RelatedBody":null},{"Id":"6932036836","Type":"PullRequestEvent","CreatedAt":"2017-12-01T20:05:16","Actor":"tannergooding","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1786","RelatedDescription":"Merged pull request \"Updating a test helper method to use GetFullPath\" (#1786) at dotnet/sdk","RelatedBody":""},{"Id":"6931747550","Type":"PullRequestEvent","CreatedAt":"2017-12-01T18:58:15","Actor":"tannergooding","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1786","RelatedDescription":"Opened pull request \"Updating a test helper method to use GetFullPath\" (#1786) at dotnet/sdk","RelatedBody":""},{"Id":"6929191743","Type":"PullRequestEvent","CreatedAt":"2017-12-01T09:13:53","Actor":"v-zbsail","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1785","RelatedDescription":"Opened pull request \"LOC CHECKIN | dotnet/sdk-master | 20171201\" (#1785) at dotnet/sdk","RelatedBody":null},{"Id":"6928921009","Type":"PullRequestEvent","CreatedAt":"2017-12-01T08:00:42","Actor":"dotnet-bot","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1784","RelatedDescription":"Opened pull request \"Merge release/15.5 to master\" (#1784) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/15.5 into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/15.5-to-master-20171201-080040\ngit reset --hard upstream/master\ngit merge upstream/release/15.5\n# Fix merge conflicts\ngit commit\ngit push merges/release/15.5-to-master-20171201-080040 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6928920934","Type":"PullRequestEvent","CreatedAt":"2017-12-01T08:00:40","Actor":"dotnet-bot","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1783","RelatedDescription":"Opened pull request \"Merge release/2.0.0 to release/15.5\" (#1783) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/15.5.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/15.5-20171201-080038\ngit reset --hard upstream/release/15.5\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/15.5-20171201-080038 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6928214547","Type":"PullRequestEvent","CreatedAt":"2017-12-01T03:16:33","Actor":"wjk","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1782","RelatedDescription":"Opened pull request \"[WIP] Build time ResX code-behind generation\" (#1782) at dotnet/sdk","RelatedBody":"This is my stab at resolving #94. There are a few things to note about this PR, though:\r\n\r\n1. _This code is totally untested at this time._ I have neither written unit tests (because I have no idea how to write unit tests for this), nor tested it informally (because I don't know how to force override the SDK bundled with MSBuild/VS). Any pointers on either of these topics will be appreciated.\r\n2. As currently written this PR does not apply heuristics to determine whether or not a `*.resx` file should have its code-behind generated. In particular, localized `*.resx` files (`*.en-US.resx`, `*.fr-FR.resx`, etc) will result in multiple identical code-behinds being generated, causing double-definition errors during compile. Any pointers on a good way to avoid this would also be appreciated.\r\n3. Currently `*.resx` code-behind files will be generated before the `Compile` target runs. I am unsure if this is the correct extensibility point for this task. Also, code-behind files will not be generated during design-time builds; the project must be manually built by the user for code-behind files to be updated. I did this because I don't know a good way to rerun the generator target immediately after these files change using only MSBuild (and not any project-system code).\r\n\r\nAgain, please don't merge this until I have worked the bugs out and written some unit tests. Thanks!"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"935927507911524352","CreatedAt":"2017-11-29T17:44:41+00:00","UserScreenname":"dotnet","Text":"Who doesn’t? Purple. All. The. Things. https://t.co/65KzPWuvbK","Source":"<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>","RetweetCount":29,"FavoriteCount":4,"RawContent":null},{"Id":"933058673206730752","CreatedAt":"2017-11-21T19:44:57+00:00","UserScreenname":"dotnet","Text":".NET Core Alpine Image Ready for Testing https://t.co/SsQtOGuAFD","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":212,"FavoriteCount":155,"RawContent":null},{"Id":"932677600715071488","CreatedAt":"2017-11-20T18:30:42+00:00","UserScreenname":"dotnet","Text":"Looking to migrate your existing .NET apps to the cloud but need our help? Fill out this survey and let us know: https://t.co/g6xbbWkX93","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":19,"FavoriteCount":15,"RawContent":null},{"Id":"931580871437635584","CreatedAt":"2017-11-17T17:52:42+00:00","UserScreenname":"dotnet","Text":"Check out our new ConfigurationBuilders that make it easier than ever to use Azure Key Vault, Environment Variables… https://t.co/nXoIDLCubn","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":57,"FavoriteCount":26,"RawContent":null}]}},"RunOn":"2017-12-04T05:30:20.2972781Z","RunDurationInMilliseconds":7883}