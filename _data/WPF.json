{"Data":{"GitHub":{"Issues":[{"Id":"484772919","IsPullRequest":true,"CreatedAt":"2019-08-24T03:27:08","Actor":"arpitmathur","Number":"1717","RawContent":null,"Title":"Enabling keyboard focus for page control buttons and zoom buttons on FlowDocumentPageViewer toolbar","State":"open","Body":"This change enables a user to keyboard focus on the page navigation controls and on the zoom controls in the toolbar in FlowDocumentPageViewer.\r\n\r\nFixes #1471 ","Url":"https://github.com/dotnet/wpf/pull/1717","RelatedDescription":"Open PR \"Enabling keyboard focus for page control buttons and zoom buttons on FlowDocumentPageViewer toolbar\" (#1717)"},{"Id":"484771882","IsPullRequest":true,"CreatedAt":"2019-08-24T03:13:20","Actor":"arpitmathur","Number":"1716","RawContent":null,"Title":"Enabling keyboard focus for page control buttons and zoom buttons on the FlowDocumentPageViewer toolbar","State":"open","Body":"[release/3.0 version of #1717]\r\n\r\nThis change enables a user to keyboard focus on the page navigation controls and on the zoom controls in the toolbar in FlowDocumentPageViewer.\r\n\r\nFixes #1471 ","Url":"https://github.com/dotnet/wpf/pull/1716","RelatedDescription":"Open PR \"Enabling keyboard focus for page control buttons and zoom buttons on the FlowDocumentPageViewer toolbar\" (#1716)"},{"Id":"484757950","IsPullRequest":true,"CreatedAt":"2019-08-24T00:55:48","Actor":"dotnet-maestro[bot]","Number":"1715","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190823.4\r\n- **Date Produced**: 8/24/2019 12:16 AM\r\n- **Commit**: ff7015f045cb1daf43ccd6106c28a5d306ee1581\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19423.4\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.NETCore.App** -> 3.0.0-rc1-19423-11 (parent: Microsoft.Private.Winforms)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1715","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1715)"},{"Id":"484757012","IsPullRequest":true,"CreatedAt":"2019-08-24T00:28:20","Actor":"vatsan-madhavan","Number":"1714","RawContent":null,"Title":"Adds missing Version resource to C++ binaries, and fixes PresentationCore.dll's missing Version resource","State":"open","Body":"[release/3.0 version of #1712]\r\n\r\nFixes #1711 \r\n\r\n- PresentationCore was losing its auto-generated manifest during the ILDASM/ILASM round-tripping. This is fixed easily by including the `.res` file in ILASM task. \r\n- For C++ binaries, a new version resource is added and included in builds. \r\n\r\nThis change needs to be merged into dotnet/wpf, and then flowed into dotnet-wpf-int, in order to fix WpfGfx, PenImc, and PresentationNative. (See [dotnet-wpf-int PR](https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int/pullrequest/2802?_a=overview))\r\n\r\n/cc @rladuca , @fabiant3 , @ryalanms , @leculver, @marklio ","Url":"https://github.com/dotnet/wpf/pull/1714","RelatedDescription":"Open PR \"Adds missing Version resource to C++ binaries, and fixes PresentationCore.dll's missing Version resource\" (#1714)"},{"Id":"484756134","IsPullRequest":true,"CreatedAt":"2019-08-24T00:21:49","Actor":"vatsan-madhavan","Number":"1713","RawContent":null,"Title":"Fixes problems in WindowsDesktop SDK due to _TargetFrameworkVersionWithoutV being undefined sometimes","State":"open","Body":"[release/3.0 version of #1707] \r\n\r\nAddresses https://github.com/dotnet/wpf/issues/1651 - Invalid comparison in MSBuild's ignore-conditions mode in outer build of multitargeted project\r\n\r\nThis change ensures that the WindowsDesktop SDK never deals with undefined numeric values related to TFM.\r\n\r\nThis solution leverages the fact that `Items` are evaluated after `Properties` by MSBuild. See [Comparing properties and items](https://docs.microsoft.com/en-us/visualstudio/msbuild/comparing-properties-and-items?view=vs-2019)\r\n\r\n`_TargetFrameworkVersionValue` - a new Property which is defined for exclusive use within the WindowsDesktop SDK, and which is intended to act as a proxy for `_TargetFrameworkVersionWithoutV` - is defined in `Microsoft.NET.Sdk.WindowsDesktop.targets` _after_ `TargetFrameworkVersionWithoutV` is guaranteed to be defined by `Microsoft.NET.Sdk.targets`. \r\n\r\nEven here, we ensure that a fallback default (`0.0`) is provided - guaranteeing that `_TargetFrameworkVersionValue` will always be numeric. \r\n\r\nWhen the `Condition`s in the various `Items` in `Microsoft.NET.WindowsDesktop.props` are evaluated (which will happen strictly after all `Properties` are evaluated - whether they appear in `.props` or `.targets`), `_TargetFrameworkVersionValue` would have been (a) well-defined and (b) guaranteed to be a numeric value. This would in turn guarantee that errors of the kind `\"A numeric comparison was attempted on \"$(_TargetFrameworkVersionValue)\" that evaluates to \"\" instead of a number,\"` will no longer appear in outer-builds or in any other context. \r\n\r\nPS: This is a fix for a regression introduced by https://github.com/dotnet/wpf/pull/1027 (which shipped in Preview 6) as part of a set of fixes for improving multi-targeting experience, improved warnings and error messages during build, and improvements to project-system integration. \r\n","Url":"https://github.com/dotnet/wpf/pull/1713","RelatedDescription":"Open PR \"Fixes problems in WindowsDesktop SDK due to _TargetFrameworkVersionWithoutV being undefined sometimes\" (#1713)"},{"Id":"484749638","IsPullRequest":true,"CreatedAt":"2019-08-23T23:38:46","Actor":"vatsan-madhavan","Number":"1712","RawContent":null,"Title":"Adds missing Version resource to C++ binaries, and fixes PresentationCore.dll's missing Version resource","State":"open","Body":"Fixes #1711 \r\n\r\n- PresentationCore was losing its auto-generated manifest during the ILDASM/ILASM round-tripping. This is fixed easily by including the `.res` file in ILASM task. \r\n- For C++ binaries, a new version resource is added and included in builds. \r\n\r\nThis change needs to be merged into dotnet/wpf, and then flowed into dotnet-wpf-int, in order to fix WpfGfx, PenImc, and PresentationNative. (See [dotnet-wpf-int PR](https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int/pullrequest/2801?_a=overview))\r\n\r\n/cc @rladuca , @fabiant3 , @ryalanms , @leculver ","Url":"https://github.com/dotnet/wpf/pull/1712","RelatedDescription":"Open PR \"Adds missing Version resource to C++ binaries, and fixes PresentationCore.dll's missing Version resource\" (#1712)"},{"Id":"484749085","IsPullRequest":false,"CreatedAt":"2019-08-23T23:35:27","Actor":"vatsan-madhavan","Number":"1711","RawContent":null,"Title":"Some .NET Core WPF assemblies are missing Version information in PE header - breaks Watson/Telemetry bucketing","State":"open","Body":"Related to #784 \r\n\r\nSeveral WPF assemblies are missing Version resource in the PE header. This will prevent Watson (Microsoft's internal Telemetry system that tracks crashes) from being able to bucketize them by version. \r\n\r\nThe affected binaries are \r\n\r\n- All C++ binaries:\r\n  - DirectWriteForwarer\r\n  - S.Printing\r\n  - wpfgfx_cor3\r\n  - PenImc_cor3\r\n  - PresentationNative_Cor3\r\n- PresentationCore\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/1711","RelatedDescription":"Open issue \"Some .NET Core WPF assemblies are missing Version information in PE header - breaks Watson/Telemetry bucketing\" (#1711)"},{"Id":"484719670","IsPullRequest":true,"CreatedAt":"2019-08-23T21:55:51","Actor":"dotnet-maestro[bot]","Number":"1710","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190823.3\r\n- **Date Produced**: 8/23/2019 9:10 PM\r\n- **Commit**: 339b8d57f0173c8fff2f3ddb6f0316470341aaea\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19423.3\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.App** -> 3.0.0-rc1-19422-14 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Configuration.ConfigurationManager** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Diagnostics.EventLog** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.DirectoryServices** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Drawing.Common** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.Emit** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.MetadataLoadContext** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Security.AccessControl** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Cryptography.Xml** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Permissions** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Principal.Windows** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.Windows.Extensions** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.Platforms** -> 3.0.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **System.IO.Packaging** -> 4.6.0-rc1.19420.10 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILDAsm** -> 3.0.0-rc1.19422.4 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **Microsoft.NETCore.Runtime.CoreCLR** -> 3.0.0-rc1.19422.4 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILAsm** -> 3.0.0-rc1.19422.4 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1710","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1710)"},{"Id":"484529676","IsPullRequest":true,"CreatedAt":"2019-08-23T14:56:46","Actor":"dotnet-maestro[bot]","Number":"1709","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190823.2\r\n- **Date Produced**: 8/23/2019 1:01 PM\r\n- **Commit**: ddf07ce845f3570bd4999f58f7ec05825bbcf5ca\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19423.2\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1709","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1709)"},{"Id":"484325571","IsPullRequest":false,"CreatedAt":"2019-08-23T04:34:26","Actor":"betam4x","Number":"1708","RawContent":null,"Title":"WPF with .NET Core 3.0","State":"open","Body":"I tried out the latest version of VS 2019 and .NET Core 3.0 earlier with WPF, I believe .NET Core was preview 8.  I am running the latest version of Windows 10.  I have 2 4K monitors, and though WPF (and UWP) scaled fine when using the .NET framework, a new project I started with .NET core had completely broken HiDPI scaling under .NET Core.  I'm not sure where to report this.  It acted like I was still using a 96 dpi monitor, even though it's 144dpi with scaling (and 163dpi without).  I had just worked on another project prior to installing everything, and HiDPI scaling was working fine.  It was only when I tried .NET Core that things broke.","Url":"https://github.com/dotnet/wpf/issues/1708","RelatedDescription":"Open issue \"WPF with .NET Core 3.0\" (#1708)"},{"Id":"483721320","IsPullRequest":true,"CreatedAt":"2019-08-23T04:25:53","Actor":"diverdan92","Number":"1692","RawContent":null,"Title":"Updating issue and feature request templates","State":"closed","Body":"We've observed some tooling related issues filed in the repo that take some additional time to get routed to the right Visual Studio teams. By suggesting developers to file issues on VS directly (for tools related issues), hopefully we can expedite triage and ultimately fixes. ","Url":"https://github.com/dotnet/wpf/pull/1692","RelatedDescription":"Closed or merged PR \"Updating issue and feature request templates\" (#1692)"},{"Id":"484286773","IsPullRequest":true,"CreatedAt":"2019-08-23T01:31:12","Actor":"vatsan-madhavan","Number":"1707","RawContent":null,"Title":"Fixes problems in WindowsDesktop SDK due to _TargetFrameworkVersionWithoutV being undefined sometimes","State":"open","Body":"Addresses https://github.com/dotnet/wpf/issues/1651 - Invalid comparison in MSBuild's ignore-conditions mode in outer build of multitargeted project\r\n\r\nThis change ensures that the WindowsDesktop SDK never deals with undefined numeric values related to TFM.\r\n\r\nThis solution leverages the fact that `Items` are evaluated after `Properties` by MSBuild. See [Comparing properties and items](https://docs.microsoft.com/en-us/visualstudio/msbuild/comparing-properties-and-items?view=vs-2019)\r\n\r\n`_TargetFrameworkVersionValue` - a new Property which is defined for exclusive use within the WindowsDesktop SDK, and which is intended to act as a proxy for `_TargetFrameworkVersionWithoutV` - is defined in `Microsoft.NET.Sdk.WindowsDesktop.targets` _after_ `TargetFrameworkVersionWithoutV` is guaranteed to be defined by `Microsoft.NET.Sdk.targets`. \r\n\r\nEven here, we ensure that a fallback default (`0.0`) is provided - guaranteeing that `_TargetFrameworkVersionValue` will always be numeric. \r\n\r\nWhen the `Condition`s in the various `Items` in `Microsoft.NET.WindowsDesktop.props` are evaluated (which will happen strictly after all `Properties` are evaluated - whether they appear in `.props` or `.targets`), `_TargetFrameworkVersionValue` would have been (a) well-defined and (b) guaranteed to be a numeric value. This would in turn guarantee that errors of the kind `\"A numeric comparison was attempted on \"$(_TargetFrameworkVersionValue)\" that evaluates to \"\" instead of a number,\"` will no longer appear in outer-builds or in any other context. \r\n\r\nPS: This is a fix for a regression introduced by https://github.com/dotnet/wpf/pull/1027 (which shipped in Preview 6) as part of a set of fixes for improving multi-targeting experience, improved warnings and error messages during build, and improvements to project-system integration. \r\n","Url":"https://github.com/dotnet/wpf/pull/1707","RelatedDescription":"Open PR \"Fixes problems in WindowsDesktop SDK due to _TargetFrameworkVersionWithoutV being undefined sometimes\" (#1707)"},{"Id":"483782125","IsPullRequest":false,"CreatedAt":"2019-08-22T23:33:33","Actor":"vatsan-madhavan","Number":"1696","RawContent":null,"Title":"Triage and fix Policheck issues reported for managed assemblies","State":"closed","Body":"Triage and fix (where appropriate0 Policheck issues reported for managed assemblies \r\n\r\nBug query [internal link](https://devdiv.visualstudio.com/DevDiv/_queries?tempQueryId=81dc8da9-2a4a-42d7-8a60-b587fe29e0f6)","Url":"https://github.com/dotnet/wpf/issues/1696","RelatedDescription":"Closed issue \"Triage and fix Policheck issues reported for managed assemblies\" (#1696)"},{"Id":"484230762","IsPullRequest":true,"CreatedAt":"2019-08-22T23:32:18","Actor":"stevenbrix","Number":"1705","RawContent":null,"Title":"Fix issues flagged by Policheck","State":"closed","Body":"## Description \r\nFixes policheck bugs assigned to us via the SDL build step. There were a lot more issues identified, but only these 5 issues were actually relevant and worth fixing. The other issues aren't actually offensive or used in the incorrect context.\r\n\r\nhttps://devdiv.visualstudio.com/DevDiv/_workitems/edit/969303/\r\nhttps://devdiv.visualstudio.com/DevDiv/_workitems/edit/969349/\r\nhttps://devdiv.visualstudio.com/DevDiv/_workitems/edit/969362/\r\nhttps://devdiv.visualstudio.com/DevDiv/_workitems/edit/969298/\r\n\r\n## Customer Impact \r\nPotentially offensive terms\r\n\r\n## Regression \r\n\r\nNo\r\n\r\n## Risk \r\n\r\nNone. Only affects comments\r\n\r\nFixes https://github.com/dotnet/wpf/issues/1696","Url":"https://github.com/dotnet/wpf/pull/1705","RelatedDescription":"Closed or merged PR \"Fix issues flagged by Policheck\" (#1705)"},{"Id":"484244107","IsPullRequest":false,"CreatedAt":"2019-08-22T22:24:00","Actor":"vsfeedback","Number":"1706","RawContent":null,"Title":"IMultiValueConverter receives {DisconnectedItem} with .NET Framework 4.8, KB4486153","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/697476/imultivalueconverter-receives-disconnecteditem-wit.html)._\n\n---\n<p>We detected a possible regression, as customers with an updated Windows Version to 1903 (to be exact, it is the recent Windows-Update, which installs .NET Framework 4.8, <strong>KB4486153</strong>) are experiencing a crash (InvalidCastException in on of our MultiValueConverter).</p><p>We've got a WPF-Binding-Scenario where we use a MultiValueConverter in a DataGrid in a WPF-UserControl, which is embedded in a WinForm.</p><p>The ViewModel - which is bound to the dataGrid - clears all used BindingLists when disposing.<br><em>B</em><em>efore KB4486153</em>, the bindingList.Clear() didnt trigger the multivalueconverter to convert anything.<br><em>After KB4486153,</em> the bindingList.Clear() triggers the mutivalueconverter with one parameter to be of type {DisconnectedItem} (in my case, it is the Item Property, which is bound to DataGridRow).</p><p>This is suprising, because as one of the changelog-items in .NET Framework 4.8 was as followed:</p><p><em>&quot;Fixed an issue involving bindings with DataContext explicitly on the binding path. When DataContext changes to {DisconnectedItem}, the binding should not pass that value to user code like converters, property-change handlers, etc. [801039, PresentationFramework.dll, Bug, Build:3761]&quot;</em> .</p><p><strong>**EDIT**:</strong></p><p>Just found out that this line is the problem in .NET 4.8. The Converter is called with {DisconnectedItem} if the bound item is getting removed, if the the problematic binding is specified as followed:</p><pre>&lt;Binding RelativeSource=&quot;{RelativeSource Mode=FindAncestor, AncestorType=DataGridRow, AncestorLevel=1}&quot; Path=&quot;Item&quot; /&gt;\n</pre><p>If i change it to:</p><pre>&lt;Binding Path=&quot;.&quot; /&gt;\n</pre><p>it works perfectly, even if we remove the item (or clearing the bindinglist) - the converter does not crash (or does not getting called).</p><p>But as this worked before 4.8 with a RelativeSource binding, this regression still should be checked.</p><p>I finally managed to create a small RePro which crashes with 4.8 (containing KB4486153) and does not Crash with 4.7.2 or earlier. Please have a look at it:<a href=\"https://developercommunity.visualstudio.com/storage/attachments/88541-disconnectedobject-repro.zip\">disconnectedobject-repro.zip</a></p>\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 8/19/2019, 00:49 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Visual Studio Feedback System on 8/22/2019, 01:53 PM: \n\n<p>Thank you for sharing your feedback! Our teams prioritize action on product issues with broad customer impact. See details at: <a target='_blank' href=\"https://docs.microsoft.com/en-us/visualstudio/ide/report-a-problem?view=vs-2017#faq\">https://docs.microsoft.com/en-us/visualstudio/ide/report-a-problem?view=vs-2017#faq</a>. In case you need answers to common questions or need assisted support, be sure to use <a target='_blank' href=\"https://visualstudio.microsoft.com/vs/support/\">https://visualstudio.microsoft.com/vs/support/</a>. We’ll keep you posted on any updates to this feedback.</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/1706","RelatedDescription":"Open issue \"IMultiValueConverter receives {DisconnectedItem} with .NET Framework 4.8, KB4486153\" (#1706)"},{"Id":"484228547","IsPullRequest":true,"CreatedAt":"2019-08-22T22:01:03","Actor":"dotnet-maestro[bot]","Number":"1704","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190822.3\r\n- **Date Produced**: 8/22/2019 7:17 PM\r\n- **Commit**: e2161d0176596afcf2144993784dcca5a6181f7f\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19422.3\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1704","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1704)"},{"Id":"484226559","IsPullRequest":true,"CreatedAt":"2019-08-22T22:00:46","Actor":"stevenbrix","Number":"1703","RawContent":null,"Title":"making small fixes for sdl violations","State":"closed","Body":"Fixes the following AzDO issues related to SDL violations\r\n\r\n- https://devdiv.visualstudio.com/DevDiv/_workitems/edit/969303/\r\n- https://devdiv.visualstudio.com/DevDiv/_workitems/edit/969349/\r\n- https://devdiv.visualstudio.com/DevDiv/_workitems/edit/969362/\r\n- https://devdiv.visualstudio.com/DevDiv/_workitems/edit/969298/","Url":"https://github.com/dotnet/wpf/pull/1703","RelatedDescription":"Closed or merged PR \"making small fixes for sdl violations\" (#1703)"},{"Id":"483781281","IsPullRequest":false,"CreatedAt":"2019-08-22T20:00:13","Actor":"vatsan-madhavan","Number":"1695","RawContent":null,"Title":"Fix PenImc and PresentationNative Policheck Issues","State":"closed","Body":"","Url":"https://github.com/dotnet/wpf/issues/1695","RelatedDescription":"Closed issue \"Fix PenImc and PresentationNative Policheck Issues\" (#1695)"},{"Id":"483780999","IsPullRequest":false,"CreatedAt":"2019-08-22T17:35:45","Actor":"vatsan-madhavan","Number":"1694","RawContent":null,"Title":"Fix WpfGfx Policheck Issues","State":"closed","Body":"","Url":"https://github.com/dotnet/wpf/issues/1694","RelatedDescription":"Closed issue \"Fix WpfGfx Policheck Issues\" (#1694)"},{"Id":"483996242","IsPullRequest":true,"CreatedAt":"2019-08-22T14:31:10","Actor":"dotnet-maestro[bot]","Number":"1701","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190822.2\r\n- **Date Produced**: 8/22/2019 1:03 PM\r\n- **Commit**: 9c4e4307f1de07a16c2e5b8be48745d3f420875d\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19422.2\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1701","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1701)"},{"Id":"484010988","IsPullRequest":false,"CreatedAt":"2019-08-22T13:57:01","Actor":"Simon-IT","Number":"1702","RawContent":null,"Title":"How to debug a WPF applications ?","State":"open","Body":"Hi,\r\nI've follow all the instructions from the developer-guide.md files. All is compiled well, but I cannot configure VS to debug a WPF application, because it doesn't take the pdb files compiled by the build.cmd. Can you help me ?","Url":"https://github.com/dotnet/wpf/issues/1702","RelatedDescription":"Open issue \"How to debug a WPF applications ?\" (#1702)"},{"Id":"483910029","IsPullRequest":false,"CreatedAt":"2019-08-22T10:34:20","Actor":"vitek-karas","Number":"1700","RawContent":null,"Title":"Xaml parser doesn't work with AssemblyLoadContext","State":"open","Body":"Trying to load XAML into non-default `AssemblyLoadContext` can lead to very confusing errors. The underlying problem is that XAML parser is not aware of assembly load contexts. The parser itself typically runs in the `Default` load context, but it may be triggered to load XAML into a custom (secondary) load context. In that case all assembly resolution should happen via the secondary load context.\r\n\r\nIn order to make this easier .NET Core 3.0 introduced the \"contextual reflection\" concept, which can switch all reflection based APIs to use the secondary load context. More details about contextual reflection can be found in [AssemblyLoadContext.ContextualReflection.md](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).\r\n\r\nThat fixes all cases where the XAML parser uses reflection APIs like `Assembly.GetType` and similar. Unfortunately the XAML parser implements its own assembly resolution logic in some cases. This logic was copied from the .NET Framework version of WPF and it still relies AppDomains, GAC and so on - it is not aware of `AssemblyLoadContext`. This logic can break the correct behavior: Among other things it walks all assemblies loaded into the current AppDomain (so all assemblies in the process, as .NET Core has only one AppDomain) and using custom logic resolves assembly against that list. If there are two assemblies of the same (or similar) names in that list, it will basically randomly pick the first one it finds. The code which does that is here: https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/SafeSecurityHelper.cs#L133\r\n\r\nAssembly load contexts are typically used to implement plugin architecture. To provide good levels of isolation for each plugin, every plugin is loaded into its own load context. This can very easily lead to cases where each plugin has its own version of a certain dependency. But the above mentioned code ignores the isolation of load contexts, and will resolve assembly globally - leading to cases where the plugins will get the wrong version of dependency used.\r\n\r\nA sample repro app is here: https://github.com/vitek-karas/WPFPluginLoadProblem  \r\nThis app shows the problem with a typical plugin architecture (host app loading two plugins, each using XAML parser to load some XAML).\r\n\r\nOriginally this problem was found trying to implement tests on WPF, using ALC to provide isolation of WPF itself. The repro of that case is here: https://github.com/nick-beer/ALC-XAML-LOAD-BUG  \r\nThis repro boils down to the same underlying problem.\r\n\r\n/cc @nick-beer","Url":"https://github.com/dotnet/wpf/issues/1700","RelatedDescription":"Open issue \"Xaml parser doesn't work with AssemblyLoadContext\" (#1700)"},{"Id":"483842207","IsPullRequest":false,"CreatedAt":"2019-08-22T08:23:23","Actor":"weltkante","Number":"1699","RawContent":null,"Title":"Regression in application template, generic.xaml doesn't work out of the box","State":"open","Body":"* .NET Core Version: latest nightly (5.0.0-alpha1.19415.3)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n\r\n **Problem description:**\r\nCreating a new WPF application for .NET Core the `generic.xaml` does not work out of the box when added manually (e.g. copy pasted from an existing project), it used to work on Desktop. It does work when using \"new item\" templates but since adding custom controls is just inheriting from a framework class it is often done without using the \"new item\" template and instead just writing code.\r\n \r\n **Actual behavior:**\r\nCreating a new application with the WPF for .NET Core template does not add a ThemeInfo attribute, I need to add a CustomControl template to get the attribute. This is a regression from Desktop Framework template behavior.\r\n\r\n **Expected behavior:**\r\nThe WPF for .NET Core application template should already add the ThemeInfo attribute.\r\n \r\n **Minimal repro:**\r\n* create a new WPF application for .NET Core\r\n* manually add code for a Custom Control and generic.xaml\r\n","Url":"https://github.com/dotnet/wpf/issues/1699","RelatedDescription":"Open issue \"Regression in application template, generic.xaml doesn't work out of the box\" (#1699)"},{"Id":"483783871","IsPullRequest":false,"CreatedAt":"2019-08-22T06:09:24","Actor":"vatsan-madhavan","Number":"1697","RawContent":null,"Title":"Fix Policheck issues in WPF Build props/targets","State":"closed","Body":"","Url":"https://github.com/dotnet/wpf/issues/1697","RelatedDescription":"Closed issue \"Fix Policheck issues in WPF Build props/targets\" (#1697)"},{"Id":"483785971","IsPullRequest":false,"CreatedAt":"2019-08-22T05:59:10","Actor":"MilosAuder","Number":"1698","RawContent":null,"Title":"When IsInactiveSelectionHighlightEnabled is turned on, then scrolling has visual defect","State":"open","Body":"* .NET Version: 4.5.1\r\n* Windows version: 10\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Don't know\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nSee title. Visual defect is that characters look different than they should - some are gray (like highlighted), some are not - see attached picture.\r\n \r\n **Expected behavior:**\r\nThere are no strange visual effects and all characters look the same.\r\n \r\n **Minimal repro:**\r\nSetup: I have _RichTextBox_ with _IsInactiveSelectionHighlightEnabled = true_. Inside is a longer text that needs scrollbar.\r\n\r\n1. Select all text.\r\n2. Click outside text box to lose focus.\r\n3. Text is still highlighted as expected with light gray.\r\n4. When scrolling text box there is strange visual defect, some characters are light gray as they should be, but some characters are not and are black.\r\n\r\nStackOverflow links with similar problem: \r\n[StackOverflow1](https://stackoverflow.com/questions/34248394/wpf-bug-in-flowdocumentscrollviewer-isinactiveselectionhighlightenabled)\r\n[StackOverflow2](https://stackoverflow.com/questions/54973499/in-a-wpf-textbox-why-does-an-inactive-selection-appear-incorrectly-when-scrolli)\r\n\r\nScreenshot: ![fed-bug](https://user-images.githubusercontent.com/45784262/63489526-a8febb80-c4b2-11e9-8c88-aca0756bd169.png) \r\n","Url":"https://github.com/dotnet/wpf/issues/1698","RelatedDescription":"Open issue \"When IsInactiveSelectionHighlightEnabled is turned on, then scrolling has visual defect\" (#1698)"},{"Id":"483762987","IsPullRequest":false,"CreatedAt":"2019-08-22T04:28:00","Actor":"Nukepayload2","Number":"1693","RawContent":null,"Title":"Some validation error messages of DataGrid are not localized","State":"open","Body":"* .NET Core Version: 3.0.100-preview8-013656\r\n* Windows version: 10.0.18362 (Japanese)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\n Some validation error messages of DataGrid are always English. No Japanese version when the program runs on a Japanese system. \r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n \r\n![image](https://user-images.githubusercontent.com/10798596/63485697-0278e180-c4d7-11e9-8b2d-f03f3bb77174.png)\r\n\r\n **Expected behavior:**\r\n \r\n![image](https://user-images.githubusercontent.com/10798596/63485802-5b487a00-c4d7-11e9-8aba-f8b8ffe549c1.png)\r\n\r\n **Minimal repro:**\r\n1. Create project\r\n```\r\ndotnet new wpf -lang vb\r\n```\r\n2. Edit `MainWindow.xaml`\r\n```xml\r\n<Window x:Class=\"MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\r\n    <Grid>\r\n        <Grid.Resources>\r\n            <Style TargetType=\"{x:Type DataGridRow}\">\r\n                <Setter Property=\"ValidationErrorTemplate\">\r\n                    <Setter.Value>\r\n                        <ControlTemplate>\r\n                            <TextBlock Text=\"!!!\"\r\n                                       Foreground=\"Red\" FontWeight=\"Bold\"\r\n                                       ToolTip=\"{Binding RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type DataGridRow}}, Path=(Validation.Errors)[0].ErrorContent}\"/>\r\n                        </ControlTemplate>\r\n                    </Setter.Value>\r\n                </Setter>\r\n            </Style>\r\n        </Grid.Resources>\r\n        <DataGrid x:Name=\"DemoDataView\" AutoGenerateColumns=\"False\">\r\n            <DataGrid.Columns>\r\n                <DataGridTextColumn Header=\"Id\" \r\n                    Binding=\"{Binding Id, ValidatesOnExceptions=True}\"/>\r\n                <DataGridTextColumn Header=\"Text\"\r\n                    Binding=\"{Binding Text, ValidatesOnExceptions=True}\"/>\r\n            </DataGrid.Columns>\r\n        </DataGrid>\r\n    </Grid>\r\n</Window>\r\n```\r\n3. Edit `MainWindow.vb`\r\n```vb\r\nImports System.Collections.ObjectModel\r\n\r\nClass MainWindow\r\n    Private ReadOnly _viewModel As New DemoViewModel\r\n\r\n    Private Sub MainWindow_Loaded(sender As Object, e As RoutedEventArgs) Handles Me.Loaded\r\n        DemoDataView.ItemsSource = _viewModel.Items\r\n    End Sub\r\nEnd Class\r\n\r\nPublic Class DemoViewModel\r\n    Public ReadOnly Property Items As New ObservableCollection(Of DemoModel)\r\nEnd Class\r\n\r\nPublic Class DemoModel\r\n    Public Property Id As Integer\r\n    Public Property Text As String\r\nEnd Class\r\n```\r\n4. Run\r\n```\r\ndotnet run\r\n```\r\n5. Input \"1111111111111111111111\" in the first cell of `DataGrid`, then press `Enter`\r\n![image](https://user-images.githubusercontent.com/10798596/63485469-18d26d80-c4d6-11e9-9b24-36a3f01c4580.png)\r\n6. Move mouse to the \"!!!\" text block\r\n![image](https://user-images.githubusercontent.com/10798596/63485504-2f78c480-c4d6-11e9-9b4d-1980a665dbe7.png)\r\n","Url":"https://github.com/dotnet/wpf/issues/1693","RelatedDescription":"Open issue \"Some validation error messages of DataGrid are not localized\" (#1693)"},{"Id":"483690259","IsPullRequest":true,"CreatedAt":"2019-08-21T23:46:21","Actor":"dotnet-maestro[bot]","Number":"1691","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190821.4\r\n- **Date Produced**: 8/21/2019 10:37 PM\r\n- **Commit**: 4c62e7db31a35c787ff05fbd40ea60dfac9a4432\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19421.4\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1691","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1691)"},{"Id":"483673027","IsPullRequest":true,"CreatedAt":"2019-08-21T22:35:57","Actor":"dotnet-maestro[bot]","Number":"1689","RawContent":null,"Title":"[release/3.0] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20190821.3\r\n- **Date Produced**: 8/21/2019 9:36 PM\r\n- **Commit**: 6818493a085b47dc5a35874852edef1449ba0429\r\n- **Branch**: refs/heads/release/3.0\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.0-rc1.19421.3\r\n\r\n[marker]: <> (End:07c1f64b-2232-48be-3da4-08d6ba11e0be)\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.NETCore.App** -> 3.0.0-rc1-19421-07 (parent: Microsoft.Private.Winforms)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/1689","RelatedDescription":"Closed or merged PR \"[release/3.0] Update dependencies from dotnet/winforms\" (#1689)"},{"Id":"483678486","IsPullRequest":false,"CreatedAt":"2019-08-21T22:17:46","Actor":"vsfeedback","Number":"1690","RawContent":null,"Title":"ArgumentOutOfRange exception thrown using WPF DataGrid control combo box with .NET Framework 4.8","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/697825/argumentoutofrange-exception-thrown-using-wpf-data.html)._\n\n---\n<p>When changing a field in a DataGrid that is of type DataGridComboBoxColumn, and then changing focus, an ArgumentOutOfRange exception is thrown from within WPF.</p><p>This only occurs with .NET Framework 4.8. Using an earlier version of the framework, no exception is thrown.</p><p>To reproduce:</p><ul><li>Load the attached project into Visual Studio 2017 or later.</li><li>Ensure you have .NET Framework 4.8 installed.</li><li>Start the sample application.</li><li>In the drop-down for &quot;First Status&quot; for &quot;Widget 1&quot;, select &quot;Disabled&quot;.</li><li>Move focus off the combo box by clicking on the &quot;Second Status&quot; column of &quot;Widget 2&quot;.</li><li>The exception is thrown.</li></ul><p>I think the problem is related to the fact that when the FirstStatus property is changed on Widget1, we make a call to Reload in the WidgetsVM, which rebuilds the Widgets collection (which is the collection the DataGrid is bound to). Doing this looks like it might be invalidating something WPF was holding on to, so that when it tries to find the object again, it gets a negative index, and the exception is thrown.</p><p>Is it legal to rebuild the collection a DataGrid is bound to during an update? The only two options I can currently think of are:</p><ol><li>This is a bug introduced in .NET Framework 4.8</li><li>We were relying on undefined behaviour before that just happened to work, and some change in .NET Framework 4.8 has meant this is no longer works.</li></ol><p>Any feedback would be greatly appreciated, as this issue is causing just about all versions of our product to crash for customers who have installed .NET Framework 4.8 (either specifically or as part of Windows 1903).</p><p>Note that we are using this &quot;DataContextSpy&quot; approach as our original code was written before .NET Framework 4.0 was released, when the DataGrid was not a type of FrameworkElement.</p><p><a href=\"https://developercommunityapi.westus.cloudapp.azure.com/storage/attachments/88566-wpfapp1.zip\">wpfapp1.zip</a></p><p>The call stack at the point of the exception is:</p><pre>&gt;    mscorlib.dll!System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument argument, System.ExceptionResource resource)    Unknown\n     mscorlib.dll!System.Collections.Generic.List&lt;System.Windows.Data.BindingExpressionBase&gt;.this[int].get(int index)    Unknown\n     PresentationFramework.dll!System.Windows.Data.BindingGroup.UpdateValues()    Unknown\n     PresentationFramework.dll!System.Windows.Data.BindingGroup.UpdateAndValidate(System.Windows.Controls.ValidationStep validationStep)    Unknown\n     PresentationFramework.dll!System.Windows.Data.BindingGroup.CommitEdit()    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGrid.OnExecutedCommitEdit(System.Windows.Input.ExecutedRoutedEventArgs e)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGrid.OnExecutedCommitEdit(object sender, System.Windows.Input.ExecutedRoutedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.Input.CommandBinding.OnExecuted(object sender, System.Windows.Input.ExecutedRoutedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.Input.CommandManager.ExecuteCommandBinding(object sender, System.Windows.Input.ExecutedRoutedEventArgs e, System.Windows.Input.CommandBinding commandBinding)    Unknown\n     PresentationCore.dll!System.Windows.Input.CommandManager.FindCommandBinding(object sender, System.Windows.RoutedEventArgs e, System.Windows.Input.ICommand command, bool execute)    Unknown\n     PresentationCore.dll!System.Windows.Input.CommandManager.OnExecuted(object sender, System.Windows.Input.ExecutedRoutedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.OnExecutedThunk(object sender, System.Windows.Input.ExecutedRoutedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.Input.ExecutedRoutedEventArgs.InvokeEventHandler(System.Delegate genericHandler, object target)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)    Unknown\n     PresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs args, bool trusted)    Unknown\n     PresentationCore.dll!System.Windows.Input.RoutedCommand.ExecuteImpl(object parameter, System.Windows.IInputElement target, bool userInitiated)    Unknown\n     PresentationCore.dll!System.Windows.Input.RoutedCommand.Execute(object parameter, System.Windows.IInputElement target)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGrid.EndEdit(System.Windows.Input.RoutedCommand command, System.Windows.Controls.DataGridCell cellContainer, System.Windows.Controls.DataGridEditingUnit editingUnit, bool exitEditMode)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGrid.OnCurrentCellChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     PresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex entryIndex, System.Windows.DependencyProperty dp, System.Windows.PropertyMetadata metadata, System.Windows.EffectiveValueEntry oldEntry, ref System.Windows.EffectiveValueEntry newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.SetValueCommon(System.Windows.DependencyProperty dp, object value, System.Windows.PropertyMetadata metadata, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType, bool isInternal)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.SetCurrentValueInternal(System.Windows.DependencyProperty dp, object value)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGrid.CurrentCellContainer.set(System.Windows.Controls.DataGridCell value)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGrid.FocusedCell.set(System.Windows.Controls.DataGridCell value)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGridCell.OnAnyGotFocus(object sender, System.Windows.RoutedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)    Unknown\n     PresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)    Unknown\n     PresentationFramework.dll!System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.IsFocused_Changed(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     PresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex entryIndex, System.Windows.DependencyProperty dp, System.Windows.PropertyMetadata metadata, System.Windows.EffectiveValueEntry oldEntry, ref System.Windows.EffectiveValueEntry newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.SetValueCommon(System.Windows.DependencyProperty dp, object value, System.Windows.PropertyMetadata metadata, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType, bool isInternal)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey key, object value)    Unknown\n     PresentationCore.dll!System.Windows.Input.FocusManager.OnFocusedElementChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     PresentationFramework.dll!System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs args)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex entryIndex, System.Windows.DependencyProperty dp, System.Windows.PropertyMetadata metadata, System.Windows.EffectiveValueEntry oldEntry, ref System.Windows.EffectiveValueEntry newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType)    Unknown\n     WindowsBase.dll!System.Windows.DependencyObject.SetValueCommon(System.Windows.DependencyProperty dp, object value, System.Windows.PropertyMetadata metadata, bool coerceWithDeferredReference, bool coerceWithCurrentValue, System.Windows.OperationType operationType, bool isInternal)    Unknown\n     PresentationCore.dll!System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject element, System.Windows.IInputElement value)    Unknown\n     PresentationFramework.dll!System.Windows.Input.KeyboardNavigation.UpdateFocusedElement(System.Windows.DependencyObject focusTarget)    Unknown\n     PresentationFramework.dll!System.Windows.FrameworkElement.OnGotKeyboardFocus(object sender, System.Windows.Input.KeyboardFocusChangedEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.Input.KeyboardFocusChangedEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)    Unknown\n     PresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseTrustedEvent(System.Windows.RoutedEventArgs args)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs args, bool trusted)    Unknown\n     PresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()    Unknown\n     PresentationCore.dll!System.Windows.Input.InputManager.ProcessInput(System.Windows.Input.InputEventArgs input)    Unknown\n     PresentationCore.dll!System.Windows.Input.KeyboardDevice.ChangeFocus(System.Windows.DependencyObject focus, int timestamp)    Unknown\n     PresentationCore.dll!System.Windows.Input.KeyboardDevice.TryChangeFocus(System.Windows.DependencyObject newFocus, System.Windows.Input.IKeyboardInputProvider keyboardInputProvider, bool askOld, bool askNew, bool forceToNullIfFailed)    Unknown\n     PresentationCore.dll!System.Windows.Input.KeyboardDevice.Focus(System.Windows.DependencyObject focus, bool askOld, bool askNew, bool forceToNullIfFailed)    Unknown\n     PresentationCore.dll!System.Windows.Input.KeyboardDevice.Focus(System.Windows.IInputElement element)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.Focus()    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGridCell.OnAnyMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs e)    Unknown\n     PresentationFramework.dll!System.Windows.Controls.DataGridCell.OnAnyMouseLeftButtonDownThunk(object sender, System.Windows.Input.MouseButtonEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.Input.MouseButtonEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)    Unknown\n     PresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.ReRaiseEventAs(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args, System.Windows.RoutedEvent newEvent)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.OnMouseDownThunk(object sender, System.Windows.Input.MouseButtonEventArgs e)    Unknown\n     PresentationCore.dll!System.Windows.Input.MouseButtonEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)    Unknown\n     PresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)    Unknown\n     PresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseTrustedEvent(System.Windows.RoutedEventArgs args)    Unknown\n     PresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs args, bool trusted)    Unknown\n     PresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()    Unknown\n     PresentationCore.dll!System.Windows.Input.InputManager.ProcessInput(System.Windows.Input.InputEventArgs input)    Unknown\n     PresentationCore.dll!System.Windows.Input.InputProviderSite.ReportInput(System.Windows.Input.InputReport inputReport)    Unknown\n     PresentationCore.dll!System.Windows.Interop.HwndMouseInputProvider.ReportInput(System.IntPtr hwnd, System.Windows.Input.InputMode mode, int timestamp, System.Windows.Input.RawMouseActions actions, int x, int y, int wheel)    Unknown\n     PresentationCore.dll!System.Windows.Interop.HwndMouseInputProvider.FilterMessage(System.IntPtr hwnd, MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)    Unknown\n     PresentationCore.dll!System.Windows.Interop.HwndSource.InputFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)    Unknown\n     WindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)    Unknown\n     WindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)    Unknown\n     WindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)    Unknown\n     WindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)    Unknown\n     WindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)    Unknown\n     WindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)    Unknown\n     [Native to Managed Transition]    \n     [Managed to Native Transition]    \n     WindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)    Unknown\n     WindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)    Unknown\n     PresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)    Unknown\n     PresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)    Unknown\n     PresentationFramework.dll!System.Windows.Application.Run(System.Windows.Window window)    Unknown\n     PresentationFramework.dll!System.Windows.Application.Run()    Unknown\n     WpfApp1.exe!WpfApp1.App.Main()    Unknown\n</pre>\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 8/19/2019, 00:46 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Sam Bent [MSFT] on 8/19/2019, 05:37 PM: \n\n<p><a rel=\"user\" href=\"https://developercommunity.visualstudio.com/users/183562/06eec267-8e99-4c3a-be77-d0daef236267.html\" nodeid=\"183562\">@Michael Priestman</a> asked:</p><p><em>Is it legal to rebuild the collection a DataGrid is bound to during an update? The only two options I can currently think of are:</em></p><ol>\n<li><em>This is a bug introduced in .NET Framework 4.8</em></li><li><em>We were relying on undefined behaviour before that just happened to work, and some change in .NET Framework 4.8 has meant this is no longer works.</em></li></ol><p>I'm afraid it's more complex.  It's unclear what should happen when you rebuild the collection during an update.  A row in a DataGrid typically displays several properties of the underlying data item, many of which might be \"dirty\" when you commit the row (e.g. by clicking in a different row).  WPF updates the dirty properties one at a time, but if updating property A causes your app to replace the DataGrid's collection, what should happen to property B?  Two possible answers (at least), both with about the same claim to correctness:</p><ol><li>Ignore the pending change to B.  The DataGrid is no longer connected to the data item - it shouldn't make any more changes.</li><li>Update property B (on the original data item).  The DataGrid started to update the data item, and should finish the job before fully disconnecting.</li></ol><p>It gets even weirder if an update encounters an error - failed validation rule, exception thrown by property-setter, etc.  The departing data item could be left in a bad state with no opportunity for the user to fix it, or even know that it happened.</p><p>So the behavior is undefined,  Your simple example (with only one dirty property) happened to work, but I suspect a more elaborate scenario with multiple dirty properties and errors in the pending values would send us into an endless discussion about what it even means for it to \"work\".</p><p>While WPF doesn't specify a behavior in this case, \"crash\" is not a helpful one, at least not without a message that helps you identify the problem.  You were close about the cause of the crash.  It turns out to involve the list of bindings corresponding to the columns.  When commit a row, WPF iterates over this list to update any \"dirty\" properties.  Updating one such property causes your app to rebuild the collection, which now (as of 4.8) removes all (or most) bindings from the list.  When the iteration continues, it crashes.  The iteration code anticipated that the current binding might get removed, but not all bindings.  (This was changed in 4.8 to fix memory leaks and aliasing problems that arose from keeping bindings alive after the DataGridRow was disconnected from its data item.)</p><p>For .NETCore we'll consider fixing the iteration code to survive your re-entrant change.  With no promises about the actual behavior, beyond \"don't crash\".  If you need the crash fixed in .NET 4.8, you should work with CSS to get a servicing request opened;  that will require some business justification.  It's probably simpler to fix your app to avoid the re-entrant change.  Your sample repro replaces the collection with another that contains identical items (or at least equivalent items), which seems unnecessary, but obviously I don't know what your real app does.</p>\n\n#### Michael Priestman on 8/20/2019, 04:57 AM: \n\n<p>Thanks for your very detailed reply. I had a feeling that rebuilding the entire collection might not be the cleverest idea. I don't know why it does it like this (I have only just inherited the source from some long-departed employees), but it feels like we should be able to fix it on the product side.</p>\n\n#### Sam Bent [MSFT] on 8/21/2019, 02:51 PM: \n\n<p>This is essentially the user’s bug.  The app changes the DataGrid’s source collection re-entrantly, while the DataGrid is committing changes to one of its data items.  This is not supported, nor can it be supported in any meaningful way (see my earlier comments).</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/1690","RelatedDescription":"Open issue \"ArgumentOutOfRange exception thrown using WPF DataGrid control combo box with .NET Framework 4.8\" (#1690)"},{"Id":"483647717","IsPullRequest":false,"CreatedAt":"2019-08-21T20:55:34","Actor":"grubioe","Number":"1688","RawContent":null,"Title":"Problem with loading component in WPF project","State":"open","Body":"@ds1709 commented on [Wed Aug 14 2019](https://github.com/dotnet/core/issues/3189)\n\n# Issue Title\r\n\r\nProblem with loading component in WPF project by calling `Application.LoadComponent(Uri)`.\r\n\r\n# General\r\n\r\nVersion: .NET Core 3.0.0 Preview 8.\r\nOS: Windows 10.\r\nVisual Studio: 2019 16.2.1.\r\nProject Sdk: Microsoft.NET.Sdk.WindowsDesktop.\r\n\r\nIn the next scenario `Application.LoadComponent(Uri)` throws exception.\r\nCreated a simple WPF application with classe `App` and `MainWindow`.\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.WindowsDesktop\">\r\n  <PropertyGroup>\r\n    <OutputType>WinExe</OutputType>\r\n    <TargetFramework>net472</TargetFramework>\r\n    <UseWPF>true</UseWPF>\r\n    <AssemblyVersion>1.2.3.54</AssemblyVersion>\r\n  </PropertyGroup>\r\n</Project>\r\n```\r\n```xml\r\n<Window x:Class=\"WpfApp1.MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\r\n    <Grid>\r\n        <Border x:Name=\"Foo\" />\r\n    </Grid>\r\n</Window>\r\n```\r\n```csharp\r\npublic partial class App : Application\r\n{\r\n    protected override void OnStartup(StartupEventArgs e)\r\n    {\r\n        base.OnStartup(e);\r\n        var uri = new Uri(\"/WpfApp1;component/mainwindow.xaml\", UriKind.Relative);\r\n        var window = LoadComponent(uri); // Exception: Cannot register duplicate Name 'Foo' in this scope.\r\n    }\r\n}\r\n```\r\nKey points here are `<AssemblyVersion>` in csproj file and named element in MainWindow xaml file. When it's declared, the window code generator creates code like `System.Uri resourceLocater = new System.Uri(\"/WpfApp1;V1.2.3.54;component/mainwindow.xaml\", System.UriKind.Relative);`. As you can see, there's version element in URI. But when `<AssemblyVersion>` is not declared, or version is declared in code ([assembly:AssemblyVersion(\"...\")]), then version is missing in generated URI, and exception is not throwing. Same for UserControls.\n\n---\n\n@carlossanlop commented on [Wed Aug 14 2019](https://github.com/dotnet/core/issues/3189#issuecomment-521354854)\n\n> `// Exception: Cannot register duplicate Name 'Foo' in this scope.`\r\n\r\n@ds1709 thank you for the details.\r\n\r\n@grubioe can you help with this issue? Feel free to transfer it to the dotnet/wpf repo if necessary.\n\n---\n\n@grubioe commented on [Wed Aug 14 2019](https://github.com/dotnet/core/issues/3189#issuecomment-521366474)\n\n@diverdan92 - this might be more related with VS, maybe in the project system, the code generator.  Can you route to the right team? \n\n","Url":"https://github.com/dotnet/wpf/issues/1688","RelatedDescription":"Open issue \"Problem with loading component in WPF project\" (#1688)"}],"ResultType":"GitHubIssue"}},"RunOn":"2019-08-24T05:30:53.5549274Z","RunDurationInMilliseconds":938}