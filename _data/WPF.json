{"Data":{"GitHub":{"Issues":[{"Id":"512309282","IsPullRequest":false,"CreatedAt":"2019-10-25T05:23:24","Actor":"vatsan-madhavan","Number":"2114","RawContent":null,"Title":"[release/3.1] Update C++ Tools to VS16.3 Preview 4","State":"open","Body":"From https://github.com/dotnet/wpf/pull/2105, we now know that C++ toolset containing libs that were built targeting 3.0 could not be used to build against 3.1 libs. \r\n\r\nhttps://github.com/dotnet/wpf/pull/2105#issuecomment-545746253\r\n> This was fixed in 16.4P3. It's caused by a mismatch between targeting 3.1 and using libs built against 3.0. Updating the tools should fix it and you should no longer need the private tools. \r\n>\r\n```\r\n##[error]msvcurt_netcore.lib(msilexit.obj)(0,0): error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000f8).\r\nmsvcurt_netcore.lib(msilexit.obj) : error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000fb). [F:\\workspace\\_work\\1\\s\\src\\Microsoft.DotNet.Wpf\\src\\DirectWriteForwarder\\DirectWriteForwarder.vcxproj]\r\n```\r\n\r\nThe toolset in Dev 16.3+ were built against 3.1 libs. \r\n\r\nThe root cause for why the compiler team needed to rebuild their tools against 3.1 libs is unclear @tgani-msft mentioned that the compiler team has yet to root-cause it. We should try to understand this further IMO. ","Url":"https://github.com/dotnet/wpf/issues/2114","RelatedDescription":"Open issue \"[release/3.1] Update C++ Tools to VS16.3 Preview 4\" (#2114)"},{"Id":"512308522","IsPullRequest":true,"CreatedAt":"2019-10-25T05:20:22","Actor":"vatsan-madhavan","Number":"2113","RawContent":null,"Title":"Update C++ Tools to VS16.3 Preview 4 ","State":"open","Body":"Fixes #2114 \r\nThere is a matching PR for [dotnet-wpf-int#3879](https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int/pullrequest/3879?_a=overview) that is needed along-with this change. \r\n\r\n## Description \r\n\r\nThis PR updates C++ tools used by WPF to VS 16.3 Preview 4 bits. \r\n\r\nFrom https://github.com/dotnet/wpf/pull/2105, we now know that C++ toolset containing libs that were built targeting 3.0 could not be used to build against 3.1 libs. \r\n\r\nhttps://github.com/dotnet/wpf/pull/2105#issuecomment-545746253\r\n> This was fixed in 16.4P3. It's caused by a mismatch between targeting 3.1 and using libs built against 3.0. Updating the tools should fix it and you should no longer need the private tools. \r\n>\r\n```\r\n##[error]msvcurt_netcore.lib(msilexit.obj)(0,0): error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000f8).\r\nmsvcurt_netcore.lib(msilexit.obj) : error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000fb). [F:\\workspace\\_work\\1\\s\\src\\Microsoft.DotNet.Wpf\\src\\DirectWriteForwarder\\DirectWriteForwarder.vcxproj]\r\n```\r\n\r\nThe toolset in Dev 16.3+ were built against 3.1 libs. \r\n\r\n## Customer Impact \r\n\r\nThis blocks .NET Core 3.1 Preview 2 builds. \r\n\r\n## Risk \r\n\r\n- The risk of toolset change without extensive testing on a release/* branch is **medium to high**.\r\n- Some basic  testing of the bits produced using this toolset suggests that the WPF bits are in good shape. I ran a set of high priority tests and did some ad-hoc tests against samples to validate the bits. \r\n\r\nMy recommendation is to merge this change now into release/3.1 branch to unblock preview builds, and continue with more testing as soon as a full SDK build is available. \r\n\r\n## Regression \r\n\r\nThe root cause for why the compiler team needed to rebuild their tools against 3.1 libs is unclear @tgani-msft mentioned that the compiler team has yet to root-cause it. We should try to understand this further IMO. ","Url":"https://github.com/dotnet/wpf/pull/2113","RelatedDescription":"Open PR \"Update C++ Tools to VS16.3 Preview 4 \" (#2113)"},{"Id":"511988145","IsPullRequest":false,"CreatedAt":"2019-10-24T22:54:38","Actor":"Symbai","Number":"2110","RawContent":null,"Title":"MissingManifestResourceException with linked resource","State":"closed","Body":"* .NET Core Version: 3.0\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: **No**\r\n\r\n **Problem description:**\r\n\r\nWith a file-linked* resource file, the app crashes on runtime when accessing it. The same app was ported from .NET Framework 4.8 where it worked without any issue. The project has no errors on build.\r\n\r\n* VS right click add existing file, at the bottom on the add button choose \"add as link\" instead.\r\n\r\n \r\n **Actual behavior:** \r\n\r\n```System.Resources.MissingManifestResourceException: 'Could not find the resource \"SchmuhHost.Properties.Resources.resources\" among the resources \"SchmuhClient.g.resources\", \"SchmuhClient.Properties.Resources.resources\" embedded in the assembly \"SchmuhClient\", nor among the resources in any satellite assemblies for the specified culture. Perhaps the resources were embedded with an incorrect name.'```\r\n \r\n **Expected behavior:**\r\n\r\nNo crash\r\n \r\n **Minimal repro:**\r\nHost = project with normal resource file. Create resource string called \"BlaString\" with content \"blabla {0}\"\r\nClient = project that has the host's resource file linked\r\n\r\nIn client's code:\r\n`string.Format(Properties.Resources.BlaString, 12)`\r\n\r\nIn client's project file\r\n```\r\n  <ItemGroup>\r\n    <Compile Include=\"..\\..\\SchmuhHost\\SchmuhHost\\Properties\\Resources.Designer.cs\">\r\n      <Link>Properties\\Resources.Designer.cs</Link>\r\n      <AutoGen>True</AutoGen>\r\n      <DesignTime>True</DesignTime>\r\n      <DependentUpon>Resources.resx</DependentUpon>\r\n    </Compile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <EmbeddedResource Include=\"..\\..\\SchmuhHost\\SchmuhHost\\Properties\\Resources.resx\">\r\n      <Link>Properties\\Resources.resx</Link>\r\n      <Generator>PublicResXFileCodeGenerator</Generator>\r\n      <LastGenOutput>Resources.Designer.cs</LastGenOutput>\r\n      <CustomToolNamespace>SchmuhHost.Properties</CustomToolNamespace>\r\n    </EmbeddedResource>\r\n  </ItemGroup>\r\n```","Url":"https://github.com/dotnet/wpf/issues/2110","RelatedDescription":"Closed issue \"MissingManifestResourceException with linked resource\" (#2110)"},{"Id":"512144946","IsPullRequest":false,"CreatedAt":"2019-10-24T19:46:25","Actor":"vsfeedback","Number":"2112","RawContent":null,"Title":"Compile error with WPF .net Core 3.0 when adding .resx files","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/771961/compile-error-with-wpf-net-core-30-when-adding-res.html)._\n\n---\nVisual Studio 2019 Professional 16.3.3\n\nIf I do **localization** with WPF **.net Framework** and add two files (Resources.resx and Resources.de.resx) it **compiles as expected.**\n\nBut if I do the same in **WPF .net Core 3.0 I get compile errors.**\n\n- Create a WPF .net Core app\n- Add a Resources folder\n- Create a Resources.resx file\n- Set it to public\n- Create a Resources.de.resx file\n- Set it to public\n- Build solution\n\n&gt; Error\t\tCustom tool PublicResXFileCodeGenerator failed to produce an output for input file 'Resources\\Resources.de.resx' but did not log a specific error.\tLocalizationWpfNetCore\tC:\\...\\source\\repos\\LocalizationWpfNetCore\\LocalizationWpfNetCore\\Resources\\Resources.de.resx\t1\t\t\n\nand\n\n&gt; Error\tMSB3086\tTask could not find &quot;al.exe&quot; using the SdkToolsPath &quot;&quot; or the registry key &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Microsoft SDKs\\NETFXSDK\\4.7.2\\WinSDK-NetFx40Tools-x86&quot;. Make sure the SdkToolsPath is set and the tool exists in the correct processor specific location under the SdkToolsPath and that the Microsoft Windows SDK is installed\tLocalizationWpfNetCore\tC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\ MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets\t3639\n\nSo why does it work when I choose .net Framework but not with .net Core?\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 10/10/2019, 11:27 AM: \n\nWe have converted this feedback item from idea to problem. This change was done to better reflect the feedback's nature.\n#### Visual Studio Feedback System on 10/11/2019, 01:27 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Olivier Leclerc on 10/19/2019, 08:44 PM: \n\n<p>I have the same two errors using NetStandard.Librairy 2.0.3  </p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/2112","RelatedDescription":"Open issue \"Compile error with WPF .net Core 3.0 when adding .resx files\" (#2112)"},{"Id":"511877623","IsPullRequest":false,"CreatedAt":"2019-10-24T18:45:58","Actor":"topsterde","Number":"2107","RawContent":null,"Title":"WPF element rendering is 20% slower on .NET Core 3.0 than on .NET Framework","State":"closed","Body":"* .NET Core Version: 3.0.0\r\n* Windows version: Windows 10 x64\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n\r\n **Problem description:**\r\n\r\nThe attached demo runs on the .NET Framework five seconds and needs 230 MB memory.\r\nThe .NET Core 3.0 version is 1 second slower and need 15 MB more memory.\r\n\r\nThis issue is not related to: https://github.com/dotnet/wpf/issues/94\r\n\r\n  **Actual behavior:** \r\nSlower perfomance and more memory consumption than .NET Framework \r\n\r\n **Expected behavior:**\r\n Better performance and less memory consumption with .NET Core 3.0\r\n\r\n\r\n **Minimal repro:**\r\n\r\n[PerformanceWpfCoreVsFramework.zip](https://github.com/dotnet/wpf/files/3767160/PerformanceWpfCoreVsFramework.zip)","Url":"https://github.com/dotnet/wpf/issues/2107","RelatedDescription":"Closed issue \"WPF element rendering is 20% slower on .NET Core 3.0 than on .NET Framework\" (#2107)"},{"Id":"512089618","IsPullRequest":true,"CreatedAt":"2019-10-24T18:19:39","Actor":"mmitche","Number":"2111","RawContent":null,"Title":"Switch to label.N form for pre-release label","State":"closed","Body":"In order to facilitate better preview sorting, switch to label.N form for the pre-release label.","Url":"https://github.com/dotnet/wpf/pull/2111","RelatedDescription":"Closed or merged PR \"Switch to label.N form for pre-release label\" (#2111)"},{"Id":"511909721","IsPullRequest":true,"CreatedAt":"2019-10-24T13:40:02","Actor":"dotnet-maestro[bot]","Number":"2109","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Build**: 20191023.12\r\n- **Date Produced**: 10/24/2019 1:19 AM\r\n- **Commit**: d42863533a66446a600856846e5af32e45cd7216\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng** -> 5.0.0-alpha1.19523.12\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2109","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#2109)"},{"Id":"511899263","IsPullRequest":true,"CreatedAt":"2019-10-24T12:33:36","Actor":"dotnet-maestro[bot]","Number":"2108","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191023.3\r\n- **Date Produced**: 10/23/2019 4:10 PM\r\n- **Commit**: 894bd005267af53f7d39ac988881e61193e67ae1\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19523.3\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2108","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2108)"},{"Id":"511810011","IsPullRequest":false,"CreatedAt":"2019-10-24T09:07:20","Actor":"pieterphilippaerts","Number":"2106","RawContent":null,"Title":"Printing XPS files fails on Windows 8.1","State":"open","Body":"Hi everyone,\r\n\r\nI'm using .NET Core 3 to print XPS files. The code I have is simple and working perfectly on Windows 7 and Windows 10, but it fails on Windows 8.1 (multiple machines, both 32-bit and 64-bit).\r\n\r\nI've tried a number of different variations of the printing code, but here's a simple example:\r\n\r\n```\r\nvar pd = new PrintDialog();\r\nif (pd.ShowDialog() == true) {\r\n    var tdoc = new XpsDocument(@\"<SOMEPATH>\\temp.xps\", FileAccess.ReadWrite);\r\n    pd.PrintDocument(tdoc.GetFixedDocumentSequence().DocumentPaginator, \"temp.xps\");\r\n}\r\n```\r\n\r\nThis code works perfectly on Windows 7 and Windows 10, but on Window 8.1 I always get the following exception: \r\n\r\n> System.IO.IOException: Cannot retrieve parts of writeonly container\r\n>    at System.IO.Packaging.Package.ThrowIfWriteOnly()\r\n>    at System.IO.Packaging.Package.GetRelationshipsByType(String relationshipType)\r\n>    at System.Windows.Xps.Packaging.XpsManager.GetXpsDocumentStartingPart(Package package)\r\n>    at System.Windows.Xps.Packaging.XpsDocument.AddFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsPackagingPolicy.AcquireXmlWriterForFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.AcquireXmlWriter(Type writerType)\r\n>    at System.Windows.Xps.Serialization.DocumentSequenceSerializer.get_XmlWriter()\r\n>    at System.Windows.Xps.Serialization.DocumentSequenceSerializer.PersistObjectData(SerializableObjectContext serializableObjectContext)\r\n>    at System.Windows.Xps.Serialization.ReachSerializer.SerializeObject(Object serializedObject)\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.SaveAsXaml(Object serializedObject)\r\n>    at System.Windows.Xps.XpsDocumentWriter.SaveAsXaml(Object serializedObject, Boolean isSync)\r\n>    at System.Windows.Xps.XpsDocumentWriter.Write(DocumentPaginator documentPaginator, PrintTicket printTicket)\r\n>    at System.Windows.Controls.PrintDialog.PrintDocument(DocumentPaginator documentPaginator, String description)\r\n\r\nI don't see any problems with the code, and the exact same code is actually working on Windows 8.1 if I use it in the full .NET Framework!! So this looks like a bug in .NET Core 3 (specifically on Windows 8.1).\r\n\r\nAlso note that I've really tried _many_ variations of the printing code (including PrintDialog.PrintVisual, PrintQueue.AddJob, XpsDocumentWriter.Write, XpsDocumentWriter.WriteAsync, creating the XpsDocument in memory instead of from a file, ...), but none of them worked on Windows 8.1 and I always get similar exceptions, for example: \r\n\r\n> System.IO.IOException: Cannot retrieve parts of writeonly container\r\n>    at System.IO.Packaging.Package.ThrowIfWriteOnly()\r\n>    at System.IO.Packaging.Package.GetRelationshipsByType(String relationshipType)\r\n>    at System.Windows.Xps.Packaging.XpsManager.GetXpsDocumentStartingPart(Package package)\r\n>    at System.Windows.Xps.Packaging.XpsDocument.AddFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsPackagingPolicy.AcquireXmlWriterForFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.AcquireXmlWriter(Type writerType)\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.SimulateBeginFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.BeginConfirmToXPSStructure(Boolean mode)\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.SaveAsXaml(Object serializedObject)\r\n>    at System.Windows.Xps.XpsDocumentWriter.SaveAsXaml(Object serializedObject, Boolean isSync)\r\n>    at System.Windows.Xps.XpsDocumentWriter.Write(Visual visual, PrintTicket printTicket)\r\n>    at System.Windows.Controls.PrintDialog.PrintVisual(Visual visual, String description)\r\n\r\nThis issue seems to be related to issue 597 (https://github.com/dotnet/wpf/issues/597). this appears to be the exact same problem, however issue 597 was closed and marked as fixed. \r\nIf I execute the exact same code as the author of issue 597 (i.e. \"PrintQueue.CreateXpsDocumentWriter(LocalPrintServer.GetDefaultPrintQueue()).Write(visual);\"), I get the exact exception he got:\r\n\r\n> System.IO.IOException: Cannot retrieve parts of writeonly container\r\n>    at System.IO.Packaging.Package.ThrowIfWriteOnly()\r\n>    at System.IO.Packaging.Package.GetRelationshipsByType(String relationshipType)\r\n>    at System.Windows.Xps.Packaging.XpsManager.GetXpsDocumentStartingPart(Package package)\r\n>    at System.Windows.Xps.Packaging.XpsDocument.AddFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsPackagingPolicy.AcquireXmlWriterForFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.AcquireXmlWriter(Type writerType)\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.SimulateBeginFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.BeginConfirmToXPSStructure(Boolean mode)\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.SaveAsXaml(Object serializedObject)\r\n>    at System.Windows.Xps.XpsDocumentWriter.SaveAsXaml(Object serializedObject, Boolean isSync)\r\n>    at System.Windows.Xps.XpsDocumentWriter.Write(Visual visual)\r\n\r\nIs it possible that the fix for issue 597 isn't working on Windows 8.1 for some reason?\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/2106","RelatedDescription":"Open issue \"Printing XPS files fails on Windows 8.1\" (#2106)"},{"Id":"511647697","IsPullRequest":true,"CreatedAt":"2019-10-24T01:10:25","Actor":"dotnet-maestro[bot]","Number":"2105","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191023.5\r\n- **Date Produced**: 10/24/2019 6:39 AM\r\n- **Commit**: d890296011263c2fd459a2c4ae63d522d1f651ba\r\n- **Branch**: refs/heads/release/3.1\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.1-preview1.19523.5\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.App** -> 3.1.0-preview2.19523.6 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Configuration.ConfigurationManager** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Diagnostics.EventLog** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.DirectoryServices** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Drawing.Common** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.Emit** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.MetadataLoadContext** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.AccessControl** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Cryptography.Xml** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Permissions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Principal.Windows** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Windows.Extensions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.Platforms** -> 3.1.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.IO.Packaging** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILDAsm** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **Microsoft.NETCore.Runtime.CoreCLR** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILAsm** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **System.Resources.Extensions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2105","RelatedDescription":"Open PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#2105)"},{"Id":"511643114","IsPullRequest":true,"CreatedAt":"2019-10-24T01:05:25","Actor":"dotnet-maestro[bot]","Number":"2104","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191023.2\r\n- **Date Produced**: 10/24/2019 12:38 AM\r\n- **Commit**: fb02fe818f8b410259776e4fa6ca0c5cdd43e07c\r\n- **Branch**: refs/heads/release/3.1\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.1-preview1.19523.2\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2104","RelatedDescription":"Closed or merged PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#2104)"},{"Id":"511629257","IsPullRequest":true,"CreatedAt":"2019-10-23T23:52:51","Actor":"rladuca","Number":"2103","RawContent":null,"Title":"[Release/3.1] Hit testing by geometry fails if more than one matrix trasformation is applied to a geometry.","State":"open","Body":"On behalf of @Simon-IT :\r\n\r\nThis is related to my issue 642. In the hit testing by geometry algotithm, the order in which the transformations are crosses is wrong. In the issue 642 there is a project to test in very simple manner the problem.\r\n\r\n3.1 port related to https://github.com/dotnet/wpf/pull/1761","Url":"https://github.com/dotnet/wpf/pull/2103","RelatedDescription":"Open PR \"[Release/3.1] Hit testing by geometry fails if more than one matrix trasformation is applied to a geometry.\" (#2103)"},{"Id":"511613394","IsPullRequest":true,"CreatedAt":"2019-10-23T22:55:34","Actor":"vatsan-madhavan","Number":"2102","RawContent":null,"Title":"[release/3.0] Prevent NULL HWND's from being parented under SystemResources listener windows","State":"open","Body":"Addresses #2089 \r\n.NET 5 PR: #2100 \r\n.NET Core 3.1 PR: #2101 \r\n\r\n## Description (Summary)\r\n\r\nWhen `HwndHost` hosted `HWND`'s need to be \"parked\" while the `HwndHost` is not being actively shown, WPF will reparent such `HWND`'s under temporary message-only windows maintained inside the `SystemResources` class. \r\n\r\nThere is a bug that causes null `HWND`'s to be parented under such message-only windows. When this happens in High-DPI applications that use mixed-mode DPI capabilities introduced by WPF in .NET 4.8 (parent and child windows with different `DPI_AWARENESS_CONTEXT `values),  a crash ensues. \r\n\r\n## Customer Impact \r\n\r\nThis is a fix for a crash affecting several applications including Visual Studio, and Azure Information Protection Add-in for Office \r\n\r\nThis was fixed recently in .NET 4.8, and is being forwarded ported to .NET Core for consistency. \r\n\r\n## Regresssion \r\n\r\nNot a regression in .NET Core, but this was a regression introduced by .NET 4.8. \r\n\r\n## Risk \r\n\r\nThe fix is small and well understood, and has been tested well. The .NET Framework version of this fix has been validated by Visual Studio (the codebases are identical in this area and .NET Framework testing is a reliable proxy for this change in .NET Core). \r\n\r\n## Details \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2102","RelatedDescription":"Open PR \"[release/3.0] Prevent NULL HWND's from being parented under SystemResources listener windows\" (#2102)"},{"Id":"511612931","IsPullRequest":true,"CreatedAt":"2019-10-23T22:54:12","Actor":"vatsan-madhavan","Number":"2101","RawContent":null,"Title":"[release/3.1] Prevent NULL HWND's from being parented under SystemResources listener windows ","State":"open","Body":"Addresses #2089 \r\n.NET 5 PR: #2100 \r\n\r\n## Description (Summary)\r\n\r\nWhen `HwndHost` hosted `HWND`'s need to be \"parked\" while the `HwndHost` is not being actively shown, WPF will reparent such `HWND`'s under temporary message-only windows maintained inside the `SystemResources` class. \r\n\r\nThere is a bug that causes null `HWND`'s to be parented under such message-only windows. When this happens in High-DPI applications that use mixed-mode DPI capabilities introduced by WPF in .NET 4.8 (parent and child windows with different `DPI_AWARENESS_CONTEXT `values),  a crash ensues. \r\n\r\n## Customer Impact \r\n\r\nThis is a fix for a crash affecting several applications including Visual Studio, and Azure Information Protection Add-in for Office \r\n\r\nThis was fixed recently in .NET 4.8, and is being forwarded ported to .NET Core for consistency. \r\n\r\n## Regresssion \r\n\r\nNot a regression in .NET Core, but this was a regression introduced by .NET 4.8. \r\n\r\n## Risk \r\n\r\nThe fix is small and well understood, and has been tested well. The .NET Framework version of this fix has been validated by Visual Studio (the codebases are identical in this area and .NET Framework testing is a reliable proxy for this change in .NET Core). \r\n\r\n## Details \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2101","RelatedDescription":"Open PR \"[release/3.1] Prevent NULL HWND's from being parented under SystemResources listener windows \" (#2101)"},{"Id":"511608382","IsPullRequest":true,"CreatedAt":"2019-10-23T22:39:30","Actor":"vatsan-madhavan","Number":"2100","RawContent":null,"Title":"Prevent NULL HWND's from being parented under SystemResources listener windows","State":"open","Body":"Addresses #2089 \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2100","RelatedDescription":"Open PR \"Prevent NULL HWND's from being parented under SystemResources listener windows\" (#2100)"},{"Id":"511600847","IsPullRequest":true,"CreatedAt":"2019-10-23T22:17:59","Actor":"vatsan-madhavan","Number":"2099","RawContent":null,"Title":"[release/3.0] Context Menus are sometimes not shown in High-DPI applications ","State":"open","Body":"Addresses #2088 \r\n.NET 5 PR: #2097 \r\n.NET Core 3.1 PR: #2098 \r\n\r\n## Description (Summary)\r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nThis previous fix depended upon a private helper-method (`Popup.DestroyWindow`) that had side-effects that were not accounted for in the original fix. One of the side effects is that the `ContextMenu` is not sown consistently. \r\n\r\nThe solution modifies (refactors) the private method to extract the useful portion and uses it to improve the previous fix. \r\n\r\n## Customer Impact\r\n\r\nThis is a forward-port from from .NET 4.8. This was reported by a customer, and has also been discovered by Visual Studio internally. \r\n\r\n## Regression \r\n\r\nRegression introduced by .NET 4.8. .NET Core 3.0 shipped with this bug. \r\n\r\n## Risk \r\n\r\nLow - this has been well tested internally and validated by multiple customers. The fix is well understood and small/scoped. \r\n\r\n## Details \r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2099","RelatedDescription":"Open PR \"[release/3.0] Context Menus are sometimes not shown in High-DPI applications \" (#2099)"},{"Id":"511600421","IsPullRequest":true,"CreatedAt":"2019-10-23T22:16:54","Actor":"vatsan-madhavan","Number":"2098","RawContent":null,"Title":"[release/3.1] Context Menus are sometimes not shown in High-DPI applications","State":"open","Body":"Addresses #2088 \r\n.NET 5 PR: #2097 \r\n\r\n## Description (Summary)\r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nThis previous fix depended upon a private helper-method (`Popup.DestroyWindow`) that had side-effects that were not accounted for in the original fix. One of the side effects is that the `ContextMenu` is not sown consistently. \r\n\r\nThe solution modifies (refactors) the private method to extract the useful portion and uses it to improve the previous fix. \r\n\r\n## Customer Impact\r\n\r\nThis is a forward-port from from .NET 4.8. This was reported by a customer, and has also been discovered by Visual Studio internally. \r\n\r\n## Regression \r\n\r\nRegression introduced by .NET 4.8. .NET Core 3.0 shipped with this bug. \r\n\r\n## Risk \r\n\r\nLow - this has been well tested internally and validated by multiple customers. The fix is well understood and small/scoped. \r\n\r\n## Details \r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2098","RelatedDescription":"Open PR \"[release/3.1] Context Menus are sometimes not shown in High-DPI applications\" (#2098)"},{"Id":"511464037","IsPullRequest":true,"CreatedAt":"2019-10-23T17:20:07","Actor":"vatsan-madhavan","Number":"2097","RawContent":null,"Title":"Context Menus are sometimes not shown in High-DPI applications","State":"open","Body":"Addresses #2088 \r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2097","RelatedDescription":"Open PR \"Context Menus are sometimes not shown in High-DPI applications\" (#2097)"},{"Id":"511276661","IsPullRequest":true,"CreatedAt":"2019-10-23T13:13:37","Actor":"dotnet-maestro[bot]","Number":"2095","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191022.8\r\n- **Date Produced**: 10/22/2019 10:28 PM\r\n- **Commit**: b809e63d8ef475faaf6fecbe8bf77180f8e3550c\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19522.8\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2095","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2095)"},{"Id":"511279817","IsPullRequest":false,"CreatedAt":"2019-10-23T12:09:51","Actor":"DarkIrata","Number":"2096","RawContent":null,"Title":"Adding a SpinEdit / NumericUpDown Control to WPF","State":"open","Body":"The NumericUpDown control is available in WinForms, and also should be in WPF. Especially since it is much easier to make custom styles for controls in WPF. \r\nIt is annoying to rebuild that control everytime you need it and can't reuse older code. Sure there are ready to use libraries like MahApps, but it should never be a requirement for basic controls to add a dependency. Even worse when you use style libraries like MaterialDesignInXaml which restyle many basic controls. (Yes, i know that an self-made problem) \r\n\r\nI am suprised that there is no request issue open for this.\r\nBut yeah, would be happy to get that control. ","Url":"https://github.com/dotnet/wpf/issues/2096","RelatedDescription":"Open issue \"Adding a SpinEdit / NumericUpDown Control to WPF\" (#2096)"},{"Id":"511088306","IsPullRequest":true,"CreatedAt":"2019-10-23T05:55:23","Actor":"dotnet-maestro[bot]","Number":"2094","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.10\r\n- **Date Produced**: 10/23/2019 5:26 AM\r\n- **Commit**: b34582761bea089eb0d19aba8e43c4b90d90c98e\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.10\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2094","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2094)"},{"Id":"511020760","IsPullRequest":true,"CreatedAt":"2019-10-23T02:05:28","Actor":"dotnet-maestro[bot]","Number":"2093","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.7\r\n- **Date Produced**: 10/23/2019 1:15 AM\r\n- **Commit**: 4f9ddf34914d9b014fde363b8cc37f2a590b03b9\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.7\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2093","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2093)"},{"Id":"510986717","IsPullRequest":true,"CreatedAt":"2019-10-22T23:36:35","Actor":"arpitmathur","Number":"2092","RawContent":null,"Title":"Adding border to ToggleButton when checked in high-contrast themes","State":"open","Body":"Fixes #1458\r\n\r\n5.0 PR: https://github.com/dotnet/wpf/pull/1976\r\n\r\n# Description\r\n\r\nIn non-high contrast themes, when you check a ToggleButton and navigate to another control, we display the checked status by highlighting the button with a lighter shade of the selection color.\r\n\r\nWe don't follow this behavior in high contrast themes. The text is slightly-depressed upon checking but that is not visually apparent . When the ToggleButton does not have focus, there is a slight border which again, is not apparent.\r\n![highcontrastwhitetogglebutton_without_change](https://user-images.githubusercontent.com/5456126/65924723-e6ecda80-e3a2-11e9-860d-66c72212c0e0.png)\r\n\r\nIn the image above, the 'S', 'C' and 'I' buttons are checked. However, it's barely noticeable that 'S' and 'C' are checked. The checked status of the 'I' button is also not noticeable when it receives focus.\r\n\r\n\r\nThe fix here is to check for a toggle button to be checked when in a high-contrast theme, we then add a border around the button. When a checked button also has keyboard focus, we add a border in the background-color. When the user navigates away, the border color is the same as the selection-color.\r\n\r\nIn the image below, the 'S', 'C' and 'I' buttons are checked again. Here, it's visually apparent that they are all currently checked.\r\n![highcontrastwhitetogglebutton_with_change](https://user-images.githubusercontent.com/5456126/65924964-c709e680-e3a3-11e9-8eab-fd1016e4c3b3.png)\r\n\r\nIn this pull request, relevant changes are in lines 673:693 in Button.xaml, the remaining files are generated off those changes.\r\n# Customer Impact\r\n\r\nIn high contrast themes, when you check a ToggleButton, it is not visually apparent that the ToggleButton has been checked, both when the ToggleButton has keyboard focus and when it does not.\r\n# Regression\r\nNo. This was discovered during accessibility testing on .Net Core 3.0\r\n\r\n# Risk - Low\r\nThis change only affects the ToggleButton control when HighContrast mode is turned on.","Url":"https://github.com/dotnet/wpf/pull/2092","RelatedDescription":"Open PR \"Adding border to ToggleButton when checked in high-contrast themes\" (#2092)"},{"Id":"510983505","IsPullRequest":true,"CreatedAt":"2019-10-22T23:35:46","Actor":"dotnet-maestro[bot]","Number":"2091","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.5\r\n- **Date Produced**: 10/22/2019 10:54 PM\r\n- **Commit**: 66b697b2c010c8f49d01af11863212a0caf18824\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.5\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2091","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2091)"},{"Id":"510975056","IsPullRequest":true,"CreatedAt":"2019-10-22T22:58:41","Actor":"arpitmathur","Number":"2090","RawContent":null,"Title":"Removing separators from SizeOfSet and PositionInSet counts","State":"open","Body":"Fixes #1467\r\n\r\n5.0 PR: https://github.com/dotnet/wpf/pull/1977\r\n\r\n# Description\r\n\r\nScreen readers were reading incorrect values of the number of menu items and their position since we were counting separators as MenuItems in the automation tree.\r\n\r\nI filtered for separators in the current MenuItems to fix the SizeOfSet count.\r\n\r\nI filtered for separators again for PositionInSet but added a short-circuit to break when you're at the element whose position you're trying to find. This short-circuit was added to not remove separators below the relevant MenuItem from the PositionInSet count.\r\n\r\n# Customer Impact\r\n\r\nNarrator and other screen readers read the wrong values of SizeOfSet and PositioninSet for each individual menu item. This is confusing for users with visual disabilities as they can not accurately tell what is being visually represented on the screen.\r\n\r\n# Regression\r\nNo. This was discovered during accessibility testing on .Net Core 3.0\r\n\r\n# Risk - Low\r\nWe're iterating over the menu items another time in a place where we're already iterating. Running another iteration through an enumerable does invalidate some caching but there doesn't seem to be an obviously better way to make this change. We rejected an approach storing the number of separators in a variable as the memory cost would always be paid and be higher than the time cost of another iteration.","Url":"https://github.com/dotnet/wpf/pull/2090","RelatedDescription":"Open PR \"Removing separators from SizeOfSet and PositionInSet counts\" (#2090)"},{"Id":"510962028","IsPullRequest":false,"CreatedAt":"2019-10-22T22:27:38","Actor":"vatsan-madhavan","Number":"2089","RawContent":null,"Title":"NULL HWND's attempted to be parented under SystemResources listener window cause unhanded exception","State":"open","Body":"When an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent. \r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now. \r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that have resulted in this bug becoming a crashing bug. In addition to calling `kernel32!SetParent `on a `NULL HWND`, WPF attempts to perform several other operations on the `HWND`, including querying its DPI characteristics (which returns invalid information). Once of the subsidiary steps returns an invalid value that in turn results in a crash with the following stack:\r\n\r\n```\r\nSystem.Collections.Generic.KeyNotFoundException: 'The given key was not present in the dictionary.'\r\nmscorlib.dll!System.Collections.Generic.Dictionary<System.__Canon, System.__Canon>.this[System.__Canon].get(System.__Canon key) Line 183\tC#\r\n \tPresentationFramework.dll!System.Windows.SystemResources.GetDpiAwarenessCompatibleNotificationWindow(System.Runtime.InteropServices.HandleRef hwnd) Line 1731\tC#\r\n \tPresentationFramework.dll!System.Windows.Interop.HwndHost.BuildOrReparentWindow() Line 1196\tC#\r\n \tPresentationFramework.dll!System.Windows.Interop.HwndHost.OnSourceChanged(object sender, System.Windows.SourceChangedEventArgs e) Line 1077\tC#\r\n \tPresentationCore.dll!System.Windows.SourceChangedEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget) Line 142\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target) Line 341\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs) Line 81\tC#\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised) Line 203\tC#\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args) Line 2354\tC#\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e) Line 432\tC#\r\n \tPresentationCore.dll!System.Windows.PresentationSource.UpdateSourceOfElement(System.Windows.DependencyObject doTarget, System.Windows.DependencyObject doAncestor, System.Windows.DependencyObject doOldParent) Line 861\tC#\r\n \tPresentationCore.dll!System.Windows.PresentationSource.RootChanged(System.Windows.Media.Visual oldRoot, System.Windows.Media.Visual newRoot) Line 566\tC#\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value) Line 699\tC#\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.Dispose(bool disposing) Line 2895\tC#\t\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.OnHwndDisposed(object sender, System.EventArgs args) Line 2819\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.Dispose(bool disposing, bool isHwndBeingDestroyed) Line 230\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) Line 360\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) Line 494\tC#\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) Line 104\tC#\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) Line 37\tC#\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) Line 1445\tC#\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) Line 398\tC#\r\n```\r\n\r\nThis issue is related to, but not a duplicate of, #1198/#1953. That said, it affects the same sorts of scenarios described in #1198.  \r\n\r\n```C#\r\n// ****BUG*** \r\n// unconditional else block\r\n// hwnd.Handle could be IntPtr.Zero, bad things can happen here\r\n// ****BUG*** \r\n```\r\nhttps://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/HwndHost.cs#L979-L997\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/2089","RelatedDescription":"Open issue \"NULL HWND's attempted to be parented under SystemResources listener window cause unhanded exception\" (#2089)"},{"Id":"510955831","IsPullRequest":false,"CreatedAt":"2019-10-22T22:16:24","Actor":"vatsan-madhavan","Number":"2088","RawContent":null,"Title":"Context Menus (Popup) are sometimes broken in High-DPI applications in .NET 4.8 ","State":"open","Body":"https://github.com/microsoft/dotnet/issues/1036#issue-443322868\r\n\r\n> After installing .NET 4.8 we have observed that Context menus via the Popup class show strange effects.\r\n> \r\n> 1. Popup is placed at top left corner\r\n> 2. Popup comes up empty\r\n> 3. Popup has no styles applied\r\n> 4. Alternating behavior:\r\n>    a) Popup works.\r\n>    b) Popup comes up empty\r\n>    ....\r\n> \r\n> I have debugged that issue and found that the is Popup is sometimes destroyed while the popup window is meant to be created:\r\n> \r\n> The diff from .NET 4.7.2 to 4.8 shows this new code was added:\r\n> \r\n> ![image](https://user-images.githubusercontent.com/408821/57610465-28562800-7571-11e9-9168-b0c036706a22.png)\r\n> \r\n> This leads to the call stack that the popup is killed while it is beeing created:\r\n> \r\n> ```\r\n> 0:000> !ClrStack\r\n> OS Thread Id: 0x2180 (0)\r\n> Call Site\r\n> System.Windows.Controls.Primitives.Popup.DestroyWindow()\r\n> System.Windows.Controls.Primitives.Popup.CreateWindow(Boolean)\r\n> \r\n> System.Windows.Controls.Primitives.Popup.OnIsOpenChanged(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex, System.Windows.DependencyProperty, System.Windows.PropertyMetadata, System.Windows.EffectiveValueEntry, System.Windows.EffectiveValueEntry ByRef, Boolean, Boolean, System.Windows.OperationType)\r\n> System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty, Boolean)\r\n> System.Windows.Data.BindingExpressionBase.Invalidate(Boolean)\r\n> System.Windows.Data.BindingExpression.TransferValue(System.Object, Boolean)\r\n> MS.Internal.Data.ClrBindingWorker.NewValueAvailable(Boolean, Boolean, Boolean)\r\n> MS.Internal.Data.PropertyPathWorker.UpdateSourceValueState(Int32, System.ComponentModel.ICollectionView, System.Object, Boolean)\r\n> MS.Internal.Data.PropertyPathWorker.OnDependencyPropertyChanged(System.Windows.DependencyObject, System.Windows.DependencyProperty, Boolean)\r\n> System.Windows.Data.BindingExpression.HandlePropertyInvalidation(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.Data.BindingExpressionBase.OnPropertyInvalidation(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.Data.BindingExpression.OnPropertyInvalidation(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependentList.InvalidateDependents(System.Windows.DependencyObject, System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.NotifyPropertyChange(System.Windows.DependencyPropertyChangedEventArgs)\r\n> System.Windows.DependencyObject.UpdateEffectiveValue(System.Windows.EntryIndex, System.Windows.DependencyProperty, System.Windows.PropertyMetadata, System.Windows.EffectiveValueEntry, System.Windows.EffectiveValueEntry ByRef, Boolean, Boolean, System.Windows.OperationType)\r\n> System.Windows.DependencyObject.SetValueCommon(System.Windows.DependencyProperty, System.Object, System.Windows.PropertyMetadata, Boolean, Boolean, System.Windows.OperationType, Boolean)\r\n> System.Windows.DependencyObject.SetCurrentValueInternal(System.Windows.DependencyProperty, System.Object)\r\n> \r\n> System.Windows.Controls.PopupControlService.**RaiseContextMenuOpeningEvent**(System.Windows.IInputElement, Double, Double, Boolean)\r\n> \r\n> System.Windows.Controls.PopupControlService.ProcessMouseUp(System.Object, System.Windows.Input.MouseButtonEventArgs)\r\n> System.Windows.Controls.PopupControlService.OnPostProcessInput(System.Object, System.Windows.Input.ProcessInputEventArgs)\r\n> System.Windows.Input.InputManager.RaiseProcessInputEventHandlers(System.Windows.Input.ProcessInputEventHandler, System.Windows.Input.ProcessInputEventArgs)\r\n> System.Windows.Input.InputManager.ProcessStagingArea()\r\n> System.Windows.Input.InputManager.ProcessInput(System.Windows.Input.InputEventArgs)\r\n> System.Windows.Input.InputProviderSite.ReportInput(System.Windows.Input.InputReport)\r\n> System.Windows.Interop.HwndMouseInputProvider.ReportInput(IntPtr, System.Windows.Input.InputMode, Int32, System.Windows.Input.RawMouseActions, Int32, Int32, Int32)\r\n> System.Windows.Interop.HwndMouseInputProvider.FilterMessage(IntPtr, MS.Internal.Interop.WindowMessage, IntPtr, IntPtr, Boolean ByRef)\r\n> System.Windows.Interop.HwndSource.InputFilterMessage(IntPtr, Int32, IntPtr, IntPtr, Boolean ByRef)\r\n> ```\r\n> \r\n> To me this looks like an error. The window should not be killed when it is already (partially) active. This call should therefore be moved to the check where BuildWindow is beeing called.\r\n> After setting the AppContext switch\r\n> \r\n> ```\r\n>   <runtime>\r\n>     <AppContextSwitchOverrides value=\"Switch.System.Windows.DoNotScaleForDpiChanges=true\" />\r\n>   </runtime>\r\n> ```\r\n> \r\n> the issue does go away. This has therefore something to do with the monitor scaling flag during Popup.CreateWindow.\r\n","Url":"https://github.com/dotnet/wpf/issues/2088","RelatedDescription":"Open issue \"Context Menus (Popup) are sometimes broken in High-DPI applications in .NET 4.8 \" (#2088)"},{"Id":"510935378","IsPullRequest":true,"CreatedAt":"2019-10-22T21:55:24","Actor":"dotnet-maestro[bot]","Number":"2087","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.4\r\n- **Date Produced**: 10/22/2019 9:17 PM\r\n- **Commit**: e260e163967f49417bc8a6d537ea6fbeb80d8d80\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.4\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2087","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2087)"},{"Id":"510907133","IsPullRequest":true,"CreatedAt":"2019-10-22T21:10:25","Actor":"dotnet-maestro[bot]","Number":"2086","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.3\r\n- **Date Produced**: 10/22/2019 8:39 PM\r\n- **Commit**: f56aec1e41265912770e661a34400725da78d541\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.3\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2086","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2086)"},{"Id":"510870246","IsPullRequest":false,"CreatedAt":"2019-10-22T19:50:31","Actor":"rladuca","Number":"2085","RawContent":null,"Title":"Update XPS Serialization Stack for Packaging/Compression Semantic Changes","State":"open","Body":"In .NET Core 3, WPF changes to use the packaging and compression in Microsoft.NetCore.App instead of carrying WPF specific libraries in WindowsBase.dll.\n\nThis resulted in several compatibility problems with XPS document creation and manipulation.\n\n#575\n#597\n#1063\n#1363\n#1985\nWorkarounds have been generally done for much of these and some of these workarounds are encoded into the product itself.\n\nWPF should be updated in order to work well with the new sematics from System.IO.Packaging and System.IO.Compression. This will require a lot of investigation in several areas:\n\nXPS document creation and serialization\nPrinting\nGeneral package usage\nCreating this as an epic for now. Once more investigation is done into the scope for these changes, we can add specific tasks.","Url":"https://github.com/dotnet/wpf/issues/2085","RelatedDescription":"Open issue \"Update XPS Serialization Stack for Packaging/Compression Semantic Changes\" (#2085)"}],"ResultType":"GitHubIssue"}},"RunOn":"2019-10-25T05:31:00.343211Z","RunDurationInMilliseconds":813}