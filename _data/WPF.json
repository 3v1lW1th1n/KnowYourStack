{"Data":{"GitHub":{"Issues":[{"Id":"512750277","IsPullRequest":true,"CreatedAt":"2019-10-25T22:52:32","Actor":"dotnet-maestro-bot","Number":"2121","RawContent":null,"Title":"[automated] Merge branch 'release/3.1' => 'master'","State":"open","Body":"I detected changes in the release/3.1 branch which have not been merged yet to master. I'm a robot and am configured to help you automatically keep master up to date, so I've opened this PR.\r\n\r\nThis PR merges commits made on release/3.1 by the following committers:\n\n* @dotnet-maestro[bot]\n* @wtgodbe\n* @vatsan-madhavan\n* @msftbot[bot]\n* @rladuca\n* @SamBent\n* @mmitche\r\n\r\n## Instructions for merging from UI\r\n\r\nThis PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.\r\n\r\n<img alt=\"merge button instructions\" src=\"https://i.imgur.com/GepcNJV.png\" width=\"300\" />\r\n\r\nIf this repo does not allow creating merge commits from the GitHub UI, use command line instructions.\r\n\r\n## Instructions for merging via command line\r\n\r\nRun these commands to merge this pull request from the command line.\r\n\r\n``` sh\r\ngit fetch\r\ngit checkout release/3.1\r\ngit pull --ff-only\r\ngit checkout master\r\ngit pull --ff-only\r\ngit merge --no-ff release/3.1\r\n\r\n# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge\r\n# Pushing the changes to the PR branch will re-trigger PR validation.\r\ngit push https://github.com/dotnet-maestro-bot/wpf HEAD:merge/release/3.1-to-master\r\n```\r\n\r\n<details>\r\n<summary>or if you are using SSH</summary>\r\n\r\n```\r\ngit push git@github.com:dotnet-maestro-bot/wpf HEAD:merge/release/3.1-to-master\r\n```\r\n\r\n</details>\r\n\r\n\r\nAfter PR checks are complete push the branch\r\n```\r\ngit push\r\n```\r\n\r\n## Instructions for resolving conflicts\r\n\r\n:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].\r\n\r\n[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/\r\n[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/\r\n\r\n## Instructions for updating this pull request\r\n\r\nContributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.1-to-master'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.\r\n\r\n```\r\ngit checkout -b merge/release/3.1-to-master master\r\ngit pull https://github.com/dotnet-maestro-bot/wpf merge/release/3.1-to-master\r\n(make changes)\r\ngit commit -m \"Updated PR with my changes\"\r\ngit push https://github.com/dotnet-maestro-bot/wpf HEAD:merge/release/3.1-to-master\r\n```\r\n\r\n<details>\r\n    <summary>or if you are using SSH</summary>\r\n\r\n```\r\ngit checkout -b merge/release/3.1-to-master master\r\ngit pull git@github.com:dotnet-maestro-bot/wpf merge/release/3.1-to-master\r\n(make changes)\r\ngit commit -m \"Updated PR with my changes\"\r\ngit push git@github.com:dotnet-maestro-bot/wpf HEAD:merge/release/3.1-to-master\r\n```\r\n\r\n</details>\r\n\r\nContact .NET Core Engineering if you have questions or issues.\r\nAlso, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.\r\n","Url":"https://github.com/dotnet/wpf/pull/2121","RelatedDescription":"Open PR \"[automated] Merge branch 'release/3.1' => 'master'\" (#2121)"},{"Id":"512730491","IsPullRequest":false,"CreatedAt":"2019-10-25T21:35:10","Actor":"tanpuresiddhant","Number":"2120","RawContent":null,"Title":"Calendar day binding not working","State":"open","Body":"1. Open VS 2019\r\n2. Create new WPF Core app.\r\n3. Open MainWindow.xaml.\r\n4. Replace Grid element with XAML below..\r\n<Grid>\r\n    <Grid.RowDefinitions>\r\n        <RowDefinition Height=\"44*\"/>\r\n        <RowDefinition Height=\"49*\"/>\r\n        <RowDefinition Height=\"43*\"/>\r\n        <RowDefinition Height=\"298*\"/>\r\n    </Grid.RowDefinitions>\r\n\r\n    <Grid.ColumnDefinitions>\r\n        <ColumnDefinition Width=\"83*\"/>\r\n        <ColumnDefinition Width=\"317*\"/>\r\n    </Grid.ColumnDefinitions>\r\n        <Label Grid.Row=\"0\" Grid.Column=\"0\" x:Name=\"label1\" Content=\"year:\" Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\" />\r\n        <TextBlock Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"textBlock1\" Text=\"{Binding DisplayDate.Year, ElementName=datePicker, Mode=OneWay}\" Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\" />\r\n        <Label Grid.Row=\"1\" Grid.Column=\"0\" x:Name=\"label2\" Content=\"Month:\" Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\"/>\r\n        <TextBlock Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"textBlock2\" Text=\"{Binding DisplayDate.Month, ElementName=datePicker, Mode=OneWay}\" Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\"/>\r\n        <Label Grid.Row=\"2\" Grid.Column=\"0\" x:Name=\"label3\" Content=\"Day:\" Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\" />\r\n        <TextBlock Grid.Row=\"2\" Grid.Column=\"1\" x:Name=\"textBlock3\"  Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\" Text=\"{Binding DisplayDate.Day, ElementName=datePicker, Mode=OneWay}\" />\r\n        <DatePicker Grid.Row=\"3\" Grid.Column=\"1\" x:Name=\"datePicker\" Grid.ColumnSpan=\"2\" Grid.RowSpan=\"4\" Height=\"100\" Width=\"100\"/>\r\n        <Button/>\r\n    </Grid>\r\n6. F5\r\n7. Change date from the calendar to some other date\r\n\r\nActual: Textbox \"textBlock3\" text doesn't update to new date \r\nExpected: Textbox \"textBlock3\" text updates to new date \r\n","Url":"https://github.com/dotnet/wpf/issues/2120","RelatedDescription":"Open issue \"Calendar day binding not working\" (#2120)"},{"Id":"512700266","IsPullRequest":false,"CreatedAt":"2019-10-25T20:15:07","Actor":"GitHubUser30","Number":"2119","RawContent":null,"Title":"VisualDiagnostics.GetXamlSourceInfo returns null for nested templates","State":"open","Body":"1. Open VS 2019\r\n2. Create new WPF Core app.\r\n3. Open MainWindow.xaml.\r\n4. Replace Grid element with XAML below.\r\n5. Make sure your config is Debug x86.\r\n6. F5\r\n7. Go to Debug > Windows > Live Visual Tree. Make sure Just My XAML is turned off (it exists and is on by default for VS 16.4). Search for Abc.\r\n**Actual**: elements from \"inner\" template donâ€™t have Go to Source icon\r\n**Expected**: elements from \"inner\" template have Go to Source icon\r\n\r\n![InnerElementsNoSource](https://user-images.githubusercontent.com/48451158/67601506-644d0600-f729-11e9-8cba-5095fb5b1c14.png)\r\n\r\n    <StackPanel>\r\n    <Button Width=\"200\" Height=\"50\" Margin=\"20\">\r\n      <Button.Template>\r\n        <ControlTemplate TargetType=\"Button\">\r\n          <ListBox Name=\"InnerListBoxAbc\">\r\n            <ListBox.ItemTemplate>\r\n              <DataTemplate>\r\n                <Grid x:Name=\"InnerRootAbc\">\r\n                  <TextBlock x:Name=\"InnerTextAbc\" Text=\"No source info\" Width=\"150\" Height=\"30\"/>\r\n                </Grid>\r\n              </DataTemplate>\r\n            </ListBox.ItemTemplate>\r\n            <ListBox.Items>\r\n              <ColumnDefinition/>\r\n            </ListBox.Items>\r\n          </ListBox>\r\n        </ControlTemplate>\r\n      </Button.Template>\r\n    </Button>\r\n\r\n    <ListBox Name=\"OuterListBoxAbc\" Width=\"200\" Height=\"50\" Margin=\"20\">\r\n      <ListBox.ItemTemplate>\r\n        <DataTemplate>\r\n          <Grid x:Name=\"OuterRootAbc\">\r\n            <TextBlock x:Name=\"OuterTextAbc\" Text=\"Source info available\" Width=\"150\" Height=\"30\"/>\r\n          </Grid>\r\n        </DataTemplate>\r\n      </ListBox.ItemTemplate>\r\n      <ListBox.Items>\r\n        <ColumnDefinition/>\r\n      </ListBox.Items>\r\n    </ListBox>\r\n  </StackPanel>\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/2119","RelatedDescription":"Open issue \"VisualDiagnostics.GetXamlSourceInfo returns null for nested templates\" (#2119)"},{"Id":"512696323","IsPullRequest":true,"CreatedAt":"2019-10-25T20:05:24","Actor":"dotnet-maestro[bot]","Number":"2118","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191025.6\r\n- **Date Produced**: 10/25/2019 8:53 PM\r\n- **Commit**: 3d60d177a681c4801db0360b6d44f42561972bb4\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha.1.19525.6\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.App** -> 5.0.0-alpha1.19524.4 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Configuration.ConfigurationManager** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Diagnostics.EventLog** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.DirectoryServices** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Drawing.Common** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.Emit** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.MetadataLoadContext** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Security.AccessControl** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Cryptography.Xml** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Permissions** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Principal.Windows** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.Windows.Extensions** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.Platforms** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **System.IO.Packaging** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILDAsm** -> 5.0.0-alpha1.19523.1 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **Microsoft.NETCore.Runtime.CoreCLR** -> 5.0.0-alpha1.19523.1 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILAsm** -> 5.0.0-alpha1.19523.1 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **System.Resources.Extensions** -> 5.0.0-alpha.1.19524.14 (parent: Microsoft.NETCore.App)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2118","RelatedDescription":"Open PR \"[master] Update dependencies from dotnet/winforms\" (#2118)"},{"Id":"511647697","IsPullRequest":true,"CreatedAt":"2019-10-25T17:55:56","Actor":"dotnet-maestro[bot]","Number":"2105","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191023.5\r\n- **Date Produced**: 10/24/2019 6:39 AM\r\n- **Commit**: d890296011263c2fd459a2c4ae63d522d1f651ba\r\n- **Branch**: refs/heads/release/3.1\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.1-preview1.19523.5\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.App** -> 3.1.0-preview2.19523.6 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Configuration.ConfigurationManager** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Diagnostics.EventLog** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.DirectoryServices** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Drawing.Common** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.Emit** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Reflection.MetadataLoadContext** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.AccessControl** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Cryptography.Xml** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Permissions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Security.Principal.Windows** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.Windows.Extensions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.Platforms** -> 3.1.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **System.IO.Packaging** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILDAsm** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **Microsoft.NETCore.Runtime.CoreCLR** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.App)\r\n- **Microsoft.NETCore.ILAsm** -> 3.1.0-preview2.19522.2 (parent: Microsoft.NETCore.Runtime.CoreCLR)\r\n- **System.Resources.Extensions** -> 4.7.0-preview2.19522.18 (parent: Microsoft.NETCore.App)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2105","RelatedDescription":"Closed or merged PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#2105)"},{"Id":"512308522","IsPullRequest":true,"CreatedAt":"2019-10-25T17:50:55","Actor":"vatsan-madhavan","Number":"2113","RawContent":null,"Title":"Update C++ Tools to VS16.3 Preview 4 ","State":"closed","Body":"Fixes #2114 \r\nThere is a matching PR for [dotnet-wpf-int#3879](https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int/pullrequest/3879?_a=overview) that is needed along-with this change. \r\n\r\n## Description \r\n\r\nThis PR updates C++ tools used by WPF to VS 16.3 Preview 4 bits. \r\n\r\nFrom https://github.com/dotnet/wpf/pull/2105, we now know that C++ toolset containing libs that were built targeting 3.0 could not be used to build against 3.1 libs. \r\n\r\nhttps://github.com/dotnet/wpf/pull/2105#issuecomment-545746253\r\n> This was fixed in 16.4P3. It's caused by a mismatch between targeting 3.1 and using libs built against 3.0. Updating the tools should fix it and you should no longer need the private tools. \r\n>\r\n```\r\n##[error]msvcurt_netcore.lib(msilexit.obj)(0,0): error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000f8).\r\nmsvcurt_netcore.lib(msilexit.obj) : error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000fb). [F:\\workspace\\_work\\1\\s\\src\\Microsoft.DotNet.Wpf\\src\\DirectWriteForwarder\\DirectWriteForwarder.vcxproj]\r\n```\r\n\r\nThe toolset in Dev 16.3+ were built against 3.1 libs. \r\n\r\n## Customer Impact \r\n\r\nThis blocks .NET Core 3.1 Preview 2 builds. \r\n\r\n## Risk \r\n\r\n- The risk of toolset change without extensive testing on a release/* branch is **medium to high**.\r\n- Some basic  testing of the bits produced using this toolset suggests that the WPF bits are in good shape. I ran a set of high priority tests and did some ad-hoc tests against samples to validate the bits. \r\n\r\nMy recommendation is to merge this change now into release/3.1 branch to unblock preview builds, and continue with more testing as soon as a full SDK build is available. \r\n\r\n## Regression \r\n\r\nThe root cause for why the compiler team needed to rebuild their tools against 3.1 libs is unclear @tgani-msft mentioned that the compiler team has yet to root-cause it. We should try to understand this further IMO. ","Url":"https://github.com/dotnet/wpf/pull/2113","RelatedDescription":"Closed or merged PR \"Update C++ Tools to VS16.3 Preview 4 \" (#2113)"},{"Id":"512542510","IsPullRequest":false,"CreatedAt":"2019-10-25T14:16:31","Actor":"aguerrieri82","Number":"2117","RawContent":null,"Title":"WPF support to .vcxproj","State":"open","Body":"I would like to recompile (https://github.com/microsoft/WPFDXInterop) to support .net core 3.\r\nI couldn't find any reference or sample explaing how to add WPF support to .vcxproj\r\nI spent half a day looking everywhere with no luck.\r\nI tryed:\r\n```xml\r\n<CLRSupport>NetCore</CLRSupport>\r\n<TargetFramework>netcoreapp3.1</TargetFramework>\r\n<UseWPF>true</UseWPF>\r\n```\r\n","Url":"https://github.com/dotnet/wpf/issues/2117","RelatedDescription":"Open issue \"WPF support to .vcxproj\" (#2117)"},{"Id":"512486775","IsPullRequest":true,"CreatedAt":"2019-10-25T13:04:11","Actor":"dotnet-maestro[bot]","Number":"2116","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Build**: 20191024.4\r\n- **Date Produced**: 10/24/2019 7:08 PM\r\n- **Commit**: fda4d048abbc5a39545974c69b91e1fa65bf202e\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng** -> 5.0.0-alpha.1.19524.4\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2116","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#2116)"},{"Id":"512477725","IsPullRequest":true,"CreatedAt":"2019-10-25T12:54:19","Actor":"dotnet-maestro[bot]","Number":"2115","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191024.2\r\n- **Date Produced**: 10/24/2019 5:42 PM\r\n- **Commit**: da545119ed327334c1d3577afd806c63eda7241c\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19524.2\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19524.2\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19524.2\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19524.2\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19524.2\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2115","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2115)"},{"Id":"511608382","IsPullRequest":true,"CreatedAt":"2019-10-25T05:53:18","Actor":"vatsan-madhavan","Number":"2100","RawContent":null,"Title":"Prevent NULL HWND's from being parented under SystemResources listener windows","State":"closed","Body":"Addresses #2089 \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2100","RelatedDescription":"Closed or merged PR \"Prevent NULL HWND's from being parented under SystemResources listener windows\" (#2100)"},{"Id":"511464037","IsPullRequest":true,"CreatedAt":"2019-10-25T05:45:04","Actor":"vatsan-madhavan","Number":"2097","RawContent":null,"Title":"Context Menus are sometimes not shown in High-DPI applications","State":"closed","Body":"Addresses #2088 \r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2097","RelatedDescription":"Closed or merged PR \"Context Menus are sometimes not shown in High-DPI applications\" (#2097)"},{"Id":"512309282","IsPullRequest":false,"CreatedAt":"2019-10-25T05:23:24","Actor":"vatsan-madhavan","Number":"2114","RawContent":null,"Title":"[release/3.1] Update C++ Tools to VS16.3 Preview 4","State":"open","Body":"From https://github.com/dotnet/wpf/pull/2105, we now know that C++ toolset containing libs that were built targeting 3.0 could not be used to build against 3.1 libs. \r\n\r\nhttps://github.com/dotnet/wpf/pull/2105#issuecomment-545746253\r\n> This was fixed in 16.4P3. It's caused by a mismatch between targeting 3.1 and using libs built against 3.0. Updating the tools should fix it and you should no longer need the private tools. \r\n>\r\n```\r\n##[error]msvcurt_netcore.lib(msilexit.obj)(0,0): error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000f8).\r\nmsvcurt_netcore.lib(msilexit.obj) : error LNK2022: metadata operation failed (80131195) : Custom attributes are not consistent: (0x0c0000fb). [F:\\workspace\\_work\\1\\s\\src\\Microsoft.DotNet.Wpf\\src\\DirectWriteForwarder\\DirectWriteForwarder.vcxproj]\r\n```\r\n\r\nThe toolset in Dev 16.3+ were built against 3.1 libs. \r\n\r\nThe root cause for why the compiler team needed to rebuild their tools against 3.1 libs is unclear @tgani-msft mentioned that the compiler team has yet to root-cause it. We should try to understand this further IMO. ","Url":"https://github.com/dotnet/wpf/issues/2114","RelatedDescription":"Open issue \"[release/3.1] Update C++ Tools to VS16.3 Preview 4\" (#2114)"},{"Id":"511988145","IsPullRequest":false,"CreatedAt":"2019-10-24T22:54:38","Actor":"Symbai","Number":"2110","RawContent":null,"Title":"MissingManifestResourceException with linked resource","State":"closed","Body":"* .NET Core Version: 3.0\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: **No**\r\n\r\n **Problem description:**\r\n\r\nWith a file-linked* resource file, the app crashes on runtime when accessing it. The same app was ported from .NET Framework 4.8 where it worked without any issue. The project has no errors on build.\r\n\r\n* VS right click add existing file, at the bottom on the add button choose \"add as link\" instead.\r\n\r\n \r\n **Actual behavior:** \r\n\r\n```System.Resources.MissingManifestResourceException: 'Could not find the resource \"SchmuhHost.Properties.Resources.resources\" among the resources \"SchmuhClient.g.resources\", \"SchmuhClient.Properties.Resources.resources\" embedded in the assembly \"SchmuhClient\", nor among the resources in any satellite assemblies for the specified culture. Perhaps the resources were embedded with an incorrect name.'```\r\n \r\n **Expected behavior:**\r\n\r\nNo crash\r\n \r\n **Minimal repro:**\r\nHost = project with normal resource file. Create resource string called \"BlaString\" with content \"blabla {0}\"\r\nClient = project that has the host's resource file linked\r\n\r\nIn client's code:\r\n`string.Format(Properties.Resources.BlaString, 12)`\r\n\r\nIn client's project file\r\n```\r\n  <ItemGroup>\r\n    <Compile Include=\"..\\..\\SchmuhHost\\SchmuhHost\\Properties\\Resources.Designer.cs\">\r\n      <Link>Properties\\Resources.Designer.cs</Link>\r\n      <AutoGen>True</AutoGen>\r\n      <DesignTime>True</DesignTime>\r\n      <DependentUpon>Resources.resx</DependentUpon>\r\n    </Compile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <EmbeddedResource Include=\"..\\..\\SchmuhHost\\SchmuhHost\\Properties\\Resources.resx\">\r\n      <Link>Properties\\Resources.resx</Link>\r\n      <Generator>PublicResXFileCodeGenerator</Generator>\r\n      <LastGenOutput>Resources.Designer.cs</LastGenOutput>\r\n      <CustomToolNamespace>SchmuhHost.Properties</CustomToolNamespace>\r\n    </EmbeddedResource>\r\n  </ItemGroup>\r\n```","Url":"https://github.com/dotnet/wpf/issues/2110","RelatedDescription":"Closed issue \"MissingManifestResourceException with linked resource\" (#2110)"},{"Id":"512144946","IsPullRequest":false,"CreatedAt":"2019-10-24T19:46:25","Actor":"vsfeedback","Number":"2112","RawContent":null,"Title":"Compile error with WPF .net Core 3.0 when adding .resx files","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/771961/compile-error-with-wpf-net-core-30-when-adding-res.html)._\n\n---\nVisual Studio 2019 Professional 16.3.3\n\nIf I do **localization** with WPF **.net Framework** and add two files (Resources.resx and Resources.de.resx) it **compiles as expected.**\n\nBut if I do the same in **WPF .net Core 3.0 I get compile errors.**\n\n- Create a WPF .net Core app\n- Add a Resources folder\n- Create a Resources.resx file\n- Set it to public\n- Create a Resources.de.resx file\n- Set it to public\n- Build solution\n\n&gt; Error\t\tCustom tool PublicResXFileCodeGenerator failed to produce an output for input file 'Resources\\Resources.de.resx' but did not log a specific error.\tLocalizationWpfNetCore\tC:\\...\\source\\repos\\LocalizationWpfNetCore\\LocalizationWpfNetCore\\Resources\\Resources.de.resx\t1\t\t\n\nand\n\n&gt; Error\tMSB3086\tTask could not find &quot;al.exe&quot; using the SdkToolsPath &quot;&quot; or the registry key &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Microsoft SDKs\\NETFXSDK\\4.7.2\\WinSDK-NetFx40Tools-x86&quot;. Make sure the SdkToolsPath is set and the tool exists in the correct processor specific location under the SdkToolsPath and that the Microsoft Windows SDK is installed\tLocalizationWpfNetCore\tC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\ MSBuild\\Current\\Bin\\Microsoft.Common.CurrentVersion.targets\t3639\n\nSo why does it work when I choose .net Framework but not with .net Core?\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 10/10/2019, 11:27 AM: \n\nWe have converted this feedback item from idea to problem. This change was done to better reflect the feedback's nature.\n#### Visual Studio Feedback System on 10/11/2019, 01:27 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Olivier Leclerc on 10/19/2019, 08:44 PM: \n\n<p>I have the same two errors using NetStandard.Librairy 2.0.3  </p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/2112","RelatedDescription":"Open issue \"Compile error with WPF .net Core 3.0 when adding .resx files\" (#2112)"},{"Id":"511877623","IsPullRequest":false,"CreatedAt":"2019-10-24T18:45:58","Actor":"topsterde","Number":"2107","RawContent":null,"Title":"WPF element rendering is 20% slower on .NET Core 3.0 than on .NET Framework","State":"closed","Body":"* .NET Core Version: 3.0.0\r\n* Windows version: Windows 10 x64\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n\r\n **Problem description:**\r\n\r\nThe attached demo runs on the .NET Framework five seconds and needs 230 MB memory.\r\nThe .NET Core 3.0 version is 1 second slower and need 15 MB more memory.\r\n\r\nThis issue is not related to: https://github.com/dotnet/wpf/issues/94\r\n\r\n  **Actual behavior:** \r\nSlower perfomance and more memory consumption than .NET Framework \r\n\r\n **Expected behavior:**\r\n Better performance and less memory consumption with .NET Core 3.0\r\n\r\n\r\n **Minimal repro:**\r\n\r\n[PerformanceWpfCoreVsFramework.zip](https://github.com/dotnet/wpf/files/3767160/PerformanceWpfCoreVsFramework.zip)","Url":"https://github.com/dotnet/wpf/issues/2107","RelatedDescription":"Closed issue \"WPF element rendering is 20% slower on .NET Core 3.0 than on .NET Framework\" (#2107)"},{"Id":"512089618","IsPullRequest":true,"CreatedAt":"2019-10-24T18:19:39","Actor":"mmitche","Number":"2111","RawContent":null,"Title":"Switch to label.N form for pre-release label","State":"closed","Body":"In order to facilitate better preview sorting, switch to label.N form for the pre-release label.","Url":"https://github.com/dotnet/wpf/pull/2111","RelatedDescription":"Closed or merged PR \"Switch to label.N form for pre-release label\" (#2111)"},{"Id":"511909721","IsPullRequest":true,"CreatedAt":"2019-10-24T13:40:02","Actor":"dotnet-maestro[bot]","Number":"2109","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Build**: 20191023.12\r\n- **Date Produced**: 10/24/2019 1:19 AM\r\n- **Commit**: d42863533a66446a600856846e5af32e45cd7216\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng** -> 5.0.0-alpha1.19523.12\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2109","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#2109)"},{"Id":"511899263","IsPullRequest":true,"CreatedAt":"2019-10-24T12:33:36","Actor":"dotnet-maestro[bot]","Number":"2108","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191023.3\r\n- **Date Produced**: 10/23/2019 4:10 PM\r\n- **Commit**: 894bd005267af53f7d39ac988881e61193e67ae1\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19523.3\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19523.3\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2108","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2108)"},{"Id":"511810011","IsPullRequest":false,"CreatedAt":"2019-10-24T09:07:20","Actor":"pieterphilippaerts","Number":"2106","RawContent":null,"Title":"Printing XPS files fails on Windows 8.1","State":"open","Body":"Hi everyone,\r\n\r\nI'm using .NET Core 3 to print XPS files. The code I have is simple and working perfectly on Windows 7 and Windows 10, but it fails on Windows 8.1 (multiple machines, both 32-bit and 64-bit).\r\n\r\nI've tried a number of different variations of the printing code, but here's a simple example:\r\n\r\n```\r\nvar pd = new PrintDialog();\r\nif (pd.ShowDialog() == true) {\r\n    var tdoc = new XpsDocument(@\"<SOMEPATH>\\temp.xps\", FileAccess.ReadWrite);\r\n    pd.PrintDocument(tdoc.GetFixedDocumentSequence().DocumentPaginator, \"temp.xps\");\r\n}\r\n```\r\n\r\nThis code works perfectly on Windows 7 and Windows 10, but on Window 8.1 I always get the following exception: \r\n\r\n> System.IO.IOException: Cannot retrieve parts of writeonly container\r\n>    at System.IO.Packaging.Package.ThrowIfWriteOnly()\r\n>    at System.IO.Packaging.Package.GetRelationshipsByType(String relationshipType)\r\n>    at System.Windows.Xps.Packaging.XpsManager.GetXpsDocumentStartingPart(Package package)\r\n>    at System.Windows.Xps.Packaging.XpsDocument.AddFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsPackagingPolicy.AcquireXmlWriterForFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.AcquireXmlWriter(Type writerType)\r\n>    at System.Windows.Xps.Serialization.DocumentSequenceSerializer.get_XmlWriter()\r\n>    at System.Windows.Xps.Serialization.DocumentSequenceSerializer.PersistObjectData(SerializableObjectContext serializableObjectContext)\r\n>    at System.Windows.Xps.Serialization.ReachSerializer.SerializeObject(Object serializedObject)\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.SaveAsXaml(Object serializedObject)\r\n>    at System.Windows.Xps.XpsDocumentWriter.SaveAsXaml(Object serializedObject, Boolean isSync)\r\n>    at System.Windows.Xps.XpsDocumentWriter.Write(DocumentPaginator documentPaginator, PrintTicket printTicket)\r\n>    at System.Windows.Controls.PrintDialog.PrintDocument(DocumentPaginator documentPaginator, String description)\r\n\r\nI don't see any problems with the code, and the exact same code is actually working on Windows 8.1 if I use it in the full .NET Framework!! So this looks like a bug in .NET Core 3 (specifically on Windows 8.1).\r\n\r\nAlso note that I've really tried _many_ variations of the printing code (including PrintDialog.PrintVisual, PrintQueue.AddJob, XpsDocumentWriter.Write, XpsDocumentWriter.WriteAsync, creating the XpsDocument in memory instead of from a file, ...), but none of them worked on Windows 8.1 and I always get similar exceptions, for example: \r\n\r\n> System.IO.IOException: Cannot retrieve parts of writeonly container\r\n>    at System.IO.Packaging.Package.ThrowIfWriteOnly()\r\n>    at System.IO.Packaging.Package.GetRelationshipsByType(String relationshipType)\r\n>    at System.Windows.Xps.Packaging.XpsManager.GetXpsDocumentStartingPart(Package package)\r\n>    at System.Windows.Xps.Packaging.XpsDocument.AddFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsPackagingPolicy.AcquireXmlWriterForFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.AcquireXmlWriter(Type writerType)\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.SimulateBeginFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.BeginConfirmToXPSStructure(Boolean mode)\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.SaveAsXaml(Object serializedObject)\r\n>    at System.Windows.Xps.XpsDocumentWriter.SaveAsXaml(Object serializedObject, Boolean isSync)\r\n>    at System.Windows.Xps.XpsDocumentWriter.Write(Visual visual, PrintTicket printTicket)\r\n>    at System.Windows.Controls.PrintDialog.PrintVisual(Visual visual, String description)\r\n\r\nThis issue seems to be related to issue 597 (https://github.com/dotnet/wpf/issues/597). this appears to be the exact same problem, however issue 597 was closed and marked as fixed. \r\nIf I execute the exact same code as the author of issue 597 (i.e. \"PrintQueue.CreateXpsDocumentWriter(LocalPrintServer.GetDefaultPrintQueue()).Write(visual);\"), I get the exact exception he got:\r\n\r\n> System.IO.IOException: Cannot retrieve parts of writeonly container\r\n>    at System.IO.Packaging.Package.ThrowIfWriteOnly()\r\n>    at System.IO.Packaging.Package.GetRelationshipsByType(String relationshipType)\r\n>    at System.Windows.Xps.Packaging.XpsManager.GetXpsDocumentStartingPart(Package package)\r\n>    at System.Windows.Xps.Packaging.XpsDocument.AddFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsPackagingPolicy.AcquireXmlWriterForFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.AcquireXmlWriter(Type writerType)\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.SimulateBeginFixedDocumentSequence()\r\n>    at System.Windows.Xps.Serialization.ReachHierarchySimulator.BeginConfirmToXPSStructure(Boolean mode)\r\n>    at System.Windows.Xps.Serialization.XpsSerializationManager.SaveAsXaml(Object serializedObject)\r\n>    at System.Windows.Xps.XpsDocumentWriter.SaveAsXaml(Object serializedObject, Boolean isSync)\r\n>    at System.Windows.Xps.XpsDocumentWriter.Write(Visual visual)\r\n\r\nIs it possible that the fix for issue 597 isn't working on Windows 8.1 for some reason?\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/2106","RelatedDescription":"Open issue \"Printing XPS files fails on Windows 8.1\" (#2106)"},{"Id":"511643114","IsPullRequest":true,"CreatedAt":"2019-10-24T01:05:25","Actor":"dotnet-maestro[bot]","Number":"2104","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191023.2\r\n- **Date Produced**: 10/24/2019 12:38 AM\r\n- **Commit**: fb02fe818f8b410259776e4fa6ca0c5cdd43e07c\r\n- **Branch**: refs/heads/release/3.1\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 4.8.1-preview1.19523.2\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2104","RelatedDescription":"Closed or merged PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#2104)"},{"Id":"511629257","IsPullRequest":true,"CreatedAt":"2019-10-23T23:52:51","Actor":"rladuca","Number":"2103","RawContent":null,"Title":"[Release/3.1] Hit testing by geometry fails if more than one matrix trasformation is applied to a geometry.","State":"open","Body":"On behalf of @Simon-IT :\r\n\r\nThis is related to my issue 642. In the hit testing by geometry algotithm, the order in which the transformations are crosses is wrong. In the issue 642 there is a project to test in very simple manner the problem.\r\n\r\n3.1 port related to https://github.com/dotnet/wpf/pull/1761","Url":"https://github.com/dotnet/wpf/pull/2103","RelatedDescription":"Open PR \"[Release/3.1] Hit testing by geometry fails if more than one matrix trasformation is applied to a geometry.\" (#2103)"},{"Id":"511613394","IsPullRequest":true,"CreatedAt":"2019-10-23T22:55:34","Actor":"vatsan-madhavan","Number":"2102","RawContent":null,"Title":"[release/3.0] Prevent NULL HWND's from being parented under SystemResources listener windows","State":"open","Body":"Addresses #2089 \r\n.NET 5 PR: #2100 \r\n.NET Core 3.1 PR: #2101 \r\n\r\n## Description (Summary)\r\n\r\nWhen `HwndHost` hosted `HWND`'s need to be \"parked\" while the `HwndHost` is not being actively shown, WPF will reparent such `HWND`'s under temporary message-only windows maintained inside the `SystemResources` class. \r\n\r\nThere is a bug that causes null `HWND`'s to be parented under such message-only windows. When this happens in High-DPI applications that use mixed-mode DPI capabilities introduced by WPF in .NET 4.8 (parent and child windows with different `DPI_AWARENESS_CONTEXT `values),  a crash ensues. \r\n\r\n## Customer Impact \r\n\r\nThis is a fix for a crash affecting several applications including Visual Studio, and Azure Information Protection Add-in for Office \r\n\r\nThis was fixed recently in .NET 4.8, and is being forwarded ported to .NET Core for consistency. \r\n\r\n## Regresssion \r\n\r\nNot a regression in .NET Core, but this was a regression introduced by .NET 4.8. \r\n\r\n## Risk \r\n\r\nThe fix is small and well understood, and has been tested well. The .NET Framework version of this fix has been validated by Visual Studio (the codebases are identical in this area and .NET Framework testing is a reliable proxy for this change in .NET Core). \r\n\r\n## Details \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2102","RelatedDescription":"Open PR \"[release/3.0] Prevent NULL HWND's from being parented under SystemResources listener windows\" (#2102)"},{"Id":"511612931","IsPullRequest":true,"CreatedAt":"2019-10-23T22:54:12","Actor":"vatsan-madhavan","Number":"2101","RawContent":null,"Title":"[release/3.1] Prevent NULL HWND's from being parented under SystemResources listener windows ","State":"open","Body":"Addresses #2089 \r\n.NET 5 PR: #2100 \r\n\r\n## Description (Summary)\r\n\r\nWhen `HwndHost` hosted `HWND`'s need to be \"parked\" while the `HwndHost` is not being actively shown, WPF will reparent such `HWND`'s under temporary message-only windows maintained inside the `SystemResources` class. \r\n\r\nThere is a bug that causes null `HWND`'s to be parented under such message-only windows. When this happens in High-DPI applications that use mixed-mode DPI capabilities introduced by WPF in .NET 4.8 (parent and child windows with different `DPI_AWARENESS_CONTEXT `values),  a crash ensues. \r\n\r\n## Customer Impact \r\n\r\nThis is a fix for a crash affecting several applications including Visual Studio, and Azure Information Protection Add-in for Office \r\n\r\nThis was fixed recently in .NET 4.8, and is being forwarded ported to .NET Core for consistency. \r\n\r\n## Regresssion \r\n\r\nNot a regression in .NET Core, but this was a regression introduced by .NET 4.8. \r\n\r\n## Risk \r\n\r\nThe fix is small and well understood, and has been tested well. The .NET Framework version of this fix has been validated by Visual Studio (the codebases are identical in this area and .NET Framework testing is a reliable proxy for this change in .NET Core). \r\n\r\n## Details \r\n\r\nWhen an `HwndHost `receives `SourceChanged `event, it goes through `BuildOrReparentWindow`. When the hosted window is invisible, it is usually reparented under a temporary windows maintained by WPF in the `SystemResources `class, until later on the window can be rebuilt and parented back to a valid parent.\r\n\r\nThere is a latent bug in this logic where in `NULL ` `HWND's `are attempted to be parented to `SystemResources `managed temporary windows. This bug goes back quite a while (.NET 4.5 likely). WPF seems to ignore the return value from `kernel32!SetParent` and not deal with this failure. This has not been a crashing failure until now.\r\n\r\nStarting .NET 4.8, there have been some changes to this codepath that has resulted in the current bug becoming a crash. In addition to calling `kernel32!SetParent` on a `NULL` `HWND`, WPF attempts to obtain a DPI-specific parking-window. This process of querying a DPI-specific parking window fails because WPF is unable to use the `DPI_AWARENESS_CONTEXT` value returned by the system for `(HWND)nullptr`.\r\n\r\nThe only necessary part of this fix is in `HwndHost`: WPF should not attempt to reparent the hosted window under a parking-window if the hosted window is `(HWND)nullptr`. This only requires a simple check : `else if (_hwnd.Handle != IntPtr.Zero)`). All other changes in `SystemResources` and `HwndHost` are defensive improvements.\r\n\r\n`SystemResources.EnsureResourceChangeListener(HwndDpiInfo)` can attempt to create a parking-window corresponding to `DPI_AWARENESS_CONTEXT_VALUE` that is invalid/meaningless. This should not be allowed. A few additional checks are added to ensure this. Further, `GetDpiAwarenessCompatibleNotificationWindow` is augmented to be more defensive.\r\n\r\nAlso, variant of `EnsureResourceChangeListener`  is dead code - it is being removed.\r\n\r\nIf for some unknown reason `SystemResources.GetDpiAwarenessCompatibleNotificationWindow`  fails and returns `null` to `HwndHost.BuildOrReparentWindow`, WPF will fail to reparent the hosted window, and it will be 'lost'. This seems very unlikely - I have added a Trace to ensure that we can debug this situation if it does occur.","Url":"https://github.com/dotnet/wpf/pull/2101","RelatedDescription":"Open PR \"[release/3.1] Prevent NULL HWND's from being parented under SystemResources listener windows \" (#2101)"},{"Id":"511600847","IsPullRequest":true,"CreatedAt":"2019-10-23T22:17:59","Actor":"vatsan-madhavan","Number":"2099","RawContent":null,"Title":"[release/3.0] Context Menus are sometimes not shown in High-DPI applications ","State":"open","Body":"Addresses #2088 \r\n.NET 5 PR: #2097 \r\n.NET Core 3.1 PR: #2098 \r\n\r\n## Description (Summary)\r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nThis previous fix depended upon a private helper-method (`Popup.DestroyWindow`) that had side-effects that were not accounted for in the original fix. One of the side effects is that the `ContextMenu` is not sown consistently. \r\n\r\nThe solution modifies (refactors) the private method to extract the useful portion and uses it to improve the previous fix. \r\n\r\n## Customer Impact\r\n\r\nThis is a forward-port from from .NET 4.8. This was reported by a customer, and has also been discovered by Visual Studio internally. \r\n\r\n## Regression \r\n\r\nRegression introduced by .NET 4.8. .NET Core 3.0 shipped with this bug. \r\n\r\n## Risk \r\n\r\nLow - this has been well tested internally and validated by multiple customers. The fix is well understood and small/scoped. \r\n\r\n## Details \r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2099","RelatedDescription":"Open PR \"[release/3.0] Context Menus are sometimes not shown in High-DPI applications \" (#2099)"},{"Id":"511600421","IsPullRequest":true,"CreatedAt":"2019-10-23T22:16:54","Actor":"vatsan-madhavan","Number":"2098","RawContent":null,"Title":"[release/3.1] Context Menus are sometimes not shown in High-DPI applications","State":"open","Body":"Addresses #2088 \r\n.NET 5 PR: #2097 \r\n\r\n## Description (Summary)\r\n\r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nThis previous fix depended upon a private helper-method (`Popup.DestroyWindow`) that had side-effects that were not accounted for in the original fix. One of the side effects is that the `ContextMenu` is not sown consistently. \r\n\r\nThe solution modifies (refactors) the private method to extract the useful portion and uses it to improve the previous fix. \r\n\r\n## Customer Impact\r\n\r\nThis is a forward-port from from .NET 4.8. This was reported by a customer, and has also been discovered by Visual Studio internally. \r\n\r\n## Regression \r\n\r\nRegression introduced by .NET 4.8. .NET Core 3.0 shipped with this bug. \r\n\r\n## Risk \r\n\r\nLow - this has been well tested internally and validated by multiple customers. The fix is well understood and small/scoped. \r\n\r\n## Details \r\nAs part of a previous fix (that shipped originally as part of .NET 4.8 in), a change was made to `Popup` that involved the destruction and recreation of the underlying `HWND`. This was done to ensure that the `HWND` was always created with the correct monitor (~=DPI) affinity.\r\n\r\nIn order to acheive this, `DestroyWindow()` and `BuildWindow()` - private methods in `Popup` - were used.\r\n\r\nWe are finding that `DestroyWindow()` has side-effects that can lead to incorrect behavior. The incorrect beahvior works as follows:\r\n\r\n  - The call into `Popup.CreateWindow` is usually a consequence `Popup.IsOpenChanged` (`false -> true`)\r\n  - Within `Popup.CreateWindow`, `DestroyWindow()` is called (when high-dpi mode is detected).\r\n  - `DestroyWindow()` destroys the underlying `HWND`, releases the capture, raises the *OnClosed* event and clears the placement-target.\r\n    - At the end of `DestroyWindow()`, we get `IsOpen == false`.\r\n  - After `DestroyWindow()`, we call into `BuildWindow()` and `CreateNewPopupRoot()` etc., which go on to build the `Popup` again (and also instnatiate a new `HWND`).\r\n    - Unfortunately, there is no mechanism here for resetting `IsOpen` back to `true` (without also leading to an undesirable infinite-recursion that calls back into `CreateWindow`).\r\n\r\nIf these calls to show the context-menu arise from `ContextMenu.OnIsOpenChanged`, and flow through `ContextMenu.HookupParentPopup -> Popup.CreateRootPopup`, then `IsOpen` gets reset (there is a direct call into `SetBinding(IsOpenProperty)`, in `Popup.CreateRootPopupInternal`) and the popup is shown correctly. Until then, the context-menu is \"stuck\" not being able to be shown.\r\n\r\nThe solution is to stop using `DestroyWindow()` as-is, which does more than what we need for it to accomplish. Our original intent in calling `DestroyWindow()` was simply destroy and recreate the `HWND`. This fix refactors `DestroyWindow()` to suit this need and uses the newly introduced `DestroyWindowImpl()` to destroy the `HWND`, and then recreate just that. The rest of the state is retained intact, and the `Popup/ContextMenu` continues to function well as before.","Url":"https://github.com/dotnet/wpf/pull/2098","RelatedDescription":"Open PR \"[release/3.1] Context Menus are sometimes not shown in High-DPI applications\" (#2098)"},{"Id":"511276661","IsPullRequest":true,"CreatedAt":"2019-10-23T13:13:37","Actor":"dotnet-maestro[bot]","Number":"2095","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Build**: 20191022.8\r\n- **Date Produced**: 10/22/2019 10:28 PM\r\n- **Commit**: b809e63d8ef475faaf6fecbe8bf77180f8e3550c\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.Arcade.Sdk** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.CodeAnalysis** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.GenAPI** -> 5.0.0-beta.19522.8\r\n  - **Microsoft.DotNet.Helix.Sdk** -> 5.0.0-beta.19522.8\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2095","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#2095)"},{"Id":"511279817","IsPullRequest":false,"CreatedAt":"2019-10-23T12:09:51","Actor":"DarkIrata","Number":"2096","RawContent":null,"Title":"Adding a SpinEdit / NumericUpDown Control to WPF","State":"open","Body":"The NumericUpDown control is available in WinForms, and also should be in WPF. Especially since it is much easier to make custom styles for controls in WPF. \r\nIt is annoying to rebuild that control everytime you need it and can't reuse older code. Sure there are ready to use libraries like MahApps, but it should never be a requirement for basic controls to add a dependency. Even worse when you use style libraries like MaterialDesignInXaml which restyle many basic controls. (Yes, i know that an self-made problem) \r\n\r\nI am suprised that there is no request issue open for this.\r\nBut yeah, would be happy to get that control. ","Url":"https://github.com/dotnet/wpf/issues/2096","RelatedDescription":"Open issue \"Adding a SpinEdit / NumericUpDown Control to WPF\" (#2096)"},{"Id":"511088306","IsPullRequest":true,"CreatedAt":"2019-10-23T05:55:23","Actor":"dotnet-maestro[bot]","Number":"2094","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.10\r\n- **Date Produced**: 10/23/2019 5:26 AM\r\n- **Commit**: b34582761bea089eb0d19aba8e43c4b90d90c98e\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.10\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2094","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2094)"},{"Id":"511020760","IsPullRequest":true,"CreatedAt":"2019-10-23T02:05:28","Actor":"dotnet-maestro[bot]","Number":"2093","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Build**: 20191022.7\r\n- **Date Produced**: 10/23/2019 1:15 AM\r\n- **Commit**: 4f9ddf34914d9b014fde363b8cc37f2a590b03b9\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms** -> 5.0.0-alpha1.19522.7\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/2093","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#2093)"},{"Id":"510986717","IsPullRequest":true,"CreatedAt":"2019-10-22T23:36:35","Actor":"arpitmathur","Number":"2092","RawContent":null,"Title":"Adding border to ToggleButton when checked in high-contrast themes","State":"open","Body":"Fixes #1458\r\n\r\n5.0 PR: https://github.com/dotnet/wpf/pull/1976\r\n\r\n# Description\r\n\r\nIn non-high contrast themes, when you check a ToggleButton and navigate to another control, we display the checked status by highlighting the button with a lighter shade of the selection color.\r\n\r\nWe don't follow this behavior in high contrast themes. The text is slightly-depressed upon checking but that is not visually apparent . When the ToggleButton does not have focus, there is a slight border which again, is not apparent.\r\n![highcontrastwhitetogglebutton_without_change](https://user-images.githubusercontent.com/5456126/65924723-e6ecda80-e3a2-11e9-860d-66c72212c0e0.png)\r\n\r\nIn the image above, the 'S', 'C' and 'I' buttons are checked. However, it's barely noticeable that 'S' and 'C' are checked. The checked status of the 'I' button is also not noticeable when it receives focus.\r\n\r\n\r\nThe fix here is to check for a toggle button to be checked when in a high-contrast theme, we then add a border around the button. When a checked button also has keyboard focus, we add a border in the background-color. When the user navigates away, the border color is the same as the selection-color.\r\n\r\nIn the image below, the 'S', 'C' and 'I' buttons are checked again. Here, it's visually apparent that they are all currently checked.\r\n![highcontrastwhitetogglebutton_with_change](https://user-images.githubusercontent.com/5456126/65924964-c709e680-e3a3-11e9-8eab-fd1016e4c3b3.png)\r\n\r\nIn this pull request, relevant changes are in lines 673:693 in Button.xaml, the remaining files are generated off those changes.\r\n# Customer Impact\r\n\r\nIn high contrast themes, when you check a ToggleButton, it is not visually apparent that the ToggleButton has been checked, both when the ToggleButton has keyboard focus and when it does not.\r\n# Regression\r\nNo. This was discovered during accessibility testing on .Net Core 3.0\r\n\r\n# Risk - Low\r\nThis change only affects the ToggleButton control when HighContrast mode is turned on. The change has been tested well internally.","Url":"https://github.com/dotnet/wpf/pull/2092","RelatedDescription":"Open PR \"Adding border to ToggleButton when checked in high-contrast themes\" (#2092)"}],"ResultType":"GitHubIssue"}},"RunOn":"2019-10-26T05:30:53.2678682Z","RunDurationInMilliseconds":783}