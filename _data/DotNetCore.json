{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018","PublishedOn":"2017-10-23T16:41:13+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"This post was written by Varun Venkatesan, Li Tian, and Juan Rodriguez, engineers at Intel. They are excited to share .NET Core-specific enhancements that Intel has made to VTune Amplifier 2018. We&#8217;re excited to have a new tool to use to help make .NET Core faster on Intel chips. Intel has been a strong partner in the development... <a aria-label=\"read more about .NET Core Performance Profiling with Intel® VTune™ Amplifier 2018\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/","RawContent":null},{"Title":"Experiment with Azure for FREE!","PublishedOn":"2017-10-19T14:00:11+00:00","CommentsCount":35,"FacebookCount":0,"Summary":"What is Azure? What can it do for me? Do I need it? How do I find out? How do I use it? Will it help my business? Can it help my career? With all the things Azure can do, it&#8217;s hard to know where to start answering these important questions. But there&#8217;s a really... <a aria-label=\"read more about Experiment with Azure for FREE!\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/","RawContent":null},{"Title":"Announcing the .NET Framework 4.7.1","PublishedOn":"2017-10-17T21:26:30+00:00","CommentsCount":29,"FacebookCount":0,"Summary":"Today, we are announcing the release of the .NET Framework 4.7.1. It’s included in the Windows 10 Fall Creators Update. .NET Framework 4.7.1 is also available on Windows 7+ and Windows Server 2008 R2+.  We’ve added support for targeting the .NET Framework 4.7.1 in Visual Studio 2017 15.5. The .NET Framework 4.7.1 includes improvements in several areas: Accessibility improvements... <a aria-label=\"read more about Announcing the .NET Framework 4.7.1\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/","RawContent":null},{"Title":".NET Framework October 2017 Preview of Quality Rollup","PublishedOn":"2017-10-17T20:56:56+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Preview of Quality Rollup. This type of rollup is intended for businesses that want to the preview or use quality improvements as soon as they are available. Quality and Reliability This release contains the following quality and reliability improvements. CLR Code optimization bug for x64 C# code targeting... <a aria-label=\"read more about .NET Framework October 2017 Preview of Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/","RawContent":null},{"Title":"RyuJIT Just-in-Time Compiler Optimization Enhancements","PublishedOn":"2017-10-17T05:16:50+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"I&#8217;d like to tell you about some of the recent changes we&#8217;ve made as part of our ongoing work to extend the optimization capabilities of RyuJIT, the MSIL-to-native code generator used by .NET Core and .NET Framework. I hope it will make for an interesting read, and offer some insight into the sorts of optimization opportunities we have... <a aria-label=\"read more about RyuJIT Just-in-Time Compiler Optimization Enhancements\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/","RawContent":null},{"Title":".NET Framework October 2017 Security and Quality Rollup","PublishedOn":"2017-10-11T06:02:21+00:00","CommentsCount":16,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Security and Quality Rollup. The update applies to all supported Windows versions. It includes a known issue for Windows 10 1507 (see below). Security This release contains no new security updates. Quality and Reliability This release contains the following quality and reliability improvements. WPF WPF fails to load... <a aria-label=\"read more about .NET Framework October 2017 Security and Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/net-framework-october-2017-security-and-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/net-framework-october-2017-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing UWP Support for .NET Standard 2.0","PublishedOn":"2017-10-10T22:57:46+00:00","CommentsCount":104,"FacebookCount":0,"Summary":"This post was mostly written by Rich Lander with contributions from Immo Landwerth. Today, we are releasing huge updates to UWP for .NET developers. The really big improvement is adding support for .NET Standard 2.0. UWP developers now have access to ~ 20k more APIs. This release brings UWP to partity with the other .NET implementations... <a aria-label=\"read more about Announcing UWP Support for .NET Standard 2.0\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/announcing-uwp-support-for-net-standard-2-0/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/10/announcing-uwp-support-for-net-standard-2-0/","RawContent":null},{"Title":".NET Framework 4.7.1 Runtime and Compiler Features","PublishedOn":"2017-09-28T23:56:59+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"This post describes the new Runtime, Compiler and Base Class Library (BCL) improvements in the .NET Framework 4.7.1. You can try out these features by downloading the Developer Pack, described in the Welcome to the .NET Framework 4.7.1 Early Access blog post.  BCL &#8211; .NET Standard 2.0 Support .NET Framework 4.7.1 has built-in support for .NET Standard 2.0. .NET Framework 4.7.1... <a aria-label=\"read more about .NET Framework 4.7.1 Runtime and Compiler Features\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/28/net-framework-4-7-1-runtime-and-compiler-features/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/28/net-framework-4-7-1-runtime-and-compiler-features/","RawContent":null},{"Title":"Build a web service with F# and .NET Core 2.0","PublishedOn":"2017-09-26T16:39:23+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Earlier this year, I wrote about an update to the roadmap for F# and .NET Core. I had mentioned that there were a number of things you could build with F# and .NET Core today, such as web services. In this post, I&#8217;ll walk through building a web service with F# and .NET Core 2.0... <a aria-label=\"read more about Build a web service with F# and .NET Core 2.0\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/","RawContent":null},{"Title":".NET Framework September 2017 Preview of Quality Rollup","PublishedOn":"2017-09-25T19:57:18+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are releasing the September 2017 Preview of Quality Rollup. This type of rollup is intended for businesses that want to the preview or use quality improvements as soon as they are available. This update applies to Windows 10 Update 1607 (Anniversary Update) and to Windows Server 2016. FYI: The KBs for Windows Server 2016... <a aria-label=\"read more about .NET Framework September 2017 Preview of Quality Rollup\" href=\"https://blogs.msdn.microsoft.com/dotnet/2017/09/25/net-framework-september-2017-preview-of-quality-rollup/\" class=\"read-more\">Read more</a>","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/09/25/net-framework-september-2017-preview-of-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6650451504","Type":"IssuesEvent","CreatedAt":"2017-09-28T16:22:10","Actor":"hughbe","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/87","RelatedDescription":"Opened issue \"PRs to repos outside of dotnet/* pattern should not always thank for signing the CLA\" (#87) at dotnet/home","RelatedBody":"For example: https://github.com/mono/libgdiplus/pull/109\r\n\r\nI have already signed the CLI. On the dotnet/corefx etc. projects, I don't get the extra message:\r\n\r\n```\r\n@hughbe,\r\nThanks for having already signed the Contribution License Agreement. Your agreement was validated by .NET Foundation. We will now review your pull request.\r\nThanks,\r\n.NET Foundation Pull Request Bot\r\n```\r\n\r\nJust a small gripe, as I get an email each time I do this. I've seen this in Mono and Xunit.\r\n\r\n/cc @karelz I know this is unrelated to corefx but maybe you know the right person/repo to route this to :D\r\n"},{"Id":"6515896963","Type":"PullRequestEvent","CreatedAt":"2017-08-26T22:20:18","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/85","RelatedDescription":"Merged pull request \"Create telerik-ui-for-uwp.md\" (#85) at dotnet/home","RelatedBody":"Submission of Telerik UI for UWP"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6761784781","Type":"IssuesEvent","CreatedAt":"2017-10-25T04:03:38","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/35","RelatedDescription":"Opened issue \"microsoft/dotnet-framework latest tag updated to 4.7.1\" (#35) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework latest tag updated to 4.7.1\r\n\r\nThe [.NET Framework 4.7.1](https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/) was released earlier this month. The [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework) `latest` [tag](https://hub.docker.com/r/microsoft/dotnet-framework/tags/) was also updated.\r\n\r\nThe .NET Framework 4.7.1 is represented by the `microsoft/dotnet-framework:4.7.1` tag.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #33](https://github.com/Microsoft/dotnet-framework-docker/issues/33)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #28](https://github.com/Microsoft/dotnet-framework-docker/pull/28)\r\n* [microsoft/dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework 4.7.1 image is now available as a Docker image. The `latest` tag points to the same image.\r\n\r\nThe following repos were updated:\r\n\r\n* [microsoft/asp](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\nThe [microsoft/dotnet-framework-samples](https://hub.docker.com/r/microsoft/dotnet-framework-samples) repo has not yet been updated.\r\n\r\nWe recommend that you use version-specific tags for production apps. For experimentation or while an application is in development, using the `latest` tag is a fine practice.\r\n\r\nWe recently found a [significant performance issue with .NET Framework Docker images](https://github.com/dotnet/announcements/issues/33). The .NET Framework 4.7.1 image includes the fix for that problem.\r\n"},{"Id":"6729762964","Type":"IssuesEvent","CreatedAt":"2017-10-17T21:21:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/34","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2017-8585 : Malformed Culture can cause application crash\" (#34) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-8585 \r\n## Malformed Culture can cause application to crash\r\n### Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed string request could cause an application to crash and lead to a denial of service.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.7 and 1.1.4. Developers are advised to update their .NET Core SDK to version 1.1.4.\r\n\r\n### Discussion\r\n\r\nUse https://github.com/dotnet/corefx/issues/24703 for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n\r\n.NET Core 2.0 is not affected by this issue.\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.6 or lower versions, or 1.1.2 or lower versions is affected. The latest version of the .NET core runtime you have installed in your computer can be listed by running `dotnet --info`. Running that command produces an output similar to the following:\r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\nAs this command only displays the latest version of the runtime installed (or the version set in the *global.json* file), it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location          |\r\n|------------------|-------------------|\r\n| Windows          | C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\ |\r\n| macOS            | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n| [Supported Linux platforms](https://docs.microsoft.com/dotnet/core/linux-prerequisites#supported-linux-versions) | /usr/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.7 and 1.1.4, then any applications targeting 1.0 or 1.1 of .NET Core are vulnerable.\r\n\r\nAlso, even if you have a directory for 1.0.7 and 1.1.4 present in your system, if you've deployed [self-contained applications](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd) targeting the impacted versions, these applications are also vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). .NET Core 1.1.4 SDK installs both versions 1.0.7 and 1.1.4 of the .NET Core runtime.\r\n\r\nIf you've built a [self-contained application](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd), you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [*application.runtime.config*](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application. Set the framework version to the desired version and the `rollForward` property to `false`. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the *application.runtime.config* file is an optional file, you may need to create one for each application and add it alongside the executable."},{"Id":"6725652001","Type":"IssuesEvent","CreatedAt":"2017-10-17T06:48:14","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/33","RelatedDescription":"Opened issue \".NET Framework Docker Performance Issue Resolved\" (#33) at dotnet/announcements","RelatedBody":"# .NET Framework Docker Performance Issue Resolved\r\n\r\nMultiple people have [reported](https://github.com/Microsoft/dotnet-framework-docker/issues/25) that [.NET Framework performance in Docker images is poor](https://github.com/moby/moby/issues/33096). In the cases reported, performance was an order of magnitude slower than expected.\r\n\r\nThis issue has now been resolved for [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) images. It was due to incorrectly generated NGEN images. They are now correctly generated and expected performance has been restored.\r\n\r\n## Discussion \r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet-framework-docker #29](https://github.com/Microsoft/dotnet-framework-docker/pull/29)\r\n\r\n## Details\r\n\r\n* [dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework uses [NGEN](https://docs.microsoft.com/dotnet/framework/tools/ngen-exe-native-image-generator) as a primary mechanism for startup performance. .NET Framework assemblies are compiled to native code with the NGEN tool as part of the .NET Framework setup process. The benefit of these files is that they can be loaded and executed without any additional significant extra work required by the Common Language Runtime (CLR). The lack of  additional work means that performance is very good.\r\n\r\nNGEN image generation interacts with a Windows subsystem that is not correctly supported in Windows containers. NGEN images are generated in Windows containers, but they are not valid. Fortunately, the CLR can still run in the presence of invalid images, but code execution is much slower.\r\n\r\nWe are in the process of fixing Windows containers so that NGEN will work correctly. In the interim, we have updated the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) images to correctly generate NGEN images. The [microsoft/windowsservercore/](https://hub.docker.com/r/microsoft/windowsservercore/) images still have the performance problem that was initially reported. We are working on updating Windows containers so that NGEN works as expected. You are recommended to use the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) base image if you can, so that you can get better performance.\r\n\r\nOne of the developers that reported the performance issue shared basic performance results. The first two rows are the before state. The last row is the dotnet-framework image after the fix. The improvement is quite significant.\r\n\r\n> Runing `powershell -command (measure-command { powershell -command exit }).TotalSeconds` in various images on our CI server produced this table of timings:\r\n \r\n| time (s) | image |\r\n|----------|--------|\r\n|10.7212372| microsoft/windowsservercore |\r\n|8.3278793  | microsoft/dotnet-framework:4.7|\r\n|0.6426073  | microsoft/dotnet-framework:4.7 (after fix)|\r\n"},{"Id":"6645912196","Type":"IssuesEvent","CreatedAt":"2017-09-27T19:47:08","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/32","RelatedDescription":"Opened issue \".NET Framework 4.7.1 provides built-in support for .NET Standard 2.0\" (#32) at dotnet/announcements","RelatedBody":"## Summary\r\n\r\n.NET Framework 4.7.1 will have built-in support for .NET Standard 2.0. This means that you don't have to deploy any additional files or use binding redirects to use .NET Standard 2.0 libraries.\r\n\r\nFor a demo, check out [this video][video].\r\n\r\n## Details\r\n\r\nWhile libraries targeting [.NET Standard 2.0][ns20post] are can be consumed by applications and libraries [targeting .NET Framework 4.6.1][nstable] and higher, not all files that are required for .NET Standard libraries were part of .NET Framework 4.6.1. In fact, .NET Framework 4.6.1 was shipped before .NET Standard 2.0 was even designed. That's why building an application targeting .NET Framework 4.6.1 (as well as 4.6.2 and 4.7) will have to deploy additional files.\r\n\r\n* If you use **Visual Studio 2017 15.3** or higher, these files are automatically copied to the application's output folder.\r\n\r\n* If you use **Visual Studio 2015 and [use NuGet 3.6][nuget36]**, we'll prompt you to install a [support package][vs2015support] which will handle copying the files to the output directory.\r\n\r\nStarting with .NET Framework 4.7.1 these files no longer have to be deployed with the application -- they are built right into the .NET Framework itself.\r\n\r\n.NET Framework 4.7.1 also adds[about 200 missing APIs][missingapis] that were part of .NET Standard 2.0 but not actually implemented by .NET Framework 4.6.1, 4.6.2 or 4.7.\r\n\r\nThis also removes the need for [binding redirects][netfx-issues] when using .NET Standard libraries on .NET Framework because the CLR automatically unifies version numbers of assemblies that are part of the platform.\r\n\r\nLearn more [by reading the .NET Standard FAQ](http://aka.ms/netstandardfaq).\r\n\r\n## Discussion\r\n\r\nDiscussion\r\n\r\nFor a discussion, please go to dotnet/standard#514.\r\n\r\n[ns20post]: https://blogs.msdn.microsoft.com/dotnet/2017/08/14/announcing-net-standard-2-0/\r\n[nstable]: https://docs.microsoft.com/en-us/dotnet/standard/net-standard\r\n[nuget36]: https://dist.nuget.org/visualstudio-2015-vsix/v3.6.0/NuGet.Tools.vsix\r\n[vs2015support]: https://aka.ms/netstandard-build-support-netfx\r\n[missingapis]: https://github.com/dotnet/standard/blob/master/netstandard/src/ApiCompatBaseline.net461.txt\r\n[netfx-issues]: https://github.com/dotnet/standard/issues/481\r\n[video]: https://www.youtube.com/watch?v=u67Eu_IgEMs\r\n\r\nhttps://github.com/dotnet/standard/issues/514"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6761943315","Type":"PullRequestEvent","CreatedAt":"2017-10-25T05:16:34","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14684","RelatedDescription":null,"RelatedBody":"Fixes issue https://github.com/dotnet/corefx/issues/23809\r\nhttps://github.com/dotnet/coreclr/pull/13886#issuecomment-328285541\r\n\r\nRelated PR for corefx: https://github.com/dotnet/corefx/pull/24245\r\n\r\nPrevious PR was closed: https://github.com/dotnet/coreclr/pull/14180\r\n\r\ncc @KrzysztofCwalina, @VSadov, @jkotas \r\n"},{"Id":"6761943249","Type":"PullRequestEvent","CreatedAt":"2017-10-25T05:16:32","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14684","RelatedDescription":"Closed pull request \"Marking {ReadOnly}Memory structs as readonly\" (#14684) at dotnet/coreclr","RelatedBody":"Fixes issue https://github.com/dotnet/corefx/issues/23809\r\nhttps://github.com/dotnet/coreclr/pull/13886#issuecomment-328285541\r\n\r\nRelated PR for corefx: https://github.com/dotnet/corefx/pull/24245\r\n\r\nPrevious PR was closed: https://github.com/dotnet/coreclr/pull/14180\r\n\r\ncc @KrzysztofCwalina, @VSadov, @jkotas \r\n"},{"Id":"6761846377","Type":"PullRequestEvent","CreatedAt":"2017-10-25T04:31:56","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14671","RelatedDescription":"Merged pull request \"Update BuildTools, CoreClr, CoreFx to prerelease-02124-02, preview1-25824-51, preview1-25824-02, respectively (master)\" (#14671) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"6761787193","Type":"IssuesEvent","CreatedAt":"2017-10-25T04:04:42","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/13778","RelatedDescription":"Closed issue \"How to detect the runtime/BCL required by an assembly?\" (#13778) at dotnet/coreclr","RelatedBody":"I am in the process of adding .NET Core/Standard support to ILSpy and I have a few questions:\r\nSide note: we're using Cecil to read assemblies, but it seems basic support for .NET Core/Standard assembly references is still missing. See jbevain/cecil#306.\r\n\r\nDetecting the required runtime/BCL in \"old\" .NET assemblies is straight forward:\r\n1. Look for a reference called `mscorlib`.\r\n2. Find the referenced version in the GAC and load it.\r\n\r\nIs there a similar procedure for .NET Core / .NET Standard assemblies?\r\nIs there some meta-data in the assembly header that specifies whether it is plain .NET, .NET Core or .NET Standard?\r\n\r\n.NET Core:\r\nCould be identified by `System.Runtime` references, although you cannot detect the version.\r\n\r\n1. I found that the assemblies are loaded from `%ProgramFiles%\\dotnet\\shared\\Microsoft.NETCore.App\\<version>`\r\n* Is this the only directory to look for .NET Core Runtime assemblies or is it configurable?\r\n2. What about nuget packages?\r\n* I found that there is `<project>.runtimeconfig.dev.json` and it contains a list of additional paths.\r\n* What if the json file is missing or does not contain any paths? Is it still possible to load the assembly and resolve its references?\r\n\r\n.NET Standard:\r\n1. There's this `netstandard` reference and `<project>.deps.json`\r\n*  How can I resolve all required assemblies from this information?\r\n* Is this still possible if the json file is missing?"},{"Id":"6761771611","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:58:23","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/11498","RelatedDescription":"Closed issue \"Assembly.Load does not find assembly in the application base directory\" (#11498) at dotnet/coreclr","RelatedBody":"I tried the following:\r\n```\r\nDebug.Assert(File.Exists(Path.Combine(AppDomain.CurrentDomain.Base​Directory, \"test2.dll\")));\r\nAssembly.Load(\"test2, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\");\r\n```\r\nwhich results in a `FileNotFoundException`. Works fine with .NET Framework.\r\n\r\nAll the documentation I'm finding relates to the .NET Framework and says that Assembly.Load will do probing in the application base directory if it fails to find the assembly elsewhere. If .NET Core is supposed to behave differently is there some documentation outlining the differences?\r\n\r\nI guess as a workaround I could use `AssemblyResolve` and implement the probing myself?"},{"Id":"6761769499","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:57:30","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/13996","RelatedDescription":"Closed issue \"Expanding \"Assembly\" variable in Debugger prevents \"FileNotFound\" exception \" (#13996) at dotnet/coreclr","RelatedBody":"VS 2017 15.3.4\r\nProject is .Net Core App 2.0 Console (Running/Debugging in Windows 10)\r\n\r\n          string filename = @\"d:\\myfile.dll\"\r\n           Assembly  asm = Assembly.LoadFrom(filename);\r\n           Type[] asmTypes = asm.GetTypes();\r\n\r\nmyfile.dll is a .Net 4.6.1 Class library with many other dependencies. I get FileNotFoundException on one of the dependencies. I have copied that file everywhere (for example c:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\2.0.0\\) but that is not enough. I also used gflags and it seems .Net is not even looking for that assembly.\r\n\r\nThe strange thing is if I am debugging it and I expand \"asm\" variable after Assembly.LoadFrom, then I wont get the exception! I also tried debugging into framework and it seems in this line (AssemblyLoadContext.cs)\r\n\r\n        Func<AssemblyLoadContext, AssemblyName, Assembly> assemblyResolveHandler = Resolving;\r\n\r\nResolving is null, which later this would cause the exception.\r\n\r\nIt also works fine if I switch to .Net Framework 4.6.1 for my console app.\r\n\r\n"},{"Id":"6761767935","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:56:51","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/13168","RelatedDescription":"Closed issue \"assembly-redirects in netcoreapp1.1 application\" (#13168) at dotnet/coreclr","RelatedBody":"See the F# repro in https://github.com/Microsoft/visualfsharp/issues/3408. I asked in gitter chat if there is a workaround to tell the runtime to load the correct assembly. @0x53A [found a similar way to make C# fail](https://github.com/Microsoft/visualfsharp/issues/3408#issuecomment-319527058). Now I have several questions and follow ups:\r\n\r\n- ~~[1] Apparently binding redirections are still a thing? Can someone confirm that? If yes, is there documentation?~~\r\n   ~~I tried to set them up via `<name>.dll.config` and `App.config` in the entry dll directory, but it seems like they are ignored.~~\r\n   ~~Is this because `Suave` Is not signed?~~\r\n - ~~[2] If yes, is there anything you can do to achieve the correct behavior (besides redirecting manually at runtime)?~~\r\n - [3] Can I get a link to some docs or some further information about `<Name>.deps.json` and how that changes runtime behavior? \r\n - [4] Are there other options I have not thought about?\r\n\r\nNote that this is not about the particular Suave packaging error, which I acknowledge and needs to be fixed. But rather about the general solution we have when transitive dependencies don't match. In particular it is easy to construct similar situations when people build not against the \"Minimal Version Requirement\" they specify in the nuspec, which can happen quite often.\r\n\r\nThank you!"},{"Id":"6761747919","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:49:01","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/11760","RelatedDescription":"Closed issue \"Assembly.LoadModule/AssemblyBuilder.LoadModule Not Implemented by Design\" (#11760) at dotnet/coreclr","RelatedBody":"Howdy,\r\n\r\nI am sure I am late to the party on this one, but what is the current reason why we are not supporting Assembly.LoadModule(string name, byte[] rawCoff) / AssemblyBuilder.LoadModule?  I noticed in .NET 4.0 this method was removed, just trying to understand why and what is the suggested workarounds?\r\n\r\nThanks in adavance!\r\n\r\nAdam"},{"Id":"6761743521","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:47:14","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/11012","RelatedDescription":"Closed issue \"[ARM32] Console app problem \"Could not load file or assembly 'System.ComponentModel.Primitives, Version=4.2.0.0\"\" (#11012) at dotnet/coreclr","RelatedBody":"Hi, \r\nI'm developing a .NET Core network-oriented console app to be deployed on a Raspberry Pi 3 running 16.04.2 LTS.  Although I was able to deploy to the rPi in the beginning when there was much less code, I get this error message now (with more code in the app)\r\n```\r\nUnhandled Exception: System.IO.FileLoadException: Could not load file or assembly 'System.ComponentModel.Primitives, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)\r\nat Microsoft.Extensions.FileProviders.PhysicalFileProvider.CreateFileWatcher(String root)\r\nat Microsoft.Extensions.Configuration.FileConfigurationExtensions.SetBasePath(IConfigurationBuilder builder, String basePath)\r\nat ProtocolHub.Program.Main(String[] args)\r\n```\r\nI have read [the post [ARM32] Could not load file or assembly ](https://github.com/dotnet/coreclr/issues/9168#issuecomment-277846829), but can't manage to implement the proposed changes partly because I'm having trouble understanding it all, partly because my .proj files are XML rather than json.\r\nMy code is [here on GitHub](https://github.com/stefaanv/ProtocolHubDotNetCore), I'm developing in VS2017.\r\nThe runtime on the rPi is\r\n```\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0-preview1-001970-00\r\n  Build    : fdfa54cfc092dbb30fe0ba53cc11aeaa6ab916e1\r\n```\r\nBefore copying the code to the rPi, I change the runtime.config.json file to reflect the version of the installed framework\r\n```\r\n{\r\n  \"runtimeOptions\": {\r\n    \"framework\": {\r\n      \"name\": \"Microsoft.NETCore.App\",\r\n      \"version\": \"2.0.0-preview1-001970-00\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAny ideas how to resolve this ?\r\nStefaan"},{"Id":"6761735875","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:44:13","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/10753","RelatedDescription":"Closed issue \"Allow IL Only mode\" (#10753) at dotnet/coreclr","RelatedBody":"We should enable something similar to COMPlus_ZapDisable that makes the whole system treat an NI image as if it were IL. This means not throwing a BadImageFormatException when the file is R2R and dealing with whatever other things would need to fallback to just treating the image as IL.\r\n\r\nThis would enable our community to try and piece things together from different systems especially places where we don't have an SDK. As creating R2R images becomes more popular, it will be nice to be able to decide to load some of them as IL."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6761661359","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:13:44","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/7898","RelatedDescription":"Closed issue \"[Quesiton] How to run 'dotnet test' without cli?\" (#7898) at dotnet/cli","RelatedBody":"I am working on porting the debugger used by the VS Code C# Extension to linux-arm. Today we depend on the 'dotnet test' command to run our unit tests. This will not work for running our unit tests on linux-arm because there is currently no cli available. \r\n\r\nI thought I would be able to build the test project on windows and run it on linux-arm against a private shared framework. This works for console apps, but I can't get it to work for a test app. \r\n\r\nHow can I get a test runner in the output of my test project build that I can run on arm against a shared framework? I thought doing a stand-alone publish would include the necessary pieces, but it doesn't have a test runner in the outputs. I took a quick look at 'dotnet-vstest' form the cli, and it looks like the runner is included in the SDK installation, which I do not have on linux-arm. Is there any way to publish 'vstest.console.dll' with the app? Is there a PackageReference I can add to include the test runner in the build/publish output?\r\n"},{"Id":"6761106136","Type":"IssuesEvent","CreatedAt":"2017-10-24T23:35:19","Actor":"chuckries","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/7898","RelatedDescription":"Opened issue \"[Quesiton] How to run 'dotnet test' without cli?\" (#7898) at dotnet/cli","RelatedBody":"I am working on porting the debugger used by the VS Code C# Extension to linux-arm. Today we depend on the 'dotnet test' command to run our unit tests. This will not work for running our unit tests on linux-arm because there is currently no cli available. \r\n\r\nI thought I would be able to build the test project on windows and run it on linux-arm against a private shared framework. This works for console apps, but I can't get it to work for a test app. \r\n\r\nHow can I get a test runner in the output of my test project build that I can run on arm against a shared framework? I thought doing a stand-alone publish would include the necessary pieces, but it doesn't have a test runner in the outputs. I took a quick look at 'dotnet-vstest' form the cli, and it looks like the runner is included in the SDK installation, which I do not have on linux-arm. Is there any way to publish 'vstest.console.dll' with the app? Is there a PackageReference I can add to include the test runner in the build/publish output?\r\n"},{"Id":"6761036906","Type":"PullRequestEvent","CreatedAt":"2017-10-24T23:11:50","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/7897","RelatedDescription":"Opened pull request \"Stop producing core sdk from CLI repo\" (#7897) at dotnet/cli","RelatedBody":"We are now producing the toolset.\r\n\r\nThe next step will be to make the CLI produce just CLI verbs + MSBuild Props/targets and then move the toolset piece to the toolset repo.\r\n\r\n@nguerrera \r\n"},{"Id":"6760977137","Type":"PullRequestEvent","CreatedAt":"2017-10-24T22:52:20","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/7896","RelatedDescription":"Opened pull request \"WIP One process restore\" (#7896) at dotnet/cli","RelatedBody":""},{"Id":"6760196091","Type":"PullRequestEvent","CreatedAt":"2017-10-24T19:45:48","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7880","RelatedDescription":"Merged pull request \"Update CoreSetup to preview1-25823-01 (master)\" (#7880) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6760194537","Type":"PullRequestEvent","CreatedAt":"2017-10-24T19:45:27","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/7893","RelatedDescription":"Merged pull request \"Merge release/2.0.0 to release/15.5\" (#7893) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/15.5.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/15.5-20171024-070026\ngit reset --hard upstream/release/15.5\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/15.5-20171024-070026 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6759432843","Type":"PullRequestEvent","CreatedAt":"2017-10-24T17:05:24","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/7884","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to dev/release/2.0\" (#7884) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into dev/release/2.0.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-dev/release/2.0-20171023-070027\ngit reset --hard upstream/dev/release/2.0\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-dev/release/2.0-20171023-070027 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6761712317","Type":"IssuesEvent","CreatedAt":"2017-10-25T03:34:52","Actor":"JohnMasen","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/549","RelatedDescription":"Closed issue \"IAsyncResult does not return after AsyncWaitHandle is set (only applies to .NET Core 2.0)\" (#549) at dotnet/standard","RelatedBody":"I have a library which converts javascript async call (Promise call) to dotnet Task. it works fine on .NET Core 1.0 and 1.1   \r\nAfter upgrading the caller project to .NET Core 2.0, the \"Await\" statement was never return.\r\n\r\nRepro steps:\r\n>1. get code from https://github.com/JohnMasen/ChakraCore.NET\r\n>2. change the target of project \"ChakraCore.NET.UnitTest“ to \".NET Core 2.0\"\r\n>3. Rebuild project\r\n>4. Run unit test \"CallPromiseTest\"\r\n\r\nExpected result: \r\n>The test will pass\r\n\r\nActual result: \r\n>The test will hang\r\n\r\nAnalyze:\r\nAfter debugging the code, I found the await of IAsyncResult was never return even the AsyncWaitHandle was set. "},{"Id":"6761625356","Type":"IssuesEvent","CreatedAt":"2017-10-25T02:59:31","Actor":"JohnMasen","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/549","RelatedDescription":"Opened issue \"IAsyncResult does not return after AsyncWaitHandle as set after upgrading project to .NET Core 2.0\" (#549) at dotnet/standard","RelatedBody":"I have a library which converts javascript async call (Promise call) to dotnet Task. it works fine on .NET Core 1.0 and 1.1   \r\nAfter upgrading the caller project to .NET Core 2.0, the \"Await\" statement was never return.\r\n\r\nRepro steps:\r\n>1. get code from https://github.com/JohnMasen/ChakraCore.NET\r\n>2. change the target of project \"ChakraCore.NET.UnitTest“ to \".NET Core 2.0\"\r\n>3. Rebuild project\r\n>4. Run unit test \"CallPromiseTest\"\r\n\r\nExpected result: \r\n>The test will pass\r\n\r\nActual result: \r\n>The test will hang\r\n\r\nAnalyze:\r\nAfter debugging the code, I found the await of IAsyncResult was never return even the AsyncWaitHandle was set. "},{"Id":"6760342124","Type":"PullRequestEvent","CreatedAt":"2017-10-24T20:17:19","Actor":"chcosta","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/548","RelatedDescription":"Merged pull request \"Enable publish to azure blob feed\" (#548) at dotnet/standard","RelatedBody":"Note: I need to enable the dependency updating task for the standard repo in order for this model to work.\r\n\r\nI haven't fully validated these changes.  I'll validate post-checkin to dotnet/standard:master via official build."},{"Id":"6759851599","Type":"PullRequestEvent","CreatedAt":"2017-10-24T18:31:59","Actor":"chcosta","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/548","RelatedDescription":"Opened pull request \"Enable publish to azure blob feed\" (#548) at dotnet/standard","RelatedBody":"Note: I need to enable the dependency updating task for the standard repo in order for this model to work.\r\n\r\nI haven't fully validated these changes.  I'll validate post-checkin to dotnet/standard:master via official build."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6761818769","Type":"PullRequestEvent","CreatedAt":"2017-10-25T04:18:53","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24803","RelatedDescription":"Merged pull request \"Adjust link fit to other URLs\" (#24803) at dotnet/corefx","RelatedBody":""},{"Id":"6761530826","Type":"PullRequestEvent","CreatedAt":"2017-10-25T02:22:43","Actor":"Priya91","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/24857","RelatedDescription":"Opened pull request \"Implement cancellation token for SslStream new AuthenticateAs*Async methods\" (#24857) at dotnet/corefx","RelatedBody":"also fixes #24853 \r\n\r\ncc @stephentoub @Tratcher @Drawaes "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6761385348","Type":"PullRequestEvent","CreatedAt":"2017-10-25T01:24:23","Actor":"333fred","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22842","RelatedDescription":"Opened pull request \"Variable declaration refactor\" (#22842) at dotnet/roslyn","RelatedBody":"This is the variable declaration refactor discussed over email. The following changes occurred:\r\n\r\n* IVariableDeclarationStatement -> IVariableDeclarationGroup\r\n* IVariableDeclaration is now a base interface for ISingleVariableDeclaration and IMultiVariableDeclaration. IVariableDeclaration just has an initializer.\r\n* ISingleVariableDeclaration was introduced. It has a single symbol, in addition to the initializer. This is used in C# for all variable declarations, and in VB for the individual variable declarations as part of a multi declaration.\r\n* IMultiVariableDeclaration was introduced. It has a list of ISingleVariableDeclarations which are the variable declarations that make up the top-level declaration.\r\n\r\nIn practice, this means the following:\r\n\r\nIn C#, `var x = 1` corresponds to an IVariableDeclarationGroup with 1 ISingleDeclaration. C# does not make use of IMultiVariableDeclaration.\r\n\r\nVB is a bit more complicated. `Dim x As Integer = 1` corresponds to:\r\n```\r\nIVariableDeclarationGroup\r\n    IMultiVariableDeclaration\r\n        ISingleVariableDeclaration\r\n            Symbol: x\r\n            Initializer: Nothing\r\n        Initializer: ILiteral\r\n```\r\nThe Initializer of an ISingleVariableDeclaration is only ever used for array bounds. While it would be possible to simplify this scenario for the single variable with single initializer, I felt that consistency across the board would be a better option.\r\n\r\nFixes https://github.com/dotnet/roslyn/issues/22362."},{"Id":"6761188060","Type":"IssuesEvent","CreatedAt":"2017-10-25T00:05:37","Actor":"VSadov","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22841","RelatedDescription":"Opened issue \"Readonly references to array elements should not do covariance check\" (#22841) at dotnet/roslyn","RelatedBody":"intuitively the following should work:\r\n\r\n```C#\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var objectArray = (object[])new string[] { \"hi\", \"hello\" };\r\n  \r\n            Test(in objectArray[0]);\r\n        }\r\n\r\n        static void Test(in object r)\r\n        {\r\n            System.Console.WriteLine(r);\r\n        }\r\n    }\r\n```\r\n\r\nHowever, it throws exception at run time:\r\n```\r\nUnhandled Exception: System.ArrayTypeMismatchException: Attempted to access an element as a type incompatible with the array.\r\n```\r\n\r\nThe IL pattern that we emit induces a dynamic type check for the array's actual element type. That is no needed since `in` parameter guarantees that it will not be used for writing.\r\n\r\nAs a result we are not only wasting time on unnecessary check, but also preventing completely type-safe scenario from working.\r\n"},{"Id":"6761099413","Type":"IssuesEvent","CreatedAt":"2017-10-24T23:33:10","Actor":"khyperia","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22840","RelatedDescription":"Opened issue \"SyntaxEquivalence.AreEquivalentRecursive does not have a recursion depth bound\" (#22840) at dotnet/roslyn","RelatedBody":"This can cause a stackoverflow in the IDE and cause a VS crash.\r\n\r\nI'm not at a Windows machine to repro this in VS, but:\r\n\r\n1) Create a file consisting of nothing but 3000 open parentheses\r\n1) Try to edit the file (trigger incremental reparse?)\r\n\r\nExpected behavior:\r\n\r\nStack guard stops the comparison (perhaps fails with `ERR_InsufficientStack` somehow?)\r\n\r\nFrom @swgillespie:\r\n\r\n```\r\n00 244b9004 2e2e81cc Microsoft_CodeAnalysis_CSharp_ni!Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxEquivalence.AreEquivalentRecursive(Microsoft.CodeAnalysis.GreenNode, Microsoft.CodeAnalysis.GreenNode, System.Func`2<Microsoft.CodeAnalysis.CSharp.SyntaxKind,Boolean>, Boolean)+0x4 [E:\\A\\_work\\7\\s\\src\\Compilers\\CSharp\\Portable\\Syntax\\SyntaxEquivalence.cs @ 86] \r\n01 244b90b8 2e2e81cc Microsoft_CodeAnalysis_CSharp_ni!Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxEquivalence.AreEquivalentRecursive(Microsoft.CodeAnalysis.GreenNode, Microsoft.CodeAnalysis.GreenNode, System.Func`2<Microsoft.CodeAnalysis.CSharp.SyntaxKind,Boolean>, Boolean)+0x7c [E:\\A\\_work\\7\\s\\src\\Compilers\\CSharp\\Portable\\Syntax\\SyntaxEquivalence.cs @ 204] \r\n02 244b916c 2e2e81cc Microsoft_CodeAnalysis_CSharp_ni!Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxEquivalence.AreEquivalentRecursive(Microsoft.CodeAnalysis.GreenNode, Microsoft.CodeAnalysis.GreenNode, System.Func`2<Microsoft.CodeAnalysis.CSharp.SyntaxKind,Boolean>, Boolean)+0x7c [E:\\A\\_work\\7\\s\\src\\Compilers\\CSharp\\Portable\\Syntax\\SyntaxEquivalence.cs @ 204] \r\n...\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/953151/31972925-1346a662-b8d8-11e7-87c6-0fdc4a320b09.png)\r\n\r\n(the above is pretty much my favorite screenshot of all time)"},{"Id":"6761001563","Type":"PullRequestEvent","CreatedAt":"2017-10-24T23:00:03","Actor":"sharwell","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22742","RelatedDescription":"Merged pull request \"Only check for missing attributes when we know the syntax tree is available\" (#22742) at dotnet/roslyn","RelatedBody":"Fixes a case where large projects repeatedly deserialized syntax trees, resulting in severe UI delays while typing.\r\n\r\n**Customer scenario**\r\n\r\nA large VB project contains a large number of partial classes spread across *very* large source files. While typing in the editor, memory pressure results in frequently GC reclaiming of weak references to syntax trees. Then, calls to `ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind` forces the syntax trees to be deserialized, further increasing memory pressure. The following shows a snippet of callees in PerfView where 4+GiB of memory was allocated while typing two short lines (less than 15 tokens).\r\n\r\n![image](https://user-images.githubusercontent.com/1408396/31700455-206ef716-b38f-11e7-87c7-7e81736887b0.png)\r\n\r\n**Bugs this fixes:**\r\n\r\nFixes [DevDiv 469472](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/469472).\r\n\r\n**Workarounds, if any**\r\n\r\nNone known.\r\n\r\n**Risk**\r\n\r\nThe risk appears to be very low, as the code was already meant to handle cases where the attribute data is not readily available.\r\n\r\n**Performance impact**\r\n\r\nDramatic performance improvement for impacted users. The IDE goes from *fully unusable* to working normally.\r\n\r\n**Is this a regression from a previous update?**\r\n\r\nIt does not appear to be a regression.\r\n\r\n**Root cause analysis:**\r\n\r\nFailed to test with partial class declarations that, when parsed, exceed the available memory of the process.\r\n\r\n**How was the bug found?**\r\n\r\nCustomer reported.\r\n\r\n**Test documentation updated?**\r\n\r\nN/A"},{"Id":"6760855764","Type":"IssuesEvent","CreatedAt":"2017-10-24T22:16:03","Actor":"jinujoseph","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22823","RelatedDescription":"Closed issue \"Do not generate a statement operation within using declaration\" (#22823) at dotnet/roslyn","RelatedBody":"See https://github.com/dotnet/roslyn/pull/22774#discussion_r146455755."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6761333748","Type":"PullRequestEvent","CreatedAt":"2017-10-25T01:03:22","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4795","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4795) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6761302549","Type":"PullRequestEvent","CreatedAt":"2017-10-25T00:50:48","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4794","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4794) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6760814674","Type":"PullRequestEvent","CreatedAt":"2017-10-24T22:05:05","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4794","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4794) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6760768044","Type":"PullRequestEvent","CreatedAt":"2017-10-24T21:53:26","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4793","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4793) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6760726976","Type":"PullRequestEvent","CreatedAt":"2017-10-24T21:43:31","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4792","RelatedDescription":"Merged pull request \"Switch to DotNetCore-Build pool\" (#4792) at dotnet/corert","RelatedBody":"This one should have VS 2017 installed."},{"Id":"6760702669","Type":"PullRequestEvent","CreatedAt":"2017-10-24T21:37:29","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4793","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4793) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6760656778","Type":"PullRequestEvent","CreatedAt":"2017-10-24T21:26:22","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4791","RelatedDescription":"Merged pull request \"Update RyuJIT\" (#4791) at dotnet/corert","RelatedBody":"Picks up dotnet/coreclr#14664."},{"Id":"6760640167","Type":"PullRequestEvent","CreatedAt":"2017-10-24T21:22:30","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4792","RelatedDescription":"Opened pull request \"Switch to DotNetCore-Build pool\" (#4792) at dotnet/corert","RelatedBody":"This one should have VS 2017 installed."},{"Id":"6760421835","Type":"PullRequestEvent","CreatedAt":"2017-10-24T20:34:32","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4791","RelatedDescription":"Opened pull request \"Update RyuJIT\" (#4791) at dotnet/corert","RelatedBody":"Picks up dotnet/coreclr#14664."},{"Id":"6759484862","Type":"PullRequestEvent","CreatedAt":"2017-10-24T17:16:07","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4789","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#4789) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6759475970","Type":"PullRequestEvent","CreatedAt":"2017-10-24T17:14:15","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4789","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#4789) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"6758894231","Type":"PullRequestEvent","CreatedAt":"2017-10-24T15:26:52","Actor":"sergign60","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4788","RelatedDescription":"Opened pull request \"Added wrappers for Div and Mod helpers\" (#4788) at dotnet/corert","RelatedBody":""},{"Id":"6757527037","Type":"PullRequestEvent","CreatedAt":"2017-10-24T11:09:09","Actor":"brianrob","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/4787","RelatedDescription":"Closed pull request \"[WIP] Test Changes Needed for EventSource Nuget Package\" (#4787) at dotnet/corert","RelatedBody":"This PR is to validate that changes being made to CoreCLR in support of the EventSource nuget package will not break CoreRT when they are mirrored."}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"923037554265296896","CreatedAt":"2017-10-25T04:04:36+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework latest tag updated to 4.7.1 https://t.co/NuV11juPrm /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":16,"FavoriteCount":8,"RawContent":null},{"Id":"922503653402882049","CreatedAt":"2017-10-23T16:43:04+00:00","UserScreenname":"dotnet","Text":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018  https://t.co/TPKfGvwNLH /cc @intel","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":91,"FavoriteCount":52,"RawContent":null},{"Id":"921143443912474624","CreatedAt":"2017-10-19T22:38:05+00:00","UserScreenname":"dotnet","Text":"New .NET Rocks podcast with @coolcsh on understanding #dotnet standard &amp; future of #dotnetcore… https://t.co/b8BCeZKEqz","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":41,"FavoriteCount":20,"RawContent":null},{"Id":"920400974321147904","CreatedAt":"2017-10-17T21:27:47+00:00","UserScreenname":"dotnet","Text":"Announcing the .NET Framework 4.7.1 https://t.co/Vu3bilF8bZ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":379,"FavoriteCount":344,"RawContent":null},{"Id":"920393493557555205","CreatedAt":"2017-10-17T20:58:03+00:00","UserScreenname":"dotnet","Text":".NET Framework October 2017 Preview of Quality Rollup https://t.co/oVqxMXye74","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":16,"FavoriteCount":16,"RawContent":null},{"Id":"920179824576028673","CreatedAt":"2017-10-17T06:49:00+00:00","UserScreenname":"dotnet","Text":".NET Framework Docker Performance Issue Resolved https://t.co/FST3EfcLtS","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":55,"FavoriteCount":29,"RawContent":null},{"Id":"920157146309730305","CreatedAt":"2017-10-17T05:18:54+00:00","UserScreenname":"dotnet","Text":"RyuJIT Just-in-Time Compiler Optimization Enhancements https://t.co/dhO8rAqiSI","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":132,"FavoriteCount":79,"RawContent":null},{"Id":"918494723425406976","CreatedAt":"2017-10-12T15:13:01+00:00","UserScreenname":"dotnet","Text":"So many fantastic #dotnetconf sessions this year! Check them out on-demand on @ch9 https://t.co/aFDC9i36Lu https://t.co/diQ3nfOU5p","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":108,"FavoriteCount":70,"RawContent":null}]}},"RunOn":"2017-10-25T05:30:19.4440255Z","RunDurationInMilliseconds":6588}