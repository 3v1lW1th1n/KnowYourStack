{"Data":{"GitHub":{"Issues":[{"Id":"387560427","IsPullRequest":false,"CreatedAt":"2018-12-05T02:00:19","Actor":"singlis","Number":"1827","RawContent":null,"Title":"The trainer API for MLContext is inconsistent for learner in external nugets","State":"open","Body":"APIs are discoverable via the MLContext. There are some learners that are declared on the MLContext where other learners define an MLContext extension in cases where the learner is in a separate nuget package. \r\n\r\nThis results inconsistent API calls when accessing there APIs BinaryClassification vs Recommendation(), for example:\r\n```\r\nvar foo_bar = mlContext.BinaryClassification.Trainers;\r\nvar foo_moo_bar = mlContext.Recommendation().Trainers;\r\n```\r\n\r\nThe API discover ability should be consistent and work across nuget pakages.\r\nOriginal issue: #1806 \r\n\r\nThis issue may be the solution #1319 as it creates extensions for the trainers. ","Url":"https://github.com/dotnet/machinelearning/issues/1827","RelatedDescription":"Open issue \"The trainer API for MLContext is inconsistent for learner in external nugets\" (#1827)"},{"Id":"387557320","IsPullRequest":false,"CreatedAt":"2018-12-05T01:45:33","Actor":"singlis","Number":"1826","RawContent":null,"Title":"MatrixFactorization construction parameters are not consistent with other learners","State":"open","Body":"The ordering of parameters for the Matrix Factorization constructor is inconsistent with other trainers, specifically the Label column should be first before the matrixColumnIndex and matrixRowIndex as the matrixColumnIndex and matrixRowIndex are the feature columns:\r\n\r\n```\r\n        /// <summary>\r\n        /// Initializing a new instance of <see cref=\"MatrixFactorizationTrainer\"/>.\r\n        /// </summary>\r\n        /// <param name=\"env\">The private instance of <see cref=\"IHostEnvironment\"/>.</param>\r\n        /// <param name=\"matrixColumnIndexColumnName\">The name of the column hosting the matrix's column IDs.</param>\r\n        /// <param name=\"matrixRowIndexColumnName\">The name of the column hosting the matrix's row IDs.</param>\r\n        /// <param name=\"labelColumn\">The name of the label column.</param>\r\n        /// <param name=\"advancedSettings\">A delegate to apply all the advanced arguments to the algorithm.</param>\r\n        public MatrixFactorizationTrainer(IHostEnvironment env,\r\n            string matrixColumnIndexColumnName,\r\n            string matrixRowIndexColumnName,\r\n            string labelColumn = DefaultColumnNames.Label,\r\n            Action<Arguments> advancedSettings = null)\r\n            : base(env, LoadNameValue)\r\n```\r\n\r\nWhere other trainers have the label column argument followed by feature column:\r\n```\r\n public static SdcaBinaryTrainer StochasticDualCoordinateAscent(\r\n                this BinaryClassificationContext.BinaryClassificationTrainers ctx,\r\n                string labelColumn = DefaultColumnNames.Label,\r\n                string featureColumn = DefaultColumnNames.Features,\r\n                string weights = null,\r\n...)\r\n```","Url":"https://github.com/dotnet/machinelearning/issues/1826","RelatedDescription":"Open issue \"MatrixFactorization construction parameters are not consistent with other learners\" (#1826)"},{"Id":"387550458","IsPullRequest":false,"CreatedAt":"2018-12-05T01:13:38","Actor":"wschin","Number":"1825","RawContent":null,"Title":"RffWorkout test is not stable and randomy fails during the build.","State":"open","Body":"As title. I failed multiple times for some unknown reasons. It needs to be improved for a more smooth merging process.","Url":"https://github.com/dotnet/machinelearning/issues/1825","RelatedDescription":"Open issue \"RffWorkout test is not stable and randomy fails during the build.\" (#1825)"},{"Id":"387547559","IsPullRequest":false,"CreatedAt":"2018-12-05T01:02:51","Actor":"TomFinley","Number":"1824","RawContent":null,"Title":"Make Row Disposable","State":"open","Body":"We have previously used what was `IRow`, and now `Row`, for two purposes:\r\n\r\n1. It was a \"restricted\" row cursor that allowed inspection but not movement. Nearly all of our transforms perform their data transformations through this mechanism, which is fine.\r\n\r\n2. It was a convenient way to store what amounted to a property bag that had the benefit of using the `IDataView` type system and familiar APIs.\r\n\r\nThe trouble was, that for scenario 2 it would have been incredibly awkward to have `IRow` be disposable. But for scenario 1 we absolutely required it. So we did awkward things like this:\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/521acad830408b43175821575f5f774629aeafe7/src/Microsoft.ML.Core/Data/ISchemaBindableMapper.cs#L116\r\n\r\n\"Here's a `Row`, and by the way, when you're done, if this thing is non-null, you should treat it as disposable.\" Kind of silly. But this was able to be done, because these `Row` objects were \"driving\" `RowCursor` implementations, and those were disposable, so we were able to hide this complexity from people. But, since `Row` must be a public type in our API (just as `RowCursor` must be), we must change it.\r\n\r\nWe have now actually resolved scenario 2 by inventing a new type of container, called `Metadata`, that operates *kind of* like a `Row`, but isn't quite one. And this leaves us free now, I think, to make `Row` disposable.\r\n\r\n* Anything that is still a `Row` that should become a `Metadata` should start being a `Metadata`. (This includes anything that currently yields `Row`s that are understood by convention to be immovable and where all columns are active... that is, simple property bags.)\r\n\r\n* Much of the disposer logic currently on `RowCursor` can be moved to `Row`.\r\n\r\n* Implement [dispose pattern](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/dispose-pattern) on `Row`.\r\n\r\nThis issue is an explication of a minor subpoint of #1532 .","Url":"https://github.com/dotnet/machinelearning/issues/1824","RelatedDescription":"Open issue \"Make Row Disposable\" (#1824)"},{"Id":"387533990","IsPullRequest":false,"CreatedAt":"2018-12-05T00:02:23","Actor":"swesonga","Number":"1823","RawContent":null,"Title":"Cannot use ML.NET in a Windows nano container","State":"open","Body":"### System information\r\n\r\nBase image: microsoft/dotnet:2.1-aspnetcore-runtime-nanoserver-1803\r\n\r\nMicrosoft Windows [Version 10.0.17134.345]\r\n(c) 2018 Microsoft Corporation. All rights reserved.\r\n\r\nC:\\app>dotnet --info\r\n\r\nHost (useful for support):\r\n  Version: 2.1.5\r\n  Commit:  290303f510\r\n\r\n.NET Core SDKs installed:\r\n  No SDKs were found.\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\r\n### Issue\r\nRepro: Install the Visual Studio Service Fabric Mesh tools from https://blogs.msdn.microsoft.com/azureservicefabric/2018/12/04/service-fabric-mesh-preview-refresh-release/ then follow the tutorial at https://docs.microsoft.com/en-us/azure/service-fabric-mesh/service-fabric-mesh-tutorial-create-dotnetcore and install the ML.NET package to try training an ML model.\r\n\r\nWhen the web project starts, a System.InvalidOperationException is thrown.\r\nInner Exception\r\nDllNotFoundException: Unable to load DLL 'CpuMathNative' or one of its dependencies: The specified module could not be found.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1823","RelatedDescription":"Open issue \"Cannot use ML.NET in a Windows nano container\" (#1823)"},{"Id":"387482029","IsPullRequest":true,"CreatedAt":"2018-12-04T21:13:28","Actor":"wschin","Number":"1822","RawContent":null,"Title":"Make SchemaShape.Column a struct instead of a class","State":"open","Body":"Fixes #1706.","Url":"https://github.com/dotnet/machinelearning/pull/1822","RelatedDescription":"Open PR \"Make SchemaShape.Column a struct instead of a class\" (#1822)"},{"Id":"387138214","IsPullRequest":true,"CreatedAt":"2018-12-04T21:08:40","Actor":"TomFinley","Number":"1814","RawContent":null,"Title":"Cleanup of IRowCursor and related interfaces. IRowCursor/IRow are now classes.","State":"closed","Body":"Partial fix for #1532. I say partial because part of what we also wanted to do was clean up some of the things in the interface (now class) that have not proven useful, but, this work is already large to the point where it would be probably unwise to try to make the PR larger.\r\n\r\nI have structured the commits so they are easy to understand, if viewed one by one. The commits with \"Rename\" in the description are *precisely that*, that is, me going to one or more types as described, hitting F2, typing something new, and that becomes my commit. Consider reviewing the other ones -- there is probably not much use in review of the rename ones. (Except perhaps to suggest a better name than `Row`. 😛 )","Url":"https://github.com/dotnet/machinelearning/pull/1814","RelatedDescription":"Closed or merged PR \"Cleanup of IRowCursor and related interfaces. IRowCursor/IRow are now classes.\" (#1814)"},{"Id":"387452782","IsPullRequest":true,"CreatedAt":"2018-12-04T19:51:47","Actor":"yaeldekel","Number":"1821","RawContent":null,"Title":"ImagePixelExtractorTransform support for images with no alpha channel","State":"open","Body":"Fixes #1820 .","Url":"https://github.com/dotnet/machinelearning/pull/1821","RelatedDescription":"Open PR \"ImagePixelExtractorTransform support for images with no alpha channel\" (#1821)"},{"Id":"387452308","IsPullRequest":false,"CreatedAt":"2018-12-04T19:50:36","Actor":"yaeldekel","Number":"1820","RawContent":null,"Title":"ImagePixelExtractorTransform only supports images with pixel format Format32bppArgb","State":"open","Body":"We also need support for Format24bppRgb.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1820","RelatedDescription":"Open issue \"ImagePixelExtractorTransform only supports images with pixel format Format32bppArgb\" (#1820)"},{"Id":"387011778","IsPullRequest":true,"CreatedAt":"2018-12-04T17:42:33","Actor":"yaeldekel","Number":"1810","RawContent":null,"Title":"Nadrop","State":"closed","Body":"Fixes #1809 .\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1810","RelatedDescription":"Closed or merged PR \"Nadrop\" (#1810)"},{"Id":"387011404","IsPullRequest":false,"CreatedAt":"2018-12-04T17:42:33","Actor":"yaeldekel","Number":"1809","RawContent":null,"Title":"MissingValueDroppingTransformer has a bug","State":"closed","Body":"When it is getting the getter of the source column, it tries to use 'iinfo' instead of '_srcCols[iinfo]'.","Url":"https://github.com/dotnet/machinelearning/issues/1809","RelatedDescription":"Closed issue \"MissingValueDroppingTransformer has a bug\" (#1809)"},{"Id":"387160651","IsPullRequest":true,"CreatedAt":"2018-12-04T15:55:58","Actor":"shauheen","Number":"1817","RawContent":null,"Title":"Cherry-pick for release 0.8","State":"closed","Body":"Cherry-pick into release for 0.8","Url":"https://github.com/dotnet/machinelearning/pull/1817","RelatedDescription":"Closed or merged PR \"Cherry-pick for release 0.8\" (#1817)"},{"Id":"387354345","IsPullRequest":false,"CreatedAt":"2018-12-04T15:55:16","Actor":"NektoDron","Number":"1819","RawContent":null,"Title":"CreatePredictionEngine<TSrc, TDst> is internal now. What is replacement?","State":"open","Body":"The CreatePredictionEngine method is internal now. What is replacement for trainedModel (ITransfomer) and scheme (SchemaDefinition)? MakePredictionFunction can't use SchemaDefinition and makes exception for me.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1819","RelatedDescription":"Open issue \"CreatePredictionEngine<TSrc, TDst> is internal now. What is replacement?\" (#1819)"},{"Id":"387293032","IsPullRequest":false,"CreatedAt":"2018-12-04T13:45:55","Actor":"NektoDron","Number":"1818","RawContent":null,"Title":"Can I use TimeSeries prediction with Vec<R4, N> input data?","State":"open","Body":"Is it possible in the future?\r\nNow it makes an exception \"The feature column has  type 'Vec<R4, 3>', but must be a float.\"","Url":"https://github.com/dotnet/machinelearning/issues/1818","RelatedDescription":"Open issue \"Can I use TimeSeries prediction with Vec<R4, N> input data?\" (#1818)"},{"Id":"387149514","IsPullRequest":true,"CreatedAt":"2018-12-04T07:11:56","Actor":"sfilipi","Number":"1816","RawContent":null,"Title":"WIP:  Calibrator estimators","State":"open","Body":"Fixes #1622 by creating one CalibratorEstimator per CalibratorTrainer. \r\nIntroduces CalibratorTransforms\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1816","RelatedDescription":"Open PR \"WIP:  Calibrator estimators\" (#1816)"},{"Id":"387144005","IsPullRequest":true,"CreatedAt":"2018-12-04T06:56:20","Actor":"shauheen","Number":"1815","RawContent":null,"Title":"Cherry-pick for release 0.8","State":"closed","Body":"Cherry-pick into release for 0.8","Url":"https://github.com/dotnet/machinelearning/pull/1815","RelatedDescription":"Closed or merged PR \"Cherry-pick for release 0.8\" (#1815)"},{"Id":"387069728","IsPullRequest":true,"CreatedAt":"2018-12-04T00:46:23","Actor":"Anipik","Number":"1813","RawContent":null,"Title":"Or converted to add, added tests for negative value of scale","State":"open","Body":"Fixes https://github.com/dotnet/machinelearning/issues/1802\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1813","RelatedDescription":"Open PR \"Or converted to add, added tests for negative value of scale\" (#1813)"},{"Id":"387069584","IsPullRequest":true,"CreatedAt":"2018-12-04T00:45:43","Actor":"abgoswam","Number":"1812","RawContent":null,"Title":"TensorFlowTransform example in Microsoft.ML.Samples","State":"open","Body":"Fixes #1715 \r\n\r\n- Adding example for TensorFlowTransform in Microsoft.ML.Samples.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1812","RelatedDescription":"Open PR \"TensorFlowTransform example in Microsoft.ML.Samples\" (#1812)"},{"Id":"387001738","IsPullRequest":true,"CreatedAt":"2018-12-03T22:59:55","Actor":"rogancarr","Number":"1808","RawContent":null,"Title":"Fixing incorrect links in XMLDocs for PFI, FCC, GAM","State":"closed","Body":"This PR fixes incorrect documentation links in the XML Docs for Permutation Feature Importance, Feature Contributions Calculator, and Generalized Additive Models.\r\n\r\nFixes #1807 ","Url":"https://github.com/dotnet/machinelearning/pull/1808","RelatedDescription":"Closed or merged PR \"Fixing incorrect links in XMLDocs for PFI, FCC, GAM\" (#1808)"},{"Id":"386999804","IsPullRequest":false,"CreatedAt":"2018-12-03T22:59:55","Actor":"sfilipi","Number":"1807","RawContent":null,"Title":"Incorrect link in PFI sample","State":"closed","Body":"The correct link in here:\r\nhttps://github.com/dotnet/machinelearning/blob/be115f416a77f88f56f6d3abe0931ca1f74ef40b/src/Microsoft.ML.Transforms/PermutationFeatureImportanceExtensions.cs#L43\r\n\r\nis:\r\n\r\n~/../docs/samples/docs/samples/Microsoft.ML.Samples/Dynamic/PermutationFeatureImportance.cs","Url":"https://github.com/dotnet/machinelearning/issues/1807","RelatedDescription":"Closed issue \"Incorrect link in PFI sample\" (#1807)"},{"Id":"387037452","IsPullRequest":true,"CreatedAt":"2018-12-03T22:38:30","Actor":"Ivanidzo4ka","Number":"1811","RawContent":null,"Title":"Ngram hashing to estimator","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/pull/1811","RelatedDescription":"Open PR \"Ngram hashing to estimator\" (#1811)"},{"Id":"386506053","IsPullRequest":true,"CreatedAt":"2018-12-03T22:20:56","Actor":"yaeldekel","Number":"1804","RawContent":null,"Title":"Add test coverage for VBuffer","State":"closed","Body":"Add unit tests for VBuffer operations.\r\nFixes #1803 .","Url":"https://github.com/dotnet/machinelearning/pull/1804","RelatedDescription":"Closed or merged PR \"Add test coverage for VBuffer\" (#1804)"},{"Id":"386489059","IsPullRequest":false,"CreatedAt":"2018-12-03T22:20:56","Actor":"yaeldekel","Number":"1803","RawContent":null,"Title":"Bug in ApplyInto() method","State":"closed","Body":"When the result of applying the function is dense, indices might be null, but this is not checked.","Url":"https://github.com/dotnet/machinelearning/issues/1803","RelatedDescription":"Closed issue \"Bug in ApplyInto() method\" (#1803)"},{"Id":"386478969","IsPullRequest":true,"CreatedAt":"2018-12-03T17:56:07","Actor":"TomFinley","Number":"1801","RawContent":null,"Title":"Delete IColumn","State":"closed","Body":"Fixes #1755.\r\n\r\nAt least initially staged as three commits, where we change some places, change the more difficult and rote places like tests and whatnot, then remove everything.","Url":"https://github.com/dotnet/machinelearning/pull/1801","RelatedDescription":"Closed or merged PR \"Delete IColumn\" (#1801)"},{"Id":"386637374","IsPullRequest":false,"CreatedAt":"2018-12-03T02:41:46","Actor":"asthana86","Number":"1806","RawContent":null,"Title":"Usage of Matrix Factorization Trainer for Recommendation ","State":"open","Body":"When using Matrix Factorization Trainer:\r\n\r\n ```csharp\r\nvar trainer = mlcontext.Recommendation().Trainers.MatrixFactorization\r\n                                                     (\"userIdEncoded\", \"movieIdEncoded\", \"rating\"));\r\n```\r\nWhen using other trainers:\r\n\r\n ```csharp\r\nvar trainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent\r\n                                                       (label: \"Label\", features: \"Features\");\r\n``` \r\n\r\nIs the difference in usage prop vs. method by design? Also there is a difference in the order of parameters being passed. First parameter is Label vs. Features being used. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/1806","RelatedDescription":"Open issue \"Usage of Matrix Factorization Trainer for Recommendation \" (#1806)"},{"Id":"386508048","IsPullRequest":true,"CreatedAt":"2018-12-02T15:54:15","Actor":"yaeldekel","Number":"1805","RawContent":null,"Title":"Calibrator trainer needs to clear data before retraining","State":"closed","Body":"This caused an incorrect calibrator to be trained in OVA and PKPD, since these trainers use the same ICalibratorTrainer to train multiple calibrators.\r\nFixes #1387 .","Url":"https://github.com/dotnet/machinelearning/pull/1805","RelatedDescription":"Closed or merged PR \"Calibrator trainer needs to clear data before retraining\" (#1805)"},{"Id":"386487666","IsPullRequest":false,"CreatedAt":"2018-12-01T19:13:11","Actor":"yaeldekel","Number":"1802","RawContent":null,"Title":"SSE bug when scaling a vector by a negative number","State":"open","Body":"When the number of elements is not divisible by 4, the sign of the result sometimes wrong.\r\nHere is an explanation from @eerhardt .\r\n\r\nWe are “double computing” at the end of the vector when there are remaining elements (1, 2, or 3 hanging elements). We then mask out the “double computed” elements in temp (which should have all 0s for the ‘double computed’ elements).\r\n\r\nHowever, when doing `temp = _mm_mul_ps(temp, x1);`, since ‘x1’ is negative, multiplying the 0s in temp against a negative number is turning them into -0 (negative zero).\r\n\r\nWe then `_mm_or_ps(temp, result);` which then switches the sign of the ‘double computed’ elements – which is incorrect.\r\n\r\nSo that’s why some of the elements are getting the wrong sign. Because we are OR’ing them with negative zero, which changes the sign.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1802","RelatedDescription":"Open issue \"SSE bug when scaling a vector by a negative number\" (#1802)"},{"Id":"386443439","IsPullRequest":false,"CreatedAt":"2018-12-01T09:57:43","Actor":"asthana86","Number":"1800","RawContent":null,"Title":"Simpler Scenario Focused (getting started API) for ML.NET","State":"open","Body":"ML.NET is a machine learning framework focused on bringing .NET developers to the world of machine learning. Given the complexity of machine learning there are a number of concepts for developers to get familiar with before becoming successful right from the get-go.  \r\n\r\nIs there a way to provide a more templated/recipe-driven scenario focused set of API which represent common machine learning task for developers like Recommendation, Sentiment Analysis, Forecasting, Image Classification etc. This can help them get started quickly and progressively graduate to machine learning using the Dynamic API guarenting both short-term and long term success with ML. \r\n\r\ne.g. (Recommendation: Just a quick ugly mockup)\r\n\r\nCurrently for the recommendation scenario for Matrix Factorization the input feature are limited to UserId, OrderId, Rating or for co-purchase scenarios limited to UserId, OrderId. Given the nature of these features the transforms (categorical) and trainers (Matrix Factorization/One Class Matrix Factorization) are somewhat pre-known. \r\n\r\nIs it potentially possible to simplify the API to as follows:\r\n\r\n            //STEP 1: Create MLContext to be shared across the model creation workflow objects \r\n            var mlcontext = new MLContext();\r\n\r\n            //STEP 2: Create a reader by defining the schema for reading the movie recommendation datasets\r\n            var reader = mlcontext.Data.TextReader(new TextLoader.Arguments()\r\n            {\r\n                Separator = \"tab\",\r\n                HasHeader = true,\r\n                Column = new[]\r\n                {\r\n                    new TextLoader.Column(\"userId\", DataKind.Text, 0),\r\n                    new TextLoader.Column(\"movieId\", DataKind.Text, 1),\r\n                    new TextLoader.Column(\"Rating\", DataKind.R4, 2)\r\n                }\r\n            });\r\n\r\n            //STEP 3: Read in training data \r\n            var trainingDataView = reader.Read(new MultiFileSource(TrainingDataLocation));\r\n\r\n            //STEP 4: Create default Recommendtion model \r\n            var model = mlcontext.CreateRecommendationModel(trainingDataView);\r\n\r\n            //STEP 5: Read in test data \r\n            var testDataView = reader.Read(new MultiFileSource(TestDataLocation));\r\n\r\n            //STEP 6: Use Recommendation model to evaluate performance of test data \r\n            var prediction = model.Transform(testDataView);\r\n            var metrics = model.Evaluate(prediction, label: \"Label\", score: \"Score\");\r\n\r\nThis for getting started purposes avoids .NET developers to necessarily dive into understanding the concept of estimators, transforms, choice of learners etc. \r\n\r\n  var pipeline = mlcontext.Transforms.Categorical.MapValueToKey(\"userId\", \"userIdEncoded\")\r\n                                    .Append(mlcontext.Transforms.Categorical.MapValueToKey(\"movieId\", \"movieIdEncoded\")\r\n                                    .Append(new MatrixFactorizationTrainer(mlcontext, \"Label\", \"userIdEncoded\", \"movieIdEncoded\")));\r\n\r\nOther ML Frameworks focused on developers and AutoML approaches out there provide a simpler set of APIs targeting developers already. Is there something we can learn on that front given ML.NET already has some AutoML smarts based upon the static rule based engine. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1800","RelatedDescription":"Open issue \"Simpler Scenario Focused (getting started API) for ML.NET\" (#1800)"},{"Id":"386441449","IsPullRequest":false,"CreatedAt":"2018-12-01T09:26:48","Actor":"asthana86","Number":"1799","RawContent":null,"Title":"Logging and Tracing in ML.NET","State":"open","Body":"In EntityFramework there exists a context log property which allows for logging SQL generated by dbcontext.\r\n\r\nFor MLContext is there a similar log property which allows for logging some of the diags currently printed to Console when using various transforms or learners? Additionally is there a way to control log location and verbosity? \r\n\r\n**_E.g.: When using Matrix Factorization:_** \r\nSample: https://github.com/dotnet/machinelearning-samples/blob/master/samples/csharp/getting-started/MatrixFactorization_MovieRecommendation/MovieRecommendation/Program.cs\r\n\r\n=============== Training the model ===============\r\niter   tr_rmse          obj\r\n   0    0.0002   4.8456e+02\r\n   1    0.0002   7.8940e+02\r\n   2    0.0002   1.1160e+03\r\n   3    0.0002   1.2787e+03\r\n   4    0.0002   1.6045e+03\r\n   5    0.0002   2.0909e+03\r\n   6    0.0002   2.5788e+03\r\n   7    0.0002   2.9040e+03\r\n   8    0.0002   3.2300e+03\r\n   9    0.0002   3.2758e+03\r\n  10    0.0001   2.8742e+03\r\n  11    0.0001   2.5185e+03\r\n  12    0.0000   2.0396e+03\r\n  13    0.0000   1.9213e+03\r\n  14    0.0000   1.6839e+03\r\n  15    0.0000   1.3291e+03\r\n  16    0.0000   1.2107e+03\r\n  17    0.0000   9.7367e+02\r\n  18    0.0000   9.7325e+02\r\n  19    0.0000   9.7242e+02\r\nreal tr_rmse = 0.0000\r\n\r\nEF provides the following to users:\r\n\r\n**Output directly to console:**\r\nusing (var context = new YourDbContext()) \r\n{ \r\n    context.Database.Log = Console.Write; \r\n     // rest of you code goes here... \r\n}\r\n\r\n**_Log output to the trace window_**\r\nusing (var context = new YourDbContext()) \r\n{ \r\n    context.Database.Log = message => Trace.Write(message);\r\n    // rest of you code goes here\r\n}\r\n\r\n**_Already have a logging framework in place_**\r\nusing Common.Logging;\r\n\r\npublic class SomeClass\r\n{\r\n    private static readonly ILog log = LogManager.GetCurrentClassLogger();\r\n\r\n    public void SomeMethod()\r\n    {\r\n        context.Database.Log = message => log.Debug(message);\r\n    }\r\n}\r\n\r\nThanks. \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1799","RelatedDescription":"Open issue \"Logging and Tracing in ML.NET\" (#1799)"},{"Id":"386392122","IsPullRequest":false,"CreatedAt":"2018-11-30T23:53:47","Actor":"TomFinley","Number":"1798","RawContent":null,"Title":"Creation of components through MLContext: advanced options and other feedback","State":"open","Body":"In our estimators and other similar components often have advanced settings, because, sometimes people have unusual circumstances. At the same time, there is a 95% or 99% scenario for \"simple\" usage that most people will be happy with. For this reason we have often made a distinction between common and advanced settings, as we see here.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/cb37c7e7f1e1b29b5608a2755db793c5435d10b1/src/Microsoft.ML.FastTree/TreeTrainersCatalog.cs#L29-L38\r\n\r\nThere are some possible things that excited feedback:\r\n\r\n1. Echoing feedback seen in #1690, these things where we're making something should have the prefix `Create`, even in situations where this a catalog where we are *always* creating. Note: `Create` preferred to `Make`.\r\n\r\n2. The worth of ASP.NET style configuration was questioned (seen above as `Action<FastTreeRegressionTrainer.Arguments> advancedSettings`), e.g., there may not be much purpose in having a delegate. The older style where it just takes the `Arguments` *period* was preferred.\r\n\r\n3. Having this `Arguments` object as a nested class the component being created was viewed as positive, but this would be more idiomatically called `Options` -- `Arguments` was a holdover name from when these were exclusively for command line arguments, but for the API this is not a great name. So while keeping the general structure of how they are placed currently, they should probably be renamed to `Options`.\r\n\r\n4. It is good to have the convenience for the simple arguments, however, if we have both simple and advanced settings, we should not mix them but have instead two distinct constructors/extension methods. (E.g., in the above, we would have two methods, one that took the advanced options.) To do otherwise is to invite confusion about which \"wins\" if we have the setting set in both.\r\n\r\n    * Note that phase setting \"set in both,\" which suggests that these settings object should retain the \"simpler\" settings in them. This reinforces feedback elsewhere as seen [here](https://github.com/dotnet/machinelearning/pull/1352#discussion_r228319239).\r\n\r\n5. If the simple arguments are totally sufficient, then there is no need to expose this `Arguments` class in hte public API. (For practical reasons relating to command line and entry-point usage, we still need to always have these `Arguments` objects, but if they serve no purpose for the API the class can simply be made internal.)\r\n\r\n/cc @KrzysztofCwalina, @terrajobst , on whose feedback this list is primarily based, and who can correct me and provide clarification in case I misspoke.","Url":"https://github.com/dotnet/machinelearning/issues/1798","RelatedDescription":"Open issue \"Creation of components through MLContext: advanced options and other feedback\" (#1798)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-12-05T05:30:55.9275164Z","RunDurationInMilliseconds":1298}