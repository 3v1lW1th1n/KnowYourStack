{"Data":{"GitHub":{"Issues":[{"Id":"394840153","IsPullRequest":false,"CreatedAt":"2018-12-30T02:15:28","Actor":"AlexeiScherbakov","Number":"225","RawContent":null,"Title":"Visual Studio 2017 .NET Core 3.0 debugger conflict with intellitrace","State":"open","Body":"* .NET Core Version: 3.0.0-preview-27122-01 (SDK 3.0.100-preview-009812) \r\n* Windows version: Windows 10 x64 1803 (17134.472)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n \r\nWhen:\r\n\r\n1. Intellitrace is enabled\r\n2. Debugging of .NET Core 3.0 WPF App\r\n3. Click on button on second window shown as dialog\r\n\r\nVisual Studio 2017 (15.9.4)  debugger process (msvsmon.exe) exits unexpectedly and debug session is terminated with started application.\r\n\r\nWhen application is started via .exe file it works normally.\r\nWhen application is started in Visual Studio version without Intellitrace, or Intellitrace is explicitly disabled - all works normal\r\n \r\n","Url":"https://github.com/dotnet/wpf/issues/225","RelatedDescription":"Open issue \"Visual Studio 2017 .NET Core 3.0 debugger conflict with intellitrace\" (#225)"},{"Id":"394794203","IsPullRequest":true,"CreatedAt":"2018-12-29T13:08:04","Actor":"dotnet-maestro[bot]","Number":"224","RawContent":null,"Title":"Update dependency files","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\nUpdates from https://github.com/dotnet/arcade\r\n\r\n- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18627.1\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/224","RelatedDescription":"Closed or merged PR \"Update dependency files\" (#224)"},{"Id":"394789612","IsPullRequest":false,"CreatedAt":"2018-12-29T11:58:38","Actor":"anirudhagupta","Number":"223","RawContent":null,"Title":"Will Visual Studio 2019 will be based on .net core 3 ?","State":"open","Body":"* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`)\r\n* Windows version: (`winver`)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n \r\n **Expected behaviour:**\r\n \r\n **Minimal repro:**\r\n \r\n I hear @coolcsh saying that we have used it internally and it's run quite well. It improves the performance of the overall app. WPF in .net core 3 is not going to Support Linux and Mac so there should not be a lot of trouble. They need to make it work on windows.\r\n\r\nSo upcoming Visual Studio will be based on .net framework or .net core 3.\r\n","Url":"https://github.com/dotnet/wpf/issues/223","RelatedDescription":"Open issue \"Will Visual Studio 2019 will be based on .net core 3 ?\" (#223)"},{"Id":"394389520","IsPullRequest":true,"CreatedAt":"2018-12-27T13:08:22","Actor":"dotnet-maestro[bot]","Number":"221","RawContent":null,"Title":"Update dependency files","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\nUpdates from https://github.com/dotnet/arcade\r\n\r\n- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18621.6\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/221","RelatedDescription":"Closed or merged PR \"Update dependency files\" (#221)"},{"Id":"394496857","IsPullRequest":false,"CreatedAt":"2018-12-27T05:57:53","Actor":"stdcppdev","Number":"222","RawContent":null,"Title":"Default WPF project self-contained application cannot run on a pure windows 7 SP1","State":"open","Body":"\r\n# Default WPF project self-contained application cannot run on a pure windows 7 SP1\r\nHi all,\r\nI am a WPF app developer and I'm trying to deploy the net core 3.0 wpf app to Windows 7 but it failed.\r\n\r\n# Reproduction Steps\r\n1. Install .NET Core v3.0.0-preview-27122-01\r\n2. use the command line \"dotnet new wpf -o C:\\test_wpf\" to create an WPF project.\r\n3. use the command line \"dotnet publish -c Release --self-contained\" to publish.\r\n4. copy the published folder to a new installed pure Windows 7 machine.\r\n5. Install KB2533623 / KB2999226 follow the doc\r\n    https://docs.microsoft.com/en-us/dotnet/core/windows-prerequisites?tabs=netcore2x\r\n6. Run the application and nothing happened. the exe start and then it ends after a few seconds.","Url":"https://github.com/dotnet/wpf/issues/222","RelatedDescription":"Open issue \"Default WPF project self-contained application cannot run on a pure windows 7 SP1\" (#222)"},{"Id":"394224375","IsPullRequest":true,"CreatedAt":"2018-12-26T19:06:21","Actor":"hughbe","Number":"220","RawContent":null,"Title":" Fix NullReferenceException in XamlType.Equals/XamlType.GetHashCode","State":"open","Body":"Fixes https://github.com/dotnet/wpf/issues/217\r\n\r\nThe issue here is that `XamlType._namespaces` can actually be null, for example when a `XamlType` is constructed using the `XamlType(string typeName, IList<XamlType> typeArguments, XamlSchemaContext schemaContext` constructor","Url":"https://github.com/dotnet/wpf/pull/220","RelatedDescription":"Open PR \" Fix NullReferenceException in XamlType.Equals/XamlType.GetHashCode\" (#220)"},{"Id":"394223146","IsPullRequest":false,"CreatedAt":"2018-12-26T18:58:19","Actor":"livarcocc","Number":"219","RawContent":null,"Title":"PresentationFramework.Aero not included by default when compiling against .NET Framework","State":"open","Body":"@twsouthwick commented on [Wed Nov 28 2018](https://github.com/dotnet/sdk/issues/2703)\n\nI'm porting an app that relies on `PresentationFramework.Aero` for `ButtonChrome` and found I need to include the following in the csproj to get it to compile when building for .NET Framework 4.7.1:\r\n\r\n```xml\r\n  <ItemGroup Condition=\" '$(TargetFramework)' == 'net471'\">\r\n    <Reference Include=\"PresentationFramework.Aero\" />\r\n  </ItemGroup\r\n```\r\n\r\nIs there a reason this isn't automatically included when setting `<UseWindowsForms>true</UseWindowsForms>`?\n\n---\n\n@livarcocc commented on [Wed Nov 28 2018](https://github.com/dotnet/sdk/issues/2703#issuecomment-442659308)\n\nFrom talking to @rladuca it seems like this is not added by default for non-sdk based projects either. So, it seems like we are keeping with the current behavior.\r\n\r\nAlso, this is a WPF theme, so I am not sure how it relates to `UseWindowsForms` flag, as that is for WinForms and not WPF.\n\n---\n\n@rladuca commented on [Wed Nov 28 2018](https://github.com/dotnet/sdk/issues/2703#issuecomment-442660748)\n\nThat's correct, the set of binaries that are referenced when you make a new desktop framework WPF application do not include PresentationFramework.Aero.  This is also not referenced from a new Windows Forms application.\r\n\r\nAdding the reference manually seems to be entirely appropriate.\r\n\r\n@twsouthwick Are you saying that compiling for netcoreapp3.0 does automatically reference PresentationFramework.Aero?\n\n---\n\n@twsouthwick commented on [Wed Nov 28 2018](https://github.com/dotnet/sdk/issues/2703#issuecomment-442687337)\n\nSorry for the confusion - I meant `<UseWPF>true</UseWPF>`. The project has both of them and copied the first one I have.\r\n\r\n@rladuca The project compiles fine for netcoreapp3.0, but now that I'm looking at it, it doesn't reference `PresentationFramework.Aero`. The file that references the aero library is here: https://github.com/twsouthwick/HandBrake/blob/netcore/win/CS/HandBrakeWPF/Themes/Generic.xaml.\n\n","Url":"https://github.com/dotnet/wpf/issues/219","RelatedDescription":"Open issue \"PresentationFramework.Aero not included by default when compiling against .NET Framework\" (#219)"},{"Id":"394220960","IsPullRequest":false,"CreatedAt":"2018-12-26T18:43:43","Actor":"hughbe","Number":"218","RawContent":null,"Title":"[Discussion/Cleanup] Can we remove ThreeValuedBool in favor of `bool?`","State":"open","Body":"Simple really!","Url":"https://github.com/dotnet/wpf/issues/218","RelatedDescription":"Open issue \"[Discussion/Cleanup] Can we remove ThreeValuedBool in favor of `bool?`\" (#218)"},{"Id":"394220436","IsPullRequest":false,"CreatedAt":"2018-12-26T18:40:53","Actor":"hughbe","Number":"217","RawContent":null,"Title":"XamlType.Equals/XamlType.GetHashCode throws NullReferenceException for types without namespaces","State":"open","Body":"Example:\r\n```cs\r\n\r\npublic static IEnumerable<object[]> Equals_TestData()\r\n{\r\n    var type = new XamlType(typeof(int), new XamlSchemaContext());\r\n    yield return new object[] { type, type, true };\r\n    yield return new object[] { type, new XamlType(typeof(int), new XamlSchemaContext()), true };\r\n    yield return new object[] { type, new XamlType(typeof(string), new XamlSchemaContext()), false };\r\n    yield return new object[] { type, new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), false };\r\n    yield return new object[] { type, new SubXamlType(\"name\", null, new XamlSchemaContext()), false };\r\n\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), true };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()), true };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), new XamlType(\"otherNamespace\", \"name\", null, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), new XamlType(\"namespace\", \"otherName\", null, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(string), new XamlSchemaContext()) }, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()), new XamlType(typeof(string), new XamlSchemaContext()) }, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(string), new XamlSchemaContext()) }, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()), new XamlType(typeof(string), new XamlSchemaContext()) }, new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), new XamlType(typeof(int), new XamlSchemaContext()), false };\r\n    yield return new object[] { new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), new SubXamlType(\"name\", null, new XamlSchemaContext()), false };\r\n\r\n    yield return new object[] { new SubXamlType(\"name\", null, new XamlSchemaContext()), new SubXamlType(\"name\", null, new XamlSchemaContext()), true };\r\n    yield return new object[] { new SubXamlType(\"name\", null, new XamlSchemaContext()), new SubXamlType(\"otherName\", null, new XamlSchemaContext()), false };\r\n    yield return new object[] { new SubXamlType(\"name\", null, new XamlSchemaContext()), new XamlType(typeof(int), new XamlSchemaContext()), false };\r\n    yield return new object[] { new SubXamlType(\"name\", null, new XamlSchemaContext()), new XamlType(\"namespace\", \"name\", null, new XamlSchemaContext()), false };\r\n\r\n    yield return new object[] { type, null, false };\r\n    yield return new object[] { type, new object(), false };\r\n    yield return new object[] { null, type, false };\r\n    yield return new object[] { null, null, true };\r\n}\r\n\r\n[Theory]\r\n[MemberData(nameof(Equals_TestData))]\r\npublic void Equals_Invoke_ReturnsExpected(XamlType type, object obj, bool expected)\r\n{\r\n    XamlType other = obj as XamlType;\r\n    if (type != null)\r\n    {\r\n        Assert.Equal(expected, type.Equals(obj));\r\n        Assert.Equal(expected, type.Equals(other));\r\n    }\r\n\r\n    Assert.Equal(expected, type == other);\r\n    Assert.Equal(!expected, type != other);\r\n}\r\n\r\npublic static IEnumerable<object[]> GetHashCode_TestData()\r\n{\r\n    yield return new object[] { new XamlType(\"name\", \"namespace\", null, new XamlSchemaContext()) };\r\n    yield return new object[] { new XamlType(\"name\", \"namespace\", new XamlType[] { new XamlType(typeof(int), new XamlSchemaContext()) }, new XamlSchemaContext()) };\r\n    yield return new object[] { new XamlType(typeof(int), new XamlSchemaContext()) };\r\n    yield return new object[] { new SubXamlType(\"typeName\", null, new XamlSchemaContext()) };\r\n    yield return new object[] { new NoUnderlyingOrBaseType() };\r\n}\r\n\r\n[Theory]\r\n[MemberData(nameof(GetHashCode_TestData))]\r\npublic void GetHashCode_Invoke_ReturnsExpected(XamlType type)\r\n{\r\n    Assert.Equal(type.GetHashCode(), type.GetHashCode());\r\n}\r\npublic class SubXamlType : XamlType\r\n{\r\n    public SubXamlType(string unknownTypeNamespace, string unknownTypeName, IList<XamlType> typeArguments, XamlSchemaContext schemaContext) : base(unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext) { }\r\n\r\n    public SubXamlType(Type underlyingType, XamlSchemaContext schemaContext) : base(underlyingType, schemaContext) { }\r\n\r\n    public SubXamlType(string typeName, IList<XamlType> typeArguments, XamlSchemaContext schemaContext) : base(typeName, typeArguments, schemaContext) { }\r\n}\r\n```\r\n\r\n- Expected: returns `expected`\r\n- Actual: throws `NullReferenceException` (release) or asserts (debug)","Url":"https://github.com/dotnet/wpf/issues/217","RelatedDescription":"Open issue \"XamlType.Equals/XamlType.GetHashCode throws NullReferenceException for types without namespaces\" (#217)"},{"Id":"394213522","IsPullRequest":false,"CreatedAt":"2018-12-26T17:55:26","Actor":"hughbe","Number":"216","RawContent":null,"Title":"XamlTypeInvoker.UnknownInvoker.GetEnumeratorMethod throws NullReferenceException","State":"open","Body":"Example:\r\n\r\n```cs\r\n[Fact]\r\npublic void GetEnumeratorMethod_Unknown_ThrowsNullReferenceException()\r\n{\r\n    XamlTypeInvoker invoker = XamlTypeInvoker.UnknownInvoker;\r\n    Assert.Throws<NullReferenceException>(() => invoker.GetEnumeratorMethod());\r\n}\r\n```\r\n\r\n- Expected: returns `null`, matching behaviour with `GetAddMethod()`\r\n- Actual: throws `NullReferenceException`","Url":"https://github.com/dotnet/wpf/issues/216","RelatedDescription":"Open issue \"XamlTypeInvoker.UnknownInvoker.GetEnumeratorMethod throws NullReferenceException\" (#216)"},{"Id":"394212258","IsPullRequest":true,"CreatedAt":"2018-12-26T17:46:54","Actor":"hughbe","Number":"215","RawContent":null,"Title":" Fix NullReferenceException in `new ContentWrapperAttribute(null).GetHashCode`","State":"open","Body":"Fixes https://github.com/dotnet/wpf/issues/212","Url":"https://github.com/dotnet/wpf/pull/215","RelatedDescription":"Open PR \" Fix NullReferenceException in `new ContentWrapperAttribute(null).GetHashCode`\" (#215)"},{"Id":"394211747","IsPullRequest":true,"CreatedAt":"2018-12-26T17:43:36","Actor":"hughbe","Number":"214","RawContent":null,"Title":"Fix NRE in XamlLoadPermission.FromXml for element without `class` attribute","State":"open","Body":"Fixes https://github.com/dotnet/wpf/issues/213","Url":"https://github.com/dotnet/wpf/pull/214","RelatedDescription":"Open PR \"Fix NRE in XamlLoadPermission.FromXml for element without `class` attribute\" (#214)"},{"Id":"394209581","IsPullRequest":false,"CreatedAt":"2018-12-26T17:29:33","Actor":"hughbe","Number":"213","RawContent":null,"Title":"XamlLoadPermission.FromXml for element without `class` attribute throws NRE","State":"open","Body":"```cs\r\n[Fact]\r\npublic void FromXml_NoClassAttribute_ThrowsNullReferenceException()\r\n{\r\n    var permission = new XamlLoadPermission(PermissionState.None);\r\n    var elem = new SecurityElement(\"IPermission\");\r\n    permission.FromXml(elem);\r\n}\r\n```\r\n\r\n- Expected: throws `ArgumentException` to match other parse failures\r\n- Actual: throws `NullReferenceException`!\r\n\r\n## Cause\r\n\r\n```cs\r\n\r\npublic override void FromXml(SecurityElement elem)\r\n{\r\n    if (elem == null)\r\n    {\r\n        throw new ArgumentNullException(nameof(elem));\r\n    }\r\n    if (elem.Tag != XmlConstants.IPermission)\r\n    {\r\n        throw new ArgumentException(SR.Get(SRID.SecurityXmlUnexpectedTag, elem.Tag, XmlConstants.IPermission), nameof(elem));\r\n    }\r\n\r\n    string className = elem.Attribute(XmlConstants.Class);\r\n    if (!className.StartsWith(GetType().FullName, false, TypeConverterHelper.InvariantEnglishUS))\r\n    {\r\n        throw new ArgumentException(SR.Get(SRID.SecurityXmlUnexpectedValue, className, XmlConstants.Class, GetType().FullName), nameof(elem));\r\n    }\r\n```\r\n\r\nProblem:\r\n```cs\r\nstring className = elem.Attribute(XmlConstants.Class);\r\nif (!className.StartsWith(GetType().FullName, false, TypeConverterHelper.InvariantEnglishUS))\r\n```\r\nThe `className` can be null! ","Url":"https://github.com/dotnet/wpf/issues/213","RelatedDescription":"Open issue \"XamlLoadPermission.FromXml for element without `class` attribute throws NRE\" (#213)"},{"Id":"394209010","IsPullRequest":false,"CreatedAt":"2018-12-26T17:25:47","Actor":"hughbe","Number":"212","RawContent":null,"Title":"new ContentWrapperAttribute(null).GetHashCode() throws NRE","State":"open","Body":"```cs\r\n[Fact]\r\npublic void GetHashCode_NullContentWrapper_ThrowsNullReferenceException()\r\n{\r\n    var attribute = new ContentWrapperAttribute(null);\r\n    Assert.Throws<NullReferenceException>(() => attribute.GetHashCode());\r\n}\r\n```\r\n\r\nFrom https://blogs.msdn.microsoft.com/ericlippert/2011/02/28/guidelines-and-rules-for-gethashcode/:\r\n> Rule: GetHashCode must never throw an exception, and must return\r\n\r\n> Getting a hash code simply calculates an integer; there's no reason why it should ever fail. An implementation of GetHashCode should be able to handle any legal configuration of the object.\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/212","RelatedDescription":"Open issue \"new ContentWrapperAttribute(null).GetHashCode() throws NRE\" (#212)"},{"Id":"394208334","IsPullRequest":true,"CreatedAt":"2018-12-26T17:21:28","Actor":"hughbe","Number":"211","RawContent":null,"Title":"Fix bug in `XamlTypeInvoker.GetAddMethod` if there is no such match","State":"open","Body":"Example code:\r\n```cs\r\n[Fact]\r\npublic void GetAddMethod_NoSuchContentType_ReturnsNull()\r\n{\r\n    var invoker = new XamlTypeInvoker(new XamlType(typeof(List<int>), new XamlSchemaContext()));\r\n    var type = new XamlType(typeof(string), new XamlSchemaContext());\r\n    Assert.Null(invoker.GetAddMethod(type));\r\n};\r\n```\r\n\r\nThere is one main bug underlying this: `XamlType.AllowedContentTypes` contains the `XamlType.ItemType` already and we add this to the array here:\r\n```cs\r\npublic virtual MethodInfo GetAddMethod(XamlType contentType)\r\n{\r\n    if (contentType == null)\r\n    {\r\n        throw new ArgumentNullException(nameof(contentType));\r\n    }\r\n    if (IsUnknown || _xamlType.ItemType == null)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // Common case is that we match the item type. Short-circuit any additional lookup.\r\n    if (contentType == _xamlType.ItemType ||\r\n        (_xamlType.AllowedContentTypes.Count == 1 && contentType.CanAssignTo(_xamlType.ItemType)))\r\n    {\r\n        return _xamlType.AddMethod;\r\n    }\r\n\r\n    // Only collections can have additional content types\r\n    if (!_xamlType.IsCollection)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // Populate the dictionary of all available Add methods\r\n    MethodInfo addMethod;\r\n    if (_addMethods == null)\r\n    {\r\n        var addMethods = new Dictionary<XamlType, MethodInfo>();\r\n        addMethods.Add(_xamlType.ItemType, _xamlType.AddMethod);\r\n        foreach (XamlType type in _xamlType.AllowedContentTypes)\r\n        {\r\n             addMethod = CollectionReflector.GetAddMethod(_xamlType.UnderlyingType, type.UnderlyingType);\r\n             if (addMethod != null)\r\n            {\r\n                addMethods.Add(type, addMethod);\r\n            }\r\n            _addMethods = addMethods;\r\n    }\r\n    // First try the fast path. Look for an exact match.\r\n    if (_addMethods.TryGetValue(contentType, out addMethod))\r\n    {\r\n        return addMethod;\r\n    }\r\n\r\n    // Next the slow path. Check each one for is assignable from.\r\n    foreach (KeyValuePair<XamlType, MethodInfo> pair in _addMethods)\r\n    {\r\n        if (contentType.CanAssignTo(pair.Key))\r\n        {\r\n            return pair.Value;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\nTherefore, use `Dictionary.TryAdd` to avoid throwing if there is more than one value. I opted to change this to `TryAdd` rather than removing `addMethods.Add(_xamlType.ItemType, _xamlType.AddMethod);`, as firstly a user can override `LookupContentWrappers` so removing this value could be breaking, and secondly because `ContentWrappers` could contain duplicate types which could throw anyway previously\r\n\r\nFixes #210 \r\nAlso fixes #216","Url":"https://github.com/dotnet/wpf/pull/211","RelatedDescription":"Open PR \"Fix bug in `XamlTypeInvoker.GetAddMethod` if there is no such match\" (#211)"},{"Id":"394207742","IsPullRequest":false,"CreatedAt":"2018-12-26T17:17:26","Actor":"hughbe","Number":"210","RawContent":null,"Title":"XamlTypeInvoker.GetAddMethod throws ArgumentException if there is no matching type - it shouldn't","State":"open","Body":"Example code:\r\n```cs\r\n[Fact]\r\npublic void GetAddMethod_NoSuchContentType_ReturnsNull()\r\n{\r\n    var invoker = new XamlTypeInvoker(new XamlType(typeof(List<int>), new XamlSchemaContext()));\r\n    var type = new XamlType(typeof(string), new XamlSchemaContext());\r\n    Assert.Null(invoker.GetAddMethod(type));\r\n};\r\n```\r\n\r\nExpected: we return null\r\nActual: we throw an `ArgumentException` for duplicate value in a dictionary","Url":"https://github.com/dotnet/wpf/issues/210","RelatedDescription":"Open issue \"XamlTypeInvoker.GetAddMethod throws ArgumentException if there is no matching type - it shouldn't\" (#210)"},{"Id":"393669865","IsPullRequest":true,"CreatedAt":"2018-12-26T16:39:49","Actor":"deanchalk","Number":"200","RawContent":null,"Title":"Null check missing before calling a method marked with 'NotNull' attribute","State":"closed","Body":"Was looking through the code and noticed a missing null check where the method to be called is marked as NotNull","Url":"https://github.com/dotnet/wpf/pull/200","RelatedDescription":"Closed or merged PR \"Null check missing before calling a method marked with 'NotNull' attribute\" (#200)"},{"Id":"393918279","IsPullRequest":false,"CreatedAt":"2018-12-24T18:23:11","Actor":"Symbai","Number":"209","RawContent":null,"Title":"Could not locate icon.ico","State":"open","Body":"* .NET Core Version: 3.0 Preview1\r\n* Windows version: (`Windows 10 64bit`)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n\r\n \r\n **Problem description:**\r\n\r\nException on application start:\r\nIOException: Cannot locate resource 'icon.ico'.\r\n\r\n \r\n **Actual behavior:**\r\n\r\n```\r\nat System.Windows.Markup.XamlReader.RewrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri)\r\n   at System.Windows.Markup.WpfXamlLoader.Load(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, Boolean skipJournaledProperties, Object rootObject, XamlObjectWriterSettings settings, Uri baseUri)\r\n   at System.Windows.Markup.WpfXamlLoader.LoadBaml(XamlReader xamlReader, Boolean skipJournaledProperties, Object rootObject, XamlAccessLevel accessLevel, Uri baseUri)\r\n   at System.Windows.Markup.XamlReader.LoadBaml(Stream stream, ParserContext parserContext, Object parent, Boolean closeStream)\r\n   at System.Windows.Application.LoadComponent(Object component, Uri resourceLocator)\r\n```\r\n\r\n **Expected behavior:**\r\n\r\nStart successfully and accept icon path for window like it does in .NET framework.\r\n \r\n **Minimal repro:**\r\n \r\n1. Create new .NET core 3.0 WPF project\r\n2. Right click on project -> properties -> \"Icon and manifest\" select an .ICO for the application. The selected icon file is now placed into root directory of the project\r\n3. On MainWindow.xaml add this line for window\r\n`Icon=\"icon.ico\"`\r\n\r\n[IconIssue.zip](https://github.com/dotnet/wpf/files/2707672/IconIssue.zip)\r\n","Url":"https://github.com/dotnet/wpf/issues/209","RelatedDescription":"Open issue \"Could not locate icon.ico\" (#209)"},{"Id":"393791320","IsPullRequest":false,"CreatedAt":"2018-12-24T00:27:59","Actor":"albahari","Number":"208","RawContent":null,"Title":"WPF assemblies are incompatible with each other in 3.0.0-alpha-27128-4","State":"open","Body":"* .NET Core Version: 3.0.0-alpha-27128-4\r\n* Windows version: 10.0.17763.0\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n\r\nIn dotnet\\shared\\Microsoft.WindowsDesktop.App\\3.0.0-alpha-27128-4, PresentationCore.dll references System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\r\n\r\nBut the System.Xaml.dll assembly in that folder has a different public key token (31bf3856ad364e35).\r\n \r\nSo when you use Roslyn to compile a WPF app by referencing these assemblies, you end up with errors like this:\r\n\r\nThe type 'IQueryAmbient' is defined in an assembly that is not referenced. You must add a reference to assembly 'System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'. \r\n\r\nI don't these errors in Visual Studio, so I presume Visual Studio must be relying on referencing assemblies drawn from some other place. But as I understand, reference assemblies aren't mandatory. It should still be possible to compile code against real assemblies.","Url":"https://github.com/dotnet/wpf/issues/208","RelatedDescription":"Open issue \"WPF assemblies are incompatible with each other in 3.0.0-alpha-27128-4\" (#208)"},{"Id":"393788825","IsPullRequest":true,"CreatedAt":"2018-12-23T23:45:06","Actor":"hughbe","Number":"207","RawContent":null,"Title":"Cleanup System.Windows.Markup code","State":"open","Body":"All this has been tested against https://github.com/dotnet/wpf/pull/138\r\n\r\nNo functional changes or dead code removal","Url":"https://github.com/dotnet/wpf/pull/207","RelatedDescription":"Open PR \"Cleanup System.Windows.Markup code\" (#207)"},{"Id":"393783517","IsPullRequest":true,"CreatedAt":"2018-12-23T22:01:32","Actor":"hughbe","Number":"206","RawContent":null,"Title":"Remove dead code from XamlNamespace generic parsing","State":"open","Body":"The method `TryGetXamlType(string typeName, Type[] typeArgs)` is only called from `GetXamlType(string typeName, params Type[] typeArgs()` which has the following code\r\n\r\n```cs\r\npublic XamlType GetXamlType(string typeName, params XamlType[] typeArgs)\r\n{\r\n    if (!IsResolved)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    string fallbackName = GetTypeExtensionName(typeName);\r\n    if (typeArgs == null || typeArgs.Length == 0)\r\n    {\r\n        return TryGetXamlType(typeName) ?? TryGetXamlType(fallbackName);\r\n    }\r\n    else\r\n    {\r\n        Type[] clrTypeArgs = ConvertArrayOfXamlTypesToTypes(typeArgs);\r\n        return TryGetXamlType(typeName, clrTypeArgs) ?? TryGetXamlType(fallbackName, clrTypeArgs);\r\n    }\r\n}\r\n```\r\n\r\nTherefore, the `typeArgs` parameter of `TryGetXamlType(string typeName, Type[] typeArgs)` is never null or empty. Therefore the code in `MangleGenericTypeName` is dead and we can collapse this function into the caller!\r\n\r\nI've also snuck in some cleanups that make sense","Url":"https://github.com/dotnet/wpf/pull/206","RelatedDescription":"Open PR \"Remove dead code from XamlNamespace generic parsing\" (#206)"},{"Id":"393759803","IsPullRequest":false,"CreatedAt":"2018-12-23T15:44:56","Actor":"hughbe","Number":"205","RawContent":null,"Title":"XamlSchemaContext.GetXamlType((Type)null) throws NRE","State":"open","Body":"This doesn't match the docs: https://docs.microsoft.com/en-us/dotnet/api/system.xaml.xamlschemacontext.getxamltype?view=netframework-4.7.2#System_Xaml_XamlSchemaContext_GetXamlType_System_Type_\r\n\r\nExample test:\r\n```cs\r\n[Fact]\r\npublic void GetXamlType_NullXamlType_ThrowsNullReferenceException()\r\n{\r\n    var context = new XamlSchemaContext();\r\n    Assert.Throws<NullReferenceException>(() => context.GetXamlType((Type)null));\r\n}\r\n```\r\n\r\nProblematic code:\r\n```cs\r\npublic virtual XamlType GetXamlType(Type type)\r\n{\r\n    return GetXamlType(type, XamlLanguage.TypeAlias(type)); // <-- NRE thrown in TypeAlias\r\n}\r\n\r\ninternal XamlType GetXamlType(Type type, string alias)\r\n{\r\n    if (type == null)\r\n    {\r\n        throw new ArgumentNullException(nameof(type));\r\n    }\r\n    XamlType xamlType = null;\r\n    if (!MasterTypeList.TryGetValue(type, out xamlType))\r\n    {\r\n        xamlType = new XamlType(alias, type, this, null, null);\r\n        xamlType = TryAdd(MasterTypeList, type, xamlType);\r\n    }\r\n    return xamlType;\r\n}\r\n```\r\n\r\nShould the code be updated, or the docs? I can fix the code if requested!","Url":"https://github.com/dotnet/wpf/issues/205","RelatedDescription":"Open issue \"XamlSchemaContext.GetXamlType((Type)null) throws NRE\" (#205)"},{"Id":"393750506","IsPullRequest":true,"CreatedAt":"2018-12-23T13:36:47","Actor":"hughbe","Number":"204","RawContent":null,"Title":"Remove unused parameter from ClrNamespaceUriParser","State":"open","Body":"Unused, so we can remove the parameter and delete the corresponding strings","Url":"https://github.com/dotnet/wpf/pull/204","RelatedDescription":"Open PR \"Remove unused parameter from ClrNamespaceUriParser\" (#204)"},{"Id":"393709850","IsPullRequest":true,"CreatedAt":"2018-12-22T23:22:01","Actor":"hughbe","Number":"203","RawContent":null,"Title":"Cleanup TypeConverter replacements","State":"open","Body":"- Delete `DateTimeValueSerializerContext` as it is a) unused in the `DateTimeValueSerializer` base class and it has b) absolutely no functionality - passing `null` will suffice!\r\n- Put `DateTimeOffsetConverter2` in the right namespace\r\n- Light code modernization and cleanup\r\n\r\nxref with https://github.com/dotnet/wpf/pull/200","Url":"https://github.com/dotnet/wpf/pull/203","RelatedDescription":"Open PR \"Cleanup TypeConverter replacements\" (#203)"},{"Id":"393704792","IsPullRequest":true,"CreatedAt":"2018-12-22T21:39:47","Actor":"hughbe","Number":"202","RawContent":null,"Title":"Remove dead consts from KnownStrings","State":"open","Body":"","Url":"https://github.com/dotnet/wpf/pull/202","RelatedDescription":"Open PR \"Remove dead consts from KnownStrings\" (#202)"},{"Id":"393671661","IsPullRequest":true,"CreatedAt":"2018-12-22T13:08:17","Actor":"dotnet-maestro[bot]","Number":"201","RawContent":null,"Title":"Update dependency files","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\nUpdates from https://github.com/dotnet/arcade\r\n\r\n- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18620.7\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/201","RelatedDescription":"Closed or merged PR \"Update dependency files\" (#201)"},{"Id":"393570685","IsPullRequest":true,"CreatedAt":"2018-12-21T20:16:00","Actor":"rladuca","Number":"199","RawContent":null,"Title":"Backing out problematic shared source changes","State":"closed","Body":"Certain changes to shared sources proved to be a problem when integrated into our unpublished sources.  This is due to the fact that analyzers do not have a full picture of what is needed based on the fact that the sources are not published.\r\n\r\n@AndreyAkinshin I had to revert the changes to shared sources caused by #103.  I should have caught this prior to merging, but I am fixing them up now.  The cleanup done in System.Xaml is perfectly fine as no unpublished mirror exists for those files.  However, the Shared directory still contains files used by PresentationBuildTasks (which multi-targets with 4.7.2) and WindowsBase.  Due to this, we can cause build breaks of various kinds in our unpublished sources.  It's more expedient to revert these for now and wait until all code that requires these shared sources can be published.  Apologies for not catching this during the PR review.\r\n\r\n@karelz and @vatsan-madhavan FYI.  We're working on a clarifying statement regarding the shared sources.","Url":"https://github.com/dotnet/wpf/pull/199","RelatedDescription":"Closed or merged PR \"Backing out problematic shared source changes\" (#199)"},{"Id":"393451737","IsPullRequest":true,"CreatedAt":"2018-12-21T13:08:32","Actor":"dotnet-maestro[bot]","Number":"198","RawContent":null,"Title":"Update dependency files","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\nUpdates from https://github.com/dotnet/arcade\r\n\r\n- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18620.6\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/198","RelatedDescription":"Closed or merged PR \"Update dependency files\" (#198)"},{"Id":"393214681","IsPullRequest":false,"CreatedAt":"2018-12-20T21:17:00","Actor":"onovotny","Number":"197","RawContent":null,"Title":"MS.Internal.FontCache.Util' threw an exception. ---> System.UriFormatException: Invalid URI: The format of the URI could not be determined.","State":"open","Body":"From Telemetry\r\n\r\n.NET Core 3.0 Preview 1\r\nWindows 7: Microsoft Windows 6.1.7601 Service Pack 1\r\nlocale: en-US\r\n\r\n\r\n```\r\nSystem.Windows.Markup.XamlParseException: Set property 'System.Windows.ResourceDictionary.DeferrableContent' threw an exception. ---> System.TypeInitializationException: The type initializer for 'System.Windows.FrameworkElement' threw an exception. ---> System.TypeInitializationException: The type initializer for 'System.Windows.Documents.TextElement' threw an exception. ---> System.TypeInitializationException: The type initializer for 'MS.Internal.FontCache.Util' threw an exception. ---> System.UriFormatException: Invalid URI: The format of the URI could not be determined.\r\n   at System.Uri.CreateThis(string uri, bool dontEscape, UriKind uriKind)\r\n   at System.Uri..ctor(string uriString, UriKind uriKind)\r\n   at MS.Internal.FontCache.Util..cctor()\r\n   --- End of inner exception stack trace ---\r\n   at MS.Internal.FontCache.Util.get_Dpi()\r\n   at System.Windows.SystemParameters.get_Dpi()\r\n   at System.Windows.SystemFonts.ConvertFontHeight(int height)\r\n   at System.Windows.SystemFonts.get_MessageFontSize()\r\n   at System.Windows.Documents.TextElement..cctor()\r\n   --- End of inner exception stack trace ---\r\n   at System.Windows.FrameworkElement..cctor()\r\n   --- End of inner exception stack trace ---\r\n   at System.Windows.FrameworkElement.FindResourceFromAppOrSystem(object resourceKey, out object source, bool disableThrowOnResourceNotFound, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference)\r\n   at System.Windows.StaticResourceExtension.FindResourceInAppOrSystem(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference)\r\n   at System.Windows.StaticResourceExtension.FindResourceInEnviroment(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference)\r\n   at System.Windows.StaticResourceExtension.TryProvideValueImpl(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference)\r\n   at System.Windows.StaticResourceExtension.TryProvideValueInternal(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference)\r\n   at System.Windows.ResourceDictionary.SetOptimizedStaticResources(IList<T> staticResources, IServiceProvider serviceProvider, StaticResourceExtension staticResourceWorker)\r\n   at System.Windows.ResourceDictionary.SetKeys(IList<T> keyCollection, IServiceProvider serviceProvider)\r\n   at System.Windows.ResourceDictionary.SetDeferrableContent(DeferrableContent deferrableContent)\r\n   at System.Windows.ResourceDictionary.set_DeferrableContent(DeferrableContent value)\r\n   at System.Windows.Baml2006.WpfSharedBamlSchemaContext+<>c.<Create_BamlProperty_ResourceDictionary_DeferrableContent>b__297_0(object target, object value)\r\n   at System.Windows.Baml2006.WpfKnownMemberInvoker.SetValue(object instance, object value)\r\n   at MS.Internal.Xaml.Runtime.ClrObjectRuntime.SetValue(XamlMember member, object obj, object value)\r\n   at MS.Internal.Xaml.Runtime.ClrObjectRuntime.SetValue(object inst, XamlMember property, object value)\r\n   --- End of inner exception stack trace ---\r\n   at System.Windows.Markup.XamlReader.RewrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri)\r\n   at System.Windows.Markup.WpfXamlLoader.Load(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, bool skipJournaledProperties, object rootObject, XamlObjectWriterSettings settings, Uri baseUri)\r\n   at System.Windows.Markup.WpfXamlLoader.LoadBaml(XamlReader xamlReader, bool skipJournaledProperties, object rootObject, XamlAccessLevel accessLevel, Uri baseUri)\r\n   at System.Windows.Markup.XamlReader.LoadBaml(Stream stream, ParserContext parserContext, object parent, bool closeStream)\r\n   at System.Windows.Application.LoadComponent(object component, Uri resourceLocator)\r\n   at PackageExplorer.App.InitializeComponent() in PackageExplorer\\App.xaml:line 1\r\n   at PackageExplorer.App.Main()\r\n```","Url":"https://github.com/dotnet/wpf/issues/197","RelatedDescription":"Open issue \"MS.Internal.FontCache.Util' threw an exception. ---> System.UriFormatException: Invalid URI: The format of the URI could not be determined.\" (#197)"},{"Id":"393083570","IsPullRequest":true,"CreatedAt":"2018-12-20T15:02:34","Actor":"hughbe","Number":"196","RawContent":null,"Title":"Move files to the right directory","State":"open","Body":"And some minor associated code cleanup","Url":"https://github.com/dotnet/wpf/pull/196","RelatedDescription":"Open PR \"Move files to the right directory\" (#196)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-12-30T05:31:03.5880132Z","RunDurationInMilliseconds":845}