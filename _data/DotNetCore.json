{"Data":{"Blog":{"FeedItems":[{"Title":"Advisory on July 2018 .NET Framework Updates","PublishedOn":"2018-07-21T00:55:00+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"The July 2018 Security and Quality Rollup updates for .NET Framework was released earlier this month. We have received multiple customer reports of applications that fail to start or don&#8217;t run...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/20/advisory-on-july-2018-net-framework-updates/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3632","PublishedOn":"2018-07-19T00:30:16+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"We released the first Early Access build for the .NET Framework 4.8 last month (June-2018) and are happy to announce the next build (3632) for your feedback. This is one of the in-development builds...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/18/announcing-net-framework-4-8-early-access-build-3632/","RawContent":null},{"Title":"IL Linker — Help us build the best experience!","PublishedOn":"2018-07-11T16:44:27+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"We are currently working on the IL Linker and would love to get your feedback. Please fill out the brief survey below and help shape the future of the IL Linker by telling us about your current...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/11/il-linker-help-us-build-the-best-experience/","RawContent":null},{"Title":".NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog","PublishedOn":"2018-07-10T19:03:38+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Today, we are happy to announce the Microsoft .NET Framework 4.7.2 is available on Windows Update, Windows Server Update Services (WSUS) and Microsoft Update (MU) Catalog. This release includes...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-framework-4-7-2-is-available-on-windows-update-wsus-and-mu-catalog/","RawContent":null},{"Title":".NET Core July 2018 Update","PublishedOn":"2018-07-10T17:50:29+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core July 2018 Update. This update includes .NET Core 1.0.12, .NET Core 1.1.9, .NET Core 2.0.9 and .NET Core 2.1.2. Security .NET Core Security Feature Bypass...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-core-july-2018-update/","RawContent":null},{"Title":"Announcing ML.NET 0.3","PublishedOn":"2018-07-09T18:30:19+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Two months ago, at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework for .NET developers. We’ve gotten great feedback so far and would like to thank the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/09/announcing-ml-net-0-3/","RawContent":null},{"Title":"System.IO.Pipelines: High performance IO in .NET","PublishedOn":"2018-07-09T16:02:10+00:00","CommentsCount":37,"FacebookCount":0,"Summary":"System.IO.Pipelines is a new library that is designed to make it easier to do high performance IO in .NET. It&#8217;s a library targeting .NET Standard that works on all .NET implementations....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/07/09/system-io-pipelines-high-performance-io-in-net/","RawContent":null},{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":34,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7951838452","Type":"IssuesEvent","CreatedAt":"2018-07-11T18:28:16","Actor":"Eilon","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/107","RelatedDescription":"Opened issue \"Links to .NET Foundation web site use HTTP instead of HTTPS\" (#107) at dotnet/home","RelatedBody":"It appears that HTTPS works just fine: https://www.dotnetfoundation.org/\r\n\r\nBut the links at these places use HTTP:\r\n1. The link in the header of https://github.com/dotnet/home\r\n2. The link in the header of https://github.com/dotnet\r\n3. Some links in https://github.com/dotnet/home/blob/master/README.md (both to .NET Foundation, and a GitHub link to another project)\r\n\r\nThese links should all change to HTTPS."},{"Id":"7948314683","Type":"IssuesEvent","CreatedAt":"2018-07-11T07:41:25","Actor":"glatzert","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/106","RelatedDescription":"Opened issue \"Updates are not requested from local WSUS\" (#106) at dotnet/home","RelatedBody":"The Team somewhen Mention, that fixes should be installed automatically, if .NET Core is on a Windows Server.\r\nThis seems not to work. What are the prerequisits for this to be working?"},{"Id":"7939112505","Type":"PullRequestEvent","CreatedAt":"2018-07-09T17:43:55","Actor":"slide","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/105","RelatedDescription":"Opened pull request \"Add DLR/IronPython2/IronPython3\" (#105) at dotnet/home","RelatedBody":"Add DLR/IronPython2/IronPython3 to project list."},{"Id":"7896820874","Type":"IssuesEvent","CreatedAt":"2018-06-29T09:52:53","Actor":"tomkerkhove","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/104","RelatedDescription":"Opened issue \"About still mentions CodePlex\" (#104) at dotnet/home","RelatedBody":"About still mentions CodePlex which is now in archive mode.\r\n\r\n![image](https://user-images.githubusercontent.com/4345663/42086259-e0b7d008-7b92-11e8-96c9-02ee61ddc457.png)\r\n\r\nIs this something that I can PR?"},{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7999286881","Type":"IssuesEvent","CreatedAt":"2018-07-21T22:29:06","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/76","RelatedDescription":"Opened issue \"July 2018 .NET Updates\" (#76) at dotnet/announcements","RelatedBody":"# July 2018 .NET Updates\r\n\r\nThe following .NET updates were released in June 2018. This issue will be updated if there are any additional updates during the month.\r\n\r\n## .NET Framework \r\n\r\n* [.NET Framework 4.7.2 is available on Windows Update, WSUS and MU Catalog](https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-framework-4-7-2-is-available-on-windows-update-wsus-and-mu-catalog/)\r\n* [Announcing .NET Framework 4.8 Early Access build 3632](https://blogs.msdn.microsoft.com/dotnet/2018/07/18/announcing-net-framework-4-8-early-access-build-3632/)\r\n* [Advisory on July 2018 .NET Framework Updates](https://blogs.msdn.microsoft.com/dotnet/2018/07/20/advisory-on-july-2018-net-framework-updates/)\r\n\r\n## .NET Core\r\n\r\n* [.NET Core July 2018 Update](https://blogs.msdn.microsoft.com/dotnet/2018/07/10/net-core-july-2018-update/)\r\n\r\n## .NET Core Support Documents\r\n\r\n* [Microsoft Support for .NET Core](https://github.com/dotnet/core/blob/master/microsoft-support.md)\r\n* [.NET Core Supported OS Lifecycle Policy](https://github.com/dotnet/core/blob/master/os-lifecycle-policy.md)\r\n\r\n## Previous Updates\r\n\r\n* [June 2018](https://github.com/dotnet/announcements/issues/75)\r\n* [May 2018](https://github.com/dotnet/announcements/issues/68)\r\n* [April 2018](https://github.com/dotnet/announcements/issues/64)\r\n"},{"Id":"7997769217","Type":"IssuesEvent","CreatedAt":"2018-07-21T00:56:48","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/74","RelatedDescription":"Opened issue \"Advisory on July 2018 .NET Framework Updates\" (#74) at dotnet/announcements","RelatedBody":"# Advisory on July 2018 .NET Framework Updates\r\n\r\nThe [July 2018 Security and Quality Rollup updates for .NET Framework](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8356) was released earlier this month. We have received multiple customer reports of applications that fail to start or don't run correctly after installing the July 2018 update. These reports are specific to applications that initialize a COM component and run with restricted permissions.\r\n\r\nWe have stopped distributing the .NET Framework July 2018 updates on Windows Update and are actively working on fixing and re-shipping this month's updates. If you installed the July 2018 update and have not yet seen any negative behavior, we recommend that you leave your systems as-is but closely monitor them and ensure that you apply upcoming .NET Framework updates.\r\n\r\nAs a team, we regret that this release was shipped with this flaw. This release was tested using our regular and extensive testing process. We discovered while investigating this issue that we have a test hole for the specific combination of COM activation and restricted permissions, including impersonation. We will be mitigating that gap going forward. Again, we are sorry for any inconvenience that this product flaw has caused.\r\n\r\nWe will continue to update this issue and [post](https://blogs.msdn.microsoft.com/dotnet/2018/07/20/advisory-on-july-2018-net-framework-updates/) as we have new information.\r\n\r\nDiscussion\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [microsoft/dotnet #811](https://github.com/Microsoft/dotnet/issues/811)\r\n\r\n## Technical Context\r\n\r\nThe .NET Framework runtime uses the process token to determine whether the process is being run within an elevated context. These system calls can fail if the required process inspection permissions are not present. This causes an “access denied\" error.\r\n\r\n## Workaround\r\n\r\nTemporarily uninstall the [July 2018 Security and Quality Rollup updates for .NET Framework](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8356) to restore functionality until a new update has been released to correct this problem. \r\n\r\n## Symptoms\r\n\r\nA COM component fails to load because of “access denied,” “class not registered,” or “internal failure occurred for unknown reasons” errors. \r\n\r\nThe most commonly reported failure results in the following error message:\r\n\r\n```console\r\nException type: System.UnauthorizedAccessException\r\nMessage: Access is denied. (Exception from HRESULT: 0x80070005 (E_ACCESSDENIED))\r\n```\r\n\r\n### Sharepoint\r\n\r\nWhen users browse to a SharePoint site they may see the following HTTP 403 message:\r\n\r\n```console\r\n\"The Web Site declined to show this webpage\"\r\n```\r\n\r\nThe SharePoint ULS Logs will contain a message like the following:  \r\n\r\n```console\r\nw3wp.exe (0x1894)         0x0B94  SharePoint Foundation  General 0000       High                UnauthorizedAccessException for the request. 403 Forbidden will be returned. Error=An error occurred creating the configuration section handler for system.serviceModel/extensions: Could not load file or assembly <AssemblySignature>  or one of its dependencies. Access is denied. (C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\Config\\machine.config line 180)    \r\n\r\nw3wp.exe (0x1894)         0x0B94  SharePoint Foundation  General b6p2      VerboseEx                Sending HTTP response 403:403 FORBIDDEN.      \r\n\r\nw3wp.exe (0x1894)         0x0B94  SharePoint Foundation  General 8nca       Verbose                Application error when access /, Error=Access is denied. (Exception from HRESULT: 0x80070005 (E_ACCESSDENIED))\r\n```\r\n\r\nWhen crawling a people content source, the request may fail with the following entry logged to the SharePoint ULS Log: \r\n\r\n```console\r\nmssearch.exe (0x118C) 0x203C SharePoint Server Search Crawler:Gatherer Plugin cd11 Warning The start address sps3s://<URLtoSite> cannot be crawled.  Context: Application 'Search_Service_Application', Catalog 'Portal_Content'  Details:  Class not registered   (0x80040154)  \r\n\r\nIIS Hosted Classic ASP calling CreateObject for .NET COM objects may receive error \"ActiveX component can't create object\" \r\n\r\n.NET Application creates instance of .NET COM application within an Impersonation Context may receive error \"0x80040154 (REGDB_E_CLASSNOTREG)\"\r\n```\r\n\r\n### BizTalk Server Administration Console\r\n\r\nBizTalk Server Administration Console fails to launch properly with the following errors: \r\n\r\n```console\r\nAn internal failure occurred for unknown reasons. (WinMgmt) \r\n\r\nProgram Location:  \r\n\r\n   at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) \r\n\r\n   at System.Management.ManagementObject.Get() \r\n\r\n   at Microsoft.BizTalk.SnapIn.Framework.WmiProvider.SelectInstance\r\n```\r\n\r\nUse the following guidance as a workaround:\r\n\r\n* Add “NETWORK SERVICE” to the local Administrators group. \r\n\r\n### IIS with Classic ASP\r\n\r\nIIS Hosted Classic ASP calling CreateObject for .NET COM objects may receive the following error: \"ActiveX component can't create object\". Use the following guidance as a workaround.\r\n\r\n* If your web site uses Anonymous Authentication, change the Web Site Anonymous Authentication credentials to use the \"Application pool identity\"\r\n* If your site uses Basic Authentication, log into the application once as the application pool identity and then create an instance of the .NET COM component. All subsequent activations for that .NET COM component should succeed, for any user.\r\n\r\n### .NET applications using COM and impersonation\r\n\r\n.NET Applications that creates instances of .NET COM application within an Impersonation Context may receive the following error: \"0x80040154 (REGDB_E_CLASSNOTREG)\". Use the following guidance as a workaround.\r\n\r\n* Create an instance of the .NET COM component prior to the impersonation context call. Later impersonated create instance calls should work as expected.\r\n* Run the .NET Application in the context of the impersonated user\r\n* Avoid using Impersonation when creating the .NET COM object\r\n"},{"Id":"7945147887","Type":"IssuesEvent","CreatedAt":"2018-07-10T17:00:38","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/73","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-8356: .NET Core Security Feature Bypass Vulnerability\" (#73) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-8356: .NET Core Security Feature Bypass Vulnerability\r\n\r\n## <a name=\"executive-summary\"></a>Executive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in .NET Core. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nMicrosoft is aware of a security feature bypass vulnerability that exists when .NET Core does not correctly validate certificates. An attacker who successfully exploited this vulnerability could present an expired certificate when challenged.\r\n\r\nThe update addresses the vulnerability by correcting how .NET Core applications handle certificate validation.\r\n\r\n## Discussion\r\n\r\nDiscussion for this issue can be found at https://github.com/dotnet/wcf/ **TBD**\r\n\r\n### <a name=\"mitigation-factors\"></a>Mitigation factors\r\n\r\n* If an application does use Windows Communication Foundation you are not affected.\r\n\r\n## <a name=\"affected-software\"></a>Affected software\r\n\r\nAny .NET Core, or ASP.NET Core based application that uses System.Private.ServiceModel with a version of 4.5.1 or earlier.\r\n\r\nPackage name | Vulnerable versions | Secure versions\r\n------------ | ---------------- | -------------------------\r\nSystem.Private.ServiceModel | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 |  4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Duplex | 4.0.0, 4.0.1, 4.0.2 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.0.3 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Http | 4.0.0, 4.0.10, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.NetTcp | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Primitives | 4.0.0, 4.1.0, 4.1.1 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.1.2 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\nSystem.ServiceModel.Security | 4.0.0, 4.0.1, 4.0.2 <br /> 4.3.0, 4.3.1 <br /> 4.4.0, 4.4.1, 4.4.2 <br /> 4.5.0, 4.5.1 | 4.0.3 or later <br /> 4.3.2 or later <br /> 4.4.3 or later <br /> 4.5.2 or later\r\n\r\n## <a name=\"advisory-faq\"></a>Advisory FAQ\r\n### <a name=\"how-affected\"></a>How do I know if I am affected?\r\n\r\n.NET Core projects have two types of dependencies: direct and transitive. You must update your projects using the following instructions to address both types of dependency.\r\n\r\n### <a name=\"project-format\"></a>.NET Core Project formats\r\n\r\n.NET Core has two different project file formats, depending on what software created the project.\r\n\r\n1. `project.json` is the format used in .NET Core 1.0 and Microsoft Visual Studio 2015.\r\n2. `csproj` is the format used in .NET Core 1.1, .NET Core 2.0 and Microsoft Visual Studio 2017.\r\n\r\n#### Direct dependencies\r\n\r\nDirect dependencies are discoverable by examining your `csproj` file or your `project.json` file. They can be fixed by [editing the project file](#direct-dependencies) or using NuGet to update the dependency.\r\n\r\n The `System.Private.ServiceModel` package is not meant to be directly depended on and will not appear in your direct dependency list.\r\n\r\n#### Transitive dependencies\r\n\r\nTransitive dependencies occur when you add a package to your project that in turn relies on another package. For example, if Contoso publishes a package `Contoso.Utility` which, in turn, depends on `Contoso.Internals` and you add the `Contoso.Utility` package to your project now your project has a direct dependency on `Contoso.Utility` and, because `Contoso.Utility` depends 'Contoso.Internals', your application gains a transitive dependency on the `Contoso.Internals` package.\r\n\r\nTransitive dependencies are reviewable in three ways, depending on your [project format](#project-format):\r\n\r\n* In the Visual Studio Solution Explorer window, which supports searching.\r\n* By examining the `project.assets.json` file contained in the obj directory of your project for `csproj` based projects *OR*.\r\n* By examining the `project.lock.json` file contained in the root directory of your project for `project.json` based projects.\r\n\r\nThe `project.assets.json` and `project.lock.json` files are the authoritative list of all packages used by your project, containing both direct and transitive dependencies.\r\n\r\n#### <a name=\"direct-dependencies-vs2017\"></a>Fixing direct dependencies in a csproj based project / Visual Studio 2017\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project. Look for `PackageReference` elements. The following shows an example project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.4.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nThe preceding example has a reference to the [vulnerable package](#affected-software), as seen by the single `PackageReference` element. The name of the package is in the `Include` attribute.\r\nThe package version number is in the `Version` attribute. The previous example shows a single direct dependency on `System.ServiceModel.Http` version 4.4.0.\r\n\r\nTo update the version to the secure package, change the version number to the updated package version as listed on the table [previously](#affected-software).\r\nIn this example, update `System.ServiceModel.Http` to the appropriate [fixed package number](#affected-software) for your major version. Save the *csproj* file. The example *csproj* now looks as follows:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.4.3\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nIf you're using Visual Studio and you save your updated *csproj* file, Visual Studio will restore the new package version.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the updated dependencies.\r\n\r\nNow recompile your application. If after recompilation you see a *Dependency conflict warning*, you must update your other direct dependencies to versions that take a dependency on the updated package.\r\n\r\n#### <a name=\"direct-dependencies-vs2015\"></a> Fixing Direct Dependencies in project.json based project / Visual Studio 2015\r\n\r\nOpen your `project.json` file in your editor. Look for the dependencies section. Below is an example dependencies section:\r\n\r\n``` json\r\n    \"dependencies\": {\r\n      \"Microsoft.NETCore.App\": {\r\n        \"version\": \"1.0.1\",\r\n        \"type\": \"platform\"\r\n      },\r\n     \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n     \"System.ServiceModel.Http\" : \"4.0.0\"\r\n    }\r\n```\r\n\r\nThis example has three direct dependencies: `Microsoft.NETCore.App`, `Microsoft.AspNetCore.Mvc.Core` and `System.ServiceModel.Http`.\r\n\r\n`Microsoft.NetCore.App` is the platform the application targets, you should ignore this. The other packages expose their version to the right of the package name. In our example, our non-platform packages are version 1.0.1.\r\n\r\nReview your direct dependencies for any instance of the packages and versions listed above. In the example above, there is a direct dependency on a vulnerable package, `System.ServiceModel.Http` version 4.4.0.\r\n\r\nTo update to the fixed package, change the version number to be the appropriate package for your release. In the example, this would be updating `System.ServiceModel.Http` to 4.4.3.\r\n\r\nAfter updating the vulnerable package versions, save your `project.json` file.\r\n\r\nThe dependencies section in our example `project.json` would now look as follows:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc.Core\": \"1.0.6\",\r\n    \"System.ServiceModel.Http \": \"4.4.3\"\r\n  }\r\n```\r\n\r\nIf you are using Visual Studio and save your updated `project.json` file, Visual Studio will restore the new package version. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependency.\r\n\r\nAfter you have addressed all of your direct dependencies, you must also review your transitive dependencies.\r\n\r\nAfter you've addressed all of your direct dependencies, you must review your transitive dependencies.\r\n\r\n#### Discovering and fixing transitive dependencies\r\n\r\nThere are two ways to view transitive dependencies. You can either [use Visual Studio’s Solution Explorer](#vs-solution-explorer), or you can review [the `project.assets.json` file](#project-assets-json) or the [the `project.lock.json` file](#project-lock-json).\r\n\r\n##### <a name=\"vs-solution-explorer\"></a>Using Visual Studio Solution Explorer\r\n\r\nTo use Solution Explorer, open the project in Visual Studio, and then press Ctrl+; to activate the search in Solution Explorer. Search for the [vulnerable package](#affected-software) and make a note of the version numbers of any results you find.\r\n\r\nFor example, searching for `Microsoft.AspNetCore.Mvc.Core` in an example project that contains a package that takes a dependency on `Microsoft.AspNetCore.Mvc` shows the following results in Visual Studio 2017:\r\n\r\n![Screenshot of search results in Visual Studio 2017](https://cloud.githubusercontent.com/assets/796298/25858816/8ecdc2b4-3491-11e7-9363-746804bb9832.png)\r\n\r\nThe search results appear as a tree. In the previous results, you can see that a reference to `Microsoft.AspNetCore.Mvc.Core` version 1.1.2 is discovered.\r\n\r\nUnder the Dependencies node is a NuGet node. Under the NuGet node is the list of packages you have directly taken a dependency on and their versions.\r\nIn screenshot, the application takes a direct dependency on `Microsoft.AspNetCore.Mvc`. `Microsoft.AspNetCore.Mvc` in turn has leaf nodes that list its dependencies and their versions.\r\nThe `Microsoft.AspNetCore.Mvc` package takes a dependency on a version of `Microsoft.AspNetCore.Mvc.ApiExplorer`, that in turn takes a dependency on a version of `Microsoft.AspNetCore.Mvc.Core`.\r\n\r\n##### <a name=\"project-assets-json\"></a> Manually reviewing project.assets.json (csproj/VS2017)\r\n\r\nOpen the *project.assets.json* file from your project’s obj directory in your editor. We suggest you use an editor that understands JSON and allows you to collapse and expand nodes to review this file.\r\nVisual Studio and Visual Studio Code provide JSON friendly editing.\r\n\r\nSearch the *project.assets.json* file for the [vulnerable package](#affected-software), using the format `packagename/` for each of the package names from the preceding table. If you find the assembly name in your search:\r\n\r\n* Examine the line on which they are found, the version number is after the `/`.\r\n* Compare to the [vulnerable versions table](#affected-software).\r\n\r\nFor example, a search result that shows `System.ServiceModel.Http/4.3.0` is a reference to version 4.3.0 of `System.ServiceModel.Http`.\r\n\r\nIf your *project.assets.json* file includes references to the [vulnerable package](#affected-software), then you need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to any vulnerable packages, this means either\r\n\r\n* None of your direct dependencies depend on any vulnerable packages, or\r\n* You have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to the [vulnerable package](#affected-software), you must add a direct dependency to the updated package to your *csproj* file to override the transitive dependency.\r\n\r\nOpen *projectname.csproj* in your editor. If you're using Visual Studio, right-click the project and choose **Edit projectname.csproj** from the context menu, where projectname is the name of your project.\r\nLook for `PackageReference` nodes, for example:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nYou must add a direct dependency to the updated version of the [vulnerable package](#affected-software) by adding it to the *csproj* file.\r\nYou do this by adding a new line to the dependencies section, referencing the fixed version.\r\nFor example, if your search showed a transitive reference to a vulnerable `System.ServiceModel.Http` version, you'd add a reference to the [fixed package number](#affected-software).\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net461</TargetFramework>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.ServiceModel.Http\" Version=\"4.3.2\" />\r\n    <PackageReference Include=\"ThirdParty.NotUpdatedYet\" Version=\"2.0.0\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nAfter you've added the direct dependency reference, save your *csproj* file.\r\n\r\nIf you're using Visual Studio, save your updated *csproj* file and Visual Studio will restore the new package versions.\r\nYou can see the restore results by opening the **Output** window (Ctrl+Alt+O) and changing the **Show output from** drop-down list to **Package Manager**.\r\n\r\nIf you're not using Visual Studio, open a command line and change to your project directory. Execute the `dotnet restore` command to restore the new dependencies.\r\n\r\n##### <a name=\"project-lock-json\"></a> Manually reviewing project.lock.json (project.json/VS2015)\r\n\r\nOpen the `project.lock.json` file in your editor. We suggest you use an editor that understands json and allows you to collapse and expand nodes to review this file; both Visual Studio and Visual Studio Code provide this functionality.\r\n\r\nIf you are using Visual Studio the `project.lock.json` file is “under” the `project.json` file. Click the right pointing triangle, ▷, to the left of the `project.json` file to expand the solution tree to expose the `project.lock.json` file. The following image shows a project with the `project.json` file expanded to show the `project.lock.json` file.\r\n\r\n![project lock json](https://cloud.githubusercontent.com/assets/796298/25858179/f6e01200-348f-11e7-8a77-7176d8dd3f03.png)\r\n\r\nSearch the `project.lock.json` file for the vulnerable packages, using the format `packagename/`, using each of the package names from the table above. If you find any vulnerable assembly name in your search examine the line on which they are found, the version number is after the `/` and compare to the vulnerable versions table above. For example a search result that shows `System.ServiceModel.Http/4.0.1` is a reference to v4.0.1 of `System.ServiceModel.Http`.   If your `project.lock.json` file includes references to any of the package versions shown above then you will need to fix the transitive dependencies.\r\n\r\nIf you have not found any reference to a vulnerable version of `System.ServiceModel.Http` this means none of your direct dependencies depend on any vulnerable packages or you have already fixed the problem by updating the direct dependencies.\r\n\r\nIf your transitive dependency review found references to any of the vulnerable packages you must add a direct dependency to the updated package to your `project.json` file to override the transitive dependency. Open your `project.json` and find the dependencies section. For example:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nFor each of the vulnerable packages your search returned you must add a direct dependency to the updated version by adding it to the `project.json` file. You do this by adding a new line to the dependencies section, referring the fixed version. For example, if your search showed a transitive reference to the vulnerable `System.ServiceModel.Http` version 1.0.0 you would add a reference to the appropriate fixed version, 1.0.6. Edit the `project.json` file as follows:\r\n\r\n``` json\r\n  \"dependencies\": {\r\n    \"Microsoft.NETCore.App\": {\r\n      \"version\": \"1.0.1\",\r\n      \"type\": \"platform\"\r\n    },\r\n    \"System.ServiceModel.Http\": \"4.1.2\",\r\n    \"Microsoft.AspNetCore.Mvc\": \"1.0.0\"\r\n  }\r\n```\r\n\r\nAfter you have added direct dependencies to the fixed packages, save your `project.json` file.\r\n\r\nIf you are using Visual Studio save your updated `project.json` file and Visual Studio will restore the new package versions. You can see the restore results by opening the Output Window (Ctrl+Alt+O) and changing the Show output from drop-down list to Package Manager.\r\n\r\nIf you are not using Visual Studio open a command line and change to your project directory. Execute the `dotnet restore` command to restore your new dependencies.\r\n\r\n#### Rebuilding your application\r\n\r\nFinally you must rebuild your application, test, and redeploy.\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \"as is\" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### External Links\r\n\r\n[CVE-2018-8356](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2018-8356)\r\n\r\n### Revisions\r\n\r\nV1.0 (July 10, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2018-07-10_\r\n"},{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"8013341177","Type":"IssuesEvent","CreatedAt":"2018-07-24T23:40:30","Actor":"cclauson","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/19119","RelatedDescription":"Opened issue \"Where is source code for .NET Native toolchain?\" (#19119) at dotnet/coreclr","RelatedBody":"Hello,\r\n\r\nI'm trying to find the source code for the .NET Native toolchain.  Is this in some dotnet repo?  Specifically ilc.exe, nutc_driver.exe, etc.\r\n\r\nThanks so much"},{"Id":"8013227228","Type":"IssuesEvent","CreatedAt":"2018-07-24T23:02:53","Actor":"dotnetjt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/19118","RelatedDescription":"Opened issue \"IMetaDataImport::GetFieldProps reporting size of field name wrong\" (#19118) at dotnet/coreclr","RelatedBody":"Working with this API, and in this method:\r\n\r\n```\r\nHRESULT GetFieldProps(\r\n  [in]                                           mdFieldDef      tkFieldDef,\r\n  [out]                                          mdTypeDef       *ptkTypeDef,\r\n  [out, size_is(cchField), length_is(*pchField)] LPWSTR          szField,\r\n  [in]                                           ULONG           cchField,\r\n  [out]                                          ULONG           *pchField,\r\n  [out]                                          DWORD           *pdwAttr,\r\n  [out, size_is(, *pcbSigBlob)]                  PCCOR_SIGNATURE *ppvSigBlob,\r\n  [out]                                          ULONG           *pcbSigBlob,\r\n  [out]                                          DWORD           *pdwCPlusTypeFlag,\r\n  [out, size_is(, *pcchValue)]                   UVCP_CONSTANT   *ppValue,\r\n  [out]                                          ULONG           *pcchValue\r\n);\r\n```\r\n\r\nThe `out ULONG *pchField ` parameter is always reporting 1 byte larger than the field actually is.\r\n\r\nFor example:\r\n\r\n```\r\nprivate string MyField;\r\n```\r\nreports as a size of 8.\r\n\r\nAny idea why this is?"},{"Id":"8013173128","Type":"IssuesEvent","CreatedAt":"2018-07-24T22:46:16","Actor":"fiigii","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/19117","RelatedDescription":"Closed issue \"[RyuJIT] Linux has more SIMD register spills than Windows\" (#19117) at dotnet/coreclr","RelatedBody":"The code example is from the SoA ray-tracer benchmark https://github.com/dotnet/coreclr/pull/18839, the C# source code is same as https://github.com/dotnet/coreclr/issues/19116\r\n![image](https://user-images.githubusercontent.com/1263030/43165851-cc4b59e4-8f49-11e8-91e3-cff128816706.png)\r\n\r\nWe can see that vector variables are always spilled on stack after generated on Linux. But the Windows version can leveage the calling convention (callee-saved XMM6-XMM15) to save/restore SIMD registers just around call-sites, sometime that call avoid memory access.\r\n"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"8013937268","Type":"PullRequestEvent","CreatedAt":"2018-07-25T03:22:21","Actor":"dotnet-maestro-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9731","RelatedDescription":"Opened pull request \"Update coresetup, sdk to preview1-26216-03, servicing-63124-04, respectively (release/2.1.401)\" (#9731) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"8013508066","Type":"IssuesEvent","CreatedAt":"2018-07-25T00:41:48","Actor":"divega","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9730","RelatedDescription":"Opened issue \"Make launchSettings.json handling something that can be reused by other design time tools\" (#9730) at dotnet/cli","RelatedBody":"Issue https://github.com/dotnet/cli/issues/6617 was about supporting launchSettings.json in dotnet run. Visual Studio also has its own way of supporting launchSettings.json. \r\n\r\nThere are actually other tools that need to honor information from launchSetting.json, such as environment variables and command line options when executing any application code on behalf of the user, but every time we have solved the launchSettings.json problem so far, we have done in and ad-hoc manner (see https://github.com/dotnet/cli/pull/6698 and https://github.com/dotnet/cli/issues/6617#issuecomment-302509090 for what CPS does) that does not allow for the logic to be reused. \r\n\r\nThis is the case for many of the dotnet ef commands (see https://github.com/aspnet/EntityFrameworkCore/issues/8695) but possibly any tool that executes user code will have similar requirements. \r\n\r\ncc @bricelam @ajcvickers \r\n\r\n"},{"Id":"8013470219","Type":"IssuesEvent","CreatedAt":"2018-07-25T00:27:09","Actor":"chuckries","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9729","RelatedDescription":"Opened issue \"Debian meta-packages do not acquire version specific child packages\" (#9729) at dotnet/cli","RelatedBody":"My goal is to install the 2.1.300 SDK (**not** 2.1.302**) on Ubuntu 16.04. I can try to install the specific version of the dotnet-sdk-2.1 package, but it does not reference the correct versions of it's dependencies.\r\n\r\n## Steps to reproduce\r\nHey I wonder if I can get older versions of the 2.1 SDK, you know for testing and stuff.\r\n```\r\nroot@68876b3dbbb8:/# apt-cache policy dotnet-sdk-2.1\r\ndotnet-sdk-2.1:\r\n  Installed: (none)\r\n  Candidate: 2.1.302-1\r\n  Version table:\r\n     2.1.302-1 500\r\n        500 https://packages.microsoft.com/ubuntu/16.04/prod xenial/main amd64 Packages\r\n     2.1.301-1 500\r\n        500 https://packages.microsoft.com/ubuntu/16.04/prod xenial/main amd64 Packages\r\n     2.1.300-1 500\r\n        500 https://packages.microsoft.com/ubuntu/16.04/prod xenial/main amd64 Packages\r\n```\r\n\r\nSweet they exist! Let me just install...\r\n\r\n```\r\nroot@68876b3dbbb8:/# apt-get install dotnet-sdk-2.1=2.1.300-1 -V\r\nReading package lists... Done\r\nBuilding dependency tree\r\nReading state information... Done\r\nThe following additional packages will be installed:\r\n   aspnetcore-runtime-2.1 (2.1.2-1)\r\n   dotnet-host (2.1.2-1)\r\n   dotnet-hostfxr-2.1 (2.1.2-1)\r\n   dotnet-runtime-2.1 (2.1.2-1)\r\n   dotnet-runtime-deps-2.1 (2.1.2-1)\r\n   libicu55 (55.1-7ubuntu0.4)\r\n   liblttng-ust-ctl2 (2.7.1-1)\r\n   liblttng-ust0 (2.7.1-1)\r\n   liburcu4 (0.9.1-3)\r\nThe following NEW packages will be installed:\r\n   aspnetcore-runtime-2.1 (2.1.2-1)\r\n   dotnet-host (2.1.2-1)\r\n   dotnet-hostfxr-2.1 (2.1.2-1)\r\n   dotnet-runtime-2.1 (2.1.2-1)\r\n   dotnet-runtime-deps-2.1 (2.1.2-1)\r\n   dotnet-sdk-2.1 (2.1.300-1)\r\n   libicu55 (55.1-7ubuntu0.4)\r\n   liblttng-ust-ctl2 (2.7.1-1)\r\n   liblttng-ust0 (2.7.1-1)\r\n   liburcu4 (0.9.1-3)\r\n0 upgraded, 10 newly installed, 0 to remove and 1 not upgraded.\r\nNeed to get 138 MB of archives.\r\nAfter this operation, 408 MB of additional disk space will be used.\r\nDo you want to continue? [Y/n]\r\n```\r\n\r\nWait a minute. That's going to give me the 2.1.2 runtime, when what I really wanted was the 2.1.0 runtime, which is available as a standalone package:\r\n\r\n```\r\nroot@68876b3dbbb8:/# apt-cache policy dotnet-runtime-2.1\r\ndotnet-runtime-2.1:\r\n  Installed: (none)\r\n  Candidate: 2.1.2-1\r\n  Version table:\r\n     2.1.2-1 500\r\n        500 https://packages.microsoft.com/ubuntu/16.04/prod xenial/main amd64 Packages\r\n     2.1.1-1 500\r\n        500 https://packages.microsoft.com/ubuntu/16.04/prod xenial/main amd64 Packages\r\n     2.1.0-1 500\r\n        500 https://packages.microsoft.com/ubuntu/16.04/prod xenial/main amd64 Packages\r\n```\r\nI guess installing a specific version of the SDK doesn't work how I thought. \r\n\r\n## Expected  behavior\r\nA specific version of the dotnet-sdk-2.1 package would give me specific versions of its dependent packages.\r\n\r\n## Actual behavior\r\nIt does not. I don't know enough about debian packages to know if this is the convention or not.\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"8011987338","Type":"PullRequestEvent","CreatedAt":"2018-07-24T18:31:19","Actor":"nguerrera","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/9726","RelatedDescription":"Merged pull request \"Update coresetup, sdk to preview1-26216-03, servicing-63122-02, respectively (release/2.1.401)\" (#9726) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"8011334706","Type":"PullRequestEvent","CreatedAt":"2018-07-24T16:27:22","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/9728","RelatedDescription":"Merged pull request \"Merge release/2.1.4xx to release/2.2.1xx\" (#9728) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into release/2.2.1xx.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-release/2.2.1xx\ngit reset --hard upstream/release/2.2.1xx\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-release/2.2.1xx --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"8011332585","Type":"PullRequestEvent","CreatedAt":"2018-07-24T16:26:59","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/9727","RelatedDescription":"Merged pull request \"Merge release/2.1.4xx to release/2.1.401\" (#9727) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into release/2.1.401.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-release/2.1.401\ngit reset --hard upstream/release/2.1.401\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-release/2.1.401 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"8013533061","Type":"IssuesEvent","CreatedAt":"2018-07-25T00:51:41","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/841","RelatedDescription":"Closed issue \"Enumerable.Single for yielding single element\" (#841) at dotnet/standard","RelatedBody":"I would like to propose a very tiny method to be included to the _System.Linq.Enumerable_ static class, something like that.\r\n```\r\npublic static IEnumerable<TResult> Single<TResult>(TResult element) {\r\n\tyield return element;\r\n}\r\n```\r\n\r\nIt might be helpful if user require an IEnumerable instance out of a particular single element. Now we are obligated to do **Enumerable.Repeat(element, 1)** or other similar, not so clean solutions.\r\nStill this is a very small change for very narrow usage thus it is only my suggestion, if naming collision is a problem then feel free to name it however you find suitable."},{"Id":"8013528078","Type":"IssuesEvent","CreatedAt":"2018-07-25T00:49:41","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/835","RelatedDescription":"Closed issue \".NET Standard vNext Review Process\" (#835) at dotnet/standard","RelatedBody":"In order to review .NET Standard vNext, I propose the following review process:\r\n\r\n1. **Review & approve the [planning document](https://github.com/dotnet/standard/pull/785)**. It covers the high-level goals of the release. I don't expect much push back there, but I'd be interested if folks have any questions or would like to add specific goals.\r\n\r\n2. **Review & approve individual [API changes with runtime-impact](https://github.com/dotnet/standard/pulls?q=is%3Aopen+is%3Apr+label%3Aruntime-impact+label%3Anetstandard-api+milestone%3A%22.NET+Standard+vNext%22)**. Those are likely the hardest ones to support, so I'd like to front load concerns in this space.\r\n\r\n3. **Review & approve [remaining API changes](https://github.com/dotnet/standard/pulls?utf8=%E2%9C%93&q=is%3Aopen+is%3Apr+-label%3Aruntime-impact+label%3Anetstandard-api+milestone%3A%22.NET+Standard+vNext%22+)**. These should be easy now 😄 \r\n\r\n4. **Decide on [version number](https://github.com/dotnet/standard/issues/833)**. This shouldn't necessarily the last thing, but I think the version number depends on the scope. So we shouldn't necessarily decided too early either.\r\n\r\n@dotnet/nsboard, any concerns or questions about this process?"},{"Id":"8012518024","Type":"PullRequestEvent","CreatedAt":"2018-07-24T20:16:23","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/785","RelatedDescription":"Merged pull request \"Add planning for .NET Standard vNext\" (#785) at dotnet/standard","RelatedBody":"This is the proposal for .NET Standard vNext. This also fixes #303.\r\n\r\n@dotnet/nsboard, any thoughts? Let's start by reviewing the overall document and *then* the list of individual PRs."},{"Id":"8012518005","Type":"IssuesEvent","CreatedAt":"2018-07-24T20:16:22","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/303","RelatedDescription":"Closed issue \"Add a roadmap document\" (#303) at dotnet/standard","RelatedBody":"Is it possible to add a document outlining future plans and release dates?"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"8014000028","Type":"IssuesEvent","CreatedAt":"2018-07-25T03:46:46","Actor":"bbowyersmyth","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/31239","RelatedDescription":"Closed issue \"VB Collection accesses wrong index via IList interface\" (#31239) at dotnet/corefx","RelatedBody":"Porting the vb collection class and came across the following bug. \r\nBoth of these tests pass when using the collection through the IList interface. It always grabs the first item in the collection for negative indexes.\r\n```\r\nIList coll = vbcollection;\r\nvar firstItem = coll[0];\r\ncoll.RemoveAt(-10);    // Indexing bug when accessing through the IList interface on non-empty collection\r\nAssert.False(coll.Contains(firstItem));\r\n\r\nAssert.Equal(coll[-10], coll[0]);    // Indexing bug when accessing through the IList interface on non-empty collection\r\n```\r\n\r\nGiven the legacy status of this class is this worth fixing?\r\ncc @danmosemsft"},{"Id":"8013951214","Type":"PullRequestEvent","CreatedAt":"2018-07-25T03:27:39","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/31347","RelatedDescription":"Opened pull request \"Update CoreClr, CoreFx, CoreSetup to servicing-26724-06, servicing-26724-03, servicing-26724-03, respectively (release/2.1)\" (#31347) at dotnet/corefx","RelatedBody":""},{"Id":"8013866068","Type":"PullRequestEvent","CreatedAt":"2018-07-25T02:56:00","Actor":"GrabYourPitchforks","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/31243","RelatedDescription":"Merged pull request \"Added GetInt32 to RandomNumberGenerator.\" (#31243) at dotnet/corefx","RelatedBody":"Attempt at implementing RNG.GetInt32.\r\n\r\n/cc @bartonjs @GrabYourPitchforks \r\n\r\nFixes #30873."},{"Id":"8013866048","Type":"IssuesEvent","CreatedAt":"2018-07-25T02:55:59","Actor":"GrabYourPitchforks","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30873","RelatedDescription":"Closed issue \"API Proposal: CSPRNG integers with ranges\" (#30873) at dotnet/corefx","RelatedBody":"Currently, there are two main ways of getting random data. The insecure `System.Random`, and `System.Security.Cryptography.RandomNumberGenerator` and its derivatives.\r\n\r\n# The Problem\r\n\r\nA common issue I find when doing reviews is that developers are unsure of the best way to get random *integers* in a secure manner, specifically when they need to clamp the integer to a specific range. They will usually take a few incorrect approaches.\r\n\r\n1. Use `System.Random` because it offers a `Next(int, int)` option that has exactly what they want, at the cost of insecurity. They may *seed* `System.Random` with output from a CSPRNG, however this is also problematic for a variety of reasons.\r\n\r\n2. Use `RandomNumberGenerator` incorrectly. They may use `GetBytes` to fill an integer and use modulus to clamp it to a specific range. Modulus usually introduces selection bias. I've seen all manners of trying to use S.S.C.RNG to coerce its values into integers, some better than others, but many of which are flawed.\r\n\r\nDevelopers usually want to do this for a variety of reasons. A common reason I see is to build a random string with a specific character set. Something like:\r\n\r\n```csharp\r\nstatic string GetRandomString(string characterSet, int length) {\r\n  var builder = new StringBuilder();\r\n  for (var i = 0; i < length; i++) {\r\n    var randInt = GetSomeRandomInteger(fromInclusive: 0, toExclusive: characterSet.Length);\r\n    builder.Append(characterSet[randInt]);\r\n  }\r\n  return builder.ToString();\r\n}\r\n```\r\n\r\nThis can be done for reset codes, confirmation codes, temporary passwords, etc.\r\n\r\n# Proposal\r\n\r\nWe should offer an API that allows developers to get random integers, securely, without having to think too hard about it.\r\n\r\nAdd the following APIs:\r\n\r\n```csharp\r\nnamespace System.Security.Cryptography {\r\n  public abstract class RandomNumberGenerator {\r\n\r\n    /// <summary>\r\n    /// Provides a random integer within a specific range.\r\n    /// </summary>\r\n    /// <param name=\"fromInclusive\">The inclusive lower-bound of the range.</param>\r\n    /// <param name=\"toExclusive\">The exclusive upper-bound of the range.</param>\r\n    public static int GetInteger(int fromInclusive, int toExclusive) => throw null;\r\n\r\n    /// <summary>\r\n    /// Provides a random integer from zero to an upper-bound.\r\n    /// </summary>\r\n    /// <param name=\"toExclusive\">The exclusive upper-bound of the range.</param>\r\n    public static int GetInteger(int toExclusive) => throw null;\r\n  }\r\n}\r\n```\r\n\r\n`S.S.C.RNG` will implement these and rely on `RandomNumberGeneratorImplementation`'s `GetBytes` implementation.\r\n\r\n # Other thoughts\r\n\r\nIs it worth making this cancellable? It's very likely that the implementation will have handle the case of making multiple attempts to generate a number that falls within the correct range. Those implementations often distribute binomially, so it's _unlikely_ to be a source of a DoS, but _possible_. If this is a concern, perhaps an overload returning `ValueTask<int>` and accepting a `CancellationToken` are desirable.\r\n\r\nIs there prior art somewhere in .NET that we can make public, or move in to CoreFX? (Perhaps aspnet has already solved this.)\r\n\r\n/cc @bartonjs @GrabYourPitchforks "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"8014211790","Type":"IssuesEvent","CreatedAt":"2018-07-25T05:13:01","Actor":"OmarTawfik","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28829","RelatedDescription":"Opened issue \"Optimize lifted range expressions when the first operand is a conditional access operator\" (#28829) at dotnet/roslyn","RelatedBody":"Test for the case:\r\n\r\n```csharp\r\nstruct Test\r\n{\r\n    void M(Test? obj, Index right)\r\n    {\r\n        Range? result = (obj?.N())..right;\r\n    }\r\n    Index N() => ^5;\r\n}\r\n```\r\n\r\nThis should be lowered into:\r\n\r\n```csharp\r\nRange? result = obj.HasValue\r\n    ? new Nullable<Range>(obj.Value.N()..right)\r\n    : new Nullable<Range>();\r\n```\r\n\r\nInstead of:\r\n\r\n```csharp\r\nIndex? left = obj.HasValue\r\n    ? new Nullable<Index>(obj.Value.N())\r\n    : new Nullable<Index>();\r\nRange? result =  left.HasValue\r\n    ? new Nullable<Range>(left.Value.N()..right)\r\n    : new Nullable<Range>();"},{"Id":"8014134761","Type":"IssuesEvent","CreatedAt":"2018-07-25T04:41:34","Actor":"OmarTawfik","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28828","RelatedDescription":"Opened issue \"Assert that range/index expressions can be used in expression trees\" (#28828) at dotnet/roslyn","RelatedBody":"For range (`1..2`) and index (`^1`) expressions, need to investigate if they're convertible correctly to LINQ expression trees, specially when either or both operands are lifted.\r\nTests should be added accourdingly."},{"Id":"8014122299","Type":"IssuesEvent","CreatedAt":"2018-07-25T04:36:32","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/25870","RelatedDescription":"Closed issue \"Infer nullability of receiver and member from `?.` expression\" (#25870) at dotnet/roslyn","RelatedBody":"There should be no warnings in the following. Currently, `Possible dereference of a null reference` is reported for `c` and `c.F` in `c.F.ToString()`.\r\n```c#\r\nclass C\r\n{\r\n    object? F;\r\n    static void M(C? c)\r\n    {\r\n        if (c?.F != null)\r\n            c.F.ToString();\r\n    }\r\n}\r\n```"},{"Id":"8013756761","Type":"IssuesEvent","CreatedAt":"2018-07-25T02:16:01","Actor":"vsfeedback","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28827","RelatedDescription":"Opened issue \"Go to implementation (Ctrl+F12) is broken for  interface async methods\" (#28827) at dotnet/roslyn","RelatedBody":"I defined an interface with async methods in a .Net Standard 2.0 project. And two implementations in two .Net Core 2.1 projects.  \nWhen I press Ctrl+F12 over the interface name, the  Visua Studio 'implementations' window displays the two implementations.\nBut when I press Ctrl+F12 over a method whose implementation has async keyword method, it doesn't find any implementation, presenting a dialog into saying &quot;This symbol has no implementations&quot;.\nThe expected result is that the 'implementations' window should present the two implementations of the method.\n\n_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/295266/go-to-implementation-ctrlf12-is-broken-for-interfa.html\nVSTS ticketId: 649802_\n_These are the original issue comments:_\n(no comments)\n_These are the original issue solutions:_\n(no solutions)"},{"Id":"8013748759","Type":"IssuesEvent","CreatedAt":"2018-07-25T02:13:08","Actor":"vsfeedback","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28826","RelatedDescription":"Opened issue \"EditorConfig interpretted incorrectly if a rule references a symbol group that doesn't exist.\" (#28826) at dotnet/roslyn","RelatedBody":"The attached .editorconfig file contains two naming rules. The first rule declares that all parameter symbols should be camel-cased. The intent of the second rule is that anything that the default for any symbol should be pascal case. Since the rule for parameter symbols is declared first, I would expect VS to suggest that all parameter symbols use camel casing. However, since the second rule declares a symbol constraint that references &quot;pascal_case_symbols&quot;, which doesn't exist in the file, VS suggests that all parameter symbols use pascal casing.\n\n_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/298409/editorconfig-interpretted-incorrectly-if-a-rule-re.html\nVSTS ticketId: 652897_\n_These are the original issue comments:_\n\njrusbatch on ‎7‎/‎23‎/‎2018, 11:34 AM (33 hours ago): <p>Attached is the .editorconfig file that I mentioned above.</p><p><a target='_blank' href=\"https://developercommunity.visualstudio.com/storage/temp/35525-editorconfig.txt\">editorconfig.txt</a></p>\n\n_These are the original issue solutions:_\n(no solutions)"},{"Id":"8013525336","Type":"PullRequestEvent","CreatedAt":"2018-07-25T00:48:38","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28825","RelatedDescription":"Opened pull request \"NonNullTypes: tolerate poisoned attribute, ignore before C# 8\" (#28825) at dotnet/roslyn","RelatedBody":"- Tolerate poisoned NonNullTypes attribute\r\n- NonNullTypes attribute only takes effect in C# 8.0\r\n- Warn on suppression operator without any NonNullTypes context\r\n\r\nRelates to https://github.com/dotnet/roslyn/issues/22152"},{"Id":"8013464549","Type":"PullRequestEvent","CreatedAt":"2018-07-25T00:24:57","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28824","RelatedDescription":"Opened pull request \"Bind NonNullTypes on members\" (#28824) at dotnet/roslyn","RelatedBody":"Removes the last remnants of syntax-based detection of NonNullTypes attribute, in favor of proper binding of the attribute. \r\nNo new cycles this time :-)"},{"Id":"8013412537","Type":"PullRequestEvent","CreatedAt":"2018-07-25T00:05:34","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28491","RelatedDescription":"Merged pull request \"Bind NonNullTypes for types\" (#28491) at dotnet/roslyn","RelatedBody":"In a previous PR on `[NonNullTypes]` I used a syntax-based check to recognize the attribute, rather than use proper binding. This allowed for avoiding a number of cycles.\r\n\r\nThe current PR removes the use of syntax-based check for deciding if a source named type symbol has `NonNullTypes`. Other symbols will be address in follow-up PRs.\r\n\r\n\r\nEven with the NonNullTypesContext design, there were a cycles left to fix, because we're pulling on NonNullTypes too early.\r\n- Symbol display is easy to fix. But the impact on GetDebuggerDisplay is unfortunate.\r\n- MakeDefaultExpression has a check that needs to be delayed. Currently commented out.\r\n- SetUnknownNullabilityForReferenceTypesIfNecessary was removed. But it was hiding a bunch of missing contexts.\r\n- CopyTypeModifiers has an assert with Equals, which pulls on NonNullTypes. Currently commented out.\r\n- TypeSymbolWithAnnotation.Update (used in SourcePropertySymbol and other places) was conditional. Made it unconditional.\r\n\r\n\r\n----\r\n\r\nCheckNullableReferenceTypeMismatchOnImplementingMember:\r\nThis was fixed by calling CheckNullableReferenceTypeMismatchOnImplementingMember later.\r\n```\r\nSymbols.SourcePropertySymbol.NonNullTypes.get() Line 1519\r\nSymbols.TypeSymbolWithAnnotations.IsAnnotatedWithNonNullTypesContext.get() Line 190\r\nSymbols.TypeSymbolWithAnnotations.Equals(Symbols.TypeSymbolWithAnnotations other, TypeCompareKind comparison) Line 281\r\nSymbols.TypeSymbol.CheckNullableReferenceTypeMismatchOnImplementingMember(Symbol implementingMember, Symbol interfaceMember, bool isExplicit, DiagnosticBag diagnostics) Line 1147\r\nSymbols.SourcePropertySymbol.SourcePropertySymbol(Symbols.SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, Syntax.BasePropertyDeclarationSyntax syntax, string name, Location location, DiagnosticBag diagnostics) Line 284\r\nSymbols.SourcePropertySymbol.Create(Symbols.SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, Syntax.PropertyDeclarationSyntax syntax, DiagnosticBag diagnostics) Line 458\r\n```\r\n\r\n\r\n\r\n\r\nSetUnknownNullabilityForReferenceTypesIfNecessary cycle via SourceMemberFieldSymbol.GetFieldType:\r\nFixed by removing the call to SetUnknownNullabilityForReferenceTypesIfNecessary. But caused other issues to become visible. Still working on those.\r\n```\r\nSymbols.FieldSymbolWithAttributesAndModifiers.NonNullTypes.get() Line 344\r\nSymbols.TypeSymbolWithAnnotations.NonLazyType.IsNullable.get() Line 614\r\nSymbols.TypeSymbolWithAnnotations.SetUnknownNullabilityForReferenceTypes() Line 510\r\nSymbols.TypeSymbolWithAnnotations.SetUnknownNullabilityForReferenceTypesIfNecessary(Symbols.ModuleSymbol module) Line 490\r\nSymbols.SourceMemberFieldSymbolFromDeclarator.GetFieldType(Roslyn.Utilities.ConsList<Symbols.FieldSymbol> fieldsBeingBound) Line 515\r\nSymbols.FieldSymbol.Type.get() Line 55\r\nSymbols.FieldSymbol.IsMetadataConstant.get() Line 119\r\nSymbols.SourceMemberContainerTypeSymbol.AddInitializer(ref PooledObjects.ArrayBuilder<Symbols.FieldOrPropertyInitializer> initializers, ref int aggregateSyntaxLength, Symbols.FieldSymbol fieldOpt, CSharpSyntaxNode node) Line 2749\r\n```\r\n\r\n\r\nCycle with SymbolDisplay:\r\nFixed by making symbol display as lazy as possible. \r\nI also had to change the display options used for debugger display, so that the debugger would not pull on NonNullTypes accidentally. It's better to only see `?` and blank, rather than no be able to see the type at all, while debugging.\r\n\r\n```\r\nSymbols.TypeSymbolWithAnnotations.NonLazyType.IsNullable.get() Line 614\r\nSymbolDisplayVisitor.VisitTypeSymbolWithAnnotations(Symbols.TypeSymbolWithAnnotations type, SymbolDisplay.AbstractSymbolDisplayVisitor visitorOpt) Line 18\r\nSymbolDisplayVisitor.AddTypeArguments(ISymbol owner, System.Collections.Immutable.ImmutableArray<System.Collections.Immutable.ImmutableArray<CustomModifier>> modifiers) Line 749\r\nSymbolDisplayVisitor.AddNameAndTypeArgumentsOrParameters(INamedTypeSymbol symbol) Line 403\r\nSymbolDisplayVisitor.VisitNamedType(INamedTypeSymbol symbol) Line 293\r\nSymbols.NamedTypeSymbol.Accept(SymbolVisitor visitor) Line 1592\r\nSymbolDisplay.ToDisplayParts(ISymbol symbol, SemanticModel semanticModelOpt, int positionOpt, SymbolDisplayFormat format, bool minimal) Line 129\r\nSymbolDisplay.ToDisplayParts(ISymbol symbol, SymbolDisplayFormat format) Line 72\r\nSymbolDisplay.ToDisplayString(ISymbol symbol, SymbolDisplayFormat format) Line 31\r\nSymbol.ToDisplayString(SymbolDisplayFormat format) Line 1117\r\nSymbols.ExplicitInterfaceHelpers.GetMemberName(string name, Symbols.TypeSymbol explicitInterfaceTypeOpt, string aliasQualifierOpt) Line 65\r\nSymbols.ExplicitInterfaceHelpers.GetMemberNameAndInterfaceSymbol(Binder binder, Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierOpt, string name, DiagnosticBag diagnostics, out Symbols.TypeSymbol explicitInterfaceTypeOpt, out string aliasQualifierOpt) Line 52\r\nSymbols.SourceOrdinaryMethodSymbol.CreateMethodSymbol(Symbols.NamedTypeSymbol containingType, Binder bodyBinder, Syntax.MethodDeclarationSyntax syntax, DiagnosticBag diagnostics) Line 57\r\nSymbols.SourceMemberContainerTypeSymbol.AddNonTypeMembers(Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializersBuilder builder, SyntaxList<Syntax.MemberDeclarationSyntax> members, DiagnosticBag diagnostics) Line 3012\r\nSymbols.SourceMemberContainerTypeSymbol.AddDeclaredNontypeMembers(Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializersBuilder builder, DiagnosticBag diagnostics) Line 2428\r\nSymbols.SourceMemberContainerTypeSymbol.BuildMembersAndInitializers(DiagnosticBag diagnostics) Line 2343\r\nSymbols.SourceMemberContainerTypeSymbol.GetMembersAndInitializers() Line 1339\r\nSymbols.SourceMemberContainerTypeSymbol.MakeAllMembers(DiagnosticBag diagnostics) Line 2204\r\n```\r\n\r\n\r\nMakeDefaultExpression:\r\nI temporarily temporarily commented out this check. We should execute this check later.\r\n\r\n```\r\nSymbols.SourceNamedTypeSymbol.NonNullTypes.get() Line 931\r\nSymbols.MethodSymbol.NonNullTypes.get() Line 981\r\nSymbols.SourceMemberMethodSymbol.NonNullTypes.get() Line 189\r\nSymbols.TypeSymbolWithAnnotations.NonLazyType.IsNullable.get() Line 614\r\nSymbols.SourceComplexParameterSymbol.MakeDefaultExpression(DiagnosticBag diagnostics, Binder binder) Line 237\r\nSymbols.SourceComplexParameterSymbol.DefaultSyntaxValue.get() Line 160\r\nSymbols.SourceComplexParameterSymbol.ExplicitDefaultConstantValue.get() Line 94\r\nBinder.GetDefaultValueArgument(Symbols.ParameterSymbol parameter, Syntax.AttributeSyntax syntax, DiagnosticBag diagnostics) Line 720\r\nBinder.GetRewrittenAttributeConstructorArguments(out System.Collections.Immutable.ImmutableArray<int> constructorArgumentsSourceIndices, Symbols.MethodSymbol attributeConstructor, System.Collections.Immutable.ImmutableArray<TypedConstant> constructorArgsArray, System.Collections.Immutable.ImmutableArray<string> constructorArgumentNamesOpt, Syntax.AttributeSyntax syntax, DiagnosticBag diagnostics, ref bool hasErrors) Line 615\r\nBinder.GetAttribute(BoundAttribute boundAttribute, DiagnosticBag diagnostics) Line 213\r\nBinder.GetAttribute(Syntax.AttributeSyntax node, Symbols.NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics) Line 100\r\nBinder.GetAttributes(System.Collections.Immutable.ImmutableArray<Binder> binders, System.Collections.Immutable.ImmutableArray<Syntax.AttributeSyntax> attributesToBind, System.Collections.Immutable.ImmutableArray<Symbols.NamedTypeSymbol> boundAttributeTypes, Symbols.CSharpAttributeData[] attributesBuilder, DiagnosticBag diagnostics) Line 74\r\nSymbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany<SyntaxList<Syntax.AttributeListSyntax>> attributesSyntaxLists, ref CustomAttributesBag<Symbols.CSharpAttributeData> lazyCustomAttributesBag, Symbols.AttributeLocation symbolPart, bool earlyDecodingOnly, Binder binderOpt, System.Func<Syntax.AttributeSyntax, bool> attributeMatchesOpt) Line 317\r\nSymbols.SourceNamedTypeSymbol.GetAttributesBag() Line 460\r\nSymbols.SourceNamedTypeSymbol.GetDecodedWellKnownAttributeData() Line 490\r\nSymbols.SourceNamedTypeSymbol.NonNullTypes.get() Line 931\r\nSymbols.MethodSymbol.NonNullTypes.get() Line 981\r\nSymbols.SourceMemberMethodSymbol.NonNullTypes.get() Line 189\r\n```\r\n\r\n\r\n\r\n\r\n----\r\nThe cycles below are no longer relevant. They were all solved by the NonNullTypesContext design :-)\r\n\r\nFor context, here are the stack traces for the various cycles:\r\nCycle 11\r\n```\r\nSymbols.SourceNamedTypeSymbol.NonNullTypes.get() Line 942\r\nBinder.NonNullTypes.get() Line 228\r\nBinder.BindNamespaceOrTypeOrAliasSymbol(Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics) Line 381\r\nBinder.BindTypeOrAlias(Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved) Line 271\r\nBinder.BindType(Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved) Line 251\r\nBinder.BindAttributeTypes(System.Collections.Immutable.ImmutableArray<Binder> binders, System.Collections.Immutable.ImmutableArray<Syntax.AttributeSyntax> attributesToBind, Symbol ownerSymbol, Symbols.NamedTypeSymbol[] boundAttributeTypes, DiagnosticBag diagnostics) Line 45\r\nSymbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany<SyntaxList<Syntax.AttributeListSyntax>> attributesSyntaxLists, ref CustomAttributesBag<Symbols.CSharpAttributeData> lazyCustomAttributesBag, Symbols.AttributeLocation symbolPart, bool earlyDecodingOnly, Binder binderOpt, System.Func<Syntax.AttributeSyntax, bool> attributeMatchesOpt) Line 293\r\nSymbols.SourceNamedTypeSymbol.GetAttributesBag() Line 460\r\nSymbols.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData() Line 507\r\nSymbols.SourceNamedTypeSymbol.NonNullTypes.get() Line 942\r\n```\r\n\r\nCycle 12 (hit in bootstrap build, fixed in `GetNextBaseTypeNoUseSiteDiagnostics` passing the `ignoreNonNullTypesAttribute` for the enum case as well):\r\n```\r\nSymbols.SourceNamedTypeSymbol.GetAttributesBag() Line 460\r\nSymbols.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData() Line 507\r\nSymbols.SourceNamedTypeSymbol.NonNullTypes.get() Line 942\r\nSymbols.SourceNamedTypeSymbol.GetDeclaredBases(Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, bool ignoreNonNullTypesAttribute) Line 229\r\nSymbols.SourceNamedTypeSymbol.GetDeclaredBaseType(Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, bool ignoreNonNullTypesAttribute) Line 243\r\nSymbols.SourceNamedTypeSymbol.MakeAcyclicBaseType(DiagnosticBag diagnostics, bool ignoreNonNullTypesAttribute) Line 626\r\nSymbols.SourceNamedTypeSymbol.GetBaseTypeNoUseSiteDiagnostics(bool ignoreNonNullTypesAttribute) Line 44\r\nSymbols.TypeSymbol.BaseTypeNoUseSiteDiagnostics.get() Line 158\r\nSymbols.TypeSymbolExtensions.GetNextBaseTypeNoUseSiteDiagnostics(Symbols.TypeSymbol type, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, CSharpCompilation compilation, ref PooledObjects.PooledHashSet<Symbols.NamedTypeSymbol> visited, bool ignoreNonNullTypesAttribute) Line 182\r\nBinder.LookupMembersInClass(LookupResult result, Symbols.TypeSymbol type, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 737\r\nBinder.LookupMembersInType(LookupResult result, Symbols.TypeSymbol type, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 187\r\nBinder.LookupMembersInternal(LookupResult result, Symbols.NamespaceOrTypeSymbol nsOrType, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 164\r\nInContainerBinder.LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 237\r\nBinder.LookupSymbolsInternal(LookupResult result, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 94\r\nBinder.LookupSymbolsOrMembersInternal(LookupResult result, Symbols.NamespaceOrTypeSymbol qualifierOpt, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 126\r\nBinder.LookupAttributeType(LookupResult result, Symbols.NamespaceOrTypeSymbol qualifierOpt, string name, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 436\r\nBinder.LookupSymbolsSimpleName(LookupResult result, Symbols.NamespaceOrTypeSymbol qualifierOpt, string plainName, int arity, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 34\r\nBinder.BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(Syntax.IdentifierNameSyntax node, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics, Symbols.NamespaceOrTypeSymbol qualifierOpt) Line 716\r\nBinder.BindNamespaceOrTypeOrAliasSymbol(Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics) Line 381\r\nBinder.BindTypeOrAlias(Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved) Line 271\r\nBinder.BindType(Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<Symbol> basesBeingResolved) Line 251\r\nBinder.BindAttributeTypes(System.Collections.Immutable.ImmutableArray<Binder> binders, System.Collections.Immutable.ImmutableArray<Syntax.AttributeSyntax> attributesToBind, Symbol ownerSymbol, Symbols.NamedTypeSymbol[] boundAttributeTypes, DiagnosticBag diagnostics) Line 45\r\nSymbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany<SyntaxList<Syntax.AttributeListSyntax>> attributesSyntaxLists, ref CustomAttributesBag<Symbols.CSharpAttributeData> lazyCustomAttributesBag, Symbols.AttributeLocation symbolPart, bool earlyDecodingOnly, Binder binderOpt, System.Func<Syntax.AttributeSyntax, bool> attributeMatchesOpt) Line 293\r\nSymbols.SourceNamedTypeSymbol.GetAttributesBag() Line 460\r\n```\r\n\r\n\r\nCycle 13 (and 14 is very closely related):\r\n```\r\nSourceNamedTypeSymbol.NonNullTypes.get() Line 942\r\nSourceNamedTypeSymbol.GetDeclaredBases(Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, bool ignoreNonNullTypesAttribute) Line 229\r\nSourceNamedTypeSymbol.GetDeclaredInterfaces(Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved) Line 248\r\nSourceNamedTypeSymbol.MakeAcyclicInterfaces(Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, DiagnosticBag diagnostics) Line 575\r\nSourceNamedTypeSymbol.InterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved) Line 69\r\nTypeSymbol.GetInterfaceInfo() Line 90\r\nTypeSymbol.GetAllInterfaces() Line 342\r\nTypeSymbol.AllInterfacesNoUseSiteDiagnostics.get() Line 208\r\nTypeSymbol.AllInterfacesWithDefinitionUseSiteDiagnostics(ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 214\r\nCSharp.Binder.LookupMembersInInterfaceOnly(CSharp.LookupResult current, NamedTypeSymbol type, string name, int arity, CSharp.LookupOptions options, CSharp.Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 915\r\nCSharp.Binder.LookupMembersInInterface(CSharp.LookupResult current, NamedTypeSymbol type, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, CSharp.LookupOptions options, CSharp.Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 949\r\nCSharp.Binder.LookupMembersInType(CSharp.LookupResult result, TypeSymbol type, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, CSharp.LookupOptions options, CSharp.Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 178\r\nCSharp.Binder.LookupMembersInternal(CSharp.LookupResult result, NamespaceOrTypeSymbol nsOrType, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, CSharp.LookupOptions options, CSharp.Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 164\r\nCSharp.InContainerBinder.LookupSymbolsInSingleBinder(CSharp.LookupResult result, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, CSharp.LookupOptions options, CSharp.Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 237\r\nCSharp.Binder.LookupSymbolsInternal(CSharp.LookupResult result, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, CSharp.LookupOptions options, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 94\r\nCSharp.Binder.LookupSymbolsWithFallback(CSharp.LookupResult result, string name, int arity, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, CSharp.LookupOptions options) Line 61\r\nCSharp.Binder.InvocableNameofInScope() Line 1638\r\nCSharp.Binder.TryBindNameofOperator(CSharp.Syntax.InvocationExpressionSyntax node, DiagnosticBag diagnostics, out CSharp.BoundExpression result) Line 1520\r\nCSharp.Binder.BindInvocationExpression(CSharp.Syntax.InvocationExpressionSyntax node, DiagnosticBag diagnostics) Line 148\r\nCSharp.Binder.BindExpressionInternal(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed) Line 384\r\nCSharp.Binder.BindExpression(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed) Line 329\r\nCSharp.Binder.BindExpression(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics) Line 324\r\nCSharp.Binder.BindSimpleBinaryOperator(CSharp.Syntax.BinaryExpressionSyntax node, DiagnosticBag diagnostics) Line 416\r\nCSharp.Binder.BindExpressionInternal(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed) Line 425\r\nCSharp.Binder.BindExpression(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed) Line 329\r\nCSharp.Binder.BindValue(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, CSharp.Binder.BindValueKind valueKind) Line 228\r\nCSharp.Binder.BindArgumentExpression(DiagnosticBag diagnostics, CSharp.Syntax.ExpressionSyntax argumentExpression, RefKind refKind, bool allowArglist) Line 2517\r\nCSharp.Binder.BindAttributeArguments(CSharp.Syntax.AttributeArgumentListSyntax attributeArgumentList, NamedTypeSymbol attributeType, DiagnosticBag diagnostics) Line 303\r\nCSharp.Binder.BindAttributeCore(CSharp.Syntax.AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics) Line 147\r\nCSharp.Binder.BindAttribute(CSharp.Syntax.AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics) Line 105\r\nCSharp.Binder.GetAttribute(CSharp.Syntax.AttributeSyntax node, NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics) Line 98\r\nCSharp.EarlyWellKnownAttributeBinder.GetAttribute(CSharp.Syntax.AttributeSyntax node, NamedTypeSymbol boundAttributeType, out bool generatedDiagnostics) Line 25\r\nCSharp.Symbol.EarlyDecodeDeprecatedOrExperimentalOrObsoleteAttribute(ref EarlyDecodeWellKnownAttributeArguments<CSharp.EarlyWellKnownAttributeBinder, NamedTypeSymbol, CSharp.Syntax.AttributeSyntax, AttributeLocation> arguments, out CSharpAttributeData attributeData, out ObsoleteAttributeData obsoleteData) Line 170\r\nSourceNamedTypeSymbol.EarlyDecodeWellKnownAttribute(ref EarlyDecodeWellKnownAttributeArguments<CSharp.EarlyWellKnownAttributeBinder, NamedTypeSymbol, CSharp.Syntax.AttributeSyntax, AttributeLocation> arguments) Line 565\r\nCSharp.Symbol.EarlyDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray<CSharp.Binder> binders, System.Collections.Immutable.ImmutableArray<NamedTypeSymbol> boundAttributeTypes, System.Collections.Immutable.ImmutableArray<CSharp.Syntax.AttributeSyntax> attributesToBind, AttributeLocation symbolPart, CSharpAttributeData[] boundAttributesBuilder) Line 577\r\nCSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany<SyntaxList<CSharp.Syntax.AttributeListSyntax>> attributesSyntaxLists, ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag, AttributeLocation symbolPart, bool earlyDecodingOnly, CSharp.Binder binderOpt, System.Func<CSharp.Syntax.AttributeSyntax, bool> attributeMatchesOpt) Line 303\r\nSourceNamedTypeSymbol.GetAttributesBag() Line 460\r\nSourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData() Line 507\r\nSourceNamedTypeSymbol.NonNullTypes.get() Line 942\r\nSourceNamedTypeSymbol.GetDeclaredBases(Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, bool ignoreNonNullTypesAttribute) Line 229\r\n```\r\n\r\nCycle 15 is when there was in `MakeAcyclicBaseType`, which would call `FindBaseRefSyntax` (which calls `BindType`) to report use-site diagnostics on bases.\r\n\r\nCycle 16 isn't solved yet:\r\n```\r\n\r\n\r\nCSharp.Binder.NonNullTypes.get() Line 228\r\nCSharp.Binder.BindNamespaceOrTypeOrAliasSymbol(CSharp.Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics) Line 376\r\nCSharp.Binder.BindTypeOrAlias(CSharp.Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved) Line 271\r\nCSharp.Binder.BindType(CSharp.Syntax.ExpressionSyntax syntax, DiagnosticBag diagnostics, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved) Line 251\r\nCSharp.Symbols.SourcePropertySymbol.ComputeType(CSharp.Binder binder,Syntax.BasePropertyDeclarationSyntax syntax, DiagnosticBag diagnostics) Line 1441\r\nCSharp.Symbols.SourcePropertySymbol.SourcePropertySymbol(CSharp.Symbols.SourceMemberContainerTypeSymbol containingType,Binder bodyBinder,Syntax.BasePropertyDeclarationSyntax syntax, string name, Location location, DiagnosticBag diagnostics) Line 241\r\nCSharp.Symbols.SourcePropertySymbol.Create(CSharp.Symbols.SourceMemberContainerTypeSymbol containingType,Binder bodyBinder,Syntax.PropertyDeclarationSyntax syntax, DiagnosticBag diagnostics) Line 458\r\nCSharp.Symbols.SourceMemberContainerTypeSymbol.AddNonTypeMembers(CSharp.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializersBuilder builder, SyntaxList<CSharp.Syntax.MemberDeclarationSyntax> members, DiagnosticBag diagnostics) Line 3058\r\nCSharp.Symbols.SourceMemberContainerTypeSymbol.AddDeclaredNontypeMembers(CSharp.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializersBuilder builder, DiagnosticBag diagnostics) Line 2419\r\nCSharp.Symbols.SourceMemberContainerTypeSymbol.BuildMembersAndInitializers(DiagnosticBag diagnostics) Line 2343\r\nCSharp.Symbols.SourceMemberContainerTypeSymbol.GetMembersAndInitializers() Line 1339\r\nCSharp.Symbols.SourceMemberContainerTypeSymbol.GetEarlyAttributeDecodingMembersDictionary() Line 1312\r\nCSharp.Symbols.SourceMemberContainerTypeSymbol.GetEarlyAttributeDecodingMembers(string name) Line 1305\r\nCSharp.Binder.GetCandidateMembers(CSharp.Symbols.NamespaceOrTypeSymbol nsOrType, string name,LookupOptions options,Binder originalBinder) Line 1075\r\nCSharp.Binder.LookupMembersWithoutInheritance(CSharp.LookupResult result,Symbols.TypeSymbol type, string name, int arity,LookupOptions options,Binder originalBinder,Symbols.TypeSymbol accessThroughType, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved) Line 664\r\nCSharp.Binder.LookupMembersInClass(CSharp.LookupResult result,Symbols.TypeSymbol type, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved,LookupOptions options,Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 697\r\nCSharp.Binder.LookupMembersInType(CSharp.LookupResult result,Symbols.TypeSymbol type, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved,LookupOptions options,Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 187\r\nCSharp.Binder.LookupMembersInternal(CSharp.LookupResult result,Symbols.NamespaceOrTypeSymbol nsOrType, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved,LookupOptions options,Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 164\r\nCSharp.InContainerBinder.LookupSymbolsInSingleBinder(CSharp.LookupResult result, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved,LookupOptions options,Binder originalBinder, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 237\r\nCSharp.Binder.LookupSymbolsInternal(CSharp.LookupResult result, string name, int arity, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved,LookupOptions options, bool diagnose, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics) Line 94\r\nCSharp.Binder.LookupSymbolsWithFallback(CSharp.LookupResult result, string name, int arity, ref System.Collections.Generic.HashSet<DiagnosticInfo> useSiteDiagnostics, Roslyn.Utilities.ConsList<CSharp.Symbol> basesBeingResolved,LookupOptions options) Line 61\r\nCSharp.Binder.BindIdentifier(CSharp.Syntax.SimpleNameSyntax node, bool invoked, bool indexed, DiagnosticBag diagnostics) Line 1216\r\nCSharp.Binder.BindLeftOfPotentialColorColorMemberAccess(CSharp.Syntax.ExpressionSyntax left, DiagnosticBag diagnostics) Line 5224\r\nCSharp.Binder.BindMemberAccess(CSharp.Syntax.MemberAccessExpressionSyntax node, bool invoked, bool indexed, DiagnosticBag diagnostics) Line 5172\r\nCSharp.Binder.BindExpressionInternal(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed) Line 402\r\nCSharp.Binder.BindExpression(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed) Line 329\r\nCSharp.Binder.BindValue(CSharp.Syntax.ExpressionSyntax node, DiagnosticBag diagnostics,Binder.BindValueKind valueKind) Line 228\r\nCSharp.Binder.BindArgumentExpression(DiagnosticBag diagnostics,Syntax.ExpressionSyntax argumentExpression, RefKind refKind, bool allowArglist) Line 2517\r\nCSharp.Binder.BindAttributeArguments(CSharp.Syntax.AttributeArgumentListSyntax attributeArgumentList,Symbols.NamedTypeSymbol attributeType, DiagnosticBag diagnostics) Line 303\r\nCSharp.Binder.BindAttributeCore(CSharp.Syntax.AttributeSyntax node,Symbols.NamedTypeSymbol attributeType, DiagnosticBag diagnostics) Line 147\r\nCSharp.Binder.BindAttribute(CSharp.Syntax.AttributeSyntax node,Symbols.NamedTypeSymbol attributeType, DiagnosticBag diagnostics) Line 105\r\nCSharp.Binder.GetAttribute(CSharp.Syntax.AttributeSyntax node,Symbols.NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics) Line 98\r\nCSharp.EarlyWellKnownAttributeBinder.GetAttribute(CSharp.Syntax.AttributeSyntax node,Symbols.NamedTypeSymbol boundAttributeType, out bool generatedDiagnostics) Line 25\r\nCSharp.Symbols.SourceNamedTypeSymbol.EarlyDecodeWellKnownAttribute(ref EarlyDecodeWellKnownAttributeArguments<CSharp.EarlyWellKnownAttributeBinder,Symbols.NamedTypeSymbol,Syntax.AttributeSyntax,Symbols.AttributeLocation> arguments) Line 577\r\nCSharp.Symbol.EarlyDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray<CSharp.Binder> binders, System.Collections.Immutable.ImmutableArray<CSharp.Symbols.NamedTypeSymbol> boundAttributeTypes, System.Collections.Immutable.ImmutableArray<CSharp.Syntax.AttributeSyntax> attributesToBind,Symbols.AttributeLocation symbolPart,Symbols.CSharpAttributeData[] boundAttributesBuilder) Line 577\r\nCSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany<SyntaxList<CSharp.Syntax.AttributeListSyntax>> attributesSyntaxLists, ref CustomAttributesBag<CSharp.Symbols.CSharpAttributeData> lazyCustomAttributesBag,Symbols.AttributeLocation symbolPart, bool earlyDecodingOnly,Binder binderOpt, System.Func<CSharp.Syntax.AttributeSyntax, bool> attributeMatchesOpt) Line 303\r\nCSharp.Symbols.SourceNamedTypeSymbol.GetAttributesBag() Line 460\r\nCSharp.Symbols.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData() Line 507\r\nCSharp.Symbols.SourceNamedTypeSymbol.NonNullTypes.get() Line 942\r\nCSharp.Symbols.PropertySymbol.NonNullTypes.get() Line 177\r\nCSharp.Symbols.SourcePropertySymbol.NonNullTypes.get() Line 1519\r\nCSharp.Binder.NonNullTypes.get() Line 228\r\n```\r\n\r\nThere was another cycle, but I lost my notes for it. I'll gather the information and add here."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"8014163224","Type":"PullRequestEvent","CreatedAt":"2018-07-25T04:53:30","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6137","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#6137) at dotnet/corert","RelatedBody":""},{"Id":"8012691276","Type":"PullRequestEvent","CreatedAt":"2018-07-24T20:51:06","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6137","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#6137) at dotnet/corert","RelatedBody":""},{"Id":"8012689453","Type":"PullRequestEvent","CreatedAt":"2018-07-24T20:50:44","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6136","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6136) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8012639816","Type":"PullRequestEvent","CreatedAt":"2018-07-24T20:40:48","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6136","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6136) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8011640268","Type":"PullRequestEvent","CreatedAt":"2018-07-24T17:25:46","Actor":"acmyu","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6135","RelatedDescription":"Opened pull request \"New ReadyToRunCompilationModuleGroup\" (#6135) at dotnet/corert","RelatedBody":""},{"Id":"8005965193","Type":"PullRequestEvent","CreatedAt":"2018-07-23T19:32:47","Actor":"jkotas","Repository":"dotnet/","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6134","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6134) at dotnet/","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8005965193","Type":"PullRequestEvent","CreatedAt":"2018-07-23T19:32:47","Actor":"jkotas","Repository":"dotnet/","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6134","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6134) at dotnet/","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8005943206","Type":"PullRequestEvent","CreatedAt":"2018-07-23T19:28:23","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6134","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6134) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8002812508","Type":"PullRequestEvent","CreatedAt":"2018-07-23T09:43:58","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6133","RelatedDescription":"Merged pull request \"Merge nmirror to master\" (#6133) at dotnet/corert","RelatedBody":""},{"Id":"8002453519","Type":"PullRequestEvent","CreatedAt":"2018-07-23T08:33:52","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6133","RelatedDescription":"Opened pull request \"Merge nmirror to master\" (#6133) at dotnet/corert","RelatedBody":""},{"Id":"8002451699","Type":"PullRequestEvent","CreatedAt":"2018-07-23T08:33:29","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6132","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6132) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"8002450069","Type":"PullRequestEvent","CreatedAt":"2018-07-23T08:33:09","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6132","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6132) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"8012781994","Type":"PullRequestEvent","CreatedAt":"2018-07-24T21:09:26","Actor":"dsplaisted","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/2427","RelatedDescription":"Merged pull request \"[Experimental] Fix tests, etc\" (#2427) at dotnet/sdk","RelatedBody":""},{"Id":"8010371710","Type":"IssuesEvent","CreatedAt":"2018-07-24T13:59:42","Actor":"jarz","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2429","RelatedDescription":"Opened issue \"Passing MSBuild property causes build to fail due to private nuget repo\" (#2429) at dotnet/sdk","RelatedBody":"I'm attempting to pass a `Version` property to my `dotnet build` command.\r\n\r\n```\r\n> dotnet build /p:Version=1.0.0\r\nMicrosoft (R) Build Engine version 15.8.138-preview+ge0cd4f1c1f for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restoring packages for C:\\git\\Sample\\Sample.WebAPI\\Sample.WebAPI.csproj...\r\nC:\\Program Files\\dotnet\\sdk\\2.1.400-preview-009063\\NuGet.targets(114,5): error : Unable to load the service index for source https://CONTOSO.pkgs.visualstudio.com/_packaging/AllePackages/nuget/v3/index.json. [C:\\git\\Sample\\Sample.WebAPI\\Sample.WebAPI.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\2.1.400-preview-009063\\NuGet.targets(114,5): error :   Response status code does not indicate success: 401 (Unauthorized). [C:\\git\\Sample\\Sample.WebAPI\\Sample.WebAPI.csproj]\r\n\r\nBuild FAILED.\r\n\r\nC:\\Program Files\\dotnet\\sdk\\2.1.400-preview-009063\\NuGet.targets(114,5): error : Unable to load the service index for source https://CONTOSO.pkgs.visualstudio.com/_packaging/AllePackages/nuget/v3/index.json. [C:\\git\\Sample\\Sample.WebAPI\\Sample.WebAPI.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\2.1.400-preview-009063\\NuGet.targets(114,5): error :   Response status code does not indicate success: 401 (Unauthorized). [C:\\git\\Sample\\Sample.WebAPI\\Sample.WebAPI.csproj]\r\n    0 Warning(s)\r\n    1 Error(s)\r\n\r\nTime Elapsed 00:00:01.88\r\n```"},{"Id":"8006695208","Type":"IssuesEvent","CreatedAt":"2018-07-23T22:06:44","Actor":"svick","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2428","RelatedDescription":"Opened issue \"Confusing error message for circular project dependency\" (#2428) at dotnet/sdk","RelatedBody":"I created a project with project reference to itself by accident. When I tried to build it, it produced a confusing error message. I think that error message should be improved.\r\n\r\nTor reproduce this, you can follow these steps.\r\n\r\n```powershell\r\n> cd (mkdir cycle)\r\n> dotnet new console\r\n> dotnet add reference ../cycle\r\n> dotnet restore\r\nC:\\Program Files\\dotnet\\sdk\\2.1.300\\NuGet.targets(913,5): error MSB4006: There is a circular\r\ndependency in the target dependency graph involving target \"_GenerateRestoreProjectPathWalk\".\r\n```\r\n\r\nI think that especially the mention of `_GenerateRestoreProjectPathWalk` should not be in the error message, since it doesn't help to the user in any way."}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1020476243089608704","CreatedAt":"2018-07-21T01:11:10+00:00","UserScreenname":"dotnet","Text":"Advisory on July 2018 .NET Framework Updates https://t.co/nMiUiov4NS #sorry #psa","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":50,"FavoriteCount":34,"RawContent":null},{"Id":"1019942507344482305","CreatedAt":"2018-07-19T13:50:18+00:00","UserScreenname":"dotnet","Text":"Our @csharpfritz is hosting another workshop tomorrow, and his guest at 12 ET / 11 CT / 9 PT is @jbogard.  Tune in… https://t.co/0aqBYfhA08","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":13,"FavoriteCount":10,"RawContent":null},{"Id":"1019598416861544453","CreatedAt":"2018-07-18T15:03:00+00:00","UserScreenname":"dotnet","Text":"#dotNETConf is back for 2018! 3 days of free #dotnet #developer content streaming live around the globe. Save the d… https://t.co/tloJwxPMb9","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":523,"FavoriteCount":368,"RawContent":null},{"Id":"1019283191507582981","CreatedAt":"2018-07-17T18:10:24+00:00","UserScreenname":"dotnet","Text":"Check out the replay and learn about building reusable business objects in your applications from @RockyLhotka and… https://t.co/VnbmnXt31C","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":15,"FavoriteCount":8,"RawContent":null},{"Id":"1019254182673436672","CreatedAt":"2018-07-17T16:15:08+00:00","UserScreenname":"dotnet","Text":"Code refactoring support in Visual Studio 2017 with @kuhlenhuth https://t.co/HkaG7b6Ac3","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":60,"FavoriteCount":28,"RawContent":null},{"Id":"1019207783844139010","CreatedAt":"2018-07-17T13:10:46+00:00","UserScreenname":"dotnet","Text":"Always a great time, and two experts that are wonderful to learn from.  Tune in at 10a ET / 7a PT / 14:00 UTC / 8p… https://t.co/PQsuqaJQY4","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":4,"RawContent":null},{"Id":"1018952801953681411","CreatedAt":"2018-07-16T20:17:33+00:00","UserScreenname":"dotnet","Text":"Rocky's got great insight into building Enterprise applications.  Be sure to tune in tomorrow when he pair-programs… https://t.co/cdQT99n8kk","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":10,"FavoriteCount":4,"RawContent":null},{"Id":"1018877434584817664","CreatedAt":"2018-07-16T15:18:04+00:00","UserScreenname":"dotnet","Text":"Our Jeff Fritz will be hosting another one of his FREE workshops this Friday.  This week, tune in and learn about s… https://t.co/06laByebWA","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":34,"FavoriteCount":14,"RawContent":null}]}},"RunOn":"2018-07-25T05:30:34.3917848Z","RunDurationInMilliseconds":8239}