{"Data":{"Blog":{"FeedItems":[{"Title":"Modernize existing .NET apps with Windows Containers and Azure","PublishedOn":"2017-11-01T23:14:48+00:00","CommentsCount":18,"FacebookCount":0,"Summary":"As part of the series of posts announced at this initial blog post (.NET Application Architecture Guidance) that explores each of the architecture areas currently covered by our team, this current...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/01/modernize-existing-net-apps-with-windows-containers-and-azure/","RawContent":null},{"Title":"Introducing API Analyzer","PublishedOn":"2017-10-31T23:24:24+00:00","CommentsCount":21,"FacebookCount":0,"Summary":"This post was written by Olia Gavrysh. Have you ever wondered which APIs are deprecated and which should you use instead? Or have you ever used an API and then found out it didn&#8217;t work on Mac or...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/31/introducing-api-analyzer/","RawContent":null},{"Title":"Welcome to C# 7.1","PublishedOn":"2017-10-31T22:39:48+00:00","CommentsCount":40,"FacebookCount":0,"Summary":"With C# we have always tended towards major releases: bundle a lot of features up, and release less frequently. We even went so far as routinely omitting the traditional &#34;.0&#34; when we talked...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/31/welcome-to-c-7-1/","RawContent":null},{"Title":"Moving to real time test discovery in Test Explorer","PublishedOn":"2017-10-30T22:46:58+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Real time test discovery is a new Visual Studio feature that uses a Roslyn analyzer to discover tests and populate the test explorer in real time without requiring you to build your project. This...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/30/real-time-test-discovery/","RawContent":null},{"Title":"Entity Framework 6.2 Runtime Released","PublishedOn":"2017-10-26T21:32:59+00:00","CommentsCount":21,"FacebookCount":0,"Summary":"Today we announce the availability of EF 6.2 runtime in NuGet.org. Entity Framework (EF) is Microsoft&#8217;s traditional object/relational mapper (O/RM) for .NET Framework. To understand the...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/26/entity-framework-6-2-runtime-released/","RawContent":null},{"Title":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018","PublishedOn":"2017-10-23T16:41:13+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"This post was written by Varun Venkatesan, Li Tian, and Juan Rodriguez, engineers at Intel. They are excited to share .NET Core-specific enhancements that Intel has made to VTune Amplifier 2018....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/23/net-core-performance-profiling-with-intel-vtune-amplifier-2018/","RawContent":null},{"Title":"Experiment with Azure for FREE!","PublishedOn":"2017-10-19T14:00:11+00:00","CommentsCount":39,"FacebookCount":0,"Summary":"What is Azure? What can it do for me? Do I need it? How do I find out? How do I use it? Will it help my business? Can it help my career? With all the things Azure can do, it&#8217;s hard to know where...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/19/experiment-with-azure-for-free/","RawContent":null},{"Title":"Announcing the .NET Framework 4.7.1","PublishedOn":"2017-10-17T21:26:30+00:00","CommentsCount":38,"FacebookCount":0,"Summary":"Today, we are announcing the release of the .NET Framework 4.7.1. It’s included in the Windows 10 Fall Creators Update. .NET Framework 4.7.1 is also available on Windows 7+ and Windows Server 2008...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/","RawContent":null},{"Title":".NET Framework October 2017 Preview of Quality Rollup","PublishedOn":"2017-10-17T20:56:56+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Today, we are releasing the October 2017 Preview of Quality Rollup. This type of rollup is intended for businesses that want to the preview or use quality improvements as soon as they are available....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/17/net-framework-october-2017-preview-of-quality-rollup/","RawContent":null},{"Title":"RyuJIT Just-in-Time Compiler Optimization Enhancements","PublishedOn":"2017-10-17T05:16:50+00:00","CommentsCount":15,"FacebookCount":0,"Summary":"I&#8217;d like to tell you about some of the recent changes we&#8217;ve made as part of our ongoing work to extend the optimization capabilities of RyuJIT, the MSIL-to-native code generator used by...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6797468573","Type":"PullRequestEvent","CreatedAt":"2017-11-01T23:04:17","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Opened pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6767783059","Type":"IssuesEvent","CreatedAt":"2017-10-26T05:52:31","Actor":"HarelM","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Opened issue \"File system watcher crach\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6803910341","Type":"IssuesEvent","CreatedAt":"2017-11-03T04:47:03","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/37","RelatedDescription":"Opened issue \"microsoft/dotnet nanoserver images now support Windows Server 1709\" (#37) at dotnet/announcements","RelatedBody":"# microsoft/dotnet nanoserver images now support Windows Server 1709\r\n\r\n[Windows Server Version 1709](https://blogs.technet.microsoft.com/windowsserver/2017/10/17/windows-server-version-1709-available-for-download/) was released in October. [microsoft/nanoserver](https://hub.docker.com/r/microsoft/nanoserver/) images have been updated to support [Windows Server 1709](https://docs.microsoft.com/en-us/windows-server/get-started/whats-new-in-windows-server-1709). These images can be identified with the `nanoserver-1709` [tag](https://hub.docker.com/r/microsoft/windowsservercore/tags/) substring.\r\n\r\nThe following repos have been updated:\r\n\r\n* [microsoft/aspnetcore](https://hub.docker.com/r/microsoft/aspnetcore/)\r\n* [microsoft/aspnetcore-build](https://hub.docker.com/r/microsoft/aspnetcore-build/)\r\n* [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet)\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet/dotnet-docker #330](https://github.com/dotnet/dotnet-docker/issues/330)\r\n\r\n## Details\r\n\r\n* [dotnet/dotnet-docker #321](https://github.com/dotnet/dotnet-docker/pull/321)\r\n* [dotnet/dotnet-docker #322](https://github.com/dotnet/dotnet-docker/issues/322)\r\n* [dotnet/dotnet-docker #329](https://github.com/dotnet/dotnet-docker/pull/329)\r\n\r\n.NET Core Docker images now support Windows Server 1709, the latest version of Windows Server.\r\n\r\nYou can see an example of 1709-based images in the following example.\r\n\r\n![.NET Core nanoserver 1709 images](https://user-images.githubusercontent.com/2608468/32360772-61680cec-c016-11e7-851d-0d962c35fe41.png)\r\n\r\nYou can identify Windows Server 1709-based .NET Core images with the tag substring `nanoserver-1709` and Windows Server 2016 images with the tag substring `nanoserver-sac2016`.\r\n\r\nChanges have been made in Windows Server 1709 that affect the [compatibility of Windows container images](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility). The practical impact is that Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creative Update hosts cannot load Windows Server 1709 images. Windows 10 Fall Creative Update and Windows Server 1709 can load both original Windows Server 2016 and Windows Server 1709 images. Windows Server 1709 requires Hyper-V isolation (`docker run --isolation=hyperv`) in order to load Windows Server 2016 images.\r\n\r\nGiven the compatibility differences with Windows container images, .NET Core images will adopt [manifest lists](https://github.com/dotnet/dotnet-docker/issues/322) so that a single logical tag, like `2.0-runtime`, can be used on both older and newer Windows 10 and Windows Server versions. `docker pull microsoft/dotnet:2.0-runtime` will pull a Windows Server 2016 image on Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creators Update machines. The same command will pull a Windows Server 1709 based image on Windows Server 1709 and Windows 10 Fall Creators Update machines. The same rules apply to FROM lines.\r\n\r\n[.NET Framework](https://github.com/dotnet/announcements/issues/36) Docker images are also using manifest lists for the same reason.\r\n\r\nYou need [Docker 17.10](https://docs.docker.com/release-notes/docker-ce/#17100-ce-2017-10-17) or later to use Windows-version-specific manifest list tags. The following change from the Docker 17.10 release notes is the one that enables this functionality.\r\n\r\n* Add support for Windows version filtering on pull [moby/moby#35090](https://github.com/moby/moby/pull/35090)\r\n\r\nYou are only recommended to use manifest tags if you want flexibility for development and deployment environments. That's what manifest tags deliver. In general, you should select the most specific tag you can. The more specific the tag, the more predictable the result of each `docker pull` and `docker build` will be.\r\n"},{"Id":"6766996801","Type":"IssuesEvent","CreatedAt":"2017-10-26T00:24:01","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/36","RelatedDescription":"Opened issue \"microsoft/dotnet-framework images now support Windows Server 1709\" (#36) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework images now support Windows Server 1709\r\n\r\n[Windows Server Version 1709](https://blogs.technet.microsoft.com/windowsserver/2017/10/17/windows-server-version-1709-available-for-download/) was released earlier this month. [microsoft/windowsservercore](https://hub.docker.com/r/microsoft/windowsservercore/) images have been updated to support [Windows Server 1709](https://docs.microsoft.com/en-us/windows-server/get-started/whats-new-in-windows-server-1709). These images can be identified with the `1709` [tag](https://hub.docker.com/r/microsoft/windowsservercore/tags/).\r\n\r\nThe following repos have been updated:\r\n\r\n* [microsoft/aspnet](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #35](https://github.com/Microsoft/dotnet-framework-docker/issues/35)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #31](https://github.com/Microsoft/dotnet-framework-docker/pull/31)\r\n* [microsoft/dotnet-framework-docker #34](https://github.com/Microsoft/dotnet-framework-docker/pull/34)\r\n* [microsoft/dotnet-framework-docker #32](https://github.com/Microsoft/dotnet-framework-docker/issues/32)\r\n\r\n.NET Framework Docker images now support Windows Server 1709, the latest version of Windows Server.\r\n\r\n.NET Framework 3.5 and 4.7.1 images are available for Windows Server 1709. Windows Server 1709 includes the .NET Framework 4.7.1. .NET Framework 4.6.2 and .NET Framework 4.7 images are only available with Windows Server 2016 images. You can see an example of 1709-based images in the following example.\r\n\r\n![.NET Framework Windows 1709 images](https://user-images.githubusercontent.com/2608468/32028249-6684a82c-b9a2-11e7-8afa-1b1abf89eb3b.png)\r\n\r\nYou can identify Windows Server 1709-based .NET Framework images with the tag substring `windowsservercore-1709` and Windows Server 2016 images with the tag substring `windowsservercore-10.0.14393`. You will likely notice that the 1709-based images are easier to identify than the Windows Server 2016 ones. \r\n\r\nChanges have been made in Windows Server 1709 that affect the [compatibility of Windows container images](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility). The practical impact is that Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creative Update hosts cannot load Windows Server 1709 images. Windows 10 Fall Creative Update and Windows Server 1709 can load both original Windows Server 2016 and Windows Server 1709 images. Windows Server 1709 requires Hyper-V isolation (`docker run --isolation=hyperv`) in order to load Windows Server 2016 images.\r\n\r\nGiven the compatibility differences with Windows container images, .NET Framework images will adopt [manifest lists](https://github.com/Microsoft/dotnet-framework-docker/issues/32) so that a single logical tag, like `4.7.1`, can be used on both older and newer Windows 10 and Windows Server versions. `docker pull microsoft/dotnet-framework:4.7.1` will pull a Windows Server 2016 image on Windows Server 2016, Windows 10 Anniversary Update, and Windows 10 Creators Update machines. The same command will pull a Windows Server 1709 based image on Windows Server 1709 and Windows 10 Fall Creators Update machines. The same rules apply to FROM lines. [.NET Core](https://hub.docker.com/r/microsoft/dotnet) Docker images use this same feature to support Linux and Windows hosts and AMD64 and ARM32 hosts with the same logical tag, like `2.0-runtime`.\r\n\r\nThe following tags will be updated to use manifest lists:\r\n\r\n- `latest`\r\n- `4.7.1`\r\n- `3.5`\r\n\r\nYou need [Docker 17.10](https://docs.docker.com/release-notes/docker-ce/#17100-ce-2017-10-17) or later to use Windows-version-specific manifest list tags. The following change from the Docker 17.10 release notes is the one that enables this functionality.\r\n\r\n* Add support for Windows version filtering on pull [moby/moby#35090](https://github.com/moby/moby/pull/35090)\r\n\r\nYou are only recommended to use manifest tags if you want flexibility for development and deployment environments. That's what manifest tags deliver. In general, you should select the most specific tag you can. The more specific the tag, the more predictable the result of each `docker pull` and `docker build` will be."},{"Id":"6761784781","Type":"IssuesEvent","CreatedAt":"2017-10-25T04:03:38","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/35","RelatedDescription":"Opened issue \"microsoft/dotnet-framework latest tag updated to 4.7.1\" (#35) at dotnet/announcements","RelatedBody":"# microsoft/dotnet-framework latest tag updated to 4.7.1\r\n\r\nThe [.NET Framework 4.7.1](https://blogs.msdn.microsoft.com/dotnet/2017/10/17/announcing-the-net-framework-4-7-1/) was released earlier this month. The [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework) `latest` [tag](https://hub.docker.com/r/microsoft/dotnet-framework/tags/) was also updated.\r\n\r\nThe .NET Framework 4.7.1 is represented by the `microsoft/dotnet-framework:4.7.1` tag.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [Microsoft/dotnet-framework-docker #33](https://github.com/Microsoft/dotnet-framework-docker/issues/33)\r\n\r\n## Details\r\n\r\n* [microsoft/dotnet-framework-docker #28](https://github.com/Microsoft/dotnet-framework-docker/pull/28)\r\n* [microsoft/dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework 4.7.1 image is now available as a Docker image. The `latest` tag points to the same image.\r\n\r\nThe following repos were updated:\r\n\r\n* [microsoft/asp](https://hub.docker.com/r/microsoft/aspnet/)\r\n* [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework)\r\n* [microsoft/wcf](https://hub.docker.com/r/microsoft/wcf)\r\n\r\nThe [microsoft/dotnet-framework-samples](https://hub.docker.com/r/microsoft/dotnet-framework-samples) repo has not yet been updated.\r\n\r\nWe recommend that you use version-specific tags for production apps. For experimentation or while an application is in development, using the `latest` tag is a fine practice.\r\n\r\nWe recently found a [significant performance issue with .NET Framework Docker images](https://github.com/dotnet/announcements/issues/33). The .NET Framework 4.7.1 image includes the fix for that problem.\r\n"},{"Id":"6729762964","Type":"IssuesEvent","CreatedAt":"2017-10-17T21:21:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/34","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2017-8585 : Malformed Culture can cause application crash\" (#34) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-8585 \r\n## Malformed Culture can cause application to crash\r\n### Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed string request could cause an application to crash and lead to a denial of service.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.7 and 1.1.4. Developers are advised to update their .NET Core SDK to version 1.1.4.\r\n\r\n### Discussion\r\n\r\nUse https://github.com/dotnet/corefx/issues/24703 for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n\r\n.NET Core 2.0 is not affected by this issue.\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.6 or lower versions, or 1.1.2 or lower versions is affected. The latest version of the .NET core runtime you have installed in your computer can be listed by running `dotnet --info`. Running that command produces an output similar to the following:\r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\nAs this command only displays the latest version of the runtime installed (or the version set in the *global.json* file), it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location          |\r\n|------------------|-------------------|\r\n| Windows          | C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\ |\r\n| macOS            | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n| [Supported Linux platforms](https://docs.microsoft.com/dotnet/core/linux-prerequisites#supported-linux-versions) | /usr/share/dotnet/shared/Microsoft.NETCore.App/ |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.7 and 1.1.4, then any applications targeting 1.0 or 1.1 of .NET Core are vulnerable.\r\n\r\nAlso, even if you have a directory for 1.0.7 and 1.1.4 present in your system, if you've deployed [self-contained applications](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd) targeting the impacted versions, these applications are also vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). .NET Core 1.1.4 SDK installs both versions 1.0.7 and 1.1.4 of the .NET Core runtime.\r\n\r\nIf you've built a [self-contained application](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd), you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [*application.runtime.config*](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application. Set the framework version to the desired version and the `rollForward` property to `false`. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the *application.runtime.config* file is an optional file, you may need to create one for each application and add it alongside the executable."},{"Id":"6725652001","Type":"IssuesEvent","CreatedAt":"2017-10-17T06:48:14","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/33","RelatedDescription":"Opened issue \".NET Framework Docker Performance Issue Resolved\" (#33) at dotnet/announcements","RelatedBody":"# .NET Framework Docker Performance Issue Resolved\r\n\r\nMultiple people have [reported](https://github.com/Microsoft/dotnet-framework-docker/issues/25) that [.NET Framework performance in Docker images is poor](https://github.com/moby/moby/issues/33096). In the cases reported, performance was an order of magnitude slower than expected.\r\n\r\nThis issue has now been resolved for [microsoft/dotnet-framework](https://hub.docker.com/r/microsoft/dotnet-framework/) images. It was due to incorrectly generated NGEN images. They are now correctly generated and expected performance has been restored.\r\n\r\n## Discussion \r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet-framework-docker #29](https://github.com/Microsoft/dotnet-framework-docker/pull/29)\r\n\r\n## Details\r\n\r\n* [dotnet-framework-docker #27](https://github.com/Microsoft/dotnet-framework-docker/pull/27)\r\n\r\nThe .NET Framework uses [NGEN](https://docs.microsoft.com/dotnet/framework/tools/ngen-exe-native-image-generator) as a primary mechanism for startup performance. .NET Framework assemblies are compiled to native code with the NGEN tool as part of the .NET Framework setup process. The benefit of these files is that they can be loaded and executed without any additional significant extra work required by the Common Language Runtime (CLR). The lack of  additional work means that performance is very good.\r\n\r\nNGEN image generation interacts with a Windows subsystem that is not correctly supported in Windows containers. NGEN images are generated in Windows containers, but they are not valid. Fortunately, the CLR can still run in the presence of invalid images, but code execution is much slower.\r\n\r\nWe are in the process of fixing Windows containers so that NGEN will work correctly. In the interim, we have updated the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) images to correctly generate NGEN images. The [microsoft/windowsservercore/](https://hub.docker.com/r/microsoft/windowsservercore/) images still have the performance problem that was initially reported. We are working on updating Windows containers so that NGEN works as expected. You are recommended to use the [dotnet-framework/](https://hub.docker.com/r/microsoft/dotnet-framework/) base image if you can, so that you can get better performance.\r\n\r\nOne of the developers that reported the performance issue shared basic performance results. The first two rows are the before state. The last row is the dotnet-framework image after the fix. The improvement is quite significant.\r\n\r\n> Runing `powershell -command (measure-command { powershell -command exit }).TotalSeconds` in various images on our CI server produced this table of timings:\r\n \r\n| time (s) | image |\r\n|----------|--------|\r\n|10.7212372| microsoft/windowsservercore |\r\n|8.3278793  | microsoft/dotnet-framework:4.7|\r\n|0.6426073  | microsoft/dotnet-framework:4.7 (after fix)|\r\n"},{"Id":"6645912196","Type":"IssuesEvent","CreatedAt":"2017-09-27T19:47:08","Actor":"terrajobst","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/32","RelatedDescription":"Opened issue \".NET Framework 4.7.1 provides built-in support for .NET Standard 2.0\" (#32) at dotnet/announcements","RelatedBody":"## Summary\r\n\r\n.NET Framework 4.7.1 will have built-in support for .NET Standard 2.0. This means that you don't have to deploy any additional files or use binding redirects to use .NET Standard 2.0 libraries.\r\n\r\nFor a demo, check out [this video][video].\r\n\r\n## Details\r\n\r\nWhile libraries targeting [.NET Standard 2.0][ns20post] are can be consumed by applications and libraries [targeting .NET Framework 4.6.1][nstable] and higher, not all files that are required for .NET Standard libraries were part of .NET Framework 4.6.1. In fact, .NET Framework 4.6.1 was shipped before .NET Standard 2.0 was even designed. That's why building an application targeting .NET Framework 4.6.1 (as well as 4.6.2 and 4.7) will have to deploy additional files.\r\n\r\n* If you use **Visual Studio 2017 15.3** or higher, these files are automatically copied to the application's output folder.\r\n\r\n* If you use **Visual Studio 2015 and [use NuGet 3.6][nuget36]**, we'll prompt you to install a [support package][vs2015support] which will handle copying the files to the output directory.\r\n\r\nStarting with .NET Framework 4.7.1 these files no longer have to be deployed with the application -- they are built right into the .NET Framework itself.\r\n\r\n.NET Framework 4.7.1 also adds[about 200 missing APIs][missingapis] that were part of .NET Standard 2.0 but not actually implemented by .NET Framework 4.6.1, 4.6.2 or 4.7.\r\n\r\nThis also removes the need for [binding redirects][netfx-issues] when using .NET Standard libraries on .NET Framework because the CLR automatically unifies version numbers of assemblies that are part of the platform.\r\n\r\nLearn more [by reading the .NET Standard FAQ](http://aka.ms/netstandardfaq).\r\n\r\n## Discussion\r\n\r\nDiscussion\r\n\r\nFor a discussion, please go to dotnet/standard#514.\r\n\r\n[ns20post]: https://blogs.msdn.microsoft.com/dotnet/2017/08/14/announcing-net-standard-2-0/\r\n[nstable]: https://docs.microsoft.com/en-us/dotnet/standard/net-standard\r\n[nuget36]: https://dist.nuget.org/visualstudio-2015-vsix/v3.6.0/NuGet.Tools.vsix\r\n[vs2015support]: https://aka.ms/netstandard-build-support-netfx\r\n[missingapis]: https://github.com/dotnet/standard/blob/master/netstandard/src/ApiCompatBaseline.net461.txt\r\n[netfx-issues]: https://github.com/dotnet/standard/issues/481\r\n[video]: https://www.youtube.com/watch?v=u67Eu_IgEMs\r\n\r\nhttps://github.com/dotnet/standard/issues/514"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6812410124","Type":"IssuesEvent","CreatedAt":"2017-11-06T02:54:41","Actor":"sjsinju","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/13653","RelatedDescription":"Closed issue \"[RyuJIT/ARM32] R2R - Implement the CreateDictionaryLookupHelper stub\" (#13653) at dotnet/coreclr","RelatedBody":"R2R Crossgen with /verbose on Tizen device\r\n\r\n```\r\nCOMPlus_AltJitNgen=* ./crossgen /verbose /ReadyToRun xxx.dll\r\n```\r\n\r\nWe can see following \r\n```\r\n...\r\nError 2147500033 (Exception from HRESULT: 0x80004001 (E_NOTIMPL)) while compiling method EvasObjectEvent`1.Dispose\r\nCompiling method EvasObjectEvent`1.Dispose\r\nError 2147500033 (Exception from HRESULT: 0x80004001 (E_NOTIMPL)) while compiling method EvasObjectEvent`1.Dispose\r\nCompiling method EvasObjectEvent`1.remove_On\r\n...\r\n```\r\n\r\nI found it had been thrown from below.\r\nvm/jitinterface.cpp\r\n```cpp\r\n 3132 #ifdef FEATURE_READYTORUN_COMPILER\r\n 3133     if (IsReadyToRunCompilation())\r\n 3134     {\r\n 3135 #if defined(_TARGET_ARM_)\r\n 3136         ThrowHR(E_NOTIMPL); /* TODO - NYI */\r\n 3137 #endif\r\n 3138         pResultLookup->lookupKind.runtimeLookupArgs = NULL;\r\n 3139 \r\n 3140         switch (entryKind)\r\n```\r\n\r\nvm/arm/stubs.cpp\r\n```cpp\r\n\r\n3766 PCODE DynamicHelpers::CreateDictionaryLookupHelper(LoaderAllocator * pAllocator, CORINFO_RUNTIME_LOOKUP * pLookup, DWORD dictionaryIndexAndSlot, Module * pModule)\r\n3767 {\r\n3768     STANDARD_VM_CONTRACT;\r\n3769 \r\n3770     // TODO (NYI)\r\n3771     ThrowHR(E_NOTIMPL);\r\n3772 }\r\n\r\n```\r\n\r\nThis helper should be implemented for R2R on ARM architecture."},{"Id":"6812004150","Type":"PullRequestEvent","CreatedAt":"2017-11-05T23:20:31","Actor":"yvanin","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14872","RelatedDescription":"Opened pull request \"Allow any string length in Environment.SetEnvironmentVariable\" (#14872) at dotnet/coreclr","RelatedBody":"Fix for CoreFX [#16766](https://github.com/dotnet/corefx/issues/16766)"},{"Id":"6811412434","Type":"PullRequestEvent","CreatedAt":"2017-11-05T17:43:06","Actor":"mikedn","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/14871","RelatedDescription":"Opened pull request \"Remove unused VNF_DIV_UN and VNF_MOD_UN\" (#14871) at dotnet/coreclr","RelatedBody":"Integer division operators do not use `GTF_UNSIGNED`. There are distinct unsigned operators (`GT_UDIV` and `GT_UMOD`) and VN already handles those directly."},{"Id":"6811218815","Type":"IssuesEvent","CreatedAt":"2017-11-05T15:50:13","Actor":"Alecu100","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/14870","RelatedDescription":"Opened issue \"[Question] Checked/free mismatch with native image exception\" (#14870) at dotnet/coreclr","RelatedBody":"So I tried to setup my own coreCLR project locally to debug it and understand it better.\r\n\r\nI could not understand if the instructions in the readme and documentation section of the repository is up to date.\r\n\r\nSo I tried something similar. I created a .net core application in Visual Studio 2017. And I added a reference to the CoreCLR I just built like this in the project:\r\n\r\n    <PackageReference Include=\"Microsoft.NETCore.Runtime.CoreCLR\" Version=\"2.0.0\" /> \r\n\r\nThen I created a new nugget package source and pointed it to the build directory when the coreCLR libraries are stored after you build them, the bin/Product/platform/.nugget directory.\r\n\r\nThen I changed the project to be self-contained, to copy all the assemblies locally and not depend on anything. I added a new entry in the project: for this:\r\n\r\n    <RuntimeIdentifier>win7-x64</RuntimeIdentifier>\r\n\r\nAnd that's about all. I checked and when I start to debug coreCLR in a .net core project it crashes at this line:\r\n\r\n`    if (info->wBuild !=\r\n#if _DEBUG\r\n        CORCOMPILE_BUILD_CHECKED\r\n#else\r\n        CORCOMPILE_BUILD_FREE\r\n#endif\r\n        )\r\n    {\r\n        RuntimeVerifyLog(LL_ERROR, pLogAsm, W(\"Checked/free mismatch with native image.\"));\r\n        return FALSE;\r\n    }`\r\n\r\nI don't know if I am doing something wrong here. "},{"Id":"6811195707","Type":"IssuesEvent","CreatedAt":"2017-11-05T15:36:29","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/14869","RelatedDescription":"Closed issue \"[Question] Span enumerator\" (#14869) at dotnet/coreclr","RelatedBody":"@jkotas @KrzysztofCwalina @jaredpar @VSadov \r\n\r\nAre there plans for Span enumerator?\r\nIt could be a ref-like type implementing enumerable pattern.\r\n\r\n"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6809672537","Type":"PullRequestEvent","CreatedAt":"2017-11-04T19:28:03","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/7964","RelatedDescription":"Opened pull request \"Removing two stage build\" (#7964) at dotnet/cli","RelatedBody":"- Changed how we version by using the BUILD_BUILDNUMBER like the SDK instead of commit count. We don't need commit count as we don't have multiple legs on this repo anymore.\r\n\r\n- Removed two staged build, now that commit count is not needed. Also removed HostInfo and BuildInfo needs from the build.\r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6811119146","Type":"IssuesEvent","CreatedAt":"2017-11-05T14:51:49","Actor":"jp2masa","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/465","RelatedDescription":"Closed issue \"Question - Using .NET Standard 2.0 libraries in VSIX projects\" (#465) at dotnet/standard","RelatedBody":"I want to know what is the correct way of distributing a Visual Studio extension with .NET Standard 2.0 libraries.\r\nThe libraries I use were targeting .NET Standard 1.5 and I would add references to System.Runtime, System.Reflection,... in the VSIX project, then set `ForceIncludeInVSIX` metadata to `true` and the references were included in the VSIX.\r\nAfter upgrading Visual Studio 2017 to version 15.3 and installing the .NET Core 2.0 SDK, this no longer works, resulting in missing references.\r\nNow I'm upgrading the libraries to .NET Standard 2.0, what should I do to make sure the extension will work? Should I include `netstandard.dll`?\r\nCurrently I'm using this MSBuild target in the VSIX project:\r\n```xml\r\n<Target Name=\"IncludeNETStandardFacadeInVSIX\" AfterTargets=\"ImplicitlyExpandNETStandardFacades\">\r\n  <ItemGroup>\r\n    <Content Include=\"@(_NETStandardLibraryNETFrameworkLib)\" Condition=\"%(Filename) == 'netstandard'\">\r\n      <IncludeInVSIX>True</IncludeInVSIX>\r\n      <VSIXSubPath>/</VSIXSubPath>\r\n    </Content>\r\n  </ItemGroup>\r\n</Target>\r\n```"},{"Id":"6811047787","Type":"IssuesEvent","CreatedAt":"2017-11-05T14:07:11","Actor":"alden-menzalgy","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/573","RelatedDescription":"Opened issue \"There's no way to get managed object size in memory\" (#573) at dotnet/standard","RelatedBody":"Hi,\r\n\r\nThere is no way to get the actual (or even an approximate) size of the cached object in the memory.\r\n\r\nThe case is, we have +100 customized cache for different purposes to accelerate our platform, for each cache we have\r\n- Cache MaxSize\r\n- Cache ConsumedSize\r\n- Cache RemainingSize\r\n\r\nWhenever we insert some object to be cached, we should detect its size to re-calculate aforementioned cache properties.\r\n\r\nI know that's a complex issue and depends on many factors, so far we have some workarounds but non of them is official and we afraid to be changed in any minor or major release.\r\n\r\nShould you add any API to get the object size in the memory ? or at least Type size and then we can add the object-specific data length.\r\n\r\nRelated Topics\r\n[Workaround 1](https://stackoverflow.com/questions/1128315/find-size-of-object-instance-in-bytes-in-c-sharp)\r\n\r\n[What Microsoft says about this issue](https://blogs.msdn.microsoft.com/cbrumme/2003/04/15/size-of-a-managed-object/)"},{"Id":"6809945575","Type":"IssuesEvent","CreatedAt":"2017-11-04T22:44:48","Actor":"michaelsogos","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/572","RelatedDescription":"Opened issue \"Cannot open class diagram .cd file\" (#572) at dotnet/standard","RelatedBody":"Dear,\r\n\r\nIn a .net standard library project, on vs2017 15.4, we cannot open a class diagram file."}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6812171195","Type":"IssuesEvent","CreatedAt":"2017-11-06T01:07:12","Actor":"JonHanna","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25067","RelatedDescription":"Opened issue \"NullReferenceException on unary operators on nullable enums in Microsoft.CSharp\" (#25067) at dotnet/corefx","RelatedBody":"Given:\r\n\r\n```C#\r\nCSharpArgumentInfo x = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, null);\r\nCallSiteBinder binder =\r\n\tBinder.UnaryOperation(\r\n\t\tCSharpBinderFlags.None, ExpressionType.OnesComplement,\r\n\t\tGetType(), new[] { x });\r\nCallSite<Func<CallSite, StringComparison?, object>> site = CallSite<Func<CallSite, StringComparison?, object>>.Create(binder);\r\nFunc<CallSite, StringComparison?, object> targ = site.Target;\r\nobject result = targ(site, StringComparison.InvariantCulture);\r\n```\r\n\r\nThe invocation of `targ` will throw a `NullReferenceException`.\r\n\r\nThe immediate problem is it hitting a path that assumes it is dealing with an `AggregateType` when it is dealing with a `NullableType`, but it seems a bit more than just a spot fix there will be needed to make it handle the combination of both lifting and between enumerable types and their underlying types.\r\n\r\nCode using `dynamic` will likely never hit this as nullable types will never be inferred from a single `dynamic` argument, but it'd be safer to have this work correctly, as well as it ideally being workable for explicit use as in the example above."},{"Id":"6812029281","Type":"IssuesEvent","CreatedAt":"2017-11-05T23:37:10","Actor":"Const-me","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25066","RelatedDescription":"Opened issue \"ARM/Linux: unable to cancel async read of /dev/input/input0 file\" (#25066) at dotnet/corefx","RelatedBody":"I’m using System.IO.FileStream to read touch screen events. More specifically, I have an endless loop that calls `await stream.ReadAsync(…)` API on that file.\r\n\r\nIt works OK and I’m getting my touch events (well, almost, because no multi-touch, but I don’t think .NET is responsible for that).\r\n\r\nI’m having problems implementing graceful shutdown.\r\n\r\nI’ve tried closing and disposing the stream, I.ve tried passing CancellationToken to ReadAsync() call, the result is the same, ReadAsync() only cancels with an exception when the next touch event becomes available. Which is kinda later than I’d like it to.\r\n\r\nI don’t have much experience with Linux, but it looks like there’s a bug in CoreFX here?"},{"Id":"6812011155","Type":"PullRequestEvent","CreatedAt":"2017-11-05T23:24:55","Actor":"yvanin","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25065","RelatedDescription":"Opened pull request \"Correct unit tests for Environment.SetEnvironmentVariable\" (#25065) at dotnet/corefx","RelatedBody":"Fix #16766"},{"Id":"6811930517","Type":"IssuesEvent","CreatedAt":"2017-11-05T22:34:15","Actor":"Daniel15","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/25064","RelatedDescription":"Opened issue \"X509Certificate2: Unclear error message when permission denied to file\" (#25064) at dotnet/corefx","RelatedBody":"If the user running an ASP.NET Core app on Linux does not have permission to access the PFX file, this confusing error message is thrown:\r\n```\r\nUnhandled Exception: Interop+Crypto+OpenSslCryptographicException: error:2006D002:BIO routines:BIO_new_file:system lib\r\n   at Interop.Crypto.CheckValidOpenSslHandle(SafeHandle handle)\r\n   at Internal.Cryptography.Pal.CertificatePal.FromFile(String fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)\r\n   at System.Security.Cryptography.X509Certificates.X509Certificate..ctor(String fileName, String password, X509KeyStorageFlags keyStorageFlags)\r\n   at System.Security.Cryptography.X509Certificates.X509Certificate2..ctor(String fileName, String password)\r\n   at Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(ListenOptions listenOptions, String fileName, String password)\r\n   at SecureSign.Web.Program.<>c__DisplayClass1_0.<BuildWebHost>b__2(ListenOptions listenOptions) in C:\\src\\SecureSign\\src\\SecureSign.Web\\Program.cs:line 53\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(IPEndPoint endPoint, Action`1 configure)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(IPAddress address, Int32 port, Action`1 configure)\r\n   at Microsoft.Extensions.Options.OptionsFactory`1.Create(String name)\r\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\r\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\r\n   at System.Lazy`1.CreateValue()\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.CreateServiceContext(IOptions`1 options, ILoggerFactory loggerFactory)\r\n   at Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer..ctor(IOptions`1 options, ITransportFactory transportFactory, ILoggerFactory loggerFactory)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite, ServiceProvider provider)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite, ServiceProvider provider)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider, Type serviceType)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.EnsureServer()\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()\r\n   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()\r\n   at SecureSign.Web.Program.Main(String[] args) in C:\\src\\SecureSign\\src\\SecureSign.Web\\Program.cs:line 20\r\n```"},{"Id":"6811632167","Type":"IssuesEvent","CreatedAt":"2017-11-05T19:53:44","Actor":"saurabh500","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/24871","RelatedDescription":"Closed issue \"SqlBulkCopy can fail with a null ref exception for some IDataReader implementations\" (#24871) at dotnet/corefx","RelatedBody":"SqlBulkCopy.WriteToServer accepts an IDataReader parameter. If the following two condition are met, the call will fail with a NullReferenceException:\r\n1.  The passed implementation of IDataReader does not inherit from DbDataReader\r\n2. A column mapping is specified\r\n\r\nIn the implementation of SqlBulkCopy.WriteToServer, the code attempts to cast the passed parameter to an DbDataReader, which is result in _DbDataReaderRowSource always being null. \r\n\r\nAttached is a zipped up .cs file with a repro: [Program.zip](https://github.com/dotnet/corefx/files/1415532/Program.zip)"},{"Id":"6811613261","Type":"PullRequestEvent","CreatedAt":"2017-11-05T19:43:18","Actor":"saurabh500","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/24655","RelatedDescription":"Merged pull request \"Correct row source field is used to get column ordinal.\" (#24655) at dotnet/corefx","RelatedBody":"Current version uses `_DbDataReaderRowSource` field. This field is `null` in case of own implementation of `IDataReader`, which is not inherited from `DbDataReader`.\r\n\r\nFixes #24638"},{"Id":"6811613243","Type":"IssuesEvent","CreatedAt":"2017-11-05T19:43:17","Actor":"saurabh500","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/24638","RelatedDescription":"Closed issue \"NullReferenceException in SqlBulkCopy when setting ColumnMappings with names\" (#24638) at dotnet/corefx","RelatedBody":"We use `SqlBulkCopy` to insert data. In full .NET framework (4, 4.6) it works. The same code in .net core 2 throws `NullReferenceException`. The problem has something to do with column mappings (`SqlBulkCopy.ColumnMappings`). When we set mappings using indexes, everything works. When we set mappings using column names, NRE is thrown. See the attached example.\r\n\r\n[SqlBulkCopySample.zip](https://github.com/dotnet/corefx/files/1382531/SqlBulkCopySample.zip)\r\n"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6812632020","Type":"IssuesEvent","CreatedAt":"2017-11-06T04:34:21","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23022","RelatedDescription":"Opened issue \"C# and VB changes missing from VS 15.5 release notes\" (#23022) at dotnet/roslyn","RelatedBody":"\r\nhttps://www.visualstudio.com/en-us/news/releasenotes/vs2017-Preview-relnotes"},{"Id":"6812586844","Type":"PullRequestEvent","CreatedAt":"2017-11-06T04:11:43","Actor":"jameslinden","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23021","RelatedDescription":"Closed pull request \"Update cross-platform.md\" (#23021) at dotnet/roslyn","RelatedBody":"CrossPlatform.sln does not exist on this branch.\r\n\r\n**Customer scenario**\r\n\r\nWhat does the customer do to get into this situation, and why do we think this\r\nis common enough to address for this release.  (Granted, sometimes this will be\r\nobvious \"Open project, VS crashes\" but in general, I need to understand how\r\ncommon a scenario is)\r\n\r\n**Bugs this fixes:**\r\n\r\n(either VSO or GitHub links)\r\n\r\n**Workarounds, if any**\r\n\r\nAlso, why we think they are insufficient for RC vs. RC2, RC3, or RTW\r\n\r\n**Risk**\r\n\r\nThis is generally a measure our how central the affected code is to adjacent\r\nscenarios and thus how likely your fix is to destabilize a broader area of code\r\n\r\n**Performance impact**\r\n\r\n(with a brief justification for that assessment (e.g. \"Low perf impact because no extra allocations/no complexity changes\" vs. \"Low\")\r\n\r\n**Is this a regression from a previous update?**\r\n\r\n**Root cause analysis:**\r\n\r\nHow did we miss it?  What tests are we adding to guard against it in the future?\r\n\r\n**How was the bug found?**\r\n\r\n(E.g. customer reported it vs. ad hoc testing)\r\n\r\n**Test documentation updated?**\r\n\r\nIf this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.\r\n"},{"Id":"6812583515","Type":"PullRequestEvent","CreatedAt":"2017-11-06T04:10:12","Actor":"jameslinden","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/23021","RelatedDescription":"Opened pull request \"Update cross-platform.md\" (#23021) at dotnet/roslyn","RelatedBody":"CrossPlatform.sln does not exist on this branch.\r\n\r\n**Customer scenario**\r\n\r\nWhat does the customer do to get into this situation, and why do we think this\r\nis common enough to address for this release.  (Granted, sometimes this will be\r\nobvious \"Open project, VS crashes\" but in general, I need to understand how\r\ncommon a scenario is)\r\n\r\n**Bugs this fixes:**\r\n\r\n(either VSO or GitHub links)\r\n\r\n**Workarounds, if any**\r\n\r\nAlso, why we think they are insufficient for RC vs. RC2, RC3, or RTW\r\n\r\n**Risk**\r\n\r\nThis is generally a measure our how central the affected code is to adjacent\r\nscenarios and thus how likely your fix is to destabilize a broader area of code\r\n\r\n**Performance impact**\r\n\r\n(with a brief justification for that assessment (e.g. \"Low perf impact because no extra allocations/no complexity changes\" vs. \"Low\")\r\n\r\n**Is this a regression from a previous update?**\r\n\r\n**Root cause analysis:**\r\n\r\nHow did we miss it?  What tests are we adding to guard against it in the future?\r\n\r\n**How was the bug found?**\r\n\r\n(E.g. customer reported it vs. ad hoc testing)\r\n\r\n**Test documentation updated?**\r\n\r\nIf this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.\r\n"},{"Id":"6812463496","Type":"IssuesEvent","CreatedAt":"2017-11-06T03:16:48","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23012","RelatedDescription":"Closed issue \"Add Go To Implementation option for Deconstruct calls\" (#23012) at dotnet/roslyn","RelatedBody":"Currently (without use of resharper) there is no convenient way to know which deconstruct is being resolved when you for example write this.\r\n\r\n    var (x, y) = GetResult();\r\n\r\nit would be nice if there was a easy an convenient way to navigate to deconstruct overload that is being used.\r\n"},{"Id":"6812400166","Type":"IssuesEvent","CreatedAt":"2017-11-06T02:50:25","Actor":"Thealexbarney","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23020","RelatedDescription":"Opened issue \"Generation of the GetHashCode method of anonymous types is not deterministic\" (#23020) at dotnet/roslyn","RelatedBody":"**Version Used**: \r\nCommit 72b8f88b0d\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Create the following .cs file:\r\n```\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        var a = new { a = 4 };\r\n    }\r\n}\r\n```\r\n2. Compile it with core MSBuild\r\n3. Copy the output .dll elsewhere and compile it again\r\n4. Alternatively, use csc and set the `deterministic` flag:\r\n`dotnet csc.dll Program.cs /target:library /deterministic /noconfig /reference:\"C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\\microsoft.netcore.app\\2.0.0\\ref\\netcoreapp2.0\\System.Collections.dll\" /reference:\"C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\\microsoft.netcore.app\\2.0.0\\ref\\netcoreapp2.0\\System.Runtime.dll\"`\r\n\r\n**Expected Behavior**:\r\nThe compiler should produce the exact same output both times.\r\n\r\n**Actual Behavior**:\r\nThe compiler's output differs every time.\r\nIf the net46 csc build is used, the compiler produces the same output each time it is run.\r\n\r\n**Reason**:\r\nThe difference comes from the GetHashCode method of the created anonymous type. Here's the IL from two separate compiles.\r\n```\r\n  .method public hidebysig virtual instance int32 \r\n          GetHashCode() cil managed\r\n  {\r\n    // Code size       29 (0x1d)\r\n    .maxstack  8\r\n    IL_0000:  ldc.i4     0x1af3bd32\r\n    IL_0005:  ldc.i4     0xa5555529\r\n    IL_000a:  mul\r\n```\r\n```\r\n.method public hidebysig virtual instance int32 \r\n          GetHashCode() cil managed\r\n  {\r\n    // Code size       29 (0x1d)\r\n    .maxstack  8\r\n    IL_0000:  ldc.i4     0xc61810dc\r\n    IL_0005:  ldc.i4     0xa5555529\r\n    IL_000a:  mul\r\n```\r\n\r\nOne of the constants used in the hash method changes every time. This is because Roslyn uses the hash codes of the backing fields of anonymous types to generate the above constant. ([Code here](https://github.com/dotnet/roslyn/blob/72b8f88b0daf42e1a8b1d6687cbfc9ccbb0cc21a/src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs#L190))\r\n\r\nThis isn't a problem in .NET Framework because [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element) is disabled by default. However, it's enabled by default in coreclr, so identical strings will give different hash codes each time the process is run, creating non-deterministic IL code."},{"Id":"6811921005","Type":"PullRequestEvent","CreatedAt":"2017-11-05T22:28:12","Actor":"sharwell","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/roslyn/pull/22140","RelatedDescription":"Merged pull request \"Suggest to add block for fixed statements\" (#22140) at dotnet/roslyn","RelatedBody":"and simplify code."},{"Id":"6811863776","Type":"IssuesEvent","CreatedAt":"2017-11-05T21:56:33","Actor":"paul1956","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23019","RelatedDescription":"Opened issue \"EV Error BC36946 using NameOf with Async Function\" (#23019) at dotnet/roslyn","RelatedBody":"**Version Used**: \r\nVB 15.4\r\n**Steps to Reproduce**:\r\n1. copy program fragment below in VB code window\r\n```\r\n       Private Async Function B_Async(_document As Document, _CancellationToken As CancellationToken) As Task(Of Document)\r\n            Debug.WriteLine($\"#Codefix Entering {NameOf(B_Async)}\")\r\n            Return Nothing\r\n        End Function\r\n```\r\n**Expected Behavior**:\r\nNo Errors\r\n**Actual Behavior**:\r\nError BC36946 The implicit return variable of an Iterator or Async method cannot be accessed.\t\r\n"}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6811758535","Type":"IssuesEvent","CreatedAt":"2017-11-05T21:01:14","Actor":"DominicMaas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/4873","RelatedDescription":"Opened issue \"System.Net.Http.HttpClient possibly causing \"Unresolved P/Invoke\" crash.\" (#4873) at dotnet/corert","RelatedBody":"## Introduction\r\nIn my UWP app, calling `GetAsync` (and possibly others) in the `System.Net.Http.HttpClient` class causes my app to produce with the following exception `Unresolved P/Invoke method 'kernel32.dll!LocalAlloc' from this method. Please look for this method in build warnings for more details`. However, there is nothing mentioned in the build warnings.\r\n\r\nThis only happens after publishing my app to the Windows Store.\r\n\r\n## More Info\r\nThis error is happening when I target the Fall Creators Update and using version 6.0.1 of the `Microsoft.NETCore.UniversalWindowsPlatform` nuget package. I'm not sure which one started causing the error as I targeted FCU and used the latest nuget package at the same time.\r\n\r\nCalling this `GetAsync` method from either my UWP app or a .NET Standard (v1.4) library cause the same error.\r\n\r\nWhat is more interesting is that this issue only happens after I publish my app to the Windows Store (and download it through the Windows Store). Performing local `DEBUG` and `RELEASE` builds work as expected. Side-loading the app also works as expected.\r\n\r\nI've also done testing with both `HttpClient`'s available in UWP. The Windows.Web `HttpClient` works as expected. \r\n\r\n## Specifications\r\nWindows 10 (16299.19)\r\nApp Target and Minimum SDK: 16299.15\r\n.NETCore UWP: 6.0.1\r\nVisual Studio: 15.4.2\r\n\r\nMy source code is below if anyone wants to check out the references and how my project is setup:\r\n*Note: You will have to download the `Performing tests on HttpClients` commit to test.*\r\nhttps://github.com/DominicMaas/SoundByte"},{"Id":"6810058667","Type":"IssuesEvent","CreatedAt":"2017-11-05T00:18:18","Actor":"morganbr","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/4551","RelatedDescription":"Closed issue \"Implement ldtoken for methods\" (#4551) at dotnet/corert","RelatedBody":"Implement the ldtoken opcode for methods. Look for ```else if (ldtokenValue is MethodDesc)``` in the [ImportLdToken method](https://github.com/dotnet/corert/blob/e6d0a9398e3d8fc83d047cccda302ed13610f190/src/ILCompiler.WebAssembly/src/CodeGen/ILToWebAssemblyImporter.cs#L934)."},{"Id":"6810057046","Type":"IssuesEvent","CreatedAt":"2017-11-05T00:16:49","Actor":"morganbr","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/4550","RelatedDescription":"Closed issue \"Finish ldtoken implementation for types\" (#4550) at dotnet/corert","RelatedBody":"There's a partial implementation of the ldtoken instruction for types, which loads the RuntimeTypeHandle for a type in [ImportLdToken](https://github.com/dotnet/corert/blob/e6d0a9398e3d8fc83d047cccda302ed13610f190/src/ILCompiler.WebAssembly/src/CodeGen/ILToWebAssemblyImporter.cs#L934), but it's missing logic to get an eeTypePtr for the type. Look for the ```// todo: this doesn't work because we don't have the eetypeptr pushed. How do we get the eetypeptr?``` comment."},{"Id":"6810032455","Type":"PullRequestEvent","CreatedAt":"2017-11-04T23:55:49","Actor":"morganbr","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/4872","RelatedDescription":"Merged pull request \"implement newobj for WASM using malloc\" (#4872) at dotnet/corert","RelatedBody":"@morganbr\r\nThis implements the remainder of #4551 but I don't see a way to test it without Reflection.\r\nFixes #4539, it's somewhat unrelated except that the lack of an initobj implementation was wrecking the evaluation stack in the main test program. \r\nNo longer breaks #4863 \r\nFixes #4512"},{"Id":"6810032454","Type":"IssuesEvent","CreatedAt":"2017-11-04T23:55:49","Actor":"morganbr","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/4539","RelatedDescription":"Closed issue \"Implement initobj opcode\" (#4539) at dotnet/corert","RelatedBody":"Implement the initobj opcode, with zero-initializes a structure. The method to fill in is:\r\nhttps://github.com/dotnet/corert/blob/e6d0a9398e3d8fc83d047cccda302ed13610f190/src/ILCompiler.WebAssembly/src/CodeGen/ILToWebAssemblyImporter.cs#L1076"},{"Id":"6808505938","Type":"PullRequestEvent","CreatedAt":"2017-11-04T03:46:19","Actor":"hippiehunter","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4872","RelatedDescription":"Opened pull request \"implement newobj for WASM using malloc\" (#4872) at dotnet/corert","RelatedBody":"@morganbr\r\nThis implements the remainder of #4551 but I don't see a way to test it without Reflection.\r\nFixes #4539, it's somewhat unrelated except that the lack of an initobj implementation was wrecking the evaluation stack in the main test program. \r\nNo longer breaks #4863 \r\nFixes #4512"},{"Id":"6808285792","Type":"PullRequestEvent","CreatedAt":"2017-11-04T00:43:55","Actor":"adityamandaleeka","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/4871","RelatedDescription":"Opened pull request \"Improve unwinder initialization perf\" (#4871) at dotnet/corert","RelatedBody":"This changes `InitializeUnwindContextAndCursor` so that the IP register is set correctly prior to initializing the unwind cursor, rather than having it be an incorrect value at first and then fixing it after initialization. Libunwind sets a bunch of internal structures based on the value of the IP register, so by setting the IP after initialization, we were effectively making it do double the work (once for the \"wrong\" IP during cursor initialization, and then later for the correct one). This makes a sizeable difference in how fast we are able to do `VirtualUnwind`.\r\n\r\nThis change, coupled with the speedup to `FindMethodInfo` done in #4869, makes the allocation benchmark mentioned in that PR (with 100 inactive threads) run about 26% faster on my machine. The perf improvement on that benchmark with this change relative to what's checked in now (which includes the work done in #4869) is ~12%.\r\n\r\n@janvorli @jkotas @sergiy-k "}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"926165116084658176","CreatedAt":"2017-11-02T19:12:25+00:00","UserScreenname":"dotnet","Text":"Great post and resources by @cesardelatorre: Modernize existing .NET apps with Windows Containers and #Azure https://t.co/c8HL8dfH4d #dotnet","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":72,"FavoriteCount":40,"RawContent":null},{"Id":"925135073921310720","CreatedAt":"2017-10-30T22:59:24+00:00","UserScreenname":"dotnet","Text":"Experience real time test discovery in Test Explorer https://t.co/niKJvslM5p #visualstudio","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":60,"FavoriteCount":38,"RawContent":null},{"Id":"923592986562142208","CreatedAt":"2017-10-26T16:51:42+00:00","UserScreenname":"dotnet","Text":"Wish you could run the code sample you read in a book? You can now with Azure Notebooks. https://t.co/evx8HPzzqe","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":131,"FavoriteCount":78,"RawContent":null},{"Id":"923344981602942977","CreatedAt":"2017-10-26T00:26:13+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework images now support Windows Server 1709 https://t.co/enC2cjj2ds /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":42,"FavoriteCount":22,"RawContent":null},{"Id":"923037554265296896","CreatedAt":"2017-10-25T04:04:36+00:00","UserScreenname":"dotnet","Text":"microsoft/dotnet-framework latest tag updated to 4.7.1 https://t.co/NuV11juPrm /cc @Docker","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":42,"FavoriteCount":23,"RawContent":null},{"Id":"922503653402882049","CreatedAt":"2017-10-23T16:43:04+00:00","UserScreenname":"dotnet","Text":".NET Core Performance Profiling with Intel® VTune™ Amplifier 2018  https://t.co/TPKfGvwNLH /cc @intel","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":96,"FavoriteCount":56,"RawContent":null},{"Id":"921143443912474624","CreatedAt":"2017-10-19T22:38:05+00:00","UserScreenname":"dotnet","Text":"New .NET Rocks podcast with @coolcsh on understanding #dotnet standard &amp; future of #dotnetcore… https://t.co/b8BCeZKEqz","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":42,"FavoriteCount":20,"RawContent":null},{"Id":"920400974321147904","CreatedAt":"2017-10-17T21:27:47+00:00","UserScreenname":"dotnet","Text":"Announcing the .NET Framework 4.7.1 https://t.co/Vu3bilF8bZ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":387,"FavoriteCount":347,"RawContent":null}]}},"RunOn":"2017-11-06T05:30:20.3559461Z","RunDurationInMilliseconds":7499}