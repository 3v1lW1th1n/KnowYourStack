{"Data":{"Blog":{"FeedItems":[{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":36,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803)","PublishedOn":"2018-05-24T01:49:57+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 April 2018 Update (version 1803). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/23/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-april-2018-update-version-1803/","RawContent":null},{"Title":".NET Framework May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update)","PublishedOn":"2018-05-21T22:44:05+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the May 2018 Preview of Quality Rollup for Windows 10 1709 (Fall Creators Update). Quality and Reliability This release contains the following quality and reliability...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/21/net-framework-may-2018-preview-of-quality-rollup-for-windows-10-1709-fall-creators-update/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7697523628","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:02","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Merged pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7697521624","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:34","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/100","RelatedDescription":"Merged pull request \"Create mvvmcross.md\" (#100) at dotnet/home","RelatedBody":"Added MvvmCross as project as part of on-boarding.\r\n\r\nhttps://github.com/MvvmCross/MvvmCross/issues/2415"},{"Id":"7697519505","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:05:08","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/102","RelatedDescription":"Merged pull request \"Update projects.json adding MLNET\" (#102) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "},{"Id":"7719029569","Type":"IssuesEvent","CreatedAt":"2018-05-23T18:04:46","Actor":"mlacouture","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/70","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil\" (#70) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil\r\n\r\nThe Microsoft Windows Communication Foundation (WCF) **dotnet-svcutil** tool is a .NET Core CLI tool that retrieves metadata from a web service on a network location or from a WSDL file, and generates a WCF class containing client proxy methods that you can use to access the web service operations.\r\n\r\nSimilarly to the [Service Model Metadata - svcutil](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool for .NET Framework projects, the **dotnet-svcutil** is a command line tool for generating a web service reference compatible with .NET Core and .NET Standard projects. \r\n\r\nThe **dotnet-svcutil** tool is an alternative option to the [WCF Web Service Reference ](https://docs.microsoft.com/en-us/dotnet/core/additional-tools/wcf-web-service-reference-guide)Visual Studio connected service provider which first shipped with Visual Studio 2017 v15.5.  The **dotnet-svcutil** tool as a .NET Core CLI tool, however, can be run on multiple platforms like Linux and MacOS in addition to Windows.\r\n\r\n# Discussion\r\nPlease share your thoughts with us by commenting on GitHub issue dotnet/wcf#2894\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7849162235","Type":"PullRequestEvent","CreatedAt":"2018-06-20T01:50:39","Actor":"tarekgh","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18551","RelatedDescription":"Merged pull request \"Avoid extra allocation in IDNA\" (#18551) at dotnet/coreclr","RelatedBody":"Fixes #18545"},{"Id":"7849162225","Type":"IssuesEvent","CreatedAt":"2018-06-20T01:50:39","Actor":"tarekgh","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18545","RelatedDescription":"Closed issue \"GlobalizationMode.Invariant's PunycodeDecode repeatedly calling StringBuilder.ToString\" (#18545) at dotnet/coreclr","RelatedBody":"See all of these calls to `output.ToString()` including two in a loop, and `output` isn't changing in this region:\r\nhttps://github.com/dotnet/coreclr/blob/473d9b09c7e000480f41021c94fbffeae27cb179/src/System.Private.CoreLib/shared/System/Globalization/IdnMapping.cs#L776-L806\r\n\r\nSeems like this should either a) create the string once rather than repeatedly creating it, or b) retrieve the char from the StringBuilder to test it rather than using a string and an index.  In other words, worst case we should be allocating one string here, best case zero.  Given the potential expense of indexing into a StringBuilder, I'm not sure which ends up being faster.\r\n\r\ncc: @tarekgh, @krwq "},{"Id":"7849038271","Type":"PullRequestEvent","CreatedAt":"2018-06-20T01:02:13","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17775","RelatedDescription":"Merged pull request \"Fix instruction groups offset on the border between cold/hot code.\" (#17775) at dotnet/coreclr","RelatedBody":"Fixes DevDiv_601045; assert while generating diffs:\r\nhttps://github.com/dotnet/coreclr/blob/71f4199f7dd043c4901a187b9bd88ab40e2b87e2/src/jit/emit.cpp#L7185\r\n\r\nI was not able to repro the original issue on Core and it did not allow me to go back and find when the desktop issue appeared. The new checks show that the problem exists in CoreCLR as well.\r\n\r\nThe fix doesn't change the generated code (it changes only unused allocated parts) and doesn't cause any diffs.\r\n\r\nThe important changes are in the fourth commit."},{"Id":"7849036842","Type":"PullRequestEvent","CreatedAt":"2018-06-20T01:01:38","Actor":"sandreenko","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18555","RelatedDescription":"Merged pull request \"Fix Complus_JitMinOpts for the first method\" (#18555) at dotnet/coreclr","RelatedBody":"Before when we set `COMPLUS_JITMinOpts=1` the first method was skipped from MinOpts because `if (jitMinOpts <= methodCount)` fails (`1 <= 0`).\r\n\r\nThe fix is to include the current method into `methodCount`.\r\n\r\nThen:\r\n`COMPLUS_JITMinOpts=0`: no min_opts;\r\n`COMPLUS_JITMinOpts=1`: all methods with min_opts;\r\n`COMPLUS_JITMinOpts=2`: all methods except the first one are compiled with min_opts;\r\n`COMPLUS_JITMinOpts=N`: all methods starting from the Nth method are compiler with min_opts."},{"Id":"7849033075","Type":"IssuesEvent","CreatedAt":"2018-06-20T01:00:14","Actor":"nattress","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18562","RelatedDescription":"Opened issue \"R2R Dumper treats READYTORUN_SECTION_RUNTIME_FUNCTIONS as required\" (#18562) at dotnet/coreclr","RelatedBody":"Currently the dumper requires READYTORUN_SECTION_RUNTIME_FUNCTIONS section to be present. It is actually optional - see https://github.com/dotnet/coreclr/blob/master/src/vm/readytoruninfo.cpp#L551\r\n\r\nWe should handle the case where it's missing gracefully in r2rdump."},{"Id":"7848970212","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:34:32","Actor":"CarolEidt","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18561","RelatedDescription":"Opened pull request \"An UnusedValue still requires a target reg\" (#18561) at dotnet/coreclr","RelatedBody":"The BuildSimple method wasn't creating a def for an unused value. Although (in this case) the code is dead, the code generator must still be able to generate code for it."},{"Id":"7848890111","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:04:32","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18557","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/corefx\" (#18557) at dotnet/coreclr","RelatedBody":"This PR contains mirrored changes from dotnet/corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848857978","Type":"IssuesEvent","CreatedAt":"2018-06-19T23:53:03","Actor":"adamsitnik","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18560","RelatedDescription":"Opened issue \"GC.GetAllocatedBytesForCurrentThread always returns 0 when processor affinity is set\" (#18560) at dotnet/coreclr","RelatedBody":"When the processor affinity is set in explicit way `GC.GetAllocatedBytesForCurrentThread` always  returns 0. Even is something was allocated.\r\n\r\n```cs\r\nusing System;\r\n\r\nnamespace gcstats\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var before = System.GC.GetAllocatedBytesForCurrentThread();\r\n            Console.WriteLine(\"Hello World!\");\r\n            var after = System.GC.GetAllocatedBytesForCurrentThread();\r\n            Console.WriteLine($\"after - before = {after - before}\");\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```log\r\nstart /affinity 1 dotnet.exe run\r\nHello World!\r\nafter - before = 0\r\n\r\nstart dotnet.exe run\r\nHello World!\r\nafter - before = 7552\r\n\r\ndotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300-rc1-008673\r\n Commit:    f5e3ddbe73\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.300-rc1-008673\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0-rc1\r\n  Commit:  eb9bc92051\r\n```\r\n\r\n@jkotas @Maoni0 is this expected behavior? am I doing something wrong? \r\n\r\nI am porting CoreCLR benchmarks from xunit-performance to BenchmarkDotNet and I have faced this issue today when I was comparing the results of some unstable benchmarks with affinity set and without.\r\n\r\n/cc @jorive \r\n"},{"Id":"7848805692","Type":"PullRequestEvent","CreatedAt":"2018-06-19T23:34:30","Actor":"acmyu","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18357","RelatedDescription":"Merged pull request \"R2RDump - Dump CompilerIdentifier and ImportSection contents\" (#18357) at dotnet/coreclr","RelatedBody":""}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7848144055","Type":"PullRequestEvent","CreatedAt":"2018-06-19T20:47:31","Actor":"AndyGerlicher","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/9517","RelatedDescription":"Opened pull request \"MSBuild 15.8.108\" (#9517) at dotnet/cli","RelatedBody":"This is the version currently in `lab/d15.8stg` for Preview 4."},{"Id":"7848118301","Type":"PullRequestEvent","CreatedAt":"2018-06-19T20:42:27","Actor":"AndyGerlicher","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/9468","RelatedDescription":"Closed pull request \"MSBuild 15.8.98\" (#9468) at dotnet/cli","RelatedBody":""},{"Id":"7848115377","Type":"IssuesEvent","CreatedAt":"2018-06-19T20:41:53","Actor":"peterhuene","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9513","RelatedDescription":"Closed issue \"Please return an errorlevel when template not found\" (#9513) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n`dotnet new some_template_that_doesnt_exist -l`\r\n\r\n\r\n## Expected  behavior\r\nChecking the `%ERRORLEVEL%` after searching for a template that isn't installed should result in something greater than 0 (error)\r\n\r\n## Actual behavior\r\n`%ERRORLEVEL%` is 0 (success) when searching for a non-existent template\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n```\r\n.NET Command Line Tools (2.1.201)\r\n\r\nProduct Information:\r\n Version:            2.1.201\r\n Commit SHA-1 hash:  7932dc6179\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17692\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.201\\\r\n\r\nMicrosoft .NET Core Shared Framework Host                                >\r\n\r\n  Version  : 2.0.7\r\n  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11\r\n\r\n```\r\n\r\n**Example Scenario:** I would like to have a basic .bat or .ps1 script that would be used by my dev team when they need to generate some code based on our templates.  It could check for existence of the template and if not found, it would install them and then generate an interactive prompt with the necessary parameters before calling \"dotnet new\".\r\n\r\nNaturally, doing a search for the template (using `dotnet new <name> -l`) was the first thing I tried to do, but without a meaningful errorlevel, it's not easy to determine if it's installed.\r\n\r\n\r\n"},{"Id":"7848010807","Type":"IssuesEvent","CreatedAt":"2018-06-19T20:21:15","Actor":"peterhuene","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/9516","RelatedDescription":"Closed issue \"`dotnet new ln` creates new solution file\" (#9516) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nType command `dotnet new ln`\r\nNote `ln`, not `sln`\r\n\r\n## Expected  behavior\r\nHelp should be shown.\r\n\r\n## Actual behavior\r\n\"The template \"Solution File\" was created successfully.\"\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300\r\n Commit:    adab45bf0c\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.300\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0\r\n  Commit:  caa7b7e2ba\r\n\r\n.NET Core SDKs installed:\r\n  1.0.0-preview2-1-003177 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.0-rc4-004771 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.0 [C:\\Program Files\\dotnet\\sdk]\r\n  1.1.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.4 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n```"},{"Id":"7847703891","Type":"IssuesEvent","CreatedAt":"2018-06-19T19:20:21","Actor":"andagr","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/9516","RelatedDescription":"Opened issue \"`dotnet new ln` creates new solution file\" (#9516) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\nType command `dotnet new ln`\r\nNote `ln`, not `sln`\r\n\r\n## Expected  behavior\r\nHelp should be shown.\r\n\r\n## Actual behavior\r\n\"The template \"Solution File\" was created successfully.\"\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.1.300\r\n Commit:    adab45bf0c\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.300\\\r\n\r\nHost (useful for support):\r\n  Version: 2.1.0\r\n  Commit:  caa7b7e2ba\r\n\r\n.NET Core SDKs installed:\r\n  1.0.0-preview2-1-003177 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.0-rc4-004771 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.0 [C:\\Program Files\\dotnet\\sdk]\r\n  1.1.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.4 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n```"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7839045747","Type":"PullRequestEvent","CreatedAt":"2018-06-18T12:31:13","Actor":"d-dizhevsky","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/776","RelatedDescription":"Opened pull request \"Update release notes link\" (#776) at dotnet/standard","RelatedBody":"fix for #775 "}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7849285639","Type":"IssuesEvent","CreatedAt":"2018-06-20T02:37:24","Actor":"ObsidianMinor","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30540","RelatedDescription":"Closed issue \"Unexpected value 'ArrayAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'\" (#30540) at dotnet/corefx","RelatedBody":"**Version Used**: \r\nVisual Studio 2017 15.7.4\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Enter this snippet into your nearest Visual Studio.\r\n```cs\r\nint[] n = new int[0];\r\nn[0] = ref u;\r\n```\r\n2. Watch roslyn crash before you can type `u`\r\n\r\n**Expected Behavior**:\r\nA compiler error\r\n\r\n**Actual Behavior**:\r\nRoslyn crashes and takes everything down with it\r\n\r\n**Full event log error**\r\n```\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: System.InvalidOperationException: Unexpected value 'ArrayAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'\r\n   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode& bindableNode, BoundNode& lowestBoundNode, BoundNode& highestBoundNode, BoundNode& boundParent)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.<AddSemanticClassificationsAsync>d__5.MoveNext()\r\nStack:\r\n   at System.Environment.FailFast(System.String, System.Exception)\r\n   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\n   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1<System.Exception>)\r\n   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5.MoveNext()\r\n   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(Microsoft.CodeAnalysis.CSharp.BoundExpression)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Func`2<Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Func`2<Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<AddSemanticClassificationsAsync>d__5 ByRef)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2<Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Func`2<Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+<AddSemanticClassificationsAsync>d__2.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+<AddSemanticClassificationsAsync>d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<AddSemanticClassificationsAsync>d__2 ByRef)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ClassifySpansAsync>d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ClassifySpansAsync>d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<ClassifySpansAsync>d__2`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<TryClassifyContainingMemberSpan>d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<TryClassifyContainingMemberSpan>d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<TryClassifyContainingMemberSpan>d__1`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ProduceTagsAsync>d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ProduceTagsAsync>d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<ProduceTagsAsync>d__0`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<System.__Canon>)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<RecomputeTagsAsync>d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<RecomputeTagsAsync>d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<RecomputeTagsAsync>d__73<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1<Microsoft.VisualStudio.Text.SnapshotPoint>, System.Nullable`1<Microsoft.CodeAnalysis.Text.TextChangeRange>, System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan>, System.Collections.Immutable.ImmutableDictionary`2<Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1<System.__Canon>>, Boolean, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<>c__DisplayClass63_1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].<RecomputeTagsForeground>b__0(System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+<>c__DisplayClass12_0.<EnqueueBackgroundTask>b__0(System.Threading.Tasks.Task)\r\n   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()\r\n   at System.Threading.Tasks.Task.Execute()\r\n   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\n   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\n   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n```\r\n"},{"Id":"7849283148","Type":"IssuesEvent","CreatedAt":"2018-06-20T02:36:23","Actor":"ObsidianMinor","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30540","RelatedDescription":"Opened issue \"Unexpected value 'ArrayAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'\" (#30540) at dotnet/corefx","RelatedBody":"**Version Used**: \r\nVisual Studio 2017 15.7.4\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Enter this snippet into your nearest Visual Studio.\r\n```cs\r\nint[] n = new int[0];\r\nn[0] = ref u;\r\n```\r\n2. Watch roslyn crash before you can type `u`\r\n\r\n**Expected Behavior**:\r\nA compiler error\r\n\r\n**Actual Behavior**:\r\nRoslyn crashes and takes everything down with it\r\n\r\n**Full event log error**\r\n```\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: System.InvalidOperationException: Unexpected value 'ArrayAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'\r\n   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode& bindableNode, BoundNode& lowestBoundNode, BoundNode& highestBoundNode, BoundNode& boundParent)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.<AddSemanticClassificationsAsync>d__5.MoveNext()\r\nStack:\r\n   at System.Environment.FailFast(System.String, System.Exception)\r\n   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\n   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1<System.Exception>)\r\n   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5.MoveNext()\r\n   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(Microsoft.CodeAnalysis.CSharp.BoundExpression)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Func`2<Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Func`2<Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<AddSemanticClassificationsAsync>d__5 ByRef)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2<Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Func`2<Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+<AddSemanticClassificationsAsync>d__2.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+<AddSemanticClassificationsAsync>d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<AddSemanticClassificationsAsync>d__2 ByRef)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ClassifySpansAsync>d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ClassifySpansAsync>d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<ClassifySpansAsync>d__2`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<TryClassifyContainingMemberSpan>d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<TryClassifyContainingMemberSpan>d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<TryClassifyContainingMemberSpan>d__1`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ProduceTagsAsync>d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ProduceTagsAsync>d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<ProduceTagsAsync>d__0`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<System.__Canon>)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<RecomputeTagsAsync>d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<RecomputeTagsAsync>d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<RecomputeTagsAsync>d__73<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1<Microsoft.VisualStudio.Text.SnapshotPoint>, System.Nullable`1<Microsoft.CodeAnalysis.Text.TextChangeRange>, System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan>, System.Collections.Immutable.ImmutableDictionary`2<Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1<System.__Canon>>, Boolean, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<>c__DisplayClass63_1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].<RecomputeTagsForeground>b__0(System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+<>c__DisplayClass12_0.<EnqueueBackgroundTask>b__0(System.Threading.Tasks.Task)\r\n   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()\r\n   at System.Threading.Tasks.Task.Execute()\r\n   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\n   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\n   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n```\r\n"},{"Id":"7849115650","Type":"PullRequestEvent","CreatedAt":"2018-06-20T01:32:54","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30539","RelatedDescription":"Opened pull request \"Simplify interop for .djustTokenPrivileges\" (#30539) at dotnet/corefx","RelatedBody":"Contributes to https://github.com/dotnet/corert/issues/5961"},{"Id":"7849099796","Type":"IssuesEvent","CreatedAt":"2018-06-20T01:26:44","Actor":"MohammadHamdyGhanem","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30538","RelatedDescription":"Opened issue \"A question about NameValueCollection \" (#30538) at dotnet/corefx","RelatedBody":"In NameValueCollection class, when reading element value by the Indexer or Get method we access the element bu its index or its key, but when setting element value by the Indexer and Set method we can access the element by its key only (Set has no overload, and the [index] is readonly!)\r\nWhat is the design purpose of that? What's wrong in setting the value bu index?\r\nCan Set method have an indexed overload, and the Indexer bu read-write?\r\nBy the way: there is a difference betwwen ```Dictionery<TKey, TValue>``` and NameValueCollection, as the last allow adding multiple values to the same key:\r\n```\r\nvar NV = new NameValueCollection( ) {\r\n        {\"Adam\", \"Apple\"}, {\"Adam\", \"Orange\"},\r\n        {\"John\", \"Orange\"}, {\"John\", \"Banana\"}, {\"John\", \"Apricot\"}\r\n};\r\n```\r\nSo, the NameValueCollection still has its unique uasage."},{"Id":"7849011264","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:51:19","Actor":"janvorli","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30431","RelatedDescription":"Merged pull request \" Convert System.Native to C \" (#30431) at dotnet/corefx","RelatedBody":"To be rebased, once https://github.com/dotnet/corefx/pull/30376 is merged"},{"Id":"7848997248","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:45:48","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30537","RelatedDescription":"Opened pull request \"Update CoreClr to preview1-26620-01 (master)\" (#30537) at dotnet/corefx","RelatedBody":""},{"Id":"7848932354","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:20:14","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30528","RelatedDescription":"Merged pull request \"Use string.Create instead of StringBuilder in BitVector32.ToString\" (#30528) at dotnet/corefx","RelatedBody":"Removes the StringBuilder and underlying char[] allocation, and just writes directly into the resulting string.\r\n\r\ncc: @safern, @ianhays "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7849462809","Type":"IssuesEvent","CreatedAt":"2018-06-20T03:47:10","Actor":"davkean","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28012","RelatedDescription":"Opened issue \"[Regression] Formatting a document in Roslyn takes ~20 seconds with all formatting options turn on\" (#28012) at dotnet/roslyn","RelatedBody":"**Version Used**: \r\nVersion 15.8.0 Preview 4.0 [27815.3001.d15.8stg]\r\n\r\n**Steps to Reproduce**:\r\n\r\nMake sure formatting settings are:\r\n\r\n![image](https://user-images.githubusercontent.com/1103906/41636160-22ea6080-7490-11e8-97fb-3b14e3b1419b.png)\r\n\r\n\r\n1. Delete .vs folder\r\n2. Restore.cmd\r\n3. Open Roslyn.sln\r\n4. Navigate to src/VisualStudio/Core/Def/Implementation/Workspace/WorkspaceFailureOutputPane.cs\r\n5. CTRL+E, D\r\n\r\n**Expected Behavior**:\r\nFormatting to be instant\r\n\r\n**Actual Behavior**:\r\nFormatting takes ~20 seconds\r\n\r\nTrace is available at: [internalshare\\public\\davkean\\Roslyn\\FormatDocument.etl.zip].\r\n"},{"Id":"7849386671","Type":"IssuesEvent","CreatedAt":"2018-06-20T03:16:28","Actor":"jaredpar","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28011","RelatedDescription":"Opened issue \"Port compiler tests to Mono\" (#28011) at dotnet/roslyn","RelatedBody":"This tracks the progress of porting our compiler tests to run on Mono.\r\n\r\n- [x] C# syntax tests\r\n- [x] C# symbol tests\r\n- [ ] C# emit tests\r\n- [ ] C# semantic tests\r\n- [ ] C# command line tests\r\n- [ ] C# winrt tests\r\n- [ ] VB syntax tests\r\n- [ ] VB symbol tests\r\n- [ ] VB emit tests\r\n- [ ] VB semantic tests\r\n- [ ] VB command line tests\r\n- [ ] VB ioperation tests\r\n"},{"Id":"7849383779","Type":"IssuesEvent","CreatedAt":"2018-06-20T03:15:21","Actor":"jaredpar","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28010","RelatedDescription":"Opened issue \" Port compiler tests to CoreClr on Linux\" (#28010) at dotnet/roslyn","RelatedBody":"The compiler unit tests need to multi-target net46 and netcoreapp2.0 in order to run on CoreClr. This tracks the progress of porting the projects:\r\n\r\n- [x] C# syntax tests\r\n- [x] C# symbol tests\r\n- [ ] C# emit tests\r\n- [ ] C# semantic tests\r\n- [ ] C# command line tests\r\n- [ ] C# winrt tests\r\n- [x] VB syntax tests\r\n- [ ] VB symbol tests\r\n- [ ] VB emit tests\r\n- [ ] VB semantic tests\r\n- [ ] VB command line tests\r\n- [ ] VB ioperation tests\r\n"},{"Id":"7849302681","Type":"IssuesEvent","CreatedAt":"2018-06-20T02:43:55","Actor":"NMSAzulX","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28009","RelatedDescription":"Opened issue \"Is \"error CS0012\" a bug for .netcore2.0 ?\" (#28009) at dotnet/roslyn","RelatedBody":"Version Used:\r\n\r\nMicrosoft.CodeAnalysis.CSharp.Scripting 2.7.0\r\n.net core 2.0\r\nBenchmarkDotNet 0.10.13\r\n\r\n**Steps to Reproduce**:\r\nHere is the src [issue](https://github.com/dotnet/roslyn/issues/27783) .\r\nHere is the src [code](https://github.com/jmarolf/RoslynPerfomanceTest/blob/4a86e03a30f297be9f2d5fd9204e3ef0029c51f9/RoslynPerfomance/RoslynTest/Watcher.cs#L42-L70) .\r\n**Expected Behavior**:\r\nRun and show the result.\r\n**Actual Behavior**:\r\n error CS0012: The type 'Object' is defined in an assembly that is not referenced. You must add a reference to assembly 'System.Runtime, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.\r\n\r\nIt works on .net framework4.7, but failed in core2.0."},{"Id":"7849286976","Type":"IssuesEvent","CreatedAt":"2018-06-20T02:37:57","Actor":"ObsidianMinor","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/28008","RelatedDescription":"Opened issue \"Unexpected value 'ArrayAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'\" (#28008) at dotnet/roslyn","RelatedBody":"**Version Used**: \r\nVisual Studio 2017 15.7.4\r\n\r\n**Steps to Reproduce**:\r\n\r\n1. Enter this snippet into your nearest Visual Studio.\r\n```cs\r\nint[] n = new int[0];\r\nn[0] = ref u;\r\n```\r\n2. Watch roslyn crash before you can type `u`\r\n\r\n**Expected Behavior**:\r\nA compiler error\r\n\r\n**Actual Behavior**:\r\nRoslyn crashes and takes everything down with it\r\n\r\n**Full event log error**\r\n```\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: System.InvalidOperationException: Unexpected value 'ArrayAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'\r\n   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode& bindableNode, BoundNode& lowestBoundNode, BoundNode& highestBoundNode, BoundNode& boundParent)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1 result, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ClassifyNode(SyntaxNode syntax)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.ProcessNodes()\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, ArrayBuilder`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.<AddSemanticClassificationsAsync>d__5.MoveNext()\r\nStack:\r\n   at System.Environment.FailFast(System.String, System.Exception)\r\n   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\n   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1<System.Exception>)\r\n   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5.MoveNext()\r\n   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(Microsoft.CodeAnalysis.CSharp.BoundExpression)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)\r\n   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.ProcessNodes()\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Func`2<Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Func`2<Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService+<AddSemanticClassificationsAsync>d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<AddSemanticClassificationsAsync>d__5 ByRef)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2<Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, System.Func`2<Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier>>, Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+<AddSemanticClassificationsAsync>d__2.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+<AddSemanticClassificationsAsync>d__2, Microsoft.CodeAnalysis.Workspaces, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<AddSemanticClassificationsAsync>d__2 ByRef)\r\n   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.WorkspaceClassificationDelegationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Classification.IClassificationService, Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1<Microsoft.CodeAnalysis.Classification.ClassifiedSpan>, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ClassifySpansAsync>d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ClassifySpansAsync>d__2`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<ClassifySpansAsync>d__2`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<TryClassifyContainingMemberSpan>d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<TryClassifyContainingMemberSpan>d__1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<TryClassifyContainingMemberSpan>d__1`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ProduceTagsAsync>d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+<ProduceTagsAsync>d__0`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<ProduceTagsAsync>d__0`1<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>, System.__Canon, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IClassificationDelegationService`1<System.__Canon>)\r\n   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<Microsoft.VisualStudio.Text.Tagging.IClassificationTag>)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1<System.__Canon>)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<RecomputeTagsAsync>d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<RecomputeTagsAsync>d__73[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.8.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](<RecomputeTagsAsync>d__73<System.__Canon> ByRef)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1<Microsoft.VisualStudio.Text.SnapshotPoint>, System.Nullable`1<Microsoft.CodeAnalysis.Text.TextChangeRange>, System.Collections.Immutable.ImmutableArray`1<Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan>, System.Collections.Immutable.ImmutableDictionary`2<Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1<System.__Canon>>, Boolean, System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+<>c__DisplayClass63_1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].<RecomputeTagsForeground>b__0(System.Threading.CancellationToken)\r\n   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+<>c__DisplayClass12_0.<EnqueueBackgroundTask>b__0(System.Threading.Tasks.Task)\r\n   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()\r\n   at System.Threading.Tasks.Task.Execute()\r\n   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\n   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\n   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n```"},{"Id":"7849152199","Type":"PullRequestEvent","CreatedAt":"2018-06-20T01:47:05","Actor":"tmat","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/pull/28007","RelatedDescription":"Opened pull request \"Avoid building vsdconfig for WPF temp projects\" (#28007) at dotnet/roslyn","RelatedBody":"Infrastructure change: fix build break."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7849431213","Type":"PullRequestEvent","CreatedAt":"2018-06-20T03:34:10","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5969","RelatedDescription":"Merged pull request \"Update RyuJIT\" (#5969) at dotnet/corert","RelatedBody":""},{"Id":"7849052970","Type":"PullRequestEvent","CreatedAt":"2018-06-20T01:08:04","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5969","RelatedDescription":"Opened pull request \"Update RyuJIT\" (#5969) at dotnet/corert","RelatedBody":""},{"Id":"7848939800","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:23:10","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5968","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5968) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848900166","Type":"PullRequestEvent","CreatedAt":"2018-06-20T00:07:59","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5968","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5968) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848794834","Type":"PullRequestEvent","CreatedAt":"2018-06-19T23:30:47","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5967","RelatedDescription":"Closed pull request \"Mirror changes from Anipik/ corefx\" (#5967) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from Anipik/ corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848786138","Type":"PullRequestEvent","CreatedAt":"2018-06-19T23:27:53","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5967","RelatedDescription":"Opened pull request \"Mirror changes from Anipik/ corefx\" (#5967) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from Anipik/ corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848742982","Type":"PullRequestEvent","CreatedAt":"2018-06-19T23:13:04","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5966","RelatedDescription":"Closed pull request \"Mirror changes from Anipik/ corefx\" (#5966) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from Anipik/ corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848742042","Type":"PullRequestEvent","CreatedAt":"2018-06-19T23:12:45","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5966","RelatedDescription":"Opened pull request \"Mirror changes from Anipik/ corefx\" (#5966) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from Anipik/ corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848586830","Type":"PullRequestEvent","CreatedAt":"2018-06-19T22:25:03","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5965","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5965) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848361026","Type":"PullRequestEvent","CreatedAt":"2018-06-19T21:31:58","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5965","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5965) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848077707","Type":"PullRequestEvent","CreatedAt":"2018-06-19T20:34:29","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/pull/5964","RelatedDescription":"Closed pull request \"Mirror changes from Anipik/ corefx\" (#5964) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from Anipik/ corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7848045064","Type":"PullRequestEvent","CreatedAt":"2018-06-19T20:28:02","Actor":"Anipik","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5964","RelatedDescription":"Opened pull request \"Mirror changes from Anipik/ corefx\" (#5964) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from Anipik/ corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"7847586609","Type":"IssuesEvent","CreatedAt":"2018-06-19T18:56:29","Actor":"am11","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5962","RelatedDescription":"Closed issue \"Crossgen is silently failing in CI\" (#5962) at dotnet/corert","RelatedBody":"While testing crossgen component on Alpine, I found there was one error which is in CI as well as in Alpine:\r\n\r\n```\r\n/Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx-TGroup_netcoreapp+CGroup_Debug+AGroup_x64+TestOuter_false_prtest/Tools/csc.dll -> /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx-TGroup_netcoreapp+CGroup_Debug+AGroup_x64+TestOuter_false_prtest/Tools/csc.ni.dll\r\nError compiling /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx-TGroup_netcoreapp+CGroup_Debug+AGroup_x64+TestOuter_false_prtest/Tools/Microsoft.DotNet.Build.Tasks.dll: Could not load file or assembly 'Microsoft.Build.Framework, Version=14.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.\r\n (Exception from HRESULT: 0x80070002)\r\nError: file \"/Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx-TGroup_netcoreapp+CGroup_Debug+AGroup_x64+TestOuter_false_prtest/Tools/Microsoft.DotNet.Build.Tasks.dll\" or one of its dependencies was not found\r\nUnable to successfully compile /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx-TGroup_netcoreapp+CGroup_Debug+AGroup_x64+TestOuter_false_prtest/Tools/Microsoft.DotNet.Build.Tasks.dll\r\n```\r\n\r\nIs this something that can fix in this repo or would we the tools repo need to be updated?"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7847435162","Type":"IssuesEvent","CreatedAt":"2018-06-19T18:26:55","Actor":"dsplaisted","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/2344","RelatedDescription":"Closed issue \"dotnet build -r runtime --no-restore fails in 2.1.301\" (#2344) at dotnet/sdk","RelatedBody":"# Repro Steps\r\n1. `dotnet new console --no-restore`\r\n2. `dotnet restore -r win-x64`\r\n3. `dotnet build -r win-x64 --no-restore`\r\n\r\nThese steps work as expected in CLI 2.1.300.  However, in CLI 2.1.301 the build step fails:\r\n\r\n```\r\nC:\\Temp\\foo\\foo.csproj : error : The project was restored using Microsoft.NETCore.App version 2.1.0, but with current settings,\r\nversion 2.1.1 would be used instead.  To resolve this issue, make sure the same settings are used for restore and for subsequent\r\noperations such as build or publish.  Typically this issue can occur if the RuntimeIdentifier property is set during build or publish\r\nbut not during restore.\r\n```\r\n\r\nThe error message is misleading, since the `RuntimeIdentifier (-r)` **is** set during both restore and build.\r\n\r\nA workaround is to remove the `--no-restore` from the `dotnet build` command:\r\n\r\n```\r\n  Restoring packages for C:\\Temp\\foo\\foo.csproj...\r\n  Installing runtime.win-x64.Microsoft.NETCore.DotNetAppHost 2.1.1.\r\n  Installing runtime.win-x64.Microsoft.NETCore.DotNetHostResolver 2.1.1.\r\n  Installing runtime.win-x64.Microsoft.NETCore.DotNetHostPolicy 2.1.1.\r\n  Installing runtime.win-x64.Microsoft.NETCore.App 2.1.1.\r\n  Generating MSBuild file C:\\Temp\\foo\\obj\\foo.csproj.nuget.g.props.\r\n  Generating MSBuild file C:\\Temp\\foo\\obj\\foo.csproj.nuget.g.targets.\r\n  Restore completed in 24.89 sec for C:\\Temp\\foo\\foo.csproj.\r\n  foo -> C:\\Temp\\foo\\bin\\Debug\\netcoreapp2.1\\win-x64\\foo.dll\r\n```\r\n\r\nIs this a bug or by design?  Is it expected that `dotnet build -r runtime --no-restore` should always work after `dotnet restore -r runtime`?\r\n\r\nCC: @JunTaoLuo "},{"Id":"7846879326","Type":"IssuesEvent","CreatedAt":"2018-06-19T16:40:50","Actor":"dsplaisted","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2345","RelatedDescription":"Opened issue \"Add link to runtime roll-forward documentation in version mismatch error message\" (#2345) at dotnet/sdk","RelatedBody":"When you restore without a RID but try to publish with a RID, you get an error message like the following:\r\n\r\n> C:\\Temp\\foo\\foo.csproj : error : The project was restored using Microsoft.NETCore.App version 2.1.0, but with current settings, version 2.1.1 would be used instead.  To resolve this issue, make sure the same settings are used for restore and for subsequent operations such as build or publish.  Typically this issue can occur if the RuntimeIdentifier property is set during build or publish but not during restore.\r\n\r\nWe should create an aka.ms link to [this doc page](https://docs.microsoft.com/en-us/dotnet/core/deploying/runtime-patch-selection) and then add that link to the error message."},{"Id":"7842870343","Type":"IssuesEvent","CreatedAt":"2018-06-19T02:11:12","Actor":"mikeharder","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/2344","RelatedDescription":"Opened issue \"dotnet build -r runtime --no-restore fails in 2.1.301\" (#2344) at dotnet/sdk","RelatedBody":"# Repro Steps\r\n1. `dotnet new console --no-restore`\r\n2. `dotnet restore -r win-x64`\r\n3. `dotnet build -r win-x64 --no-restore`\r\n\r\nThese steps work as expected in CLI 2.1.300.  However, in CLI 2.1.301 the build step fails:\r\n\r\n```\r\nC:\\Temp\\foo\\foo.csproj : error : The project was restored using Microsoft.NETCore.App version 2.1.0, but with current settings,\r\nversion 2.1.1 would be used instead.  To resolve this issue, make sure the same settings are used for restore and for subsequent\r\noperations such as build or publish.  Typically this issue can occur if the RuntimeIdentifier property is set during build or publish\r\nbut not during restore.\r\n```\r\n\r\nThe error message is misleading, since the `RuntimeIdentifier (-r)` **is** set during both restore and build.\r\n\r\nA workaround is to remove the `--no-restore` from the `dotnet build` command:\r\n\r\n```\r\n  Restoring packages for C:\\Temp\\foo\\foo.csproj...\r\n  Installing runtime.win-x64.Microsoft.NETCore.DotNetAppHost 2.1.1.\r\n  Installing runtime.win-x64.Microsoft.NETCore.DotNetHostResolver 2.1.1.\r\n  Installing runtime.win-x64.Microsoft.NETCore.DotNetHostPolicy 2.1.1.\r\n  Installing runtime.win-x64.Microsoft.NETCore.App 2.1.1.\r\n  Generating MSBuild file C:\\Temp\\foo\\obj\\foo.csproj.nuget.g.props.\r\n  Generating MSBuild file C:\\Temp\\foo\\obj\\foo.csproj.nuget.g.targets.\r\n  Restore completed in 24.89 sec for C:\\Temp\\foo\\foo.csproj.\r\n  foo -> C:\\Temp\\foo\\bin\\Debug\\netcoreapp2.1\\win-x64\\foo.dll\r\n```\r\n\r\nIs this a bug or by design?  Is it expected that `dotnet build -r runtime --no-restore` should always work after `dotnet restore -r runtime`?\r\n\r\nCC: @JunTaoLuo "},{"Id":"7842314555","Type":"PullRequestEvent","CreatedAt":"2018-06-18T22:52:31","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/pull/2311","RelatedDescription":"Closed pull request \"Merge release/2.1.4xx to master\" (#2311) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.4xx into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.4xx-to-master\ngit reset --hard upstream/master\ngit merge upstream/release/2.1.4xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.4xx-to-master --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7842005808","Type":"IssuesEvent","CreatedAt":"2018-06-18T21:32:53","Actor":"jceddy","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/2338","RelatedDescription":"Closed issue \"Since installing SDK 2.1.3, getting GenerateDepsFile error\" (#2338) at dotnet/sdk","RelatedBody":"Since I installed the 2.1.3 SDK, I have started getting this error when building a solution that previously built correctly:\r\n\r\n> Severity\tCode\tDescription\tProject\tFile\tLine\tSuppression State\r\n> Error\tMSB4018\tThe \"GenerateDepsFile\" task failed unexpectedly.\r\n> System.ArgumentException: Can not add property Company.Product.Server.Core/3.1.2.0 to Newtonsoft.Json.Linq.JObject. Property with the same name already exists on object.\r\n>    at Newtonsoft.Json.Linq.JObject.ValidateToken(JToken o, JToken existing)\r\n>    at Newtonsoft.Json.Linq.JContainer.InsertItem(Int32 index, JToken item, Boolean skipParentCheck)\r\n>    at Newtonsoft.Json.Linq.JObject.InsertItem(Int32 index, JToken item, Boolean skipParentCheck)\r\n>    at Newtonsoft.Json.Linq.JContainer.AddInternal(Int32 index, Object content, Boolean skipParentCheck)\r\n>    at Newtonsoft.Json.Linq.JContainer.AddInternal(Int32 index, Object content, Boolean skipParentCheck)\r\n>    at Newtonsoft.Json.Linq.JContainer.Add(Object content)\r\n>    at Newtonsoft.Json.Linq.JObject..ctor(Object content)\r\n>    at Microsoft.Extensions.DependencyModel.DependencyContextWriter.WriteTarget(IReadOnlyList`1 libraries)\r\n>    at Microsoft.Extensions.DependencyModel.DependencyContextWriter.WriteTargets(DependencyContext context)\r\n>    at Microsoft.Extensions.DependencyModel.DependencyContextWriter.Write(DependencyContext context)\r\n>    at Microsoft.Extensions.DependencyModel.DependencyContextWriter.Write(DependencyContext context, Stream stream)\r\n>    at Microsoft.NET.Build.Tasks.GenerateDepsFile.ExecuteCore()\r\n>    at Microsoft.NET.Build.Tasks.TaskBase.Execute()\r\n>    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()\r\n>    at Microsoft.Build.BackEnd.TaskBuilder.<ExecuteInstantiatedTask>d__26.MoveNext()\tOATI.webVision.Server.Core\tC:\\Program Files\\dotnet\\sdk\\2.1.300\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.Sdk.targets\t128\t\r\n\r\nI've looked around the web and haven't been able to find any kind of solution. Is this a known issue?"},{"Id":"7841751603","Type":"IssuesEvent","CreatedAt":"2018-06-18T20:40:26","Actor":"peterhuene","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/1905","RelatedDescription":"Closed issue \"Non-selfcontained RID-specific app should copy host executable to build output\" (#1905) at dotnet/sdk","RelatedBody":"TL;DR\r\nCombination of `RuntimeIdentifier` + `SelfContained=false` doesn't work well for development work (`dotnet run`, visual studio F5).\r\n```xml\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n    <RuntimeIdentifier>win-x86</RuntimeIdentifier>\r\n    <SelfContained>false</SelfContained>\r\n  </PropertyGroup>\r\n```\r\n\r\nScenario / Repro steps:\r\n\r\n* Create  a console app\r\n* Add native 32-bit dlls to PInvoke into\r\n* Realize you now need to make sure you run 32bit only and are locked into a RID\r\n  * add `<RuntimeIdentifier>win-x86</RuntimeIdentifier>` to the csproj\r\n* `dotnet run` works just fine now since there is a 32 bit host executable copied to the output directory which resolves the 32bit runtime. Visual Studio also runs the app just fine.\r\n* Publish once and realize you don't need to publish self-contained. Or have problems using `dotnet publish --self-contained` because it is passed as a global parameter to all reference projects and some may error out (https://github.com/dotnet/sdk/issues/1834)\r\n  * Put `<SelfContained>false</SelfContained>` into the csproj file.\r\n* `dotnet run` and Visual Studio run no longer work because it falls back to calling `dotnet the.dll` which fails to load 32-bit (native) assemblies.\r\n\r\nCan the generation of the native host be turned on even though `SelfContained` is false for build output only?\r\n\r\nThere may be some additional advantages in also copying this host without the self-contained framework for publish - (https://github.com/dotnet/cli/issues/6237)\r\n\r\nThe advantage of this host is that it launches with the right bitness and there is no need to put the 32bit `dotnet.exe` on the `PATH` or use a 32bit SDK."}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1009207915775811584","CreatedAt":"2018-06-19T22:54:51+00:00","UserScreenname":"dotnet","Text":"The RyuJIT transition is complete! https://t.co/JhkSV0Aybh","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":142,"FavoriteCount":72,"RawContent":null},{"Id":"1008787534451638272","CreatedAt":"2018-06-18T19:04:25+00:00","UserScreenname":"dotnet","Text":"Staying up-to-date with .NET Container Images https://t.co/09vnrG5uqh /cc @aspnet @Docker @DockerCon","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":200,"FavoriteCount":103,"RawContent":null},{"Id":"1008746685697150976","CreatedAt":"2018-06-18T16:22:06+00:00","UserScreenname":"dotnet","Text":"Building distributed applications with Orleans https://t.co/GgWRQHcdPP","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":64,"FavoriteCount":24,"RawContent":null},{"Id":"1007054749512814592","CreatedAt":"2018-06-14T00:18:57+00:00","UserScreenname":"dotnet","Text":"Using .NET and Docker Together – DockerCon 2018 Update https://t.co/ZYju7lEGqz","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":146,"FavoriteCount":77,"RawContent":null},{"Id":"1007012327353454594","CreatedAt":"2018-06-13T21:30:22+00:00","UserScreenname":"dotnet","Text":"Join @csharpfritz tomorrow to learn how to use @AppInsights with your #ASP.NET Core project. https://t.co/pSofjdde2Y","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":21,"FavoriteCount":9,"RawContent":null},{"Id":"1005426264029753345","CreatedAt":"2018-06-09T12:27:55+00:00","UserScreenname":"dotnet","Text":"Tune in today at 10a ET / 7a PT / 14:00 UTC / 8p IST and learn about global tools along with Jeff. https://t.co/hqxNjfqPMq","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":12,"FavoriteCount":5,"RawContent":null}]}},"RunOn":"2018-06-20T05:30:36.2910887Z","RunDurationInMilliseconds":9303}