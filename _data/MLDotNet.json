{"Data":{"GitHub":{"Issues":[{"Id":"399638165","IsPullRequest":false,"CreatedAt":"2019-01-16T04:00:27","Actor":"endintiers","Number":"2159","RawContent":null,"Title":"AggregateException/InvalidOperationException when training from IEnumerable backed by EF Core Context","State":"open","Body":"### System information\r\n- .Net Core 2.2, EF Core 2.2.1, ML.NET 0.9\r\n\r\n### Issue\r\n\r\n- Read data from SQL DB via EF Core as IEnumerable, pass to pipeline via streaming IDataView\r\n- Get InvalidOperationException from Microsoft.ML.Transforms.RowShufflingTransformer.Cursor.LoopProducerWorker()\r\n- It worked fine in ML.NET 0.8. I can work-around by forcing the trainer to be single-threaded but this makes training in 0.9 much slower than in 0.8 (on my machine).\r\n\r\nThe EF Core problem could be addressed by allowing multiple dbcontexts to be provided but this is likely to be an issue with any non thread-safe IDataView source...  \r\n\r\n### Source code / logs\r\n\r\nSource at: https://github.com/endintiers/Unearth.Demo.ML.FromDB shows this working in 0.8, failing in 0.9 and a work-around for 0.9 (single-threading the training).\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2159","RelatedDescription":"Open issue \"AggregateException/InvalidOperationException when training from IEnumerable backed by EF Core Context\" (#2159)"},{"Id":"398480598","IsPullRequest":true,"CreatedAt":"2019-01-16T03:25:45","Actor":"eerhardt","Number":"2131","RawContent":null,"Title":"Remove \"VectorType\" specific members on ColumnType.","State":"closed","Body":"Remove the following members from ColumnType:\r\n\r\n- IsVector\r\n- ItemType\r\n- IsKnownSizeVector\r\n- VectorSize\r\n- ValueCount\r\n\r\nPart of the work necessary for #1860 and contributes to #1533.","Url":"https://github.com/dotnet/machinelearning/pull/2131","RelatedDescription":"Closed or merged PR \"Remove \"VectorType\" specific members on ColumnType.\" (#2131)"},{"Id":"399555462","IsPullRequest":true,"CreatedAt":"2019-01-16T01:17:50","Actor":"shauheen","Number":"2153","RawContent":null,"Title":"Adding packages to the solution","State":"closed","Body":"Does not effect users, however would be nice to have all packages in the solution. Fixes #1168 ","Url":"https://github.com/dotnet/machinelearning/pull/2153","RelatedDescription":"Closed or merged PR \"Adding packages to the solution\" (#2153)"},{"Id":"399020074","IsPullRequest":true,"CreatedAt":"2019-01-16T00:42:53","Actor":"Ivanidzo4ka","Number":"2136","RawContent":null,"Title":"Revert tests changes in tensorflow to unblock builds","State":"closed","Body":"I can't find proper way to handle tests right now for case where we load same model twice. So i'm removing that part of test","Url":"https://github.com/dotnet/machinelearning/pull/2136","RelatedDescription":"Closed or merged PR \"Revert tests changes in tensorflow to unblock builds\" (#2136)"},{"Id":"399595235","IsPullRequest":true,"CreatedAt":"2019-01-16T00:26:43","Actor":"sfilipi","Number":"2158","RawContent":null,"Title":"KMeans and Implicit weight cleanup","State":"open","Body":"Towards #1798 \r\n\r\nRenaming Args ->Options, internalizing ctors, and fixing the issue with the weigh column being initialized as Implicit or Explicit. \r\n","Url":"https://github.com/dotnet/machinelearning/pull/2158","RelatedDescription":"Open PR \"KMeans and Implicit weight cleanup\" (#2158)"},{"Id":"399594934","IsPullRequest":true,"CreatedAt":"2019-01-16T00:25:23","Actor":"Anipik","Number":"2157","RawContent":null,"Title":"Support running benchmarks on netfx","State":"open","Body":"Fixes https://github.com/dotnet/machinelearning/issues/1945\r\n\r\nThis PR makes changes in order to enable developers to run ML benchmarks against .NetFramework\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2157","RelatedDescription":"Open PR \"Support running benchmarks on netfx\" (#2157)"},{"Id":"399586255","IsPullRequest":false,"CreatedAt":"2019-01-15T23:48:26","Actor":"Ivanidzo4ka","Number":"2156","RawContent":null,"Title":"Loading of same model for tensorflow throw exception","State":"open","Body":"just run in two different threads:\r\n`var loadModelSchema = TensorFlowUtils.GetModelSchema(mlContext, modelLocation);`\r\nit will throw exception.","Url":"https://github.com/dotnet/machinelearning/issues/2156","RelatedDescription":"Open issue \"Loading of same model for tensorflow throw exception\" (#2156)"},{"Id":"399572511","IsPullRequest":false,"CreatedAt":"2019-01-15T22:55:49","Actor":"TomFinley","Number":"2155","RawContent":null,"Title":"C# samples should probably use C# and not Python naming conventions","State":"open","Body":"I was reading a PR when suddenly I saw something a bit odd.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/6b9f5893ea6830481a8779f81f2b723e9b5cd6cd/docs/samples/Microsoft.ML.Samples/Dynamic/KeyToValue_Term.cs#L42-L47\r\n\r\nNote the underscores in the middle of a field variable name. While in private we might elect to bend the rules a little bit, in our public API and also probably our samples, we probably ought to write them with [consideration of standard practices](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-conventions). This does not seem to be a justifiable or explainable diversion from the recommended practice, and I'm guessing it was added by mistake.\r\n\r\nEach individual renaming is probably not huge, but might span several files, since the example listed above is just one of many examples I see in our samples project. So not a \"hard\" change, except possibly in scale?","Url":"https://github.com/dotnet/machinelearning/issues/2155","RelatedDescription":"Open issue \"C# samples should probably use C# and not Python naming conventions\" (#2155)"},{"Id":"398482437","IsPullRequest":true,"CreatedAt":"2019-01-15T22:49:32","Actor":"wschin","Number":"2132","RawContent":null,"Title":"Remove ISchema in TreeEnsembleFeaturizer","State":"closed","Body":"New member of #1501.","Url":"https://github.com/dotnet/machinelearning/pull/2132","RelatedDescription":"Closed or merged PR \"Remove ISchema in TreeEnsembleFeaturizer\" (#2132)"},{"Id":"399558585","IsPullRequest":false,"CreatedAt":"2019-01-15T22:12:30","Actor":"abgoswam","Number":"2154","RawContent":null,"Title":"Add XML summary comments to fields in Options class","State":"open","Body":"We need to add XML summary comments to fields in `Options` class.\r\n\r\nLearners where its missing:\r\n\r\n- SdcaBinaryTrainer\r\n- SdcaMultiClassTrainer\r\n- SdcaRegressionTrainer\r\n- StochasticGradientDescentClassificationTrainer","Url":"https://github.com/dotnet/machinelearning/issues/2154","RelatedDescription":"Open issue \"Add XML summary comments to fields in Options class\" (#2154)"},{"Id":"399494716","IsPullRequest":true,"CreatedAt":"2019-01-15T19:17:57","Actor":"stephentoub","Number":"2152","RawContent":null,"Title":"Reuse threads in ThreadUtils","State":"open","Body":"ThreadUtils.CreateBackgroundThread is being truthful to its name and creating a new thread for every call.  However, even for very simple ML.NET usage, such as the MulticlassClassification_Iris demo app, this method is being called ~110,000 times, resulting in ~110,000 threads getting created and destroyed.  That adds measurable overhead in normal runs, but when the debugger is attached it makes the solution effectively unusable, as every thread creation/destruction is tracked by Visual Studio, leading to significant overheads that make an F5 execution last \"forever\" (== I gave up waiting).\r\n\r\nThe right solution is for the higher-level algorithms and architecture to be better about its need for threads, creating them only when necessary and otherwise relying on the .NET ThreadPool for execution, via either ThreadPool.QueueUserWorkItem or via Task.Run or the like.\r\n\r\nHowever, as an immediate stop-gap that significantly helps the situation, this commit allows the created threads to be reused for a period of time such that not every call ends up creating a new thread.  In my runs:\r\n- The same demo that app that created ~110K threads now creates only ~32.\r\n- With ctrl-F5 (e.g. no debugger attached), it previously took ~13 seconds, and with this change now takes ~6.\r\n- With F5 (debugger attached), execution previously took \"forever\", now takes ~190 seconds (still way too high, but vastly improved).\r\n\r\nThe CreateBackgroundThread method is renamed to StartBackgroundThread, and returns a Task instead of a Thread, such that callers may synchronize with that instead with Thread.Join.  In several cases, this avoids additional threads from being consumed, where callers were blocking a thread pool thread doing a synchronous wait for all tasks, and where now that's entirely avoided via Task.WhenAll.  Eventually, more call sites can be fixed as well, as more of the code base is moved to async/await; for now this just handles the obvious ones that don't require any significant restructuring.\r\n\r\nContributes to https://github.com/dotnet/machinelearning/issues/2099","Url":"https://github.com/dotnet/machinelearning/pull/2152","RelatedDescription":"Open PR \"Reuse threads in ThreadUtils\" (#2152)"},{"Id":"399423437","IsPullRequest":false,"CreatedAt":"2019-01-15T16:21:42","Actor":"wschin","Number":"2151","RawContent":null,"Title":"TreeEnsembleFeaturizerTransform has no Transformer derivative","State":"open","Body":"As title. Please see [TreeEnsembleFeaturizerTransform](https://github.com/dotnet/machinelearning/blob/2e5612c029583185c10044fb1b665c5d308676d7/src/Microsoft.ML.FastTree/TreeEnsembleFeaturizer.cs#L540). As most transforms have become transformers, maybe this one should do as well.","Url":"https://github.com/dotnet/machinelearning/issues/2151","RelatedDescription":"Open issue \"TreeEnsembleFeaturizerTransform has no Transformer derivative\" (#2151)"},{"Id":"399097824","IsPullRequest":true,"CreatedAt":"2019-01-15T15:22:21","Actor":"wschin","Number":"2140","RawContent":null,"Title":"Remove ISchema in TextLoader.cs and TextLoaderCursor.cs","State":"closed","Body":"As title. This might be the tail of #1501.","Url":"https://github.com/dotnet/machinelearning/pull/2140","RelatedDescription":"Closed or merged PR \"Remove ISchema in TextLoader.cs and TextLoaderCursor.cs\" (#2140)"},{"Id":"399311728","IsPullRequest":false,"CreatedAt":"2019-01-15T11:54:42","Actor":"joelving","Number":"2150","RawContent":null,"Title":"FeatureContributionCalculator property is frequently misspelled","State":"open","Body":"FeatureContributionCalculator is misspelled as FeatureContributionClaculator (note the switched 'a' and 'l' in 'Calculator' => 'Claculator').\r\n\r\nThe mistake seems to have been copy-pasted around a bit: https://github.com/dotnet/machinelearning/search?q=FeatureContributionClaculator","Url":"https://github.com/dotnet/machinelearning/issues/2150","RelatedDescription":"Open issue \"FeatureContributionCalculator property is frequently misspelled\" (#2150)"},{"Id":"399229993","IsPullRequest":false,"CreatedAt":"2019-01-15T08:10:46","Actor":"shaykels","Number":"2149","RawContent":null,"Title":"OnnxTransfrom - onnxruntime.dll - ReleaseOrtAllocatorInfo- System.EntryPointNotFoundException:","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Win 10, 64-bit, 10.0.17763\r\n- **.NET Version (eg., dotnet --info)**:  4.6.2\r\n\r\n### Issue\r\n\r\nAdded OnnxTransformSample.cs + nugets to a console app, trying to run the example.\r\n\r\n1. Exception onnxruntime.dll is not found, probably similar to this https://github.com/dotnet/machinelearning/issues/2106\r\n\r\n2. Copied onnxruntime.dll from ..\\packages\\Microsoft.ML.OnnxRuntime.Gpu.0.1.5\\runtimes\\win10-x64\\native to my app directory. The example works find, but when I close the console app, there is an exception \r\n\r\nSystem.EntryPointNotFoundException: 'Unable to find an entry point named 'ReleaseOrtAllocatorInfo' in DLL 'onnxruntime.dll'.'\r\n\r\n\r\n\r\n### Source code / logs\r\n\r\nPlease paste or attach the code or logs or traces that would be helpful to diagnose the issue you are reporting.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2149","RelatedDescription":"Open issue \"OnnxTransfrom - onnxruntime.dll - ReleaseOrtAllocatorInfo- System.EntryPointNotFoundException:\" (#2149)"},{"Id":"399211321","IsPullRequest":false,"CreatedAt":"2019-01-15T06:56:41","Actor":"wschin","Number":"2148","RawContent":null,"Title":"TextLoader.ColInfo will be a redundant data structure","State":"open","Body":"As mentioned in #2140, TextLoader.ColInfo can potentially be removed because its function overlaps with that of the output schema of TextLoader. We should remove TextLoader.ColInfo for cleaning.","Url":"https://github.com/dotnet/machinelearning/issues/2148","RelatedDescription":"Open issue \"TextLoader.ColInfo will be a redundant data structure\" (#2148)"},{"Id":"399066289","IsPullRequest":true,"CreatedAt":"2019-01-15T06:35:26","Actor":"stephentoub","Number":"2138","RawContent":null,"Title":"Avoid using exceptions for control flow in GetBatch","State":"closed","Body":"Fixes https://github.com/dotnet/machinelearning/issues/2137\r\nContributes to https://github.com/dotnet/machinelearning/issues/2099\r\n\r\nThis avoids using Take() in GetBatch, instead using TryTake with an infinite timeout, the only difference being whether it expects to eventually get data, and thus whether it throws or returns false when it finds the collection empty and marked for completion. This doesn't fix #2099, but it helps.  These exceptions are largely a side-effect of tons of threads getting created, which is another huge contributor to #2099.\r\n\r\ncc: @TomFinley ","Url":"https://github.com/dotnet/machinelearning/pull/2138","RelatedDescription":"Closed or merged PR \"Avoid using exceptions for control flow in GetBatch\" (#2138)"},{"Id":"399055967","IsPullRequest":false,"CreatedAt":"2019-01-15T06:35:26","Actor":"TomFinley","Number":"2137","RawContent":null,"Title":"Change TextLoader synchronization to not use exceptions","State":"closed","Body":"The `TextLoader` code in its current form uses multithreading in its parsing. While reading the raw data from the file is in a single thread, the work of interpreting that data, putting it into buffers, etc. etc., is done in separate threads as that was the bottleneck in parsing. It uses blocking collections to synchronize this work, as we do in many other places. So far, so good.\r\n\r\nNow, unfortunately, unlike our other usages of blocking collections, this implementation uses exception catching simply as a matter of course, to detect and react to empty buffers, etc. While this always seemed to me to have at least a bad code smell, apparently it is detrimental from a perf perspective as well, being needlessly slow compared to the other exception free mechanisms of using blocking collections, according to @stephentoub, whose diagnosis I quote directly below:\r\n\r\n> I believe the problem is that the demo is throwing ~110,000 exceptions (which are caught internally).  Adding the AppendCacheCheckpoint drops that to 50.  Exception throwing/catching is expensive, and there’s a noticeable difference in throughput even without the debugger attached, but exceptions are even more expensive when a debugger is attached, hence F5 being super slow.\r\n> \r\n> Almost all of the exceptions are InvalidOperationExceptions stemming from invalid use of a BlockingCollection:\r\n> System.InvalidOperationException: The collection argument is empty and has been marked as complete with regards to additions.\r\n> \r\n> Coming from:\r\n> \r\n> ```\r\n> System.Collections.Concurrent.dll!System.Collections.Concurrent.BlockingCollection<Microsoft.ML.Data.TextLoader.Cursor.LineBatch>.Take() Line 545     C#\r\n> Microsoft.ML.Data.dll!Microsoft.ML.Data.TextLoader.Cursor.LineReader.GetBatch() Line 451     C#\r\n> Microsoft.ML.Data.dll!Microsoft.ML.Data.TextLoader.Cursor.GetSomeLines(Microsoft.ML.Data.IMultiStreamSource source, int count, ref System.Collections.Generic.List<System.ReadOnlyMemory<char>> lines = null) Line 221    C#\r\n> Microsoft.ML.Data.dll!Microsoft.ML.Data.TextLoader.Bindings.Bindings(Microsoft.ML.Data.TextLoader parent = {Microsoft.ML.Data.TextLoader}, Microsoft.ML.Data.TextLoader.Column[] cols = {Microsoft.ML.Data.TextLoader.Column[5]}, Microsoft.ML.Data.IMultiStreamSource headerFile = null, Microsoft.ML.Data.IMultiStreamSource dataSample) Line 570      C#\r\n> Microsoft.ML.Data.dll!Microsoft.ML.Data.TextLoader.TextLoader(Microsoft.ML.IHostEnvironment env, Microsoft.ML.Data.TextLoader.Arguments args, Microsoft.ML.Data.IMultiStreamSource dataSample) Line 1135     C#\r\n> Microsoft.ML.Data.dll!Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader(Microsoft.ML.DataOperations catalog, Microsoft.ML.Data.TextLoader.Arguments args, Microsoft.ML.Data.IMultiStreamSource dataSample) Line 37 C#\r\n> MulticlassClassification_Iris.dll!MulticlassClassification_Iris.Program.BuildTrainEvaluateAndSaveModel(Microsoft.ML.MLContext mlContext = {Microsoft.ML.MLContext}) Line 51 C#\r\n> MulticlassClassification_Iris.dll!MulticlassClassification_Iris.Program.Main(string[] args = {string[0]}) Line 38      C#\r\n> ```\r\n> \r\n> Whether or not that’s the only issue, I don’t know, but my guess is if you fix that issue, the perf will get a lot better.\r\n\r\nTangentially related to #2099, insofar as it sprang from the same discussion.","Url":"https://github.com/dotnet/machinelearning/issues/2137","RelatedDescription":"Closed issue \"Change TextLoader synchronization to not use exceptions\" (#2137)"},{"Id":"399173592","IsPullRequest":false,"CreatedAt":"2019-01-15T03:28:46","Actor":"justinormont","Number":"2147","RawContent":null,"Title":"Check range of ScalePosWeight in LightGBM","State":"open","Body":"Our recommendation seems to be (0,Inf) for `ScalePosWeight`, but we then restrict it to (0,1].\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/a570da14a41f2870eb8f61d84496a58422398253/src/Microsoft.ML.LightGBM/LightGbmArguments.cs#L155-L158\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/a570da14a41f2870eb8f61d84496a58422398253/src/Microsoft.ML.LightGBM/LightGbmArguments.cs#L170\r\n\r\nThis likely should be:\r\n```C#\r\nContracts.CheckUserArg(Args.ScalePosWeight > 0, nameof(Args.ScalePosWeight), \"must be > 0.\");\r\n```","Url":"https://github.com/dotnet/machinelearning/issues/2147","RelatedDescription":"Open issue \"Check range of ScalePosWeight in LightGBM\" (#2147)"},{"Id":"399172306","IsPullRequest":true,"CreatedAt":"2019-01-15T03:21:51","Actor":"artidoro","Number":"2146","RawContent":null,"Title":"KeyType Simplification","State":"open","Body":"Fixes #1540.\r\n\r\nIn this PR I remove the Min and Contiguous fields of KeyType. The reason for doing so is elaborated in the issue #1540.\r\n\r\nBefore this PR, a valid range of values for a key could be 1000 to 4000. This was represented by a key with Min 1000 and Count 4001. Having a key that starts at a value that is not 1 only very rarely happened in practice.\r\n\r\nNow by default a valid range will start at 1, up to Count, with 0 being used for missing values.\r\n\r\nAs part of this PR I also removed the Min and Contiguous field of KeyRange (KeyRange serves the purpose of representing a valid range of values for a KeyType). It is useful to note that the max of a KeyRange will be equal to Count - 1 of the associated KeyType.\r\n\r\nAlso fixed the comments and the [documentation ](https://github.com/dotnet/machinelearning/blob/master/docs/code/IDataViewTypeSystem.md#key-types) on the type system to make sure they reflect the change.","Url":"https://github.com/dotnet/machinelearning/pull/2146","RelatedDescription":"Open PR \"KeyType Simplification\" (#2146)"},{"Id":"399162632","IsPullRequest":false,"CreatedAt":"2019-01-15T02:32:33","Actor":"zeahmed","Number":"2145","RawContent":null,"Title":"Relocate Microsoft.ML.TensorFlow.TestModels nuget or grant access to dotnet-core feed.","State":"open","Body":"Currently, Microsoft.ML.TensorFlow.TestModels nuget is created from https://github.com/dotnet/machinelearning-testdata and push to dotnet-core feed. \r\n\r\nML.Net people don't have push access to dotnet-core feed. Whenever there is a change in the repo and nuget needs to be regenerated, we need to ask the relevant people (who have access) to do this. The solution is either create a new feed where ML.Net people have access to or grant push access on dotnet-core to ML.Net people (whichever is convenient).\r\n\r\nCc: @yaeldekel, @ericstj, @eerhardt.","Url":"https://github.com/dotnet/machinelearning/issues/2145","RelatedDescription":"Open issue \"Relocate Microsoft.ML.TensorFlow.TestModels nuget or grant access to dotnet-core feed.\" (#2145)"},{"Id":"399077549","IsPullRequest":true,"CreatedAt":"2019-01-15T01:17:24","Actor":"wschin","Number":"2139","RawContent":null,"Title":"Remove ISchema in BinaryLoader","State":"closed","Body":"As title. Parade of #1501 continues today.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/2139","RelatedDescription":"Closed or merged PR \"Remove ISchema in BinaryLoader\" (#2139)"},{"Id":"399147635","IsPullRequest":false,"CreatedAt":"2019-01-15T01:16:49","Actor":"najeeb-kazmi","Number":"2144","RawContent":null,"Title":"Decide a good name for TextLoader","State":"open","Body":"In #1690 we renamed `MLContext.Data.CreateTextReader` to `MLContext.Data.CreateTextLoader` to have the method match the return type `TextLoader`.\r\n\r\nIn #581 and subsequent work, we are replacing `IDataLoader` with `IDataReader`, and so renaming the `TextLoader` to `TextReader` would make sense. However, doing so would lead to disambiguation issues between `Microsoft.ML.Data.TextReader` and `System.IO.TextReader`, which we should avoid as per .NET guidelines. So, we must come up with a new name for `TextLoader` that is descriptive but is different from `TextReader`.\r\n\r\nSome suggestions:\r\n- `DelimitedTextReader`\r\n- `DelimTextReader`\r\n- `TextDataReader`\r\n\r\ncc: @glebuk @eerhardt @TomFinley ","Url":"https://github.com/dotnet/machinelearning/issues/2144","RelatedDescription":"Open issue \"Decide a good name for TextLoader\" (#2144)"},{"Id":"399134254","IsPullRequest":true,"CreatedAt":"2019-01-15T00:19:52","Actor":"eerhardt","Number":"2143","RawContent":null,"Title":"Remove ColumnType.RawKind usages Round 1.","State":"open","Body":"Remove all usages of RawKind that are outside of ML.Core and ML.Data assemblies. The next round will completely remove ColumnType.RawKind.\r\n\r\nPart of the work necessary for #1860 and contributes to #1533.","Url":"https://github.com/dotnet/machinelearning/pull/2143","RelatedDescription":"Open PR \"Remove ColumnType.RawKind usages Round 1.\" (#2143)"},{"Id":"399126527","IsPullRequest":true,"CreatedAt":"2019-01-14T23:50:51","Actor":"rogancarr","Number":"2142","RawContent":null,"Title":"Refactor GAM Predictor to be Generic","State":"open","Body":"This PR refactors the GAM trainer and predictor such that all training information remains in the trainer, and the GAM predictor is for any generic (binned) GAM.\r\n\r\nFixes #1948\r\n\r\n**Update**:  Two small bug fixes included in this PR\r\n1. Fixed a serialization error when reading in GAM models written prior to 0.6. Now we issue a warning with a workaround.\r\n2. Fixed a scoring error for sparse datasets.","Url":"https://github.com/dotnet/machinelearning/pull/2142","RelatedDescription":"Open PR \"Refactor GAM Predictor to be Generic\" (#2142)"},{"Id":"399112226","IsPullRequest":false,"CreatedAt":"2019-01-14T22:54:10","Actor":"yaeldekel","Number":"2141","RawContent":null,"Title":"Why can't SlotDroppingTransformer be applied to integer columns?","State":"open","Body":"This is the comment on the IsValidColumnType method of the transformer:\r\nhttps://github.com/dotnet/machinelearning/blob/master/src/Microsoft.ML.Data/Transforms/DropSlotsTransform.cs#L474\r\n\r\nBoth scalars and vectors are acceptable types, but the item type must have a default value which means it must be a string, a key, a float or a double.\r\n\r\nI think integers fit this description as well.","Url":"https://github.com/dotnet/machinelearning/issues/2141","RelatedDescription":"Open issue \"Why can't SlotDroppingTransformer be applied to integer columns?\" (#2141)"},{"Id":"398476760","IsPullRequest":true,"CreatedAt":"2019-01-14T18:10:09","Actor":"yaeldekel","Number":"2130","RawContent":null,"Title":"Fix bug with order of pixels in the Interleave=true case","State":"closed","Body":"Fixes #2129.","Url":"https://github.com/dotnet/machinelearning/pull/2130","RelatedDescription":"Closed or merged PR \"Fix bug with order of pixels in the Interleave=true case\" (#2130)"},{"Id":"398506488","IsPullRequest":true,"CreatedAt":"2019-01-12T01:25:05","Actor":"wschin","Number":"2135","RawContent":null,"Title":"Add a test to make sure example pipeline can run","State":"open","Body":"An [example](https://github.com/dotnet/machinelearning-samples/blob/16acc2f55880808bd34f3465e3eec4571565cb89/samples/csharp/getting-started/MatrixFactorization_MovieRecommendation/MovieRecommendation/Program.cs#L48) built with 0.7 doesn't work anymore because we reorder a function's arguments. Therefore, I'd like add a test for preventing it from happening again.","Url":"https://github.com/dotnet/machinelearning/pull/2135","RelatedDescription":"Open PR \"Add a test to make sure example pipeline can run\" (#2135)"},{"Id":"398491210","IsPullRequest":false,"CreatedAt":"2019-01-11T23:40:25","Actor":"CESARDELATORRE","Number":"2134","RawContent":null,"Title":"Support for \"Multi target regression models\" (MTR)","State":"open","Body":"This feature request started from a particular customer feedback (see feedback at the end of the comment).\r\n\r\nContext/explanation:\r\n\r\nMost Machine Learning models targeting a regression problem usually support a single target variable to predict, which for the case of a regression is a numeric value.\r\n\r\nHowever, other machine learning frameworks also provide \"Multi target regression models\" (MTR) like explained in the post link below:\r\n\r\nhttps://towardsdatascience.com/regression-models-with-multiple-target-variables-8baa75aacd \r\n\r\nHowever, ML.NET currently doesn't have a built-in multi-output regression learner/trainer.\r\n\r\nCurrently, by just using ML.NET, you need to use a different trained model per each target variable/prediction. If you want to predict 5 different target or dependent variables , you'd need to create 5 different models for that, instead of a single model predicting 5 target variables. \r\n\r\nFEATURE:\r\n\r\nThe implementation of this feature would allow ML.NET to support \"Multi target regression models\" (MTR), built-in in ML.NET without needing external frameworks like TensorFlow.\r\n\r\n--------------------------------------------------------------------------------------------------------\r\nCUSTOMER FEEDBACK:\r\n--------------------------------------------------------------------------------------------------------\r\nta.speot.is\r\nHi, thanks for improving ML.NET. I’ve spent a little bit of time with it and it’s nice to have a first-class .NET API for Machine Learning.\r\n\r\nRight now I’m using ML.NET very much like described in “Tutorial: Predict New York taxi fares using a regression learner with ML.NET” but I’m wondering how to build on it. Presently I’m predicting one attribute (in the tutorial’s case: the taxi fare) but I have more complicated scenarios I want to predict that involve multiple attributes (using the tutorial’s domain it would be predicting, say, taxi fare AND a surge charging multiple e.g. 1.0x, 1.5x).\r\n\r\nTrying to make “Score” an array of floats didn’t work (the glossary on MSDN says regression is “the output is a real value, for example, double” i.e. one value so that it didn’t work was to be expected).\r\n\r\n**Obviously I could train 10 models for the 10 attributes I want to predict but I feel like there’s a better way.** \r\n\r\nIf anybody has any thoughts I’d appreciate any suggestions!\r\n\r\n--------------------------------------------------------------------------------------------------------\r\n","Url":"https://github.com/dotnet/machinelearning/issues/2134","RelatedDescription":"Open issue \"Support for \"Multi target regression models\" (MTR)\" (#2134)"},{"Id":"398485238","IsPullRequest":false,"CreatedAt":"2019-01-11T23:12:10","Actor":"sfilipi","Number":"2133","RawContent":null,"Title":"Command-line oriented arguments, that have more suitable alternatives for the API should be made internal","State":"open","Body":"In the arguments classes there are several arguments that get translated to the same parameter for the estimators/transforms. \r\n\r\nOne of the variant is  a convenience for the command line version of ML.Net. \r\n\r\nI think those can be made internal, and kept away from the user for v1. \r\n\r\nExample:\r\n\r\n[ValueToKeyMappingTransformer.ArgumentsBase](https://github.com/dotnet/machinelearning/blob/312f9e4c71953bee701ea2a63be3cb4d2d276d20/src/Microsoft.ML.Data/Transforms/ValueToKeyMappingTransformer.cs#L53)\r\n\r\n```csharp\r\npublic abstract class ArgumentsBase : TransformInputBase\r\n{\r\n     [Argument(ArgumentType.AtMostOnce, HelpText = \"Maximum number of terms to keep per column when auto-training\", ShortName = \"max\", SortOrder = 5)]\r\n      public int MaxNumTerms = ValueToKeyMappingEstimator.Defaults.MaxNumTerms;\r\n\r\n      [Argument(ArgumentType.AtMostOnce, HelpText = \"Comma separated list of terms\", SortOrder = 105, Visibility = ArgumentAttribute.VisibilityType.CmdLineOnly)]\r\n      public string Terms;\r\n\r\n      [Argument(ArgumentType.AtMostOnce, HelpText = \"List of terms\", SortOrder = 106, Visibility = ArgumentAttribute.VisibilityType.EntryPointsOnly)]\r\n      public string[] Term;\r\n```\r\n\r\nI don't think our API users should see the first \r\n\r\n`public string Terms`","Url":"https://github.com/dotnet/machinelearning/issues/2133","RelatedDescription":"Open issue \"Command-line oriented arguments, that have more suitable alternatives for the API should be made internal\" (#2133)"}],"ResultType":"GitHubIssue"}},"RunOn":"2019-01-16T05:30:39.6819388Z","RunDurationInMilliseconds":770}