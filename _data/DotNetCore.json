{"Data":{"Blog":{"FeedItems":[{"Title":".NET Core 2.1 June Update","PublishedOn":"2018-06-22T21:08:25+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"We released .NET Core 2.1.1. This update includes .NET Core SDK 2.1.301, ASP.NET Core 2.1.1 and .NET Core 2.1.1. See .NET Core 2.1.1 release notes for complete details on the release. Quality Updates...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/22/net-core-2-1-june-update/","RawContent":null},{"Title":".NET Core 2.0 will reach End of Life on October 1, 2018","PublishedOn":"2018-06-20T19:12:38+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Last Updated: 6/22/2018 .NET Core 2.0 was released on August 14, 2017. As a non-LTS release, it is supported for 3 months after the next release. .NET Core 2.1 was released on May 30th, 2018. As a...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/20/net-core-2-0-will-reach-end-of-life-on-september-1-2018/","RawContent":null},{"Title":"The RyuJIT transition is complete!","PublishedOn":"2018-06-19T22:53:27+00:00","CommentsCount":26,"FacebookCount":0,"Summary":"RyuJIT is the code name for the .NET just-in-time compiler, one of the foundational components of the .NET runtime. In contrast, the Roslyn C# compiler compiles C# code to IL byte code. The RyuJIT...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/19/the-ryujit-transition-is-complete/","RawContent":null},{"Title":"Staying up-to-date with .NET Container Images","PublishedOn":"2018-06-18T18:59:03+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"This post describes the container images that we produce and update for you, that you can use with Docker, Kubernetes and other systems. When you are using .NET and Docker together, you are probably...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/","RawContent":null},{"Title":"Using .NET and Docker Together – DockerCon 2018 Update","PublishedOn":"2018-06-14T00:15:31+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"I posted about Using .NET and Docker Together last year. With DockerCon 2018 being this week, it seemed like a great time to give you an update.  Since my last post, we&#8217;ve enabled a set of...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/","RawContent":null},{"Title":".NET Framework June 2018 Security and Quality Rollup","PublishedOn":"2018-06-13T19:29:27+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the June 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework May 2018 Security and Quality Rollup for the latest security updates. Quality and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/13/net-framework-june-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Announcing .NET Framework 4.8 Early Access build 3621!","PublishedOn":"2018-06-06T21:19:43+00:00","CommentsCount":38,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.8 Early Access build 3621 for your feedback. This is one of the in-development builds of the next version of the .NET Framework. The changes in this...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/06/announcing-net-framework-4-8-early-access-build-3621/","RawContent":null},{"Title":"Announcing ML.NET 0.2","PublishedOn":"2018-06-06T04:36:25+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"Last month at //Build 2018, we released ML.NET 0.1, a cross-platform, open source machine learning framework. We would like to thank the community for the engagement so far in helping us shape ML.NET....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/06/05/announcing-ml-net-0-2/","RawContent":null},{"Title":"Announcing .NET Core 2.1","PublishedOn":"2018-05-30T17:22:16+00:00","CommentsCount":71,"FacebookCount":0,"Summary":"We&#8217;re excited to announce the release of .NET Core 2.1. It includes improvements to performance, to the runtime and tools. It also includes a new way to deploy tools as NuGet packages....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1","PublishedOn":"2018-05-30T17:22:00+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Today we are excited to announce the release of Entity Framework (EF) Core 2.1. This is the latest production-ready release of our open-source and cross-platform data access technology. We are...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-entity-framework-core-2-1/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7896820874","Type":"IssuesEvent","CreatedAt":"2018-06-29T09:52:53","Actor":"tomkerkhove","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/104","RelatedDescription":"Opened issue \"About still mentions CodePlex\" (#104) at dotnet/home","RelatedBody":"About still mentions CodePlex which is now in archive mode.\r\n\r\n![image](https://user-images.githubusercontent.com/4345663/42086259-e0b7d008-7b92-11e8-96c9-02ee61ddc457.png)\r\n\r\nIs this something that I can PR?"},{"Id":"7724991049","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:33:10","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Merged pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7724874671","Type":"PullRequestEvent","CreatedAt":"2018-05-24T16:12:32","Actor":"danmosemsft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/103","RelatedDescription":"Opened pull request \"Add ML.NET to readme\" (#103) at dotnet/home","RelatedBody":"cc @shauheen @jongalloway "},{"Id":"7697543163","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:28","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Merged pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"7697541521","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:10:06","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Merged pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"7697539314","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:09:35","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/93","RelatedDescription":"Merged pull request \"Add Humanizer\" (#93) at dotnet/home","RelatedBody":"Onboarding Humanizer: https://github.com/Humanizr/Humanizer/issues/682"},{"Id":"7697528376","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:07:09","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Merged pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"},{"Id":"7697526900","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:48","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Merged pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7697525283","Type":"PullRequestEvent","CreatedAt":"2018-05-18T19:06:25","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Merged pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7780591341","Type":"IssuesEvent","CreatedAt":"2018-06-05T20:33:11","Actor":"huanwu","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/72","RelatedDescription":"Opened issue \"Introducing dotnet-svcutil.xmlserializer for .NET Core\" (#72) at dotnet/announcements","RelatedBody":"# Introducing dotnet-svcutil.xmlserializer for .NET Core\r\nOn the full .NET Framework you are able to pre-generate a serialization assembly using the tool svcutil. We are providing similar functionality on .NET Core by releasing the dotnet-svcutil.xmlserializer NuGet package. It pre-generates c# serialization code for the types used by WCF Service Contract in the client applications that can be serialized using the XmlSerializer to improve the startup performance of Xml Serialization when serializing or de-serializing objects of those types using XmlSerializer. \r\nYou can start using the tool today by following the instructions. \r\n## Discussion \r\nPlease share with us any thoughts of questions that you may have at: \r\n\r\n- dotnet/wcf [#2927](https://github.com/dotnet/wcf/issues/2927)\r\n## Details \r\nWhen to use XmlSerializer with WCF in an app to serialize contract data types, it will generate an XmlSerializer during runtime to do the serialization. You can improve the startup performance of Xml serialization by simply adding the reference of dotnet-svcutil.xmlserializer NuGet package to your project. This tool will generate the serialization code and compile it into an assembly next to your output assembly at build time in advance. This assembly can then be deployed and ran with your application. \r\n\r\nPlease create an issue with your feedback at [dotnet/wcf](https://github.com/dotnet/wcf/issues). We are actively looking to improve the tool and your input is a valuable part of the process. "}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7910211328","Type":"PullRequestEvent","CreatedAt":"2018-07-03T04:38:34","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18751","RelatedDescription":"Merged pull request \"Add back most CreateInstance APIs to AppDomain and Activator\" (#18751) at dotnet/coreclr","RelatedBody":"\r\ncoreclr part of https://github.com/dotnet/corefx/issues/30190#issue-330334307\r\ncorefx  part ready to go after merge https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:createinstanceapis?diff=unified&name=createinstanceapis\r\n\r\nCoreclr code was taken from https://referencesource.microsoft.com/#mscorlib/system/activator.cs\r\n\r\n/cc @jkotas @danmosemsft @ericstj\r\n\r\n"},{"Id":"7910205034","Type":"IssuesEvent","CreatedAt":"2018-07-03T04:35:43","Actor":"A-And","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18701","RelatedDescription":"Closed issue \"System.Security.Principal.Tests Failure\" (#18701) at dotnet/coreclr","RelatedBody":"The following error is hit when running System.Security.Principal.Tests - this also crashes the .NET Core Host running the XUnit runner. \r\nThere is a substantial number of tests, which fail with `ObjectDisposedException`\r\n```\r\n\r\nTest:\r\nError:\r\n    System.ObjectDisposedException: Safe handle has been closed\r\n       at System.Runtime.InteropServices.SafeHandle.DangerousAddRef(Boolean& success)\r\n       at System.StubHelpers.StubHelpers.SafeHandleAddRef(SafeHandle pHandle, Boolean& success)\r\n       at Interop.Advapi32.ImpersonateLoggedOnUser(SafeAccessTokenHandle userToken)\r\n       at System.Security.Principal.WindowsIdentity.CurrentImpersonatedTokenChanged(AsyncLocalValueChangedArgs`1 args)\r\n       at System.Threading.AsyncLocal`1.System.Threading.IAsyncLocal.OnValueChanged(Object previousValueObj, Object currentValueObj, Boolean contextChanged)\r\n       at System.Threading.ExecutionContext.OnValuesChanged(ExecutionContext previousExecutionCtx, ExecutionContext nextExecutionCtx)\r\n```\r\n\r\n### To reproduce failing \r\n\r\n1. `build x64 [release/debug] skiptests`\r\n2. `.\\build-test.cmd x64 [release/debug] buildtesthostonly`\r\n3. Navigate to `<repo-root>\\bin\\tests\\<Configuration>\\CoreFX\\tests_downloaded\\System.Security.Principal.Tests`\r\n4. Run `<repo-root>\\bin\\tests\\<Configuration>\\testhost\\dotnet.exe .\\xunit.console.netcore.exe .\\System.Security.Principal.Tests.dll `"},{"Id":"7910204726","Type":"IssuesEvent","CreatedAt":"2018-07-03T04:35:34","Actor":"A-And","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18702","RelatedDescription":"Closed issue \"System.Linq.Expressions.Tests Failures\" (#18702) at dotnet/coreclr","RelatedBody":"Multiple tests in Linq.Expressions.Tests fail. \r\n\r\nWith all of the below, only some elements in the collections don't pass the test.\r\n\r\n```\r\n\r\nGroupJoinTests.GroupJoin_CustomComparator_LeftWithOrderingColisions\r\n\r\nGroupJoinTests.GroupJoin_Multiple_LeftWithOrderingColisions\r\n\r\nGroupJoinTests.GroupJoin_CustomComparator\r\n\r\nGroupJoinTests.GroupJoin_Multiple\r\n\r\nJoinTests.Join_CustomComparator_LeftWithOrderingColisions_UnorderedRight\r\n\r\nJoinTests.Join_CustomComparator\r\n\r\nJoinTests.Join_Multiple_LeftWithOrderingColisions_UnorderedRight\r\n\r\nJoinTests.Join_CustomComparator_LeftWithOrderingColisions\r\n\r\nJoinTests.Join_Multiple_LeftWithOrderingColisions\r\n\r\n```\r\n\r\nThe `LeftWithOrderingCollisions`, `CustomComparator` and `GroupJoin` patterns seem to stand out.\r\n\r\n### To reproduce failing \r\n\r\n1. `build x64 [release/debug] skiptests`\r\n2. `.\\build-test.cmd x64 [release/debug] buildtesthostonly`\r\n3. Navigate to `<repo-root>\\bin\\tests\\<Configuration>\\CoreFX\\tests_downloaded\\System.Linq.Expressions.Tests`\r\n4. Run `<repo-root>\\bin\\tests\\<Configuration>\\testhost\\dotnet.exe .\\xunit.console.netcore.exe .\\System.Linq.Expressions.Tests.dll -method [name of method to debug] `"},{"Id":"7910204375","Type":"IssuesEvent","CreatedAt":"2018-07-03T04:35:24","Actor":"A-And","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18703","RelatedDescription":"Closed issue \"System.Net.Http.Functional.Tests Failures\" (#18703) at dotnet/coreclr","RelatedBody":"Three \"*Uppercased\" tests fail in System.Net.Http.Functional.Tests\r\nTest:\r\n    SocketsHttpHandler_HttpProtocolTests_Dribble.CustomMethod_SentUppercasedIfKnown\r\nError:\r\n    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\\\r\\\\nExpected: GET \\\\r\\\\nActual:   get ..\r\n\r\nTest:\r\n    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown_Additional\r\nError:\r\n    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\\\r\\\\nExpected: DELETE \\\\r\\\\nActual:   delete ...\r\n\r\nTest:\r\n    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown\r\nError:\r\n    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\\\r\\\\nExpected: GET \\\\r\\\\nActual:   get ...\r\n\r\n\r\n### To reproduce failing \r\n\r\n1. `build x64 [release/debug] skiptests`\r\n2. `.\\build-test.cmd x64 [release/debug] buildtesthostonly`\r\n3. Navigate to `<repo-root>\\bin\\tests\\<Configuration>\\CoreFX\\tests_downloaded\\System.Net.Http.Functional.Tests`\r\n4. Run `<repo-root>\\bin\\tests\\<Configuration>\\testhost\\dotnet.exe .\\xunit.console.netcore.exe .\\System.Net.Http.Functional.Tests.dll -method [name of method to debug] `\r\n"},{"Id":"7910203874","Type":"IssuesEvent","CreatedAt":"2018-07-03T04:35:11","Actor":"A-And","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18700","RelatedDescription":"Closed issue \"System.Linq.Expressions.Tests TypeLoadException in System.Private.CoreLib\" (#18700) at dotnet/coreclr","RelatedBody":"A TypeLoadException is hit when running System.Linq.Expressions.\r\n```\r\nTest:\r\n    GetDelegateTypeTests.CantBeFunc\r\nResult:\r\n    System.TypeLoadException System.TypeLoadException : The generic type 'System.Func`1' was used with an invalid instantiation in assembly 'System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e'.\r\n\r\nTest:\r\n    GetDelegateTypeTests.CantBeAction\r\nResult:\r\n    System.TypeLoadException System.TypeLoadException: The generic type 'System.Action`1' was used with an invalid instantiation in assembly 'System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e'\r\n```\r\n\r\n\r\n### To reproduce failing \r\n\r\n1. `build x64 [release/debug] skiptests`\r\n2. `.\\build-test.cmd x64 [release/debug] buildtesthostonly`\r\n3. Navigate to `<repo-root>\\bin\\tests\\<Configuration>\\CoreFX\\tests_downloaded\\System.Linq.Expressions.Tests`\r\n4. Run `<repo-root>\\bin\\tests\\<Configuration>\\testhost\\dotnet.exe .\\xunit.console.netcore.exe .\\System.Linq.Expressions.Tests -method [name of method to debug] `"},{"Id":"7910203504","Type":"IssuesEvent","CreatedAt":"2018-07-03T04:35:01","Actor":"A-And","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/18704","RelatedDescription":"Closed issue \"System.Net.Primitives.Functional.Tests Failures\" (#18704) at dotnet/coreclr","RelatedBody":"The following tests fail in System.Net.Primitives.Functional.Tests with an EntryPointNotFoundException\r\n```\r\n    CookieCollectionTest.Clear_Success\r\n    CookieCollectionTest.Remove_Success\r\n    CookieCollectionTest.Contains_Success\r\n    CookieCollectionTest.Remove_NonExistantCookie_ReturnsFalse\r\n```\r\n\r\n### To reproduce failing \r\n\r\n1. `build x64 [release/debug] skiptests`\r\n2. `.\\build-test.cmd x64 [release/debug] buildtesthostonly`\r\n3. Navigate to `<repo-root>\\bin\\tests\\<Configuration>\\CoreFX\\tests_downloaded\\System.Net.Primitives.Functional.Tests`\r\n4. Run `<repo-root>\\bin\\tests\\<Configuration>\\testhost\\dotnet.exe .\\xunit.console.netcore.exe .\\System.Net.Primitives.Functional.Tests.dll -method [name of method to debug] `\r\n\r\n\r\n"},{"Id":"7910020846","Type":"PullRequestEvent","CreatedAt":"2018-07-03T03:20:40","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18760","RelatedDescription":"Merged pull request \"Update CoreFX CI packages to NetcoreApp3\" (#18760) at dotnet/coreclr","RelatedBody":"Updates restored packages. \r\n@jkotas mentioned some failures we're seeing are due to CoreFX mismatch - setting `TargetFramework`  before specifying dependencies restored `netstandard` versions of libraries. Moving `TargetFramework` up seems to have fixed the issue. "},{"Id":"7909915953","Type":"PullRequestEvent","CreatedAt":"2018-07-03T02:41:09","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18763","RelatedDescription":"Opened pull request \"Use generic win-x86/win-x64 RIDs in stress_dependencies\" (#18763) at dotnet/coreclr","RelatedBody":"Update Windows Stress Dependencies to match https://github.com/dotnet/llilc/pull/1087"},{"Id":"7909807111","Type":"PullRequestEvent","CreatedAt":"2018-07-03T01:59:30","Actor":"tannergooding","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/18519","RelatedDescription":"Merged pull request \"Fold away Sse.StaticCast and Avx.StaticCast in the importer\" (#18519) at dotnet/coreclr","RelatedBody":"FYI. @CarolEidt, @eerhardt, @fiigii \r\n\r\nThis improves the codegen for code using `StaticCast` as the rest of the JIT no longer has to care that it exists at all."}],"ResultType":"GitHubEvent"},"CLI":{"Events":[],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7910306192","Type":"IssuesEvent","CreatedAt":"2018-07-03T05:19:07","Actor":"EEVblog","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/791","RelatedDescription":"Opened issue \"When Building a UWP app with .netstandard 2.0 and Compile With Native Tool Chain, Build Hangs forever\" (#791) at dotnet/standard","RelatedBody":"I have a project that I have released into the windows app store and have an update which included porting from xamarin forms project to a .net standard project.\r\n\r\nAfter porting the project I have found that any time I build the app with the:\r\n\r\n\"Compile with .NET Native tool chain\" checked the build hangs forever. It will hang on any platform when this item is checked.\r\n\r\nI have tried the following flags in an attempt to fix it in my project build settings:\r\n\r\n<ShortcutGenericAnalysis>true</ShortcutGenericAnalysis>\r\n<SingleThreadNUTC>true</SingleThreadNUTC>\r\n<Use64BitCompiler>true</Use64BitCompiler>\r\n\r\nI have tried deleting obj and bin folders, no success.\r\nI have all of the latest VS updates and the latest package updates. "},{"Id":"7909110492","Type":"IssuesEvent","CreatedAt":"2018-07-02T21:47:15","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/787","RelatedDescription":"Closed issue \"nsboard GitHub team is not public\" (#787) at dotnet/standard","RelatedBody":"> There is also a (public) GitHub team [nsboard](https://github.com/orgs/dotnet/teams/nsboard) you can\r\nuse when you want the board to take a look at a particular issue\r\n\r\nActually nsboard team is not public. Following the above link leads to:\r\n\r\n\r\n![nsboard](https://user-images.githubusercontent.com/801959/42095457-f63bf5a6-7bb2-11e8-8e98-dff65911b038.png)\r\n\r\n\r\n\r\n"},{"Id":"7909102076","Type":"IssuesEvent","CreatedAt":"2018-07-02T21:45:00","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/682","RelatedDescription":"Closed issue \".Net Standard 2.1?\" (#682) at dotnet/standard","RelatedBody":"_From @jherby2k on March 7, 2018 19:35_\n\nI can't find any information about a .net standard 2.1.\r\n\r\nI really want to use the new Span-ified methods like Stream.Read in my class libraries, but it looks like that stuff isn't in System.Memory but rather the .net core 2.1 SDK. Any other way to get these APIs, or do I have to wait for .net standard 2.1. And is there any ETA on that?\n\n_Copied from original issue: dotnet/coreclr#16806_"},{"Id":"7908012095","Type":"PullRequestEvent","CreatedAt":"2018-07-02T17:36:49","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/790","RelatedDescription":"Merged pull request \"Finalize board membership\" (#790) at dotnet/standard","RelatedBody":"This fills in the folks from the .NET Foundation\r\n\r\n/cc @dotnet/nsboard "},{"Id":"7907978751","Type":"PullRequestEvent","CreatedAt":"2018-07-02T17:29:29","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/790","RelatedDescription":"Opened pull request \"Finalize board membership\" (#790) at dotnet/standard","RelatedBody":"This fills in the folks from the .NET Foundation\r\n\r\n/cc @dotnet/nsboard "},{"Id":"7907925695","Type":"IssuesEvent","CreatedAt":"2018-07-02T17:17:39","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/789","RelatedDescription":"Opened issue \"Add release notes for the trimming package\" (#789) at dotnet/standard","RelatedBody":"We need to have our own link for release notes for the trimming package.\r\n\r\nIt should be a FWLink that points to a github issue / document of some sort that lists out the details of the release, bugs fixed, etc."},{"Id":"7907912147","Type":"IssuesEvent","CreatedAt":"2018-07-02T17:14:32","Actor":"ericstj","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/788","RelatedDescription":"Opened issue \"Trimming package\" (#788) at dotnet/standard","RelatedBody":"There's really no good reason for this package to live in the standard repo.\r\n\r\nA few suggestions for a new home:\r\n1. CoreFxLab\r\n2. Its own repo under dotnet\r\n3. Its own repo under ericstj, since I'm the sole contributor.  I'd change the name of the package if I did this.\r\n\r\nThe downside of lab is that it implies an experiment and never has \"releases\" however I'd actually like to push towards a stable release of this tool.\r\n\r\n@weshaggard @Petermarcu @terrajobst do any of you have an opinion?"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7910221687","Type":"PullRequestEvent","CreatedAt":"2018-07-03T04:43:15","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/30806","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#30806) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7910219106","Type":"IssuesEvent","CreatedAt":"2018-07-03T04:42:07","Actor":"i8beef","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30805","RelatedDescription":"Closed issue \"Unix HttpClient throwing an exception I can't catch\" (#30805) at dotnet/corefx","RelatedBody":"I'm running an application with the Microsoft 2.1 Docker images. The app is using the Microsoft.Extensions.Hosting generic host stuff to implement a long running poll that calls a POST endpoint via a static HttpClient. Now I have an unfortunate issue where the device I'm calling returns a non-standard result, which on Windows, would give me a \"WinHttpException: The server returned an invalid or unrecognized response”. I have exhausted my options to make it do anything else, the device in question simply does not follow protocol. So my HttpClient.SendAsync() call is wrapped in a specific catch to try and swallow this:\r\n\r\n```\r\n            try\r\n            {\r\n                var response = await SendAsyncWithTimeout(requestMessage, cancellationToken)\r\n                    .ConfigureAwait(false);\r\n            }\r\n            catch (HttpRequestException ex) when (ex.InnerException != null && ex.InnerException.Message == \"The server returned an invalid or unrecognized response\")\r\n            {\r\n                // This will ALWAYS throw an exception because the Apex API doesn't even return a valid HTTP protocol response\r\n                // Thus it is ignored. This is probably one of the more evil things I've ever written...\r\n            }\r\n```\r\n\r\nWhen this app is run on Windows (At least in a debugger), it swallows the error as expected and things work fine.\r\n\r\nBut I found when I run it on a Linux instance, it fails to catch the exception:\r\n\r\n```\r\nUnhandled Exception: System.Net.Http.HttpRequestException: An error occurred while sending the request. ---> System.IO.IOException: The server returned an invalid or unrecognized response.\r\n   at System.Net.Http.HttpConnection.FillAsync()\r\n   at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean foldedHeadersAllowed)\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   --- End of inner exception stack trace ---\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)\r\n... My code here ...\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n\r\n```\r\n\r\nAnyone see anything obvious here I'm missing, or something thats different in the Linux implementation that would cause this?"},{"Id":"7910011163","Type":"IssuesEvent","CreatedAt":"2018-07-03T03:16:48","Actor":"i8beef","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/30805","RelatedDescription":"Opened issue \"Unix HttpClient throwing an exception I can't catch\" (#30805) at dotnet/corefx","RelatedBody":"I'm running an application with the Microsoft 2.1 Docker images. The app is using the Microsoft.Extensions.Hosting generic host stuff to implement a long running poll that calls a POST endpoint via a static HttpClient. Now I have an unfortunate issue where the device I'm calling returns a non-standard result, which on Windows, would give me a \"WinHttpException: The server returned an invalid or unrecognized response”. I have exhausted my options to make it do anything else, the device in question simply does not follow protocol. So my HttpClient.SendAsync() call is wrapped in a specific catch to try and swallow this:\r\n\r\n```\r\n            try\r\n            {\r\n                var response = await SendAsyncWithTimeout(requestMessage, cancellationToken)\r\n                    .ConfigureAwait(false);\r\n            }\r\n            catch (HttpRequestException ex) when (ex.InnerException != null && ex.InnerException.Message == \"The server returned an invalid or unrecognized response\")\r\n            {\r\n                // This will ALWAYS throw an exception because the Apex API doesn't even return a valid HTTP protocol response\r\n                // Thus it is ignored. This is probably one of the more evil things I've ever written...\r\n            }\r\n```\r\n\r\nWhen this app is run on Windows (At least in a debugger), it swallows the error as expected and things work fine.\r\n\r\nBut I found when I run it on a Linux instance, it fails to catch the exception:\r\n\r\n```\r\nUnhandled Exception: System.Net.Http.HttpRequestException: An error occurred while sending the request. ---> System.IO.IOException: The server returned an invalid or unrecognized response.\r\n   at System.Net.Http.HttpConnection.FillAsync()\r\n   at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean foldedHeadersAllowed)\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   --- End of inner exception stack trace ---\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)\r\n... My code here ...\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n\r\n```\r\n\r\nAnyone see anything obvious here I'm missing, or something thats different in the Linux implementation that would cause this?"},{"Id":"7909908535","Type":"PullRequestEvent","CreatedAt":"2018-07-03T02:38:27","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/30800","RelatedDescription":"Merged pull request \"Update CoreClr to preview1-26703-01 (master)\" (#30800) at dotnet/corefx","RelatedBody":""},{"Id":"7909879872","Type":"IssuesEvent","CreatedAt":"2018-07-03T02:28:09","Actor":"karelz","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/30756","RelatedDescription":"Closed issue \"Required libcurl + OpenSSL version for self-contained apps\" (#30756) at dotnet/corefx","RelatedBody":"We have a self-contained .NET Core 2.0 app running on Centos7 (though the RID is `linux-x64` currently).\r\n\r\nWe have some code that will ignore certificates under certain scenarios, which means we need libcurl+openssl. \r\n\r\nI have found a couple of related packages around this, specifically the (RedHat .NET Core 2.0 packages)[https://access.redhat.com/errata/RHEA-2017:2495], but beyond that haven't found any definitive documentation on what version of libcurl+opensll we can/should bring in to support this.\r\n\r\nIs the latest stable version of libcurl+openssl supported, or only specific versions? \r\n\r\n~I think this might be an issue for the docs repo as well, but will wait for reply before raising one, as it is just as likely I've missed something~\r\n\r\nIn the [documentation](https://docs.microsoft.com/en-us/dotnet/core/linux-prerequisites?tabs=netcore2x#linux-distribution-dependencies) versions aren't specified, so would just like some clarity more than anything."},{"Id":"7909864940","Type":"IssuesEvent","CreatedAt":"2018-07-03T02:22:09","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/28614","RelatedDescription":"Closed issue \"AppDomain SetPrincipalPolicy not implemented\" (#28614) at dotnet/corefx","RelatedBody":"corefx/src/System.Runtime.Extensions/src/System/AppDomain.cs\r\n\r\npublic void SetPrincipalPolicy(PrincipalPolicy policy) { }\r\n\r\nThis is clearly unimplemented. Maybe [ObsoleteAttribute] could be added to spare people frustration."}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7910221916","Type":"PullRequestEvent","CreatedAt":"2018-07-03T04:43:21","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6044","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6044) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7910012681","Type":"PullRequestEvent","CreatedAt":"2018-07-03T03:17:25","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6034","RelatedDescription":"Merged pull request \"Fix stack slot kind for ByReference.get_Value in CppCodegen\" (#6034) at dotnet/corert","RelatedBody":"This should be tracked as a ByRef.\r\n\r\nThis was the reason why the compiler was considering `MemoryMarshal.GetNonNullPinnableReference` invalid IL and we were generating a throwing body for it while compiling Hello World."},{"Id":"7910012127","Type":"PullRequestEvent","CreatedAt":"2018-07-03T03:17:11","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6040","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6040) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @brianrob"},{"Id":"7910011546","Type":"PullRequestEvent","CreatedAt":"2018-07-03T03:16:57","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6043","RelatedDescription":"Merged pull request \"Merge changes from TFS\" (#6043) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7909815402","Type":"PullRequestEvent","CreatedAt":"2018-07-03T02:02:36","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6043","RelatedDescription":"Opened pull request \"Merge changes from TFS\" (#6043) at dotnet/corert","RelatedBody":"When merging, this PR, please ensure a merge commit is created as automation requires the merge commit.  Do not 'Squash and merge' or 'Rebase and merge'!"},{"Id":"7909662501","Type":"IssuesEvent","CreatedAt":"2018-07-03T01:00:51","Actor":"mellinoe","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/6042","RelatedDescription":"Opened issue \"Strange null ref in COM call\" (#6042) at dotnet/corert","RelatedBody":"After #5587 was fixed, I'm able to get much further with my project. Most everything works, but there's still some issues calling into SharpDX (or so it seems). I get a crash with this stack:\r\n\r\n```\r\nUnhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.\r\n   at Veldrid.D3D11.D3D11Swapchain..ctor(Device, SwapchainDescription&) + 0x342\r\n   at Veldrid.D3D11.D3D11GraphicsDevice..ctor(GraphicsDeviceOptions, Nullable`1) + 0x1e3\r\n   at Veldrid.GraphicsDevice.CreateD3D11(GraphicsDeviceOptions, IntPtr, UInt32, UInt32) + 0xfb\r\n   at Veldrid.StartupUtilities.VeldridStartup.CreateDefaultD3D11GraphicsDevice(GraphicsDeviceOptions, Sdl2Window) + 0x6e\r\n   at Veldrid.StartupUtilities.VeldridStartup.CreateGraphicsDevice(Sdl2Window, GraphicsDeviceOptions, GraphicsBackend) + 0x86\r\n   at SampleBase.VeldridStartupWindow.Run() + 0x9c\r\n   at Instancing.Program.Main(String[]) + 0x6d\r\n   at Instancing.Desktop!<BaseAddress>+0x4ad77a\r\n   at Instancing.Desktop!<BaseAddress>+0x4ad807\r\n```\r\n\r\nI believe that it's hitting a null ref [on this line](https://github.com/mellinoe/veldrid/blob/master/src/Veldrid/D3D11/D3D11Swapchain.cs#L88). `dxgiDevice` is null when it shouldn't be, and isn't when using CoreCLR. That query function shouldn't return null (it should throw instead), as far as I know.\r\n\r\nThe problem can be reprod by checking out the `corert-crash` branch of https://github.com/mellinoe/veldrid-samples/.\r\n\r\n`dotnet publish -r win-x64 src\\Instancing\\Desktop\\Instancing.Desktop.csproj`"},{"Id":"7909397154","Type":"IssuesEvent","CreatedAt":"2018-07-02T23:16:15","Actor":"christianscheuer","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/6041","RelatedDescription":"Opened issue \"Odd threading behavior - Thread.CurrentThread.ManagedThreadId != Environment.ManagedThreadId\" (#6041) at dotnet/corert","RelatedBody":"I'm getting a `The write lock is being released without being held` exception when exiting write mode on a `ReaderWriterLockSlim` on macOS.\r\n\r\nDebugging this issue has led me to conclude, that apparently my call to`ExitWriteLock` happens on a different thread than where I started, albeit in a weird way.\r\n\r\nWhen I debug it, `Thread.CurrentThread.ManagedThreadId` will indicate I'm still on thread 1 where I acquired the lock, but `Environment.ManagedThreadId` which is what `ReaderWriterLockSlim` uses, indicates I'm on thread 6.\r\nThis does not seem to happen on CoreCLR.\r\n\r\nThe code paths involved do not include any calls to Thread.Start or asynchronous Task code. It really all should be happening on the same thread (which `Thread.CurrentThread.ManagedThreadId` also seems to indicate is true).\r\nThe rest of the app does have asynchronous Task code though.\r\n\r\nUnfortunately, I haven't yet been able to make a repro case. It does seem to make a difference though if GC is invoked between the calls to EnterWriteLock and ExitWriteLock.\r\nAny ideas as how to better debug this?\r\n\r\n\r\nThis is basically what I'm doing, but I don't think this helps much.\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\n\r\nnamespace Test\r\n{\r\n\r\n    public struct WriteLock : IDisposable\r\n    {\r\n        private readonly LockManager lockManager;\r\n\r\n        internal WriteLock(LockManager lockManager)\r\n        {\r\n            this.lockManager = lockManager;\r\n        }\r\n\r\n        public void Dispose()\r\n        {\r\n            this.lockManager.ReleaseWriteLock();\r\n        }\r\n    }\r\n\r\n    public class LockManager : IDisposable\r\n    {\r\n        private ReaderWriterLockSlim readerWriterLock;\r\n\r\n        public LockManager()\r\n        {\r\n            this.readerWriterLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);\r\n        }\r\n\r\n        public IDisposable AcquireWriteLock()\r\n        {\r\n            // Enter the lock\r\n            if (!this.readerWriterLock.TryEnterWriteLock(-1))\r\n            {\r\n                throw new Exception(\"Could not enter write lock\");\r\n            }\r\n            Console.WriteLine(\"Entered write lock: \" + Thread.CurrentThread.ManagedThreadId);\r\n\r\n            // Return a new instance of a write lock\r\n            return new WriteLock(this);\r\n        }\r\n\r\n        public void Dispose()\r\n        {\r\n            this.Dispose(true);\r\n            GC.SuppressFinalize(this);\r\n        }\r\n\r\n        internal void ReleaseReadLock()\r\n        {\r\n            this.readerWriterLock.ExitReadLock();\r\n        }\r\n\r\n        internal void ReleaseWriteLock()\r\n        {\r\n            this.readerWriterLock.ExitWriteLock();\r\n        }\r\n\r\n        protected virtual void Dispose(bool disposing)\r\n        {\r\n            Console.WriteLine(\"Disposing lock manager... disposing: \" + disposing);\r\n            if (disposing)\r\n            {\r\n                if (this.readerWriterLock != null)\r\n                {\r\n                    this.readerWriterLock.Dispose();\r\n                    this.readerWriterLock = null;\r\n                }\r\n            }\r\n        }   \r\n  \r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            using (var lockMan = new LockManager())\r\n            using (var locky = lockMan.AcquireWriteLock())\r\n            {\r\n                //Lots of stuff happening in here. No Task awaits though...\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n"},{"Id":"7909201885","Type":"PullRequestEvent","CreatedAt":"2018-07-02T22:12:04","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6040","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6040) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7908384445","Type":"PullRequestEvent","CreatedAt":"2018-07-02T18:58:27","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/6039","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#6039) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**\n\n cc @tannergooding"},{"Id":"7907852556","Type":"PullRequestEvent","CreatedAt":"2018-07-02T17:01:21","Actor":"dotnet-maestro-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/6039","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#6039) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"1013052742326280192","CreatedAt":"2018-06-30T13:32:50+00:00","UserScreenname":"dotnet","Text":"Tune in for Jeff's Saturday show, learn how to use C# and @ASPNET Core.  Always a good time https://t.co/KJoRPYHnHt","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":31,"FavoriteCount":8,"RawContent":null},{"Id":"1010269960948465665","CreatedAt":"2018-06-22T21:15:03+00:00","UserScreenname":"dotnet","Text":".NET Core 2.0 End of Life Extended to October 1, 2018 https://t.co/KQAlfqjfGv","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":57,"FavoriteCount":53,"RawContent":null},{"Id":"1010268594725269504","CreatedAt":"2018-06-22T21:09:37+00:00","UserScreenname":"dotnet","Text":".NET Core 2.1 June Update https://t.co/GJkOJkg0zJ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":135,"FavoriteCount":85,"RawContent":null}]}},"RunOn":"2018-07-03T05:30:33.4830582Z","RunDurationInMilliseconds":6789}