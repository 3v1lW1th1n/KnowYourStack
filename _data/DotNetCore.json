{"Data":{"Blog":{"FeedItems":[{"Title":"Calling all Desktop Developers: how should UI development be improved?","PublishedOn":"2018-03-23T18:01:31+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"The user interface (UI) of any application is critical in making your app convenient and efficient for the folks using it. When developing applications for Enterprise use, a good UI can shave time off...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/23/calling-all-desktop-developers-how-should-ui-development-be-improved/","RawContent":null},{"Title":".NET Framework 4.7.2 Developer Pack Early Access build 3056 is available!","PublishedOn":"2018-03-08T23:22:13+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are happy to share an Early Access build with the .NET Framework 4.7.2 Developer Pack. The .NET Framework 4.7.2 Developer Pack lets developers build applications that target the .NET...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/08/net-framework-4-7-2-developer-pack-early-access-build-3056-is-available/","RawContent":null},{"Title":"F# language and tools update for Visual Studio 2017 version 15.6","PublishedOn":"2018-03-06T18:28:06+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"With the release of Visual Studio 2017 version 15.6, we’re excited to share updates to the F# language and core library, F# tooling in Visual Studio, and infrastructure updates that concern OSS...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/03/06/f-language-and-tools-update-for-visual-studio-2017-version-15-6/","RawContent":null},{"Title":"Announcing Entity Framework Core 2.1 Preview 1","PublishedOn":"2018-02-27T18:11:29+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"Today we are releasing the first preview of EF Core 2.1, alongside .NET Core 2.1 Preview 1 and ASP.NET Core 2.1 Preview 1. The new bits are available in NuGet as part of the individual packages, and...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/announcing-entity-framework-core-2-1-preview-1/","RawContent":null},{"Title":"Announcing .NET Core 2.1 Preview 1","PublishedOn":"2018-02-27T18:08:23+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Today, we are announcing .NET Core 2.1 Preview 1. It is the first public release of .NET Core 2.1. We have great improvements that we want to share and that we would love to get your feedback on,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/announcing-net-core-2-1-preview-1/","RawContent":null},{"Title":"Calling All Desktop Developers: How do you interact with data?","PublishedOn":"2018-02-27T17:00:36+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Connecting to databases and services is an important part of desktop application development for many of our customers. Visual Studio provides a variety of tools and technologies that can help you...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/27/calling-all-desktop-developers-how-do-you-interact-with-data/","RawContent":null},{"Title":"Azure Blob Storage as a Network Drive","PublishedOn":"2018-02-26T16:00:00+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Many applications make use of a network drive to backup and store files. When I was in university I found myself constantly coding for fun, and one example took the form of a network share for my...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/26/azure-blob-storage-as-a-network-drive/","RawContent":null},{"Title":".NET Framework February 2018 Security and Quality Rollup","PublishedOn":"2018-02-14T04:27:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Today, we are releasing the February 2018 Security and Quality Rollup. Security No new security fixes. See .NET Framework January 2018 Security and Quality Rollup for the latest security updates....","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/13/net-framework-february-2018-security-and-quality-rollup/","RawContent":null},{"Title":"Machine Learning in .NET – Help us build the right experience!","PublishedOn":"2018-02-13T17:17:58+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"In the past few years, Machine Learning (ML) and Artificial Intelligence (AI) have paved the road for building smarter applications through advancements in speech recognition, computer vision,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/13/machine-learning-in-net-help-us-build-the-right-experience/","RawContent":null},{"Title":"Announcing .NET Framework 4.7.2 Early Access build 3052!","PublishedOn":"2018-02-05T21:55:13+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Today, we are happy to share the .NET Framework 4.7.2 Early Access build 3052 for your feedback. .NET Framework 4.7.2 is the next version of the .NET Framework. It is currently feature-complete and in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2018/02/05/announcing-net-framework-4-7-2-early-access-build-3052/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"7452103949","Type":"PullRequestEvent","CreatedAt":"2018-03-29T07:03:03","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/97","RelatedDescription":"Merged pull request \"update CLA PDF link\" (#97) at dotnet/home","RelatedBody":""},{"Id":"7419410563","Type":"IssuesEvent","CreatedAt":"2018-03-22T14:02:36","Actor":"vvavrychuk","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/99","RelatedDescription":"Opened issue \"not working \"Linux Distribution\" dropdown on http://www.microsoft.com/net/learn/get-started/linux \" (#99) at dotnet/home","RelatedBody":"On the page http://www.microsoft.com/net/learn/get-started/linux dropdown \"Linux Distribution\" has no effect on the installation instruction next to him (they are always displayed for RedHat).\r\n\r\n![screenshot from 2018-03-22 16-02-19](https://user-images.githubusercontent.com/152563/37775020-6ec5778e-2dea-11e8-9ea3-b33e26c1c4e1.png)\r\n"},{"Id":"7192252734","Type":"PullRequestEvent","CreatedAt":"2018-02-03T01:30:47","Actor":"karann-msft","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/98","RelatedDescription":"Opened pull request \"Updates to reflect the latest information\" (#98) at dotnet/home","RelatedBody":""},{"Id":"7187459205","Type":"PullRequestEvent","CreatedAt":"2018-02-02T05:26:03","Actor":"mairaw","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/97","RelatedDescription":"Opened pull request \"update CLA PDF link\" (#97) at dotnet/home","RelatedBody":""},{"Id":"7102763357","Type":"PullRequestEvent","CreatedAt":"2018-01-16T00:17:04","Actor":"galatrash-at-dnn","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/96","RelatedDescription":"Opened pull request \"Adding DNN Platform.\" (#96) at dotnet/home","RelatedBody":""},{"Id":"7097053889","Type":"PullRequestEvent","CreatedAt":"2018-01-14T15:15:00","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/95","RelatedDescription":"Opened pull request \"Fix broken logo URL\" (#95) at dotnet/home","RelatedBody":""},{"Id":"7065382954","Type":"PullRequestEvent","CreatedAt":"2018-01-06T19:21:47","Actor":"ctaggart","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/94","RelatedDescription":"Opened pull request \"add SourceLink\" (#94) at dotnet/home","RelatedBody":"Adding SourceLink to the project list as per the checklist https://github.com/ctaggart/SourceLink/issues/138"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"7387413694","Type":"IssuesEvent","CreatedAt":"2018-03-15T21:18:32","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/63","RelatedDescription":"Reopened issue \"Transport Layer Security (TLS) best practices with the .NET Framework article published\" (#63) at dotnet/announcements","RelatedBody":"# Transport Layer Security (TLS) best practices with the .NET Framework article published\r\n\r\nA new article was published that discusses the Transport Layer Security (TLS) best practices at https://docs.microsoft.com/dotnet/framework/network-programming/tls.\r\n\r\nTo ensure .NET Framework applications remain secure, the TLS version should **not** be hardcoded. .NET Framework applications should use the TLS version the operating system (OS) supports.\r\n\r\nThe (TLS) best practices article targets developers who are:\r\n* Directly using the System.Net APIs (for example, `System.Net.Http.HttpClient` and `System.Net.Security.SslStream`).\r\n* Directly using WCF clients and services using the `System.ServiceModel` namespace.\r\n* Using [Azure Cloud Services](https://azure.microsoft.com/services/cloud-services/) Web and Worker roles to host and run your application. See the [Azure Cloud Services](https://docs.microsoft.com/dotnet/framework/network-programming/tls#azure-cloud-services) section.\r\n\r\nThe article explains how to enable the strongest security available for the version of the .NET Framework that your app targets and runs on.\r\n\r\nThe section [Audit your code and make code changes](https://docs.microsoft.com/dotnet/framework/network-programming/tls#audit-your-code-and-make-code-changes) covers auditing and updating your code.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\ndotnet/docs#4675"},{"Id":"7387391842","Type":"IssuesEvent","CreatedAt":"2018-03-15T21:13:45","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/63","RelatedDescription":"Closed issue \"Transport Layer Security (TLS) best practices with the .NET Framework article published\" (#63) at dotnet/announcements","RelatedBody":"# Transport Layer Security (TLS) best practices with the .NET Framework article published\r\n\r\nA new article was published that discussed the Transport Layer Security (TLS) best practices at https://docs.microsoft.com/dotnet/framework/network-programming/tls.\r\n\r\nTo ensure .NET Framework applications remain secure, the TLS version should **not** be hardcoded. .NET Framework applications should use the TLS version the operating system (OS) supports.\r\n\r\nThe (TLS) best practices article targets developers who are:\r\n* Directly using the System.Net APIs (for example, `System.Net.Http.HttpClient` and `System.Net.Security.SslStream`).\r\n* Directly using WCF clients and services using the `System.ServiceModel` namespace.\r\n* Using [Azure Cloud Services](https://azure.microsoft.com/services/cloud-services/) Web and Worker roles to host and run your application. See the [Azure Cloud Services](https://docs.microsoft.com/dotnet/framework/network-programming/tls#azure-cloud-services) section.\r\n\r\nThe article explains how to enable the strongest security available for the version of the .NET Framework that your app targets and runs on.\r\n\r\nThe section [Audit your code and make code changes](https://docs.microsoft.com/dotnet/framework/network-programming/tls#audit-your-code-and-make-code-changes) covers auditing and updating your code.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\ndotnet/docs#4675"},{"Id":"7373349220","Type":"IssuesEvent","CreatedAt":"2018-03-13T17:01:53","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/62","RelatedDescription":"Opened issue \"Microsoft Security Advisory CVE-2018-0875: Hash Collison can cause Denial of Service\" (#62) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2018-0875: Hash Collison can cause Denial of Service\r\n## Executive Summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 2.0 (including other minor and patch releases).\r\nThis advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public versions of .NET Core where a malicious file or web request could cause a denial of service (DoS) attack.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.10, 1.1.7 or 2.0.6. Developers are advised to update their .NET Core SDK to versions 1.1.8 or 2.1.101.\r\n\r\n## Discussion\r\n\r\nUse *TBD* for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\nNone\r\n\r\n### Affected Software\r\n\r\nAny application running against .NET Core 1.0.9 or lower versions, 1.1.6 or lower minor versions or 2.0.5 or lower minor versions is affected. \r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\nAny application running against .NET Core 1.0.9 or lower versions, 1.1.6 or lower minor versions or 2.0.5 or lower minor versions is affected. \r\n\r\nA complete list of runtimes can be discovered by performing a directory listing in the install root directories. The default root directories are listed in the following table:\r\n\r\n| Operating System | Location |\r\n|------------------|----------|\r\n| Windows\t| `C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\` |\r\n| macOS\t| `/usr/local/share/dotnet/shared/Microsoft.NETCore.App/` |\r\n| Supported Linux platforms\t| `/usr/share/dotnet/shared/Microsoft.NETCore.App/` |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you don't have a directory for 1.0.10, 1.1.7 and 2.0.6, then any applications targeting the respective major/minor versions, 1.0 or 1.1 or 2.0 of .NET Core are vulnerable.\r\n\r\nAdditionally, if you've deployed self-contained applications targeting any of the impacted versions, these applications are also vulnerable and must be recompiled and redeployed.\r\n\r\n#### How do I fix my affected application?\r\n\r\nApplications can be fixed by installing the latest .NET Core runtimes or SDKs. Typically, application servers only have runtime packages installed and developer machines have the SDKs installed. \r\nInstallers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). \r\n.NET Core 1.1.8 SDK installs both versions 1.0.10 and 1.1.7 of the .NET Core runtime.\r\n\r\nIf you've built a self-contained application, you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n#### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the `application.runtime.config` file for that application. Set the framework version to the desired version and the `rollForward` property to false. These settings should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nSince the `application.runtime.config` file is an optional file, you may need to create one for each application and add it alongside the executable.\r\n\r\n### Acknowledgments\r\n[Ben Adams](https://twitter.com/ben_a_adams) of [Illyriad Games](https://www.illyriad.co.uk/)\r\n\r\n### External Links\r\n[CVE-2018-0875](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0875)\r\n\r\n### Revisions\r\n\r\nV1.0 (Mar 13, 2018): Advisory published.\r\n\r\n_Version 1.0_\r\n_Last Updated 2018-03-13_\r\n"},{"Id":"7301596554","Type":"IssuesEvent","CreatedAt":"2018-02-27T06:10:33","Actor":"mairaw","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/61","RelatedDescription":"Opened issue \"New offline books released for Visual Studio 2017\" (#61) at dotnet/announcements","RelatedBody":"# New offline books released for Visual Studio 2017\r\n\r\nEarlier this month, we released an update to Offline Books for the Visual Studio 2017 Help Viewer.\r\n\r\nThis release includes new .NET books, including .NET Core Guide, .NET Guide, .NET Framework Guide and the .NET API Reference. It also includes the latest content for Visual Studio 2017 version 15.5, the latest updates to Visual Basic, C# (7.1 and 7.2), F#, ASP.NET Core, NuGet, SQL Server, and the Universal Windows Platform.\r\n\r\nThe .NET Guide, .NET Framework Guide and .NET API Reference books together are a replacement for the .NET Framework 4.6 and 4.5 book, which can be removed. Just be aware that the new .NET API Reference book currently displays the API syntax block for C# only, but examples are shown in other languages, just like the experience you currently have on docs.microsoft.com.If you need to see the API syntax for Visual Basic, C++/CLI or F#, then you should keep the old book until the new reference book is updated again in a few weeks. Once you remove the .NET Framework 4.6 and 4.5 book, you cannot reinstall it.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts and have any discussions with us at:\r\n\r\n- https://github.com/dotnet/docs/issues/4502\r\n\r\n## Add new content\r\n\r\nYou will see these new books when you have Help Viewer installed and choose **Help** > **Add and Remove Content** from the Visual Studio 2017 main menu. If you don't see this menu item, then [open the Visual Studio Installer](https://docs.microsoft.com/visualstudio/install/modify-visual-studio), click the **More** dropdown and choose **Modify**. When the component list appears, choose **Individual Components** at the top, then check **Help Viewer**.\r\n\r\n![help_viewer_component](https://user-images.githubusercontent.com/12971179/36713111-c9d49a7c-1b40-11e8-918a-e7e3619669a2.png)\r\n\r\n## Help Viewer Installation\r\n\r\nTo start the installation, select the **Modify** button in the lower right corner of the Installer window.\r\n\r\nTo update individual books whose status is \"Updates available\", remove the book and then click **Add** to get the new version. To update all your books at once, select the link in the lower right corner of the **Add and Remove Content** window:\r\n\r\n![offline-books](https://user-images.githubusercontent.com/12971179/36713028-75b944f6-1b40-11e8-91c4-4830355f815e.png)"},{"Id":"7300537622","Type":"IssuesEvent","CreatedAt":"2018-02-27T00:12:10","Actor":"eerhardt","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/60","RelatedDescription":"Opened issue \"System.Runtime.Intrinsics in .NET Core 2.1\" (#60) at dotnet/announcements","RelatedBody":"# System.Runtime.Intrinsics in .NET Core 2.1\r\n\r\n.NET Core 2.1 has been adding platform intrinsic APIs to support directly calling processor specific instructions, such as Intel’s x86 SIMD instructions.  See the [initial platform intrinsics design](https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md) for more information.\r\n\r\nWe have decided that it makes the most sense for this intrinsics feature to ship in a “preview” status in the .NET Core 2.1 RTM timeframe.  This means that the runtime support we are implementing will be included, but the assembly exposing the intrinsics will only be available to projects via explicit reference to a “preview-only” package.  These APIs won’t be included in the official .NET Core 2.1 packages.\r\n\r\nGiven our limited time and resources, recent changes in the approach we take to expose the intrinsics, and API changes prompted by design feedback from the community, we don’t believe there is enough time to settle these APIs for 2.1. We plan to follow the pattern of other recent features like Span<T> and Memory<T> that first shipped in preview before formally joining the supported API surface.  Not only would we expect the next version of .NET Core to support more intrinsics than could be supported in 2.1, but we expect to have real usage examples in CoreFX and higher level components as well.  These real world examples, as well as feedback from customers who opt in to the preview, should give us the confidence we need to officially support the APIs going forward.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\nhttps://github.com/dotnet/corefx/issues/27486\r\n\r\n## Details\r\n\r\nIn the coming days, we plan on removing System.Runtime.Intrinsics.dll from the Microsoft.NETCore.App package.  This means any libraries/applications that are using these APIs will no longer compile by default, and will not run on new builds of .NET Core 2.1.\r\n\r\nAt the same time, we will start producing a new System.Runtime.Intrinsics.Experimental NuGet package.  In order to continue using these APIs on .NET Core 2.1, a project will need to add a reference to this new package.\r\n\r\nAs its name implies, this package is experimental and should only be used for preview purposes.  It isn’t expected to be used in production scenarios.  Future version of .NET Core (after 2.1) will be allowed to break this package. This enables us respond to future feedback that requires the APIs to be modified.\r\n\r\nIn the future, when we are confident we have the intrinsic APIs right, we will stop producing the System.Runtime.Intrinsics.Experimental package. The platform intrinsics APIs will then be added back to Microsoft.NETCore.App and will be officially supported."},{"Id":"7273056222","Type":"IssuesEvent","CreatedAt":"2018-02-21T02:28:03","Actor":"KathleenDollard","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/57","RelatedDescription":"Opened issue \"Manually Uninstall .NET Core SDK 2.2.0-Preview Nightly Builds\" (#57) at dotnet/announcements","RelatedBody":"# Manually Uninstall .NET Core SDK 2.2.0-Preview Nightly Builds\r\n\r\n[A change in the version number strategy for .NET Core SDK](https://github.com/dotnet/designs/pull/29) resulted in some nightly builds having a higher version number. This higher version number will block the installation of the correct .NET Core SDK.\r\n\r\nIf you have installed nightly builds of the .NET Core SDK that start with version number that begin with `2.2.0-preview1`, you must manually uninstall these preview builds before later versions of the SDK with version numbers like 2.1.xxx will be available. This may have occurred by installing nightly builds of the .NET Core SDK or nightly builds of Visual Studio 15.5 Preview. \r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n[dotnet/cli #8652](https://github.com/dotnet/cli/issues/8652)\r\n\r\n## Details\r\n\r\n[We changed the version number strategy for .NET Core SDK](https://github.com/dotnet/designs/pull/29) as development was ongoing. Because of this, version numbers on the old scheme appeared in nightly builds. Unfortunately, these numbers are higher than the version numbers in the new scheme. All of the newer SDKs for .NET Core 2.1 will be ignored due to this higher version number; this includes newer nightly builds, public previews and eventual releases.\r\n\r\nThese older version numbers are similar to the following, with the last several different values in the last six digits:\r\n\r\n```\r\n2.2.0-preview1-008000\r\n```\r\n\r\nSince the newer versions are in the form:\r\n\r\n```\r\n2.1.300-preview1-008000\r\n```\r\n\r\n## Call to Action\r\n\r\nIf you have installed nightly builds. Please uninstall any .NET SDK versions that start with 2.2.0-preview1."}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7461569256","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:52:30","Actor":"davmason","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17369","RelatedDescription":"Opened pull request \"Fix for #17356\" (#17369) at dotnet/coreclr","RelatedBody":"Previously we always returned false in local GC for HasCriticalFinalizer. "},{"Id":"7461564841","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:48:03","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17368","RelatedDescription":"Opened pull request \"Make AsSpan(this string) ForceInline to be on par with AsSpan(this T[])\" (#17368) at dotnet/coreclr","RelatedBody":""},{"Id":"7461562658","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:45:49","Actor":"BruceForstall","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17319","RelatedDescription":"Merged pull request \"Mark GCCollect test as GC stress excluded\" (#17319) at dotnet/coreclr","RelatedBody":"This test is incompatible with GC stress. The tests compares results of\r\nGC.GetTotalMemory before and after GC.Collect and fails if the size\r\nbefore the collection is smaller than after the collection. But GC\r\nstress breaks this assumption."},{"Id":"7461541097","Type":"IssuesEvent","CreatedAt":"2018-03-31T04:24:56","Actor":"ahsonkhan","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17296","RelatedDescription":"Reopened issue \"Consider adding reflection support for Span<T>\" (#17296) at dotnet/coreclr","RelatedBody":"From https://github.com/dotnet/coreclr/issues/5851#issuecomment-337356969\r\n\r\n> It is about calling methods on Span or that take Span arguments via reflection:\r\n- [x] It is not possible to do it via existing reflection methods. We should have test to verify that e.g. `typeof(SpanExtensions).GetMethod(\"AsReadOnlySpan\", new Type[] { typeof(string) }).Invoke(null, new object[] { \"Hello\" });` fails gracefully.\r\n- [ ] We may want to look into adding new reflection APIs that allow calling these methods via reflection.\r\n\r\ncc @jkotas, @AtsushiKan, @RussKeldorph "},{"Id":"7461541014","Type":"IssuesEvent","CreatedAt":"2018-03-31T04:24:50","Actor":"ahsonkhan","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/17296","RelatedDescription":"Closed issue \"Consider adding reflection support for Span<T>\" (#17296) at dotnet/coreclr","RelatedBody":"From https://github.com/dotnet/coreclr/issues/5851#issuecomment-337356969\r\n\r\n> It is about calling methods on Span or that take Span arguments via reflection:\r\n- [x] It is not possible to do it via existing reflection methods. We should have test to verify that e.g. `typeof(SpanExtensions).GetMethod(\"AsReadOnlySpan\", new Type[] { typeof(string) }).Invoke(null, new object[] { \"Hello\" });` fails gracefully.\r\n- [ ] We may want to look into adding new reflection APIs that allow calling these methods via reflection.\r\n\r\ncc @jkotas, @AtsushiKan, @RussKeldorph "},{"Id":"7461540987","Type":"IssuesEvent","CreatedAt":"2018-03-31T04:24:49","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/16827","RelatedDescription":"Closed issue \"Stack probing in managed code for frames > 64kB doesn't work on Linux kernel >= 4.9.34\" (#16827) at dotnet/coreclr","RelatedBody":"I have spend some time during the last week tracing down an issue reported by @pavlexander  (#16462) that he had when running his .NET app on Debian 9.3.\r\nIt manifested itself as a sigsegv when running a static constructor. And it was also intermittent, happening on some runs and not happening on others. And also not happening when running under a debugger. Until @pavlexander found that it is due to the fact that debuggers disable ASLR by default. After enabling it, it started to repro under the debugger too. But only on Debian 9.3, not e.g. on Ubuntu 14.04 or 16.04 etc.\r\n\r\nThis static constructor has enormous frame size, almost 128kB. So depending on where the ASLR set the initial RSP for the process, the used stack size either crossed the initial stack size of 128kB or not. And if it did, it has crashed during the stack probing. That was pretty strange since this was running on the primary thread and the maximum stack size was 8MB. So the kernel did not convert the fault to stack expansion on the affected system.\r\n\r\nI’ve written a little testing app in C that basically does the same thing as the probing generated by the JIT. And on all my systems other than the Debian 9.3 (I even had Debian 9.0 and it was ok), it was working fine. On the Debian 9.3, it was crashing with sigsegv.\r\n\r\nTo make the story shorter, I’ve found that it is a kernel version dependent thing. By bisection and building and testing various kernel versions, I’ve found that it started to happen on kernel 4.9.34. Further bisection identified the linux kernel commit that changed that (https://github.com/torvalds/linux/commit/cfc0eb403816c5c4f9667d959de5e22789b5421e). It was a fix to a potential issue fixed by a rewrite of the guard page handling stuff. I spent some time reading and debugging the related portions of the kernel source and it turns out that basically, we were just lucky it has worked before this change. There is this comment close to the stack expansion invocation:\r\n> Accessing the stack below %sp is always a bug. The large cushion allows instructions like enter and pusha to work. (\"enter $65535, $31\" pushes 32 pointers and then decrements %sp by 65535.)\r\n\r\nThere is a check that tests if the fault address is farther than (65536 + 32 * 8) bytes from the stack pointer and if it is, it refuses to expand the stack. But before this check, there is another check testing if the fault address is inside of a range stored in a virtual memory descriptor for the stack. And that’s where the new and old kernels differ. The new kernel includes only the committed portion of the stack virtual memory range while the old one was including the guard page in that range too. \r\nThat means that on the old kernel, our probing has hit the guard page and since it was inside of the range described by the virtual memory descriptor for the stack, the test for the distance between SP and the failure address was skipped, the new page committed and the range expanded by another guard page. \r\nOn the new kernel, we hit the guard page, it is not part of the range for the stack anymore, so it checks the distance between the failure address and the RSP, finds that it is too large and so it passes sigsegv to our process.\r\n\r\nI’ve tested even the latest Linux kernel 4.15 and this new behavior persists.\r\n\r\nThat means that in order to make stack probing work correctly on the new kernels too, we will need to modify the probing so that it moves the RSP as it probes (or at least once every 64kB). Btw, it looks like this check of the address to SP distance is there only for x86 / x64 and not for ARM / ARM64.\r\n\r\n"},{"Id":"7461516374","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:01:27","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17274","RelatedDescription":null,"RelatedBody":""},{"Id":"7461516295","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:01:22","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17274","RelatedDescription":"Closed pull request \"[NO MERGE] Dummy change for dotnet:dev/unix_test_workflow\" (#17274) at dotnet/coreclr","RelatedBody":""},{"Id":"7461495725","Type":"PullRequestEvent","CreatedAt":"2018-03-31T03:43:29","Actor":"echesakovMSFT","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17360","RelatedDescription":"Merged pull request \"Fix#16827 Stack probing for Linux\" (#17360) at dotnet/coreclr","RelatedBody":"This PR enables #14481 under `#ifdef _TARGET_UNIX_`, so\r\n1. changing `RSP`  during stack probing does not impact stack walking under Windows since `CodeGen::genAllocLclFrame` will continue to use \"old\" approach for stack probing;\r\n2. enables allocating very large frames (more than two page sizes) under Linux \r\n\r\n**Related issues:** #13740 #16827 #17112"},{"Id":"7461494633","Type":"PullRequestEvent","CreatedAt":"2018-03-31T03:42:28","Actor":"ahsonkhan","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/17346","RelatedDescription":"Merged pull request \"Update BuildTools, CoreClr, CoreFx to preview3-02631-01, preview3-26331-01, preview3-26331-02, respectively (master)\" (#17346) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"7461454730","Type":"IssuesEvent","CreatedAt":"2018-03-31T03:07:59","Actor":"RussKeldorph","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/13651","RelatedDescription":"Closed issue \"[Linux/ARM32] Instruction cache flush on arm32 linux\" (#13651) at dotnet/coreclr","RelatedBody":"A crash occurred when using AOT images. It was generated with `/FragileNonVersionable` option, but it looks not the point here. When analyzing the problem, the crash was occurred by SIGSEG while accessing the memory address because the value of `*.ni.dll` partly differs from the value loaded in memory. The code at a different point was associated with an target address of `movt`, `movw` instruction.\r\n\r\nOn a kernel dump, SIGSEGV occurs when trying to access a strange memory address (0x100174d4).\r\n```\r\n[2-117.0372] 5860: fc52f7fe 63b8f243 3377f6ca 6819681b\r\n \u2028                  9a019803 f7fe6803 bf00fc4d 93042301\r\n[2-117.0372] 5880: e7ffbf00 b0069804 8c10e8bd 4c1ce92d\r\n\u2028                   0b10f10d f2439001 f6ca5338 681b[3377] <-- crashed here, 0x3377\r\n\u2028[2-117.0372] 58a0: 2b00681b f7fed001 9801fcb3 fc38f7fe\u2028\r\n                   bf00bf00 8c1ce8bd 4c10e92d f10db086\u2028\r\n[2-117.0372] 58c0: 23000b20 93019302 91049005 f2439203\r\n\u2028                   f6ca5338 681b3377 2b00681b f7fed001\r\n```\r\nContents of the XXX.ni.dll file is\r\n```\r\n0003850: c1f2 0102 0198 0021 43f2 bd63 c1f2 0103  .......!C..c....\u2028\r\n0003860: fef7 52fc 41f2 b863 c1f2 0103 1b68 1968  ..R.A..c.....h.h\u2028\r\n0003870: 0398 019a 0368 fef7 4dfc 00bf 0123 0493  .....h..M....#..\r\n\u20280003880: 00bf ffe7 0498 06b0 bde8 108c 2de9 1c4c  ............-..L\u2028\r\n0003890: 0df1 100b 0190 41f2 3853 c1f2 [0103] 1b68  ......A.8S.....h <-- The file contains a value of 0x0301 instead of 0x3377\r\n00038a0: 1b68 002b 01d0 fef7 b3fc 0198 fef7 38fc  .h.+..........8.\r\n\u202800038b0: 00bf 00bf bde8 1c8c 2de9 104c 86b0 0df1  ........-..L....\u2028\r\n00038c0: 200b 0023 0293 0193 0590 0491 0392 41f2   ..#..........A.\r\n\r\n```\r\nBased on the values ​​in the memory, the area is composed of the following code, and the problematic part is the `ldr r3, [r3, # 0]` part.\r\n\r\n```gdb\r\n(gdb) p/x &code\u2028$2 = 0x1102c\r\n(gdb) p/x 0xad06-0xace0\u2028$3 = 0x26\r\n\u2028(gdb) p/x 0x1102c+0x26\u2028$4 = 0x11052 \u2028\r\n(gdb) x/17i 0x1102c+1\u2028\r\n   0x1102d <code+1>:    ldr     r0, [sp, #44]   ; 0x2c\r\n\u2028   0x1102f <code+3>:    ldr     r1, [sp, #20]\r\n\u2028   0x11031 <code+5>:    ldr     r2, [sp, #24]\u2028\r\n   0x11033 <code+7>:    ldr     r3, [r0, #0]\u2028\r\n   0x11035 <code+9>:    bl      0xf470\u2028\r\n   0x11039 <code+13>:   nop\r\n\u2028   0x1103b <code+15>:   movw    r3, #30480      ; 0x7710\r\n\u2028   0x1103f <code+19>:   movt    r3, #43969      ; 0xabc1\r\n\u2028   0x11043 <code+23>:   ldr     r0, [r3, #0]\r\n\u2028   0x11045 <code+25>:   bl      0xf6f4\r\n\u2028   0x11049 <code+29>:   str     r0, [sp, #16]\u2028\r\n   0x1104b <code+31>:   movw    r3, #29908      ; 0x74d4\r\n\u2028   0x1104f <code+35>:   movt    r3, #43969      ; 0xabc1\u2028\r\n   0x11053 <code+39>:   ldr     r0, [r3, #0] <-- SIGSEGV HERE\r\n\u2028   0x11055 <code+41>:   movw    r3, #30448      ; 0x76f0\u2028\r\n   0x11059 <code+45>:   movt    r3, #43969      ; 0xabc1\u2028\r\n   0x1105d <code+49>:   ldr     r1, [r3, #0]\r\n```\r\nThe strange thing is that the memory address that should be accessed in this area is `0xabc174d4` instead of `0x100174d4`.\r\n\r\nIt seemed to be related to relocation.\r\n\r\nWe looked at the code and we could find the relevant code in `PEImageLayout::ApplyBaseRelocations()`.\r\nIn response to the story that there was an issue of the instruction cache flush associated with the other JIT VM, we tried to force the cache flush as follows, and the symptom of the problem was eliminated.\r\n\r\n```diff\r\ndiff --git a/src/vm/peimagelayout.cpp b/src/vm/peimagelayout.cpp\r\nindex 93ab77c..ca4b487 100644\r\n--- a/src/vm/peimagelayout.cpp\r\n+++ b/src/vm/peimagelayout.cpp\r\n@@ -227,6 +227,8 @@ void PEImageLayout::ApplyBaseRelocations()\r\n #ifdef _TARGET_ARM_\r\n             case IMAGE_REL_BASED_THUMB_MOV32:\r\n                 PutThumb2Mov32((UINT16 *)address, GetThumb2Mov32((UINT16 *)address) + delta);\r\n+\r\n+                ClrFlushInstructionCache(address, 8);\r\n                 break;\r\n #endif\r\n```\r\n\r\nBasically, I think that cache flush through `mprotect()` is already well done in CoreCLR.\r\nHowever, when I searched the Internet, I can found the following.\r\n\r\n> You would expect that the mmap / mprotect syscalls would establish mappings that are immediately updated, I see that the kernel does indeed flush caches on mprotect. In that case, no cache flush would be required.\r\n> However, I also see that some versions of libc do call cacheflush after mprotect, which would imply that some environments would need the caches flushed (or have previously). I'd take a guess that this is a workaround to a bug.\r\n\r\nHttps://stackoverflow.com/questions/2777725/does-mprotect-flush-the-instruction-cache-on-arm-linux\r\n\r\nI looked at the `glibc` source code and found the following information:\r\n- [Here](https://github.com/bminor/glibc/blob/master/sysdeps/unix/sysv/linux/arm/dl-machine.h#L22\u2028) defines CLEAR_CACHE.\u2028 \r\n- [This](https://github.com/bminor/glibc/blob/master/elf/dl-reloc.c#L298\u2028) is the only place where CLEAR_CACHE is used while relocating object. \u2028\r\n- [Here](https://github.com/bminor/glibc/blob/master/sysdeps/arm/dl-machine.h#L30\u2028) warnings that there the CLEAR_CACHE should be present to support text relocation.\u2028\r\n\r\nIt seems that `mprotect()` alone is not enough to support dynamic relocation of code `Linux/ARM`. \u2028Perhaps, the comment /* This definition is Linux-specific. */ in dl-machine.h explains why there was no problem in other platform before.\r\n\r\nI have some questions at this point.\r\n- Is this the right solution? Is it a best way to solve this problem? \r\n- Doesn't it has any impact on performance?\r\n- If this is a really problem, why has not this been fixed in the linux kernel before?\r\n- Is anyone encountered this problem on `Windows/ARM`?\r\n\r\nI want anyone to comment.\r\n"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7461503688","Type":"PullRequestEvent","CreatedAt":"2018-03-31T03:50:30","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8945","RelatedDescription":"Merged pull request \"Updating the runtime to 2.0.7 and the CLI branding to 2.1.105.\" (#8945) at dotnet/cli","RelatedBody":"Marked WIP because we can't merge this until the NuGet fix is in and that build is cut."},{"Id":"7461289600","Type":"IssuesEvent","CreatedAt":"2018-03-31T00:59:23","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8959","RelatedDescription":"Opened issue \"Flaky Test: Microsoft.DotNet.Migration.Tests.GivenThatIWantToMigrateSolutions.ItMigratesAndBuildsSln\" (#8959) at dotnet/cli","RelatedBody":"This test fails in CI with the stack below:\r\n\r\nLatest failure: https://ci.dot.net/job/dotnet_cli/job/master/job/release_windows_nt_x64_prtest/2583/\r\n\r\n```\r\ntacktrace\r\n\r\n                                        MESSAGE:\r\n                                        Expected command to pass but it did not.\r\nFile Name: D:\\j\\workspace\\release_windo---f861f43b\\bin\\2\\win-x64\\dotnet\\dotnet.exe\r\nArguments: build \"TestApp\\TestApp.sln\"\r\nWorkingDir:: D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\r\nExit Code: 1\r\nStdOut:\r\nMicrosoft (R) Build Engine version 15.7.124.19828 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restore completed in 102.36 ms for D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestLibrary\\TestLibrary.csproj.\r\n  Restore completed in 73.53 ms for D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\src\\subdir\\subdir.csproj.\r\n  Restore completed in 93.46 ms for D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj.\r\n  You are working with a preview version of the .NET Core SDK. You can define the SDK version via a global.json file in the current project. More at https://go.microsoft.com/fwlink/?linkid=869452\r\n  You are working with a preview version of the .NET Core SDK. You can define the SDK version via a global.json file in the current project. More at https://go.microsoft.com/fwlink/?linkid=869452\r\n  You are working with a preview version of the .NET Core SDK. You can define the SDK version via a global.json file in the current project. More at https://go.microsoft.com/fwlink/?linkid=869452\r\n  subdir -> D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\src\\subdir\\bin\\Release\\netstandard1.5\\subdir.dll\r\n  TestLibrary -> D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestLibrary\\bin\\Release\\netstandard1.5\\TestLibrary.dll\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(10,12): error CS0579: Duplicate 'System.Reflection.AssemblyCompanyAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(11,12): error CS0579: Duplicate 'System.Reflection.AssemblyConfigurationAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(12,12): error CS0579: Duplicate 'System.Reflection.AssemblyFileVersionAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(13,12): error CS0579: Duplicate 'System.Reflection.AssemblyInformationalVersionAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(14,12): error CS0579: Duplicate 'System.Reflection.AssemblyProductAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(15,12): error CS0579: Duplicate 'System.Reflection.AssemblyTitleAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(16,12): error CS0579: Duplicate 'System.Reflection.AssemblyVersionAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\n\r\nBuild FAILED.\r\n\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(10,12): error CS0579: Duplicate 'System.Reflection.AssemblyCompanyAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(11,12): error CS0579: Duplicate 'System.Reflection.AssemblyConfigurationAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(12,12): error CS0579: Duplicate 'System.Reflection.AssemblyFileVersionAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(13,12): error CS0579: Duplicate 'System.Reflection.AssemblyInformationalVersionAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(14,12): error CS0579: Duplicate 'System.Reflection.AssemblyProductAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(15,12): error CS0579: Duplicate 'System.Reflection.AssemblyTitleAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\nobj\\Release\\netcoreapp1.1\\TestApp.AssemblyInfo.cs(16,12): error CS0579: Duplicate 'System.Reflection.AssemblyVersionAttribute' attribute [D:\\j\\workspace\\release_windo---f861f43b\\bin\\3\\win-x64\\test\\dotnet-migrate.Tests\\ItMigratesAndBuildsSln\\PJAppWithSlnAndXprojRefs\\TestApp\\TestApp.csproj]\r\n    0 Warning(s)\r\n    7 Error(s)\r\n```\r\n\r\n\r\n\r\n\r\n"},{"Id":"7461278757","Type":"IssuesEvent","CreatedAt":"2018-03-31T00:51:46","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/7550","RelatedDescription":"Closed issue \"openSUSE Leap 42.1 has end-of-life'd - no builds available for 42.2/42.3\" (#7550) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\nGo to https://www.microsoft.com/net/download/linux\r\n\r\n## Expected  behaviour\r\n\r\nBuilds available for openSUSE Leap 42.2 (released November 2016) and 42.3 (released July 2017).\r\n\r\n## Actual behaviour\r\n\r\nA build is only available for 42.1, which hit [end-of-life in May 2017](https://lists.opensuse.org/opensuse-announce/2017-05/msg00002.html).\r\n\r\n## Background\r\n\r\nAs 42.1 has hit end-of-life, it's [package repo](http://download.opensuse.org/distribution/leap/) is no longer available, meaning its very difficult to build an openSUSE image to test our net core code against.\r\n\r\nNote, this was raised in https://github.com/dotnet/cli/issues/5834, but closed with an incorrect answer (it referred to 42.1, which had already been superseded).\r\n\r\nInterestingly, on https://www.microsoft.com/net/core#linuxopensuse, it refers to 42.2, but https://www.microsoft.com/net/download/linux refers to 42.1.\r\n\r\n\r\n\r\n"},{"Id":"7461277545","Type":"IssuesEvent","CreatedAt":"2018-03-31T00:50:57","Actor":"kasper3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8958","RelatedDescription":"Opened issue \"Tab-completion is expected to exhibit \"starts with\" semantics, instead of \"contains\"\" (#8958) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\nIn PowerShell, copy the contents of https://github.com/dotnet/cli/blob/6b240926a3f4a71ac097ba234bd4f627efaedcad/scripts/register-completions.ps1 in `$PROFILE`\r\n\r\n```powershell\r\n(curl https://raw.githubusercontent.com/dotnet/cli/master/scripts/register-completions.ps1).Content`\r\n    | out-file -append -encoding ASCII -filepath $PROFILE\r\n\r\n# then start a new session (or close and reopen pwsh)\r\npowershell\r\n```\r\n\r\nType in `dotnet n<TAB>`.\r\n\r\n\r\n## Expected  behavior\r\n`dotnet new`, or something that **starts with `n`**.\r\n\r\n## Actual behavior\r\n`dotnet clean`\r\nPress tab again to get `dotnet internal-reportinstallsuccess` (why is this internal thingy visible??)\r\nPress tab third time to get `dotnet new`\r\n\r\n## Environment data\r\n`dotnet --info` output:\r\n\r\n```\r\n.NET Command Line Tools (2.1.103)\r\n\r\nProduct Information:\r\n Version:            2.1.103\r\n Commit SHA-1 hash:  60218cecb5\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.1.103\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.6\r\n  Build    : 74b1c703813c8910df5b96f304b0f2b78cdf194d\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"7461259288","Type":"IssuesEvent","CreatedAt":"2018-03-31T00:39:38","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/issues/8048","RelatedDescription":"Closed issue \"'dotnet build <SLN>' fails if path in the solution file is not case sensitive\" (#8048) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\n```\r\nmkdir ProjectA\r\nmkdir ProjectB\r\ncd ProjectA\r\ndotnet new classlib\r\ncd ../ProjectB/\r\ndotnet new classlib\r\ncd ..\r\ndotnet new sln\r\ndotnet sln add projecta\\projecta.csproj <- this will break the build\r\ndotnet sln add projectb\\projectb.csproj\r\n```\r\n\r\nAdd the following to ProjectB\r\n```xml\r\n<ItemGroup>\r\n    <ProjectReference Include=\"..\\ProjectA\\ProjectA.csproj\" />\r\n</ItemGroup>\r\n```\r\n\r\nAnd build the solution with\r\n\r\n```\r\ndotnet build\r\n```\r\n\r\n## Expected  behavior\r\n\r\n```\r\nλ  dotnet build\r\nMicrosoft (R)-Buildmodul, Version 15.4.8.50001 für .NET Core\r\nCopyright (C) Microsoft Corporation. Alle Rechte vorbehalten.\r\n\r\n  ProjectA -> C:\\temp\\test\\ProjectA\\bin\\Debug\\netstandard2.0\\ProjectA.dll\r\n  ProjectB -> C:\\temp\\test\\ProjectB\\bin\\Debug\\netstandard2.0\\ProjectB.dll\r\n\r\nDer Buildvorgang wurde erfolgreich ausgeführt.\r\n    0 Warnung(en)\r\n    0 Fehler\r\n\r\nVerstrichene Zeit 00:00:03.00\r\n```\r\n\r\n## Actual behavior\r\n\r\n```\r\nλ  dotnet build\r\nMicrosoft (R)-Buildmodul, Version 15.4.8.50001 für .NET Core\r\nCopyright (C) Microsoft Corporation. Alle Rechte vorbehalten.\r\n\r\n  projecta -> C:\\test\\projecta\\bin\\Debug\\netstandard2.0\\projecta.dll\r\nC:\\Program Files\\dotnet\\sdk\\2.0.2\\Sdks\\Microsoft.NET.Sdk\\build\\Microsoft.NET.Sdk.targets(114,5): error : Die Projektinformationen für \"C:\\test\\projecta\\projecta.csproj\" wurden nicht gefunden. Dies ist möglicherweise auf einen fehlenden Projektverweis zurückzuführen. [C:\\test\\projectb\\projectb.csproj]\r\n\r\nFehler beim Buildvorgang.\r\n\r\nC:\\Program Files\\dotnet\\sdk\\2.0.2\\Sdks\\Microsoft.NET.Sdk\\build\\Microsoft.NET.Sdk.targets(114,5): error : Die Projektinformationen für \"C:\\test\\projecta\\projecta.csproj\" wurden nicht gefunden. Dies ist möglicherweise auf einen fehlenden Projektverweis zurückzuführen. [C:\\test\\projectb\\projectb.csproj]\r\n    0 Warnung(en)\r\n    1 Fehler\r\n\r\nVerstrichene Zeit 00:00:02.99\r\n```\r\n\r\nRunning the build with `/v:d` or `/v:diag` did not help as it produced no additional information except\r\n```\r\nDie Ausführung der GenerateDepsFile-Aufgabe ist abgeschlossen -- FEHLER.\r\n```\r\n\r\nI had to build my own `Microsoft.NET.Build.Tasks.dll`[*] to be able to debug the `GenerateDepsFile`-Task.\r\n\r\nThe problem here is that in \r\nhttps://github.com/dotnet/sdk/blob/8992a1b11f55b93bea97aa8483de8c85a986c070/src/Tasks/Microsoft.NET.Build.Tasks/DependencyContextBuilder.cs#L623-L627\r\n`_referenceProjectInfos` contains a list of the **case sensitive** absolute paths to the referenced projects and for some reason the path from the SLN which is not case sensitive is used to find the referenced project. \r\n\r\n## Environment data\r\n```\r\nλ  dotnet --info\r\n.NET-Befehlszeilentools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.15063\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\n## Workaround\r\n\r\nChange the projet references inside the SLN to the correct case sensitive version\r\n\r\n[*] On a side note\r\nDebugging the `Microsoft.NET.Build.Tasks.dll` did not work out of the box too.\r\nAfter adding `Debugger.Launch();` in `GenerateDepsFile.Execute()`, building the project and copying the output to `C:\\Program Files\\dotnet\\sdk\\2.0.2\\Sdks\\Microsoft.NET.Sdk\\tools` I could attach Visual Studio to the process but was unable to debug because Visual Stiudio wouldn't load my debug PDB (see dotnet/core-setup#3138).\r\n\r\nAfter some googling and trying the same with VSCode I found the following warning while attaching to the build process\r\n```\r\nWARNING: Could not load symbols for 'Microsoft.NET.Build.Tasks.dll'. 'C:\\Program Files\\dotnet\\sdk\\2.0.2\\Sdks\\Microsoft.NET.Sdk\\build\\..\\tools\\netcoreapp1.0/\\Microsoft.NET.Build.Tasks.pdb' is a Windows PDB. These are not supported by the cross-platform .NET Core debugger.\r\n```\r\nAfter adding \r\n```xml\r\n<DebugType>portable</DebugType>\r\n```\r\nto the `Microsoft.NET.Build.Tasks` project and rebuilding it I was finally able to debug the Task.\r\n"},{"Id":"7461224050","Type":"PullRequestEvent","CreatedAt":"2018-03-31T00:19:30","Actor":"peterhuene","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8950","RelatedDescription":"Merged pull request \"Implement `buildserver shutdown` command.\" (#8950) at dotnet/cli","RelatedBody":"This PR implements the `buildserver shutdown` command that can be used to\r\nshutdown MSBuild, VB/C# compiler, and Razor build servers.\r\n\r\nBy default, all three build servers are shut down.  Options can be passed to\r\nshut down a subset of the build servers.\r\n\r\nFixes #8185.\r\n\r\n"},{"Id":"7461170753","Type":"PullRequestEvent","CreatedAt":"2018-03-30T23:50:58","Actor":"natemcmaster","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8957","RelatedDescription":"Opened pull request \"Remove instruction to install dotnet-dev-certs separately\" (#8957) at dotnet/cli","RelatedBody":"Old message doesn't apply anymore now that dev-certs is baked in.\r\n\r\n"},{"Id":"7461163417","Type":"PullRequestEvent","CreatedAt":"2018-03-30T23:47:10","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8919","RelatedDescription":"Merged pull request \"Add latest patch versions to BundledVersions.props, and tests to make sure that they are up to date\" (#8919) at dotnet/cli","RelatedBody":"- Add properties to BundledVersions.props for the latest patch version of each minor release of .NET Core.  This will be consumed by dotnet/sdk#2085, which automatically rolls forward self-contained apps to the latest patch version\r\n- Add tests to make sure that the latest patch version properties are up-to-date.  These tests will fail until dotnet/sdk#2085 is merged and inserted into the CLI\r\n\r\nI think that these tests will mean that the only thing we will need to do to keep the latest patch numbers up-to-date is to update them when test failures tell us to do so.  The `ItRollsForwardToTheLatestVersion` test compares the resolved version of `Microsoft.NETCore.App` for a self-contained app with the version that is resolved when the `RuntimeFrameworkVersion` floats the patch version (eg `2.0.*`).  If they don't match, then it will fail with a message like the following:\r\n\r\n> Expected string to be equivalent to \"2.0.6\" because the latest patch version properties in Microsoft.NETCoreSdk.BundledVersions.props need to be updated (see MSBuildExtensions.targets in this repo), but \"2.0.0\" differs near \"0\" (index 4).\r\n\r\nWe also need to make sure that the tests cover each minor release of .NET Core.  That's covered by the `WeCoverLatestNetCoreAppRollForward` test, which creates a project via `dotnet new console` and makes sure that the `TargetFramework` from that project has a corresponding entry in the `MemberData` used by the previous test.  So when we update the templates to target a new version of .NET Core, we'll be reminded to update these tests via the following failure message:\r\n\r\n> Expected collection {\"netcoreapp1.0\", \"netcoreapp1.1\", \"netcoreapp2.0\"} to contain \"netcoreapp2.1\" because the SupportedNetCoreAppVersions property should include the default version of .NET Core created by \"dotnet new\"."},{"Id":"7461106543","Type":"IssuesEvent","CreatedAt":"2018-03-30T23:19:56","Actor":"dsplaisted","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8956","RelatedDescription":"Opened issue \"NETStandard.Library 2.0.2 should be picked up in SDK servicing\" (#8956) at dotnet/cli","RelatedBody":"_From @ericstj on September 26, 2017 21:6_\n\n/cc @livarcocc @dsplaisted \n\n_Copied from original issue: dotnet/sdk#1608_"},{"Id":"7461074073","Type":"PullRequestEvent","CreatedAt":"2018-03-30T23:05:42","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8943","RelatedDescription":"Merged pull request \"Remove empty PATH in path resolver\" (#8943) at dotnet/cli","RelatedBody":"Path adding logic on Windows is wrong. Windows require `;` in the end of the path.\r\n\r\nAlso filter out empty PATH. So it won't resolve to current directory\r\n\r\nhttps://stackoverflow.com/questions/11391390/placing-the-semicolon-in-the-windows-path-environment-variable"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7460346731","Type":"IssuesEvent","CreatedAt":"2018-03-30T19:16:00","Actor":"jnm2","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/697","RelatedDescription":"Opened issue \"Trimmer tries to run when assemblies are missing\" (#697) at dotnet/standard","RelatedBody":"When project B depends on project A and something causes project A to stop compiling, this appears for project B:\r\n\r\n> Error MSB4018 The \"TrimFiles\" task failed unexpectedly. System.IO.FileNotFoundException: Could not find file 'ProjectA\\bin\\Debug\\ProjectA.exe'.\r\n\r\n```\r\n   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)\r\n   at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)\r\n   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share)\r\n   at Microsoft.DotNet.Build.Tasks.FileNode.PopulateDependenciesInternal(IDictionary`2 allFiles, Boolean preferNativeImage, ILog log, Stack`1 stack)\r\n   at Microsoft.DotNet.Build.Tasks.FileNode.PopulateDependencies(IDictionary`2 allFiles, Boolean preferNativeImage, ILog log)\r\n   at Microsoft.DotNet.Build.Tasks.TrimFiles.GetFiles(IDictionary`2 packages)\r\n   at Microsoft.DotNet.Build.Tasks.TrimFiles.Execute()\r\n   at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()\r\n   at Microsoft.Build.BackEnd.TaskBuilder.<ExecuteInstantiatedTask>d__26.MoveNext()\r\n```\r\n\r\n(build\\Microsoft.Packaging.Tools.Trimming.targets, line 71)\r\n\r\nI don't know if this is the whole picture, but when I ran into this I added `Condition=\"Exists(@(IntermediateAssembly))\"` to the main trimming target which had `AfterTargets=\"CoreCompile\"`.\r\n\r\n/cc @ericstj \r\n"},{"Id":"7457305260","Type":"PullRequestEvent","CreatedAt":"2018-03-30T03:20:07","Actor":"terrajobst","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/440","RelatedDescription":"Merged pull request \"Update reference for .NET Standard 2.0 to match final bits\" (#440) at dotnet/standard","RelatedBody":"The diff is surprisingly large, but that seems to be a result of [this CCI change](https://github.com/dotnet/buildtools/commit/7cf90764ff3f869ad6c680fb71a5c89d26a16cc5).\r\n\r\n@weshaggard "},{"Id":"7454371159","Type":"IssuesEvent","CreatedAt":"2018-03-29T14:51:34","Actor":"MohammadHamdyGhanem","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/696","RelatedDescription":"Opened issue \"XAML standard API\" (#696) at dotnet/standard","RelatedBody":"I say Microsoft should make a XAML standard API (Like .NET Standard) that should be obeyed be Xamarin.Forms, UWP and ASP.NET some XAML/C# razor. Or extend .NET Standard to include this. \r\nControls and their properties and methods should have the same names whatever the underling implementation. This will make all these components easier to learn, and make most of the code reusable.\r\n\r\n"},{"Id":"7451276904","Type":"PullRequestEvent","CreatedAt":"2018-03-29T01:58:17","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/695","RelatedDescription":"Opened pull request \"Update BuildTools to preview3-02629-02 (master)\" (#695) at dotnet/standard","RelatedBody":""},{"Id":"7451016632","Type":"PullRequestEvent","CreatedAt":"2018-03-29T00:20:18","Actor":"weshaggard","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/standard/pull/694","RelatedDescription":"Merged pull request \"Update BuildTools to preview3-02628-01 (master)\" (#694) at dotnet/standard","RelatedBody":""},{"Id":"7447113182","Type":"IssuesEvent","CreatedAt":"2018-03-28T11:23:52","Actor":"Foroughi","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/686","RelatedDescription":"Closed issue \"Missing NetStatandard 2 after install my nuget package\" (#686) at dotnet/standard","RelatedBody":"I have a netstandard2 class library project, which contains some Roslyn analyzers. I'm trying to create NuGet package using a` .nuspec `and `msbuild \\t:pack` command. All working find and i can create the nuget package easily. But as soon as i register my analyzer afteer installing the package on another project i get the following error for each analyzer in my package :\r\n\r\n`An instance of analyzer [AnalyzerName] cannot be created from [AnalyzerDllFile]: Could not load file or assembly 'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies. The system cannot find the file specified`\r\n\r\nHere is the .nuspec file :\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<package xmlns=\"http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd\">\r\n  <metadata>\r\n    <id>[PackageId]</id>\r\n    <version>1.0.9</version>\r\n    <authors>Ali</authors>\r\n    <requireLicenseAcceptance>false</requireLicenseAcceptance>\r\n    <description>test</description>  \r\n  <!-- Solution A i found -->\r\n  <dependencies>\r\n  <group targetFramework=\"net46\">\r\n    <dependency id=\"NETStandard.Library\" version=\"2.0.0\" />\r\n  </group>\r\n\r\n  </dependencies>\r\n     <!-- Solution B i found -->\r\n    <references>      \r\n      <reference file=\"netstandard.dll\" />\r\n  </references>\r\n  </metadata>\r\n  <files>    \r\n    <file src=\"bin\\Debug\\netstandard2.0\\[PackageName].dll\" target=\"analyzers\\dotnet\\cs\" />    \r\n    <file src=\"tools\\*.ps1\" target=\"tools\\\" />\r\n  </files>\r\n</package>\r\n```\r\n\r\n\r\n\r\nI tried many solution that i found on internet but seems I'm missing something else\r\n\r\nFYI both project are targeting to .Net Framework 4.6.1"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7461577576","Type":"PullRequestEvent","CreatedAt":"2018-03-31T05:00:38","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/28639","RelatedDescription":"Merged pull request \"Stop blocking explicit opt-in to old SslProtocols in SslStream and HttpClient\" (#28639) at dotnet/corefx","RelatedBody":"By default, .NET Core defaults to allowing TLSv1, TLSv1.1, and TLSv1.2.  However, whereas .NET Framework allows a developer to opt-in to SSLv2/SSLv3, .NET Core currently blocks it.  This means developers are unable to use .NET Core when they need to communicate with an endpoint they don't control and that's unfortunately limited to one of these protocols, which blocks adoption of .NET Core.\r\n\r\nThis commit stops blocking these protocols.  They're still disabled by default, and compiling against them still results in a deprecation warning, but if a developer chooses to ignore the warning and explicitly sets SslProtocols, they are at least able to use the protocols, subject to whatever the underlying operating system allows (e.g. Windows stops supporting SSLv2 as of v1607).\r\n\r\nFixes https://github.com/dotnet/corefx/issues/15661\r\ncc: @bartonjs, @GrabYourPitchforks, @davidsh\r\n(Note I'm expecting when mission control comes back up I'll still have a handful of test failures to investigate.  I also should call out that some of the impacted tests are previously ActiveIssue'd, so as part of testing this I temporarily commented out the ActiveIssue, but I reverted that commenting for the PR.)"},{"Id":"7461577566","Type":"IssuesEvent","CreatedAt":"2018-03-31T05:00:38","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/15661","RelatedDescription":"Closed issue \"Reconsider allowing unsecure connections in .NET Core\" (#15661) at dotnet/corefx","RelatedBody":"I'm writing a C# wrapper around a very-much legacy SOAP/XML webservice.\r\n\r\nThe service uses a self-signed certificate that is expired. It also uses SSLv3, which, from what I can learn here and on the WCF teams github, is not allowed in corefx.\r\n\r\nI fully understand the implications and reasoning behind this, but is there no way around this limitation? The company that made the device running the webservice stopped maintaining it years ago.\r\n\r\nWill .NET Core not allow us to interact with such legacy devices? As I see it, being able to trust a self-signed certificate is no better than allowing SSL.\r\n\r\nOn a side note: My app works on Windows, but not on Ubuntu or Docker. Is that intentional?"},{"Id":"7461551024","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:34:22","Actor":"saurabh500","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/27011","RelatedDescription":"Merged pull request \"Bump System.Data.SqlClient assembly version to 4.4.0.\" (#27011) at dotnet/corefx","RelatedBody":"Fixes https://github.com/dotnet/corefx/issues/26142"},{"Id":"7461551022","Type":"IssuesEvent","CreatedAt":"2018-03-31T04:34:22","Actor":"saurabh500","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/26142","RelatedDescription":"Closed issue \"System.Data.SqlClient needs to update version\" (#26142) at dotnet/corefx","RelatedBody":"As part of https://github.com/dotnet/corefx/pull/25142 new API was added to the assembly which mean we need to bump the minor assembly version the PR only updated the patch version from 4.3.0 to 4.3.1 (see comment https://github.com/dotnet/corefx/pull/25142#discussion_r156465074). We should update assembly version to 4.4.0.\r\n\r\nGiven this library currently ships inbox for UAP we need to start shipping a build of this in the nuget package so it can correctly override what is shipped inbox for UAP otherwise folks trying to consume the new APIs and run on UAP will fail to run on the one currently inbox. (see comment https://github.com/dotnet/corefx/pull/25142#discussion_r156465352), see also issue https://github.com/dotnet/corefx/issues/23743 for more details. \r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"7461548268","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:31:50","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/28472","RelatedDescription":"Closed pull request \"Check for IReadOnlyCollection\" (#28472) at dotnet/corefx","RelatedBody":"... as well as ICollection, to avoid IEnumerator loop."},{"Id":"7461541018","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:24:51","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/28674","RelatedDescription":"Merged pull request \"Add tests for calling Span APIs via reflection to verify graceful failures.\" (#28674) at dotnet/corefx","RelatedBody":"Partially resolves https://github.com/dotnet/coreclr/issues/17296\r\n\r\ncc @jkotas, @AtsushiKan, @KrzysztofCwalina"},{"Id":"7461525056","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:09:28","Actor":"stephentoub","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28676","RelatedDescription":"Opened pull request \"Avoid unnecessarily propagating ExecutionContext in SocketAsyncEngine\" (#28676) at dotnet/corefx","RelatedBody":"SocketAsyncEngines are created lazily on-demand.  If we happen to create one at a point where there's a non-default ExecutionContext, we end up capturing that context onto the event loop thread, such that all subsequent dispatches capture and restore that ExecutionContext.\r\n\r\nFixes https://github.com/dotnet/corefx/issues/28482\r\ncc: @benaadams, @geoffkizer, @tmds"},{"Id":"7461524196","Type":"PullRequestEvent","CreatedAt":"2018-03-31T04:08:41","Actor":"bartonjs","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/28675","RelatedDescription":"Opened pull request \"[2.0] React to X509Chain changes in macOS 10.13.4\" (#28675) at dotnet/corefx","RelatedBody":"10.13.4 changed some of the detail codes for building the X509ChainStatusFlag values.\r\n\r\n\"ValidLeaf\" (etc) => \"TemporalValidity\"\r\n\"WeakLeaf\" (etc) => \"WeakKeySize\"\r\nnew \"MissingIntermediate\" when the chain didn't complete instead of \"AnchorTrusted\" lower down.\r\n\r\nPort #28673 to release/2.0.0"},{"Id":"7461512539","Type":"IssuesEvent","CreatedAt":"2018-03-31T03:58:10","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/27496","RelatedDescription":"Closed issue \"[Perf][Windows_NT] Investigate the improvement/regressions on System/IO/Tests/PerfStreamWriter\" (#27496) at dotnet/corefx","RelatedBody":"From release/2.0.0 to release/2.1 there has been the following changes in the tests:\r\n```\r\n  WriteCharArray(writeLength: 100)         // Improved ~8%\r\n  WriteCharArray(writeLength: 2)           // Improved ~7%\r\n  WritePartialCharArray(writeLength: 100)  // Improved ~16%\r\n  WritePartialCharArray(writeLength: 2)    // Regressed ~25%\r\n  WriteString(writeLength: 2)              // Regressed ~4%\r\n```"}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7461202402","Type":"PullRequestEvent","CreatedAt":"2018-03-31T00:07:38","Actor":"ahsonkhan","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5642","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5642) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7460989580","Type":"PullRequestEvent","CreatedAt":"2018-03-30T22:31:31","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5642","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5642) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7459227263","Type":"IssuesEvent","CreatedAt":"2018-03-30T14:26:36","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5604","RelatedDescription":"Closed issue \"Net Native compilation fails with Out of Memory (Xamarin/UWP)\" (#5604) at dotnet/corert","RelatedBody":"_From @sebastianfilke on March 22, 2018 13:54_\n\nWe have a big problem with the net native compilation in a relative big project.\r\nThe release build only works if we disable the option “Compile with .NET Native tool chain” or “Optimize code”.\r\nOtherwise the build takes up to 10 minutes and ends with an out of memory error.\r\n\r\nThe build log file is attached: [build.log](https://github.com/dotnet/core/files/1837784/build.log)\r\n\r\nThere is also an ilcRepro.zip file attached:\r\nhttps://drive.google.com/file/d/1bhEwZco0fugxxRDxj0hi86jnb9eJIpOV/view?usp=sharing\r\n\r\nWe tried several different settings in the Default.rd.xml, but nothing worked yet.\r\n\r\n•\tWe comment out the application assembly tag\r\n<!-- <Assembly Name=\"*Application*\" Dynamic=\"Required All\" DoNotOptimize=\"true\"/> -->\r\n•\tWe also tried to add an extra assembly tag for every assembly and with DoNotOptimize\r\n\r\nBut neither worked. \r\n\r\nPlease give me an advice or another solution. I don’t know if this is a bug or an assembly doesn’t worked or is not ready for net native.\r\n\n\n_Copied from original issue: dotnet/core#1372_"},{"Id":"7455835029","Type":"PullRequestEvent","CreatedAt":"2018-03-29T19:44:43","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5641","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5641) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7455294539","Type":"PullRequestEvent","CreatedAt":"2018-03-29T17:40:06","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5641","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5641) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7455264798","Type":"PullRequestEvent","CreatedAt":"2018-03-29T17:34:00","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5618","RelatedDescription":"Merged pull request \"Implement P/Invoke 'A' and 'W' Probing\" (#5618) at dotnet/corert","RelatedBody":"Implement probing for native function names following the A/W suffix notation used on Windows.\r\n\r\nFixes #730."},{"Id":"7455264786","Type":"IssuesEvent","CreatedAt":"2018-03-29T17:34:00","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/730","RelatedDescription":"Closed issue \"Pinvoke method \"W\" and \"A\" probing\" (#730) at dotnet/corert","RelatedBody":"(1). [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\npublic static extern bool GetProcessMemoryInfo(IntPtr hProcess, out PROCESS_MEMORY_COUNTERS ppsmemCounters, int cb);\n\nlinking phase  will fails since it can't find \"GetProcessMemoryInfo\" in any of the libs.\n\n(2).  On windows distinguish between \"W\" and \"A\" version of method.\n"},{"Id":"7455253165","Type":"PullRequestEvent","CreatedAt":"2018-03-29T17:31:35","Actor":"ahsonkhan","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5640","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5640) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"7451139923","Type":"PullRequestEvent","CreatedAt":"2018-03-29T01:06:36","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5640","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5640) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7461454010","Type":"PullRequestEvent","CreatedAt":"2018-03-31T03:07:24","Actor":"dotnet-bot","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/2102","RelatedDescription":"Opened pull request \"Merge release/2.1.1xx to release/2.1.2xx\" (#2102) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.1.1xx into release/2.1.2xx.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.1.1xx-to-release/2.1.2xx\ngit reset --hard upstream/release/2.1.2xx\ngit merge upstream/release/2.1.1xx\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.1.1xx-to-release/2.1.2xx --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7461244212","Type":"PullRequestEvent","CreatedAt":"2018-03-31T00:30:39","Actor":"peterhuene","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/2088","RelatedDescription":"Merged pull request \"Fix case sensitivity when mapping project paths to project infos.\" (#2088) at dotnet/sdk","RelatedBody":"When a solution contains a path to a project that differs by case for a project\r\nreference identity, the build fails because the project info can't be found.\r\n\r\nThe fix is to make the internal map case insensitive, allowing the case\r\ndifference in a project's path in the solution file.\r\n\r\nFixes dotnet/cli#8048."}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"977245582724022272","CreatedAt":"2018-03-23T18:07:57+00:00","UserScreenname":"dotnet","Text":"Calling all Desktop Developers: how should UI development be improved? https://t.co/lKHACsK0Sv","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":105,"FavoriteCount":74,"RawContent":null},{"Id":"976910301634465792","CreatedAt":"2018-03-22T19:55:40+00:00","UserScreenname":"dotnet","Text":"Get started building .NET web apps in the browser with Blazor https://t.co/OokEA8H4Mo","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":231,"FavoriteCount":179,"RawContent":null}]}},"RunOn":"2018-03-31T05:30:20.4139222Z","RunDurationInMilliseconds":8069}