{"Data":{"GitHub":{"Issues":[{"Id":"362728587","IsPullRequest":false,"CreatedAt":"2018-09-23T04:09:01","Actor":"Anipik","Number":"982","RawContent":null,"Title":"Reduce Running time of Machinelearning Benchmarks ","State":"closed","Body":"Currently some of the benchmarks take an hour or two to run , which makes difficult for developers to get the instant results.\r\n\r\nOur target is to reduce the running time to 5~15 mins at max\r\n","Url":"https://github.com/dotnet/machinelearning/issues/982","RelatedDescription":"Closed issue \"Reduce Running time of Machinelearning Benchmarks \" (#982)"},{"Id":"362831926","IsPullRequest":true,"CreatedAt":"2018-09-22T06:42:05","Actor":"sfilipi","Number":"996","RawContent":null,"Title":"PcaTrainer as estimator","State":"open","Body":"Addresses part of #754 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/996","RelatedDescription":"Open PR \"PcaTrainer as estimator\" (#996)"},{"Id":"362830045","IsPullRequest":false,"CreatedAt":"2018-09-22T06:05:28","Actor":"kjsbedi","Number":"995","RawContent":null,"Title":"ML.NET 0.5.0 not getting installed on VS2017 ","State":"open","Body":"### System information\r\n\r\n- **OS version/Windows 10**:\r\n- **.NET Version (VS2017)**: \r\n\r\n### Issue\r\n\r\n- Trying to Install ML.NET 0.5\r\n\r\n-Severity\tCode\tDescription\tProject\tFile\tLine\tSuppression State\r\nError\t\tCould not install package 'Microsoft.ML 0.5.0'. You are trying to install this package into a project that targets '.NETFramework,Version=v4.5.2', but the package does not contain any assembly references or content files that are compatible with that framework. For more information, contact the package author.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/995","RelatedDescription":"Open issue \"ML.NET 0.5.0 not getting installed on VS2017 \" (#995)"},{"Id":"362458430","IsPullRequest":true,"CreatedAt":"2018-09-22T05:01:12","Actor":"sfilipi","Number":"974","RawContent":null,"Title":"undoing test changes","State":"closed","Body":"Fixing merge errors on those two files, on the TreeEstimators PR. \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/974","RelatedDescription":"Closed or merged PR \"undoing test changes\" (#974)"},{"Id":"362820849","IsPullRequest":true,"CreatedAt":"2018-09-22T02:59:20","Actor":"cTxplorer","Number":"994","RawContent":null,"Title":"Made loop bound checking in hardware intrinsics more efficient","State":"open","Body":"Changed style to make loop bound checking more efficient.\r\n\r\n`Closes #835`","Url":"https://github.com/dotnet/machinelearning/pull/994","RelatedDescription":"Open PR \"Made loop bound checking in hardware intrinsics more efficient\" (#994)"},{"Id":"362816900","IsPullRequest":true,"CreatedAt":"2018-09-22T01:50:35","Actor":"Zruty0","Number":"993","RawContent":null,"Title":"Extended contexts to regression and multiclass, added FFM pigstension","State":"open","Body":"Part of #754, extends #949.\r\nAdded MulticlassClassification context and RegressionContext, with corresponding Evaluate methods. Also added FFM binary trainer to the context extensions.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/993","RelatedDescription":"Open PR \"Extended contexts to regression and multiclass, added FFM pigstension\" (#993)"},{"Id":"362806774","IsPullRequest":true,"CreatedAt":"2018-09-21T23:59:10","Actor":"wschin","Number":"992","RawContent":null,"Title":"Fix a conversion bug in KeyToVectorTransform.","State":"open","Body":"This PR addresses #971 with the following changes.\r\n\r\n(1) A ReduceSum is missing when Bag+ for merging\r\n    all features' one-hot vectors\r\n(2) Since this conversion depends on the input shape,\r\n    an API is added to retrieve shape of existing\r\n    variables.\r\n\r\nThis PR hasn't been verified with a runtime due to a potential bug in their interface.","Url":"https://github.com/dotnet/machinelearning/pull/992","RelatedDescription":"Open PR \"Fix a conversion bug in KeyToVectorTransform.\" (#992)"},{"Id":"362806130","IsPullRequest":true,"CreatedAt":"2018-09-21T23:53:46","Actor":"zeahmed","Number":"991","RawContent":null,"Title":"Converted Feature selection transforms in to transformers/estimators.","State":"open","Body":"This PR implements a work item related to #754.\r\n\r\nThe following transforms were converted in this PR.\r\n- CountFeatureSelectionTransform\r\n- MutualInformationFeatureSelectionTransform\r\n","Url":"https://github.com/dotnet/machinelearning/pull/991","RelatedDescription":"Open PR \"Converted Feature selection transforms in to transformers/estimators.\" (#991)"},{"Id":"362805360","IsPullRequest":false,"CreatedAt":"2018-09-21T23:47:47","Actor":"abgoswam","Number":"990","RawContent":null,"Title":"DnnAnalyzer does not work with TensorFlow's SavedModel format","State":"open","Body":"Currently the DnnAnalyzer only works with frozen models.\r\n\r\nWe need to fix it so it also works for TensorFlow's SavedModel format","Url":"https://github.com/dotnet/machinelearning/issues/990","RelatedDescription":"Open issue \"DnnAnalyzer does not work with TensorFlow's SavedModel format\" (#990)"},{"Id":"362792239","IsPullRequest":false,"CreatedAt":"2018-09-21T22:22:48","Actor":"wschin","Number":"989","RawContent":null,"Title":"ONNX converter needs to acccess shapes in addition to variable names","State":"open","Body":"Some conversion strategies are shape-sensitive. ML.NET only passes input and output names to the each transform's conversion function, and it'd be better if shapes can be accessed as well.","Url":"https://github.com/dotnet/machinelearning/issues/989","RelatedDescription":"Open issue \"ONNX converter needs to acccess shapes in addition to variable names\" (#989)"},{"Id":"362762747","IsPullRequest":false,"CreatedAt":"2018-09-21T21:43:11","Actor":"TomFinley","Number":"986","RawContent":null,"Title":"`ITransformer` yields `IRowToRowMapper`, make prediction engine faster","State":"closed","Body":"Things like `ITransformer` (or its predecessor, `IDataTransform`) given an `IDataView` can produce another `IDataView`. This works well for doing things like streaming over billions of records, but for just one record, the whole machinery around setting up a cursor.\r\n\r\nFor example, consider the prediction engine.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/ecb9126691401a3142e59139290bf78ed9bc68ad/src/Microsoft.ML.Api/PredictionEngine.cs#L149\r\n\r\nWhat this does currently is it basically composes an `IDataView` consisting of *one* item, then applies the transform chain to it, and so on. But this is pretty heavyweight. The setting up the dynamically typed delegates, binding to the appropriate types, and so on, on every single point absolutely dwarfs any actual computation that happens in many pipelines. Again, this system is fine if you're doing what it was designed to do, stream efficiently over billions of records, but on a small scale it's not great.\r\n\r\nThere is an existing `IRowToRowMapper` interface that we might be able to exploit.\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/ecb9126691401a3142e59139290bf78ed9bc68ad/src/Microsoft.ML.Core/Data/ISchemaBindableMapper.cs#L91\r\n\r\nThis interface is somewhat analogous to `IDataView`, and the `IRowToRowMapper.GetRow` method is somewhat analogous to `IDataView.GetRowCursor`. This is something many existing `IDataTransform` interfaces would implement, to enable faster mapping. We can exploit this same functionality through `ITransformer`.\r\n\r\nSo we can do this:\r\n\r\n* Allow `ITransformer` to, in addition to providing `IDataView`s through transformation of datasets, *optionally* allow them to also provide `IRowToRowMapper` implementors.\r\n\r\n* Exploit this new functionality to make `PredictionEngine` faster, on applicable pipelines.\r\n\r\nThis will also allow us to check in prediction engine if a pipeline really is able to be expressed in a row-to-row capacity.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/986","RelatedDescription":"Closed issue \"`ITransformer` yields `IRowToRowMapper`, make prediction engine faster\" (#986)"},{"Id":"362422753","IsPullRequest":true,"CreatedAt":"2018-09-21T21:43:11","Actor":"TomFinley","Number":"973","RawContent":null,"Title":"PredictionEngine uses IRowToRowMapper, ITransformer can create IRowToRowMapper","State":"closed","Body":"In which we reduce the overhead of calls to `Predict` by avoiding the creation of cursors.\r\n\r\n`PredictionEngine` used to create a \"fake\" data view under the hood, by wrapping a `BatchPredictionEngine`, but only feeding in one item. This was a fairly heavy operation involving spooling up of cursors, including heavy reflection based processing on each row, etc. Now we are able to avoid this by using an existing interface `IRowToRowMapper`.\r\n\r\nThe other major part of the change is, of course, changing transformers so they *can* produce `IRowToRowMapper`, which they previously did not. In most cases this is relatively straightforward since nearly all transformers of interest are using these `IRowToRowMapper` under the hood to support their computation.\r\n\r\n* `IRowToRowMapper` enhancements, unification of some interfaces.\r\n* `ITransformer` has `IRowToRowMapper` accessor.\r\n* `PredictionEngine` now uses `IRowToRowMapper`\r\n\r\nThe effects of this are most dramatic using prediction engines *outside* of the ML.NET v0.1 pipeline API (e.g., using `IEstimator` based pipelines, pre-ML.NET v0.1 API, and so forth). The effect of this is that when predicting, now actual computation dominates the cost, as opposed to reflection based stuff. ðŸ˜„ Due to architectural limitations of pipeline API models, these do not see benefit.\r\n\r\nWill perhaps update with timings later.\r\n\r\nFix #986.","Url":"https://github.com/dotnet/machinelearning/pull/973","RelatedDescription":"Closed or merged PR \"PredictionEngine uses IRowToRowMapper, ITransformer can create IRowToRowMapper\" (#973)"},{"Id":"362775354","IsPullRequest":true,"CreatedAt":"2018-09-21T21:09:50","Actor":"eerhardt","Number":"988","RawContent":null,"Title":"NO MERGE: Diagnosing why ComponentCatalog change is deadlocking a test","State":"open","Body":"Trying to reproduce an issue I can't reproduce on my local dev machine.","Url":"https://github.com/dotnet/machinelearning/pull/988","RelatedDescription":"Open PR \"NO MERGE: Diagnosing why ComponentCatalog change is deadlocking a test\" (#988)"},{"Id":"362346066","IsPullRequest":true,"CreatedAt":"2018-09-21T20:56:12","Actor":"TomFinley","Number":"967","RawContent":null,"Title":"Binary train context with evaluation and SDCA","State":"closed","Body":"Fixes #949. In which I provide a working sketch of the context object, for evaluation (both dynamic and otherwise). If we think this is a good idea then we can add more capabilities to it. (Either in this PR or future ones.)","Url":"https://github.com/dotnet/machinelearning/pull/967","RelatedDescription":"Closed or merged PR \"Binary train context with evaluation and SDCA\" (#967)"},{"Id":"362766483","IsPullRequest":false,"CreatedAt":"2018-09-21T20:38:42","Actor":"Zruty0","Number":"987","RawContent":null,"Title":"Need some markdown documentation for the new APIs","State":"open","Body":"We have a bunch of tests against the new API, but we should have some more text-heavy explanations. For example a 'overview of API concepts' and a 'cookbook' with samples'recipes for common scenarios.","Url":"https://github.com/dotnet/machinelearning/issues/987","RelatedDescription":"Open issue \"Need some markdown documentation for the new APIs\" (#987)"},{"Id":"362762137","IsPullRequest":false,"CreatedAt":"2018-09-21T20:23:36","Actor":"Zruty0","Number":"985","RawContent":null,"Title":"Improve data view inspectability","State":"open","Body":"Because the `IDataView` is lazy, it is hard to stop in the debugger and see what does this 'data' variable contain.\r\n\r\nWe need to add programmatic ways to scan some of the data (in addition to `AsEnumerable<MyRowClass>`), as well as debugger convenience classes to improve the IDE experience.","Url":"https://github.com/dotnet/machinelearning/issues/985","RelatedDescription":"Open issue \"Improve data view inspectability\" (#985)"},{"Id":"362725648","IsPullRequest":true,"CreatedAt":"2018-09-21T18:51:20","Actor":"codemzs","Number":"981","RawContent":null,"Title":"Add dependency for System.Collections.Immutable in ML.Net nuget.","State":"closed","Body":"fixes #976\r\n","Url":"https://github.com/dotnet/machinelearning/pull/981","RelatedDescription":"Closed or merged PR \"Add dependency for System.Collections.Immutable in ML.Net nuget.\" (#981)"},{"Id":"362679401","IsPullRequest":false,"CreatedAt":"2018-09-21T18:51:20","Actor":"singlis","Number":"976","RawContent":null,"Title":"Missing System.Collections.Immutable from ML.Net 0.6.0-preview nuget package dependencies","State":"closed","Body":"### Issue\r\nThe latest ML.Net (0.6.0-preview) has a dependency on System.Collections.Immutable but the ML.Net nuget package does not list System.Collections.Immutable as a dependency. This results in a crash in ML.Net because of the missing assembly. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/976","RelatedDescription":"Closed issue \"Missing System.Collections.Immutable from ML.Net 0.6.0-preview nuget package dependencies\" (#976)"},{"Id":"362732809","IsPullRequest":false,"CreatedAt":"2018-09-21T18:44:06","Actor":"Anipik","Number":"984","RawContent":null,"Title":"Porting Missing Tests and Enabling Disabled Tests","State":"open","Body":"Many of the tests in machineLearning repo are disabled due to missing baseline files, datasets or components.\r\n\r\nThis issue tracks the development of enabling these tests and porting more tests from the TLC repo\r\n","Url":"https://github.com/dotnet/machinelearning/issues/984","RelatedDescription":"Open issue \"Porting Missing Tests and Enabling Disabled Tests\" (#984)"},{"Id":"362731486","IsPullRequest":false,"CreatedAt":"2018-09-21T18:40:28","Actor":"sfilipi","Number":"983","RawContent":null,"Title":"Test changed incorrectly","State":"open","Body":"PR #855 incorrectly changed the New_DecomposableTrainAndPredict and the New_Metacomponents; as a result of a merge operation. \r\n\r\nRe-establish those tests to the pre- PR#855 state. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/983","RelatedDescription":"Open issue \"Test changed incorrectly\" (#983)"},{"Id":"362715952","IsPullRequest":false,"CreatedAt":"2018-09-21T17:51:09","Actor":"briancylui","Number":"980","RawContent":null,"Title":"Avoids pointer overflow in bound checking of SSE/AVX intrinsics","State":"open","Body":"#821 references and aims to solve this issue.\r\n---\r\nSuggested by @ahsonkhan to avoid integer overflow in bound checking inside SSE/AVX intrinsics implementation, i.e. change all `while (pCurrent + 8 OR 4 <= pEnd)` into `while (pEnd - pCurrent >= 8 OR 4)`.\r\n\r\nPerf tests results before and after the change are shown below:\r\n## Before the change:\r\n``` ini\r\nBenchmarkDotNet=v0.11.1, OS=Windows 10.0.17134.228 (1803/April2018Update/Redstone4)\r\nIntel Core i7-7700 CPU 3.60GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=3.0.100-alpha1-20180720-2\r\n  [Host] : .NET Core 3.0.0-preview1-26710-03 (CoreCLR 4.6.26710.05, CoreFX 4.6.26708.04), 64bit RyuJIT\r\n\r\nToolchain=InProcessToolchain\r\n```\r\n|                   Type | Method |     Mean |    Error |    StdDev |\r\n|----------------------- |------- |---------:|---------:|----------:|\r\n|    AvxPerformanceTests |   SumU | 159.4 us | 1.104 us | 0.9784 us |\r\n| NativePerformanceTests |   SumU | 283.5 us | 5.492 us | 4.8687 us |\r\n|    SsePerformanceTests |   SumU | 281.2 us | 1.472 us | 1.3045 us |\r\n|    AvxPerformanceTests |   AddU | 276.1 us | 3.018 us | 2.520 us |\r\n| NativePerformanceTests |   AddU | 330.1 us | 3.585 us | 3.178 us |\r\n|    SsePerformanceTests |   AddU | 325.6 us | 6.883 us | 7.926 us |\r\n\r\n## After the change:\r\n``` ini\r\nBenchmarkDotNet=v0.11.1, OS=Windows 10.0.17134.228 (1803/April2018Update/Redstone4)\r\nIntel Core i7-7700 CPU 3.60GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=3.0.100-alpha1-20180720-2\r\n  [Host] : .NET Core 3.0.0-preview1-26710-03 (CoreCLR 4.6.26710.05, CoreFX 4.6.26708.04), 64bit RyuJIT\r\n\r\nToolchain=InProcessToolchain\r\n```\r\n|                   Type | Method |     Mean |    Error |   StdDev |\r\n|----------------------- |------- |---------:|---------:|---------:|\r\n|    AvxPerformanceTests |   SumU | 183.5 us | 3.621 us | 3.023 us |\r\n| NativePerformanceTests |   SumU | 281.6 us | 5.261 us | 4.921 us |\r\n|    SsePerformanceTests |   SumU | 294.1 us | 2.080 us | 1.946 us |\r\n|    AvxPerformanceTests |   AddU | 296.3 us | 5.185 us | 4.850 us |\r\n| NativePerformanceTests |   AddU | 335.1 us | 3.053 us | 2.707 us |\r\n|    SsePerformanceTests |   AddU | 345.0 us | 2.155 us | 1.800 us |\r\n\r\nBoth SSE and AVX implementations are slower by 10-20% after this change.\r\n\r\nIn my opinion, after seeing the perf results, I may not recommend merging this PR.  I may wait until the alternative suggested by @tannergooding in an earlier PR review has been implemented (2nd item under \"Functionality\" in https://github.com/briancylui/machinelearning/issues/2):\r\n``` log\r\nvar remainder = count % elementsPerIteration;\r\nfloat* pEnd = pdst + (count - remainder);\r\nwhile (pDstCurrent < pEnd)\r\n{ â€¦ }\r\n```\r\n\r\nAnother question I have is: would `pDstCurrent + 8 OR 4` ever have the possibility to result in integer overflow?  According to my knowledge, `pEnd` is initialized as `pDstCurrent + count`, and there are `Contract.Asserts` in the wrapper class to check that `count` does not exceed the original array length.  I'm not sure, and am open to any PR comments and advice.\r\n\r\ncc: @danmosemsft @eerhardt @tannergooding @ahsonkhan @markusweimer ","Url":"https://github.com/dotnet/machinelearning/issues/980","RelatedDescription":"Open issue \"Avoids pointer overflow in bound checking of SSE/AVX intrinsics\" (#980)"},{"Id":"362713982","IsPullRequest":true,"CreatedAt":"2018-09-21T17:45:02","Actor":"sfilipi","Number":"979","RawContent":null,"Title":"Converting KMeans++trainer to estimator.","State":"open","Body":"Ongoing work to address #754 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/979","RelatedDescription":"Open PR \"Converting KMeans++trainer to estimator.\" (#979)"},{"Id":"362707403","IsPullRequest":false,"CreatedAt":"2018-09-21T17:23:21","Actor":"codemzs","Number":"978","RawContent":null,"Title":"Time Series","State":"open","Body":"Bring time series prediction to ML.NET. More details will be added soon here.","Url":"https://github.com/dotnet/machinelearning/issues/978","RelatedDescription":"Open issue \"Time Series\" (#978)"},{"Id":"362704321","IsPullRequest":true,"CreatedAt":"2018-09-21T17:12:36","Actor":"codemzs","Number":"977","RawContent":null,"Title":"Time Series","State":"open","Body":"Time series prediction.\r\n* ExponentialAverage\r\n* IidChangePointDetector\r\n* IidSpikeDetector\r\n* PercentileThresholdTransform\r\n* PValueTransform\r\n* SlidingWindowTransform\r\n* SsaChangePointDetector\r\n* SsaSpikeDetector\r\n\r\nfixes #978","Url":"https://github.com/dotnet/machinelearning/pull/977","RelatedDescription":"Open PR \"Time Series\" (#977)"},{"Id":"362553901","IsPullRequest":false,"CreatedAt":"2018-09-21T10:30:25","Actor":"justinormont","Number":"975","RawContent":null,"Title":"ComponentCatalog logging errors","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: OSX 10.12\r\n- **.NET Version (eg., dotnet --info)**:  .NET Core SDK 2.1.401\r\n\r\n### Issue\r\nWhen running a simple showSchema command, `dotnet ./bin/AnyCPU.Release/Microsoft.ML.Console/netcoreapp2.0/MML.dll showSchema data=test/data/breast-cancer.txt`, as taken from https://github.com/dotnet/machinelearning/issues/593#issuecomment-408582190, many errors are displayed.\r\n\r\nOutput:\r\n```\r\nCacheClassesFromAssembly: can't map name ModuleGenerator to ModuleGenerator, already mapped to ModuleGenerator\r\nCacheClassesFromAssembly: can't map name Module to ModuleGenerator, already mapped to ModuleGenerator\r\nCacheClassesFromAssembly: can't map name CrossValidationBinaryMacro to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name CrossValidationMacro to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name CVSplit to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name DataViewReference to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name FeatureCombiner to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name ImportTextData to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name ExecGraph to ExecuteGraphCommand, already mapped to ExecuteGraphCommand\r\nCacheClassesFromAssembly: can't map name ModelOperations to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name OneVersusAllMacro to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name TrainTestBinaryMacro to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name TrainTestMacro to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name TrainTestSplit to Void, already mapped to Void\r\nCacheClassesFromAssembly: can't map name CSGenerator to CSharpApiGenerator, already mapped to CSharpApiGenerator\r\nCacheClassesFromAssembly: can't map name CS to CSharpApiGenerator, already mapped to CSharpApiGenerator\r\n2 columns:\r\n  Label: R4\r\n  Features: Vec<R4, 9>\r\n```\r\n\r\nThis error is logged within the ComponentCatalog:\r\nhttps://github.com/dotnet/machinelearning/blob/6812cb565ebaa522685571103a4e441ee908dbb0/src/Microsoft.ML.Core/ComponentModel/ComponentCatalog.cs#L491-L493","Url":"https://github.com/dotnet/machinelearning/issues/975","RelatedDescription":"Open issue \"ComponentCatalog logging errors\" (#975)"},{"Id":"362415808","IsPullRequest":true,"CreatedAt":"2018-09-21T00:33:43","Actor":"zeahmed","Number":"972","RawContent":null,"Title":" Converted LdaTransform into Transformer/Estimator.","State":"open","Body":"This PR implements a work item related to #754.\r\n\r\nPlease only review LDA related classes. The other text transform changes are being reviewed in #953. I will merge the branches once approved.\r\n\r\nTests are disabled because LdaNative.dll is missing","Url":"https://github.com/dotnet/machinelearning/pull/972","RelatedDescription":"Open PR \" Converted LdaTransform into Transformer/Estimator.\" (#972)"},{"Id":"362389288","IsPullRequest":false,"CreatedAt":"2018-09-20T22:21:43","Actor":"wschin","Number":"971","RawContent":null,"Title":"Potential bug in ONNX exporter of KeyToVectorTransform","State":"open","Body":"[KeyToVectorTransform](https://github.com/dotnet/machinelearning/blob/1e7b8be855210f2bd8adbd532396a1840a20541d/src/Microsoft.ML.Data/Transforms/KeyToVectorTransform.cs#L711) is mapped to a single [OneHotEncoder](https://github.com/onnx/onnx/blob/master/docs/Operators-ml.md#aionnxmlonehotencoder )in ONNX now. It's correct if `bag-` but if `bag+`, we need to sum up the produced one-hot vectors with one extra `ReduceSum`.","Url":"https://github.com/dotnet/machinelearning/issues/971","RelatedDescription":"Open issue \"Potential bug in ONNX exporter of KeyToVectorTransform\" (#971)"},{"Id":"362369718","IsPullRequest":true,"CreatedAt":"2018-09-20T21:13:38","Actor":"eerhardt","Number":"970","RawContent":null,"Title":"ComponentCatalog refactor","State":"open","Body":"This executes on the plan outlined in https://github.com/dotnet/machinelearning/issues/208#issuecomment-422136134 copied here for easy reading:\r\n\r\n## New Proposal\r\n\r\n1. We will move `ComponentCatalog` from being a static class to being an instance member on `Environment`. This has been a planned refactoring for ML.NET for a while, but hasn't been funded until now.\r\n2. We will completely remove any implicit scanning for components in `ComponentCatalog` itself. It will have public APIs to register components, but will not do any registering itself - neither by loading assemblies from disk, nor by scanning loaded assemblies.\r\n3. Other subsystems (like the GUI, command-line, Entry Points, and model loading) will be responsible for registering the components they require in the manner they require.\r\n4. During model saving, we will write the `Assembly.FullName` into the model file. We will then register that assembly with the `env.ComponentCatalog` when loading the model.\r\n    - Any model that was saved with a previous version of ML.NET, and loaded using the API, will need to explicitly register the components before loading the model. (Or they will need to save the model again with a current version of ML.NET that will save the assembly names.)\r\n\r\nUnder normal circumstances, API users won't have to explicitly register components with the `ComponentCatalog`. Using the API to train models won't require looking up components from a catalog - you just create .NET objects like normal. Loading a trained model from disk will register the components inside of it by loading the Assembly and scanning it for `LoadableClass` assembly attributes.\r\n\r\nFix #208","Url":"https://github.com/dotnet/machinelearning/pull/970","RelatedDescription":"Open PR \"ComponentCatalog refactor\" (#970)"},{"Id":"362363086","IsPullRequest":false,"CreatedAt":"2018-09-20T20:57:24","Actor":"zeahmed","Number":"969","RawContent":null,"Title":"TestEstimatorCore fails when training on EmptyDataView for Ngram based transforms.","State":"open","Body":"`TestEstimatorCore` method tests the schema of estimator that of transformer. It trains estimator on EmptyDataView and get the schema. Then, it fits the estimator on actual data, and get the schema from transformer.\r\n\r\nIt then verifies of both schema are same. However for the case of ngram transform, schema learnt from EmptyDataView is different from actually learned from data. The actual cause is size of ngram is zero in case of training on EmptyDataView which causes output vector type to be variable length. Additionally, some other meta are not filled properly in this case.\r\n\r\nBecause of this following tests are failing right now.\r\n\r\nWordBagWorkout\r\nNgramWorkout\r\n\r\nNeed to think how to fix it.","Url":"https://github.com/dotnet/machinelearning/issues/969","RelatedDescription":"Open issue \"TestEstimatorCore fails when training on EmptyDataView for Ngram based transforms.\" (#969)"},{"Id":"362359358","IsPullRequest":false,"CreatedAt":"2018-09-20T20:47:48","Actor":"wschin","Number":"968","RawContent":null,"Title":"Handle unreachable ONNX variables when saving as ONNX","State":"open","Body":"As title. Sometime, we end up with a computation graph with unreachable variables. We have `inputsToDrop` and `outputsToDrop` for manually removing them but it'd be better to have an automatic mechanism. #952 includes a solution.","Url":"https://github.com/dotnet/machinelearning/issues/968","RelatedDescription":"Open issue \"Handle unreachable ONNX variables when saving as ONNX\" (#968)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-09-24T05:30:36.317756Z","RunDurationInMilliseconds":1025}