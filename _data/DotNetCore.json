{"Data":{"Blog":{"FeedItems":[{"Title":"Announcing the Windows Compatibility Pack for .NET Core","PublishedOn":"2017-11-17T04:59:32+00:00","CommentsCount":36,"FacebookCount":0,"Summary":"Porting existing code to .NET Core used to be quite hard because the available API set was very small. In .NET Core 2.0, we already made this much easier, thanks to .NET Standard 2.0. Today,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/","RawContent":null},{"Title":"UPDATE – Microservices and Docker containers: Architecture, Patterns and Development guidance (Updated for .NET Core 2.0)","PublishedOn":"2017-11-16T22:00:06+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published this eBook/guide and sample application offering guidance for architecting microservices and Docker containers based applications. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-microservices-and-docker-containers-architecture-patterns-and-development-guidance-updated-for-net-core-2-0/","RawContent":null},{"Title":"UPDATE – Web Applications with ASP.NET Core Architecture and Patterns guidance (Updated for ASP.NET Core 2)","PublishedOn":"2017-11-16T21:00:05+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published an eBook/Guide and sample application offering guidance named Architecting Modern Web Applications with ASP.NET Core and Microsoft Azure. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-web-applications-with-asp-net-core-architecture-and-patterns-guidance-updated-for-asp-net-core-2/","RawContent":null},{"Title":"Introducing Tensor for multi-dimensional Machine Learning and AI data","PublishedOn":"2017-11-15T22:00:18+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"Overview Tensor is an exchange type for homogenous multi-dimensional data for 1 to N dimensions. The motivation behind introducing Tensor&#60;T&#62; is to make it easy for Machine Learning library...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/introducing-tensor-for-multi-dimensional-machine-learning-and-ai-data/","RawContent":null},{"Title":"Introducing Nullable Reference Types in C#","PublishedOn":"2017-11-15T20:00:47+00:00","CommentsCount":170,"FacebookCount":0,"Summary":"Today we released a prototype of a C# feature called &#8220;nullable reference types&#8220;, which is intended to help you find and fix most of your null-related bugs before they blow up at runtime....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/","RawContent":null},{"Title":"Announcing F# support for .NET Core and .NET Standard projects in Visual Studio","PublishedOn":"2017-11-15T19:00:49+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"We&#8217;re pleased to announce that Visual Studio 2017 15.5 Preview 4 now supports F# projects targeting .NET Core, .NET Standard, and .NET Framework through the .NET Core SDK. Some of you have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/announcing-f-support-for-net-core-and-net-standard-projects-in-visual-studio/","RawContent":null},{"Title":"Welcome to C# 7.2 and Span","PublishedOn":"2017-11-15T19:00:26+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"C# 7.2 is the latest point release of C#, and adds a number of small but useful features. All the features are described in wonderful detail in the docs. Start with the overview, What&#8217;s new in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/welcome-to-c-7-2-and-span/","RawContent":null},{"Title":".NET Core November 2017 Update","PublishedOn":"2017-11-15T05:25:23+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core November Update. This includes .NET Core 1.0.8, 1.1.5 and 2.0.1 and .NET Core SDK 1.1.5 and 2.0.3. Details regarding the security issues addressed by this release...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-core-november-2017-update/","RawContent":null},{"Title":".NET Framework November 2017 Security and Quality Rollup","PublishedOn":"2017-11-15T03:54:36+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"Today, we are releasing the November 2017 Security and Quality Rollup. Security This release contains no new security updates. The most recent .NET security updates were shipped with the September...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-framework-november-2017-security-and-quality-rollup/","RawContent":null},{"Title":"Modernize existing .NET apps with Windows Containers and Azure","PublishedOn":"2017-11-01T23:14:48+00:00","CommentsCount":22,"FacebookCount":0,"Summary":"As part of the series of posts announced at this initial blog post (.NET Application Architecture Guidance) that explores each of the architecture areas currently covered by our team, this current...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/01/modernize-existing-net-apps-with-windows-containers-and-azure/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6872255902","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:01:26","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Merged pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6872252909","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:00:44","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Merged pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6868854916","Type":"PullRequestEvent","CreatedAt":"2017-11-17T09:04:03","Actor":"AndreyAkinshin","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Opened pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6816687850","Type":"IssuesEvent","CreatedAt":"2017-11-06T20:30:07","Actor":"Petermarcu","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Closed issue \"File system watcher crash\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."},{"Id":"6797468573","Type":"PullRequestEvent","CreatedAt":"2017-11-01T23:04:17","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Opened pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6767783059","Type":"IssuesEvent","CreatedAt":"2017-10-26T05:52:31","Actor":"HarelM","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Opened issue \"File system watcher crach\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6886438076","Type":"IssuesEvent","CreatedAt":"2017-11-21T19:28:57","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/49","RelatedDescription":"Opened issue \".NET Core Alpine Image Ready for Testing\" (#49) at dotnet/announcements","RelatedBody":"# .NET Core Alpine Image Ready for Testing\r\n\r\nAn [Alpine](https://hub.docker.com/_/alpine/)-based Docker image is now available for .NET Core. Alpine is much smaller than Debian, which we have used for the .NET Core base image to date. There have been many requests for an Alpine image. We are pleased to make it available. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image.\r\n\r\nWe have added two new images:\r\n\r\n- `2.1-runtime-alpine`\r\n- `2.1-runtime-deps-alpine`\r\n\r\nAlpine support is part of the .NET Core 2.1 release. .NET Core 2.1 images are currently provided at the [microsoft/dotnet-nightly](https://hub.docker.com/r/microsoft/dotnet-nightly/) repo, including the new Alpine images. .NET Core 2.1 images will be promoted to the [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) repo when .NET Core 2.1 is shipped as a Preview, expected to be early 2018.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet/dotnet-docker-nightly #500](https://github.com/dotnet/dotnet-docker-nightly/issues/500)\r\n\r\n## Details\r\n\r\n* [dotnet/dotnet-docker-nightly #480](https://github.com/dotnet/dotnet-docker-nightly/pull/480)\r\n* [dotnet/announcements #20](https://github.com/dotnet/announcements/issues/20)\r\n* [dotnet/dotnet-docker-samples #94](https://github.com/dotnet/dotnet-docker-samples/pull/94)\r\n\r\nThe primary goal of Alpine is very small deployments. We have been considering various design decisions to make .NET Core Alpine base images as small as possible to align with that. In this first iteration, we enabled [.NET Core 2.0 Globalization Invariant Mode](https://github.com/dotnet/announcements/issues/20) in order to reduce the default size of the image. This change reduced the image by ~30MB. You can see the reduction in size for .NET Core images relative to Debian in the following table.\r\n\r\n|2.1 Image|Debian|Alpine|\r\n|-----    |------|------|\r\n|`-deps`   |153MB (68MB compressed) |13.8 MB (6MB compressed)|\r\n|`-runtime`|222MB (96MB compressed) |82.5 (34MB compressed)|\r\n\r\nNote: The compressed size is what you will see in a [registry](https://hub.docker.com/r/microsoft/dotnet-nightly/tags/) and is the wire-size cost.\r\n\r\nWe are also considering saving more space by native-compiling fewer assemblies. .NET Core runtime assemblies are native-compiled with the [crossgen tool](https://github.com/dotnet/coreclr/blob/master/Documentation/building/crossgen.md) in the [Ready2Run format](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md). Native-compiled code delivers superior startup performance but at the cost of 2-3x larger files. We have the opportunity to compile less, skipping compiling assemblies in part or in whole. We believe that we can save at least another 10MB through compiling less without a material drop in performance. For scenarios that value size over startup or where wire cost is significant, it may be valuable to aggressively reduce the number/% of compilation.\r\n\r\nAlpine images are only available for .NET Core 2.1. At the current time, only Runtime images are available. We intend to offer SDK images at a later date.\r\n\r\nUse cases that cannot tolerate Globalization invariant mode can reset the `DOTNET_SYSTEM_GLOBALIZATION_INVARIANT` environment variable and install the ICU package. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image with and without Globalization Invariant Mode enabled.\r\n\r\n## Call to Action\r\n\r\nPlease test your workloads with the new Alpine image. In particular, we want to know if enabling .NET Core Globalization Invariant Mode is acceptable/appreciated.\r\n"},{"Id":"6854176970","Type":"IssuesEvent","CreatedAt":"2017-11-14T18:00:49","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Reopened issue \"Microsoft Security Advisory CVE-2017-11770 : Malformed Certificate can cause Denial of Service\" (#44) at dotnet/announcements","RelatedBody":"# Microsoft Security Advisory CVE-2017-11770 \r\n## Malformed Certificate can cause Denial of Service\r\n### Executive Summary \r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in the public versions of .NET Core 1.0 and 1.1, and 2.0. This advisory also provides guidance on what developers can do to update their applications correctly.\r\n\r\nMicrosoft is aware of a security vulnerability in the public version of .NET Core where a malformed certificate or other ASN.1 formatted data could lead to a denial of service via an infinite loop on Linux and macOS.\r\n\r\nSystem administrators are advised to update their .NET Core runtimes to versions 1.0.8, 1.1.5 and 2.0.1. Developers are advised to update their .NET Core SDK to version 2.0.3 or 1.1.5.\r\n### Discussion\r\n\r\nPlease use **** TODO: FILL IN ISSUE LINK *** for discussion of this advisory.\r\n\r\n### Mitigation Factors\r\n.NET Core applications running on Windows are not affected by this vulnerability. \r\n\r\n## Affected Software\r\nThe vulnerabilities affect any Microsoft .NET Core project if it uses any of affected runtime versions listed blow and is running on Linux.\r\n\r\nPlatform  | Runtime Version | Fixed runtime version\r\n----------------|----------------| -------------------------\r\nLinux | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.7<br />1.1.0, 1.1.1, 1.1.2, 1.1.4<br />2.0.0 |  1.0.8<br />1.1.5<br />2.0.1\r\nmacOS | 1.0.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.7<br />1.1.0, 1.1.1, 1.1.2, 1.1.4 |  1.0.8<br />1.1.5\r\n\r\n### Advisory FAQ\r\n#### How do I know if I am affected?\r\n\r\nAny application running against .NET Core 1.0.7 or lower, or 1.1.2 or lower, or 2.0.0 is affected. The default version of the .NET core runtime can be listed by running `dotnet --info`, which should produce output in the form of \r\n\r\n```\r\n.NET Command Line Tools (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n\r\n```\r\n\r\nAs this only displays the latest version of the runtime installed it may hide the fact that you have a vulnerable runtime. A complete list of runtimes can be discovered by performing a directory listing in the install root directories. By default these are\r\n\r\n| Operating System          | Location          |\r\n|---------------------------|-------------------|\r\n| macOS | /usr/local/share/dotnet/shared/Microsoft.NETCore.App/       |\r\n| Supported Linux platforms | /usr/share/dotnet/shared/Microsoft.NETCore.App/       |\r\n\r\nEach runtime version is installed in its own directory, where the directory name is the version number. If you do not have a directory for 1.0.8, 1.1.5 or 2.0.1 then any applications targeting .NET Core will be vulnerable.\r\n\r\n#### How do I fix my affected application?\r\nApplications can be fixed by installing the latest runtimes or SDKs. Typically application servers only install a runtime package, developer machines install SDKs. Installers for the runtimes can be downloaded from the [Runtime and SDK download archive](https://github.com/dotnet/core/blob/master/release-notes/download-archive.md). Version 1.1.5 will also install version 1.0.8 of the runtime.\r\n\r\nIf you have built a [self-contained application](https://docs.microsoft.com/en-us/dotnet/core/deploying/#self-contained-deployments-scd) you must install the new runtime and SDK, recompile your application and redeploy.\r\n\r\n## Other Information\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including Terms and Conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).\r\n\r\n### Support\r\nYou can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue where you can ask questions.\r\n\r\n### What if the update breaks my application?\r\nAn application can be pinned to a previous version of the runtime by editing the [application.runtime.config](https://github.com/dotnet/cli/blob/ede74b6be1406ba0c086b6d5fc1a5d4eacff1f01/Documentation/specs/runtime-configuration-file.md#appnameruntimeconfigjson) file for that application and editing the framework version and setting `rollForward` to `false`. This should be treated as a temporary measure and the application updated to work with the patched versions of the framework.\r\n\r\nNote that this file is optional, you may need to create it for each application alongside the executable.\r\n\r\n### Acknowledgments\r\n\r\nThanks to Bachraty Gergely for reporting this issue.\r\n\r\n### External Links\r\n\r\n[CVE-2017-11770](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8585)\r\n\r\n### Revisions\r\n\r\nV1.0 (Nov 14, 2017): Advisory published.\r\n\r\n_Version 1.0_\r\n_Last Updated 2017-11-14_"},{"Id":"6853282986","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:23:02","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/48","RelatedDescription":"Closed issue \"Reserved\" (#48) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853280485","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:35","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/47","RelatedDescription":"Closed issue \"Reserved\" (#47) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n\r\n"},{"Id":"6853280272","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:33","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/47","RelatedDescription":"Opened issue \"Reserved\" (#47) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n\r\n"},{"Id":"6853278942","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:20","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/46","RelatedDescription":"Closed issue \"Reserved\" (#46) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853278548","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:22:15","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/46","RelatedDescription":"Opened issue \"Reserved\" (#46) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853276874","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:58","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/45","RelatedDescription":"Closed issue \"Reserved\" (#45) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853274106","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:28","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Closed issue \"Reserved\" (#44) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"},{"Id":"6853272527","Type":"IssuesEvent","CreatedAt":"2017-11-14T15:21:12","Actor":"blowdart","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/44","RelatedDescription":"Opened issue \"Reserved\" (#44) at dotnet/announcements","RelatedBody":"_This issue has been reserved for a potential future security announcement._\r\n\r\nThis does **not** mean a security advisory is coming soon, it simply gives us the ability to predict the issue number that will be used in the future.\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"6901324035","Type":"PullRequestEvent","CreatedAt":"2017-11-25T05:23:19","Actor":"dotnet-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15213","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/corefx\" (#15213) at dotnet/coreclr","RelatedBody":"This PR contains mirrored changes from dotnet/corefx\n\n\n**Please REBASE this PR when merging**"},{"Id":"6901216780","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:32:55","Actor":"danmosemsft","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15212","RelatedDescription":"Opened pull request \"Fix resx typo\" (#15212) at dotnet/coreclr","RelatedBody":""},{"Id":"6901189722","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:07:38","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15211","RelatedDescription":"Merged pull request \"Update path\" (#15211) at dotnet/coreclr","RelatedBody":""},{"Id":"6901189597","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:07:31","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15211","RelatedDescription":"Opened pull request \"Update path\" (#15211) at dotnet/coreclr","RelatedBody":""},{"Id":"6901087615","Type":"PullRequestEvent","CreatedAt":"2017-11-25T01:28:39","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15210","RelatedDescription":"Opened pull request \"Update CoreClr to preview1-25925-01 (master)\" (#15210) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"6901082112","Type":"PullRequestEvent","CreatedAt":"2017-11-25T01:23:13","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15209","RelatedDescription":"Merged pull request \"Use build-test for unix jobs\" (#15209) at dotnet/coreclr","RelatedBody":""},{"Id":"6901073321","Type":"PullRequestEvent","CreatedAt":"2017-11-25T01:14:48","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15209","RelatedDescription":"Opened pull request \"Use build-test for unix jobs\" (#15209) at dotnet/coreclr","RelatedBody":""},{"Id":"6900976568","Type":"PullRequestEvent","CreatedAt":"2017-11-24T23:49:37","Actor":"danmosemsft","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15201","RelatedDescription":"Merged pull request \"Key item added to KeyNotFoundException\" (#15201) at dotnet/coreclr","RelatedBody":"issue- dotnet/corefx#5188\r\ncorefx pr - https://github.com/dotnet/corefx/pull/25472 "},{"Id":"6900970508","Type":"PullRequestEvent","CreatedAt":"2017-11-24T23:44:50","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15208","RelatedDescription":"Merged pull request \"Use build-test for unix jobs\" (#15208) at dotnet/coreclr","RelatedBody":""},{"Id":"6900931172","Type":"PullRequestEvent","CreatedAt":"2017-11-24T23:14:11","Actor":"jashook","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15208","RelatedDescription":"Opened pull request \"Use build-test for unix jobs\" (#15208) at dotnet/coreclr","RelatedBody":""},{"Id":"6900895694","Type":"IssuesEvent","CreatedAt":"2017-11-24T22:49:01","Actor":"jkotas","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/coreclr/issues/15207","RelatedDescription":"Closed issue \"Finalizer no longer called in .NET Core 2.0 after GC.Collect / GC.WaitForPendingFinalizers\" (#15207) at dotnet/coreclr","RelatedBody":"I already reported this issue [here](https://github.com/dotnet/core/issues/1115), but realized this repo might be more appropriate. If not, I'll close it. Otherwise I'll close the other.\r\n\r\n# Finalizer no longer called in .NET Core 2.0 after GC.Collect / GC.WaitForPendingFinalizers\r\n\r\nAs of **.NET Core 2.0**, an object's finalizer **is no longer called** when calling `GC.Collect` and `GC.WaitForPendingFinalizers`.\r\n\r\n# General\r\n\r\nTo be clear: the following code works as advertised in .NET Framework 4.7 and earlier; .NET Core 1.1 and earlier; but not in .NET Core 2.0:\r\n\r\n```csharp\r\n[TestClass]\r\npublic class GarbageCollectionTest\r\n{\r\n    [TestMethod]\r\n    [Description(\"Asserts that an un-rooted object's finalizer will be called.\")]\r\n    public void GarbageCollectionTest01()\r\n    {\r\n        // Instantiate a spy to record that the Foo finalizer is called.\r\n        var spy = new Spy();\r\n\r\n        // Instantiate a new Foo.\r\n        var foo = new Foo(spy);\r\n\r\n        // Unroot foo.\r\n        foo = null;\r\n\r\n        // Force a collection.\r\n        GC.Collect(0, GCCollectionMode.Forced, blocking: true);\r\n\r\n        // Wait for all finalizers to have executed.\r\n        GC.WaitForPendingFinalizers();\r\n\r\n        // Assert that Foo's finalizer is called.\r\n        // WARNING: This assertion fails in .NET Core 2.0, but works in .NET Core 1.1 and .NET Framework 4.7 and before.\r\n        Assert.IsTrue(spy.FinalizerIsCalled);\r\n    }\r\n\r\n    private class Spy\r\n    {\r\n        public bool FinalizerIsCalled { get; set; }\r\n    }\r\n\r\n    private class Foo\r\n    {\r\n        ~Foo()\r\n        {\r\n            spy.FinalizerIsCalled = true;\r\n        }\r\n\r\n        public Foo(Spy spy)\r\n        {\r\n            this.spy = spy;\r\n        }\r\n\r\n        private readonly Spy spy;\r\n    }\r\n}\r\n```\r\n\r\nUnit test output:\r\n\r\n![image](https://user-images.githubusercontent.com/938393/33224269-df6ee77a-d167-11e7-857c-2fdfec794574.png)\r\n\r\nTo demonstrate the issue, I created a unit test project for the following frameworks which all share the same .cs file:\r\n\r\n- .NET Framework 4.7 [passing]\r\n- .NET Core 1.0 [passing]\r\n- .NET Core 1.1 [passing]\r\n- .NET Core 2.0 *[failing]*\r\n\r\n[GarbageCollectionTests.zip](https://github.com/dotnet/core/files/1502553/GarbageCollectionTests.zip)\r\n\r\n\r\n"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"6901237029","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:53:44","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8096","RelatedDescription":"Closed pull request \"Merge release/15.5 to master\" (#8096) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/15.5 into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/15.5-to-master-20171124-080044\ngit reset --hard upstream/master\ngit merge upstream/release/15.5\n# Fix merge conflicts\ngit commit\ngit push merges/release/15.5-to-master-20171124-080044 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6901236449","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:53:05","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8095","RelatedDescription":"Merged pull request \"Merge release/2.0.0 to dev/release/2.0\" (#8095) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into dev/release/2.0.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-dev/release/2.0-20171124-080042\ngit reset --hard upstream/dev/release/2.0\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-dev/release/2.0-20171124-080042 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6901236081","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:52:42","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8094","RelatedDescription":"Merged pull request \"Merge release/2.0.0 to release/15.5\" (#8094) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/15.5.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/15.5-20171124-080040\ngit reset --hard upstream/release/15.5\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/15.5-20171124-080040 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6901097469","Type":"PullRequestEvent","CreatedAt":"2017-11-25T01:38:21","Actor":"livarcocc","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8097","RelatedDescription":"Merged pull request \"Update CoreSetup to preview1-25924-02 (master)\" (#8097) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6900516245","Type":"PullRequestEvent","CreatedAt":"2017-11-24T19:20:07","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8097","RelatedDescription":"Opened pull request \"Update CoreSetup to preview1-25924-01 (master)\" (#8097) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"6898118481","Type":"PullRequestEvent","CreatedAt":"2017-11-24T08:00:47","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8096","RelatedDescription":"Opened pull request \"Merge release/15.5 to master\" (#8096) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/15.5 into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/15.5-to-master-20171124-080044\ngit reset --hard upstream/master\ngit merge upstream/release/15.5\n# Fix merge conflicts\ngit commit\ngit push merges/release/15.5-to-master-20171124-080044 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6898118383","Type":"PullRequestEvent","CreatedAt":"2017-11-24T08:00:46","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8095","RelatedDescription":"Opened pull request \"Merge release/2.0.0 to dev/release/2.0\" (#8095) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into dev/release/2.0.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-dev/release/2.0-20171124-080042\ngit reset --hard upstream/dev/release/2.0\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-dev/release/2.0-20171124-080042 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6898118309","Type":"PullRequestEvent","CreatedAt":"2017-11-24T08:00:43","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8094","RelatedDescription":"Opened pull request \"Merge release/2.0.0 to release/15.5\" (#8094) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/15.5.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/15.5-20171124-080040\ngit reset --hard upstream/release/15.5\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/15.5-20171124-080040 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"6893875796","Type":"IssuesEvent","CreatedAt":"2017-11-23T07:25:10","Actor":"WalterEbbers","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/575","RelatedDescription":"Closed issue \".NET Standard 2.0 / .NET Framework 4.6.1 Could not load file or assembly 'System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'. The system cannot find the file specified.\" (#575) at dotnet/standard","RelatedBody":"Hi,\r\nI have a .NET Standard 2.0 library which references a few NET 4.6.1 libraries. \r\nThe .NET Standard library will be used in a .NET Core web application. \r\nThe .NET 4.6.1 Framework uses library 'System.ServiceModel.dll' for WCF calls.\r\n\r\nI try to do the following. \r\nMy .NET Core webapp goes to the .NET Standard library which calls something from my .NET Framework 4.6.1 project. But at that moment i get the following error: \r\n'Could not load file or assembly 'System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'. The system cannot find the file specified.'\r\n\r\nThe 'System.ServiceModel.dll' is referenced as a assemblyreference in the .NET Standard project and the .NET Core webapp. \r\n\r\nI really thought that this would work but sadly it doesn't. Is this a issue with the .NET libraries?\r\nDo i need to change things in my .NET Standard / Core project?\r\n\r\nThnx in advance :) \r\n\r\nWalter\r\n\r\n\r\n\r\n"},{"Id":"6891923193","Type":"IssuesEvent","CreatedAt":"2017-11-22T18:51:46","Actor":"mb236","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/591","RelatedDescription":"Opened issue \".NET Standard 2 Library missing assembly error\" (#591) at dotnet/standard","RelatedBody":"I'm currently working on migrating a PCL to a .NET Standard 2.0 Library. After I have readded all NuGet dependencies I get the following error:\r\n`The type 'IReflectable' is defined in an assembly that is not referenced. You must add a reference to assembly 'System.Reflection, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'`\r\n\r\nThe strange part about it is that i get this error on exactly four lines in the project. If I comment these lines out, the errors are gone and compilation is successful. Is there any fix for this problem?"}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"6901320922","Type":"PullRequestEvent","CreatedAt":"2017-11-25T05:20:21","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25448","RelatedDescription":null,"RelatedBody":"Api Approved\r\nissue- #25094\r\nPR implementation link = https://github.com/dotnet/coreclr/pull/15180"},{"Id":"6901320833","Type":"PullRequestEvent","CreatedAt":"2017-11-25T05:20:17","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/25448","RelatedDescription":"Closed pull request \"Tests for new string.contains Api\" (#25448) at dotnet/corefx","RelatedBody":"Api Approved\r\nissue- #25094\r\nPR implementation link = https://github.com/dotnet/coreclr/pull/15180"},{"Id":"6901320322","Type":"PullRequestEvent","CreatedAt":"2017-11-25T05:19:50","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25472","RelatedDescription":null,"RelatedBody":"Fix #5188\r\ncoreclr pr - https://github.com/dotnet/coreclr/pull/15201"},{"Id":"6901320234","Type":"PullRequestEvent","CreatedAt":"2017-11-25T05:19:44","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/pull/25472","RelatedDescription":"Closed pull request \"Key item added to KeyNotFoundException\" (#25472) at dotnet/corefx","RelatedBody":"Fix #5188\r\ncoreclr pr - https://github.com/dotnet/coreclr/pull/15201"},{"Id":"6901319931","Type":"PullRequestEvent","CreatedAt":"2017-11-25T05:19:28","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/25490","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#25490) at dotnet/corefx","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6901269781","Type":"PullRequestEvent","CreatedAt":"2017-11-25T04:27:08","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/25065","RelatedDescription":"Merged pull request \"Correct unit tests for Environment.SetEnvironmentVariable\" (#25065) at dotnet/corefx","RelatedBody":"Fix #16766"},{"Id":"6901269776","Type":"IssuesEvent","CreatedAt":"2017-11-25T04:27:08","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/16766","RelatedDescription":"Closed issue \"System.Environment rejects env variable values acceptable to the OS\" (#16766) at dotnet/corefx","RelatedBody":"\r\nIn https://github.com/dotnet/coreclr/issues/9793 an environment variable already set in the OS caused an ArgumentException when MSBuild tried to set it because the length of the value was over 32KB. (CI apparently passes the change description in an environment variable)\r\n\r\nWe should accept any environment variable that's acceptable to the OS. Apparently on Windows Server 2012 (this run) over 32KB is acceptable. Rather than check the length we should perhaps let Windows return an error.\r\n\r\nhttps://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Environment.cs#L45\r\nhttps://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Environment.cs#L843"},{"Id":"6901216437","Type":"PullRequestEvent","CreatedAt":"2017-11-25T03:32:35","Actor":"danmosemsft","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/25493","RelatedDescription":"Opened pull request \"Fix resx typo\" (#25493) at dotnet/corefx","RelatedBody":""}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"6900868489","Type":"IssuesEvent","CreatedAt":"2017-11-24T22:30:36","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/22648","RelatedDescription":"Closed issue \"Should `LoweredDynamicOperationFactory.GetArgumentInfo` handle `in`?\" (#22648) at dotnet/roslyn","RelatedBody":"This was spawned by reviewing code that makes use of `RefKind.Out` and asking whether it should handle `RefKind.In` as well.\r\n\r\n```C#\r\npublic partial class C \r\n{\r\n    void M()\r\n    {\r\n        int x = 1;\r\n     \tdynamic d = this;\r\n        d.M(ref x); // works\r\n        d.M(x); // runtime error\r\n        d.M(in x); // runtime error\r\n    }\r\n    void M2(in int x) { }\r\n}\r\n```\r\n\r\nTagging @OmarTawfik to confirm this accurately describes what we tested.\r\nFYI @VSadov "},{"Id":"6900791531","Type":"IssuesEvent","CreatedAt":"2017-11-24T21:44:03","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/20229","RelatedDescription":"Closed issue \"Unable to suppress CS2002\" (#20229) at dotnet/roslyn","RelatedBody":"**Version Used**: 2.2.0.61624\r\n\r\n**Steps to Reproduce**: Create a new .NET Standard project, add `<NoWarn>2002</NoWarn>` and include some files twice.\r\n\r\n**Expected Behavior**: No CS2002\r\n\r\n**Actual Behavior**: `Source file ... specified multiple times`\r\n\r\nI'm not sure whether this is intentional since not many people want to include duplicate files anyway. However, I need to include duplicate files to work around a bug where Visual Studio doesn't pick up on some auto-generated code files, so it would be really useful to suppress these warnings.\r\n"},{"Id":"6900746746","Type":"IssuesEvent","CreatedAt":"2017-11-24T21:18:19","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/21236","RelatedDescription":"Closed issue \"Test plan for \"non-trailing named arguments\" (7.2)\" (#21236) at dotnet/roslyn","RelatedBody":"Test Plan for Non-Trailing Named Arguments\r\n==========================================\r\n\r\nThe draft specification needs to describe the error situation as an error.\r\n\r\nTest for proper execution in simple positive test cases\r\n- [x] Method call `M(1, b: 2, 3)` (see `TestSimple`)\r\n- [x] Constructor `new C(1, b: 2, 3)` (see `TestSimpleConstructor`)\r\n- [x] Indexer `c[1, b: 2, 3]` (see `TestSimpleIndexer`)\r\n- [x] Attribute `[MyAttr(1, b: 2, 3)]` (see `TestInAttribute`)\r\n- [x] Extension method invocation. (see `TestSimpleExtension`)\r\n- [x] Delegate Invocation (see `TestSimpleDelegate`)\r\n- [x] Local function invocation (see `TestSimpleLocalFunction`)\r\n- [x] `this(...)` and `base(...)` (see `TestSimpleThis` and `TestSimpleBase`)\r\n\r\nYou can set a property in an attribute spec using `[A(a, b, P=1)]`. Ensure you can still do that after a positional argument following an in-place named argument. Is there a way of exercising an equivalent thing in VB?\r\n\r\nTest that the above positive cases are errors when language version is < 7.2. (see `TestNamedAndOptionalParamsErrors`, `TestDynamicCallErrors`, `TestDynamicCallErrors`, error `CS1738`, see most Simple test cases which also test old langversion)\r\n\r\nTest for errors in simple negative test cases\r\n- [x] Method call `M(b: 2, 3)` (see `TestSimpleError`)\r\n- [x] Other kinds of invocations, above (a couple of combinations are tested, but not all)\r\n\r\nTest showing that *any* named argument out of position disallows following values\r\n- [x] Method call `M(b: 2, a: 1, c: 3, 4)` (see `TestPositionalUnaffected2`, error `CS8321`)\r\n- [x] Other kinds, above\r\n\r\nDemonstrate interaction with kinds of symbols\r\n- [x] Feature should be operative in symbols from source, metadata, and in a reference to another compilation (see `TestMetadataAndPESymbols`)\r\n- [X] Should work for methods that are generic, permitting type inference from arguments in the call. (see `TestGenericInference`)\r\n  - [ ] VB too (has been hand-verified)\r\n\r\nDemonstrate interaction with `params`\r\n- [x] If there is a named argument for the `params` (last) parameter, no further arguments can be specified without names. Not even that same parameter. (see `TestNamedParams`, `TestNamedParams2`, `TestTwiceNamedParams`, `TestNamedParams5`)\r\n- [ ] Even when this feature is used for preceding arguments, a named argument may still name the `params` parameter either in expanded or unexpanded form. (see `TestParams`, `TestParams2`) **Need test for unexpanded form (has been hand-verified).**\r\n\r\nDemonstrate that optional parameters may be omitted after taking advantage of this feature for leading parameters.\r\n\r\nDemonstrate interaction with `dynamic`\r\n- [x] A dynamic invocation should forbid any positional argument following a named argument. (see `TestDynamicInvocation`)\r\n- [x] Some invocations involving dynamic are not dynamic invocations (i.e. do not involve the use of the dynamic binder to resolve the invocation). Reportedly `c[a: 1, dyn] = dyn` (an indexer) is one example. Test that the feature may be used in those cases. See Ashley's email for a list of cases. (see `TestDynamicWhenNotInvocation`)\r\n- [x] In VB, something similar occurs with `Option Strict Off` and calls that involve the type `Object`. We should not permit non-trailing named arguments in VB late-bound calls. (see `TestDynamicInvocation` in VB)\r\n\r\nDemonstrate interaction with [`__arglist`](http://bartdesmet.net/blogs/bart/archive/2006/09/28/4473.aspx)\r\n- [x] `__arglist` should act like a positional parameter that cannot be named\r\n  - [x] Can use `__arglist` after named arguments in proper position (see `TestSimpleArglist`)\r\n  - [x] Cannot use `__arglist` after named arguments out of proper position (see `TestSimpleArglistAfterOutOfPositionArg`)\r\n\r\nLanguage Version\r\n- [x] Feature only works in language version 7.2 (C#)\r\n- [x] Feature only works in language version 15.5 (VB)\r\n\r\nIDE integration\r\n- [ ] The \"add argument name\" IDE action no longer adds names to following arguments in language version 7.2 (see `TestNonTrailingNamedArgumentInCSharp7_2`) **That is a completion test, not a test for 'add argument name'**\r\n- [ ] The \"add argument name\" IDE action adds names to following arguments in language version < 7.2 (see `TestNonTrailingNamedArgumentInCSharp7_1`) **That is a completion test, not a test for 'add argument name'**\r\n- [ ] It should have an option to \"add all argument names\" (which before would have been accomplished by adding a name to the first argument) in language version 7.2 [jcouv: this is not currently planned]\r\n- [ ] These should be true for all four invocation forms identifier above\r\n- [ ] Language version upgrade suggested when needed\r\n  - [x] C# *Hand-tested, verified working*\r\n  - [ ] VB **Hand-tested, *verified not working***\r\n\r\nCompiler APIs\r\n- [x] The SemanticModel APIs that can return the symbol of an argument name in a named argument work even when this feature is used. \r\n- [x] What is the kind of result when a call is unambiguous but has a named-arg-out-of-position-followed-by-positional problem `CandidateReason.OverloadResolutionFailure`? Demonstrate. (see ` TestPositionalUnaffected2`)\r\n\r\n## Pointers to related links:\r\n- PR to master: https://github.com/dotnet/roslyn/pull/20805\r\n- language proposal: https://github.com/dotnet/csharplang/blob/master/proposals/non-trailing-named-arguments.md\r\n- work items: https://github.com/dotnet/roslyn/issues/19890"},{"Id":"6900637261","Type":"IssuesEvent","CreatedAt":"2017-11-24T20:20:03","Actor":"jnm2","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23373","RelatedDescription":"Opened issue \"Ambiguous type reference should suggest adding a using alias\" (#23373) at dotnet/roslyn","RelatedBody":"(Following the pattern of reporting my most frequent ReSharper quick actions with the goal of being able to use vanilla VS one day.)\r\n\r\nMost times that I have an ambiguous type reference I don't want to resolve it by fully qualifying. It can appear many files in a file. My resolution of choice is to add `using TypeName = The.Namespace.I.Want.TypeName`."}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"6901248171","Type":"PullRequestEvent","CreatedAt":"2017-11-25T04:05:06","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5021","RelatedDescription":"Merged pull request \"Merge master to nmirror\" (#5021) at dotnet/corert","RelatedBody":""},{"Id":"6901247857","Type":"PullRequestEvent","CreatedAt":"2017-11-25T04:04:44","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5021","RelatedDescription":"Opened pull request \"Merge master to nmirror\" (#5021) at dotnet/corert","RelatedBody":""},{"Id":"6901246805","Type":"PullRequestEvent","CreatedAt":"2017-11-25T04:03:35","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5020","RelatedDescription":"Merged pull request \"Mirror changes from dotnet/coreclr\" (#5020) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6900978066","Type":"PullRequestEvent","CreatedAt":"2017-11-24T23:50:40","Actor":"dotnet-bot","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5020","RelatedDescription":"Opened pull request \"Mirror changes from dotnet/coreclr\" (#5020) at dotnet/corert","RelatedBody":"This PR contains mirrored changes from dotnet/coreclr\n\n\n**Please REBASE this PR when merging**"},{"Id":"6900683928","Type":"IssuesEvent","CreatedAt":"2017-11-24T20:44:17","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5019","RelatedDescription":"Opened issue \"Use scanner analysis to aid devirtualization\" (#5019) at dotnet/corert","RelatedBody":"I originally thought this would just be a perf optimization we can do later, but it turns out this is needed for making devirtualization working with our IL scanner at all.\r\n\r\nAs a refresher - scanning phase in the compiler tries to determine the exact set of methods that we're going to compile so that we can precompute generic dictionary layouts or vtable layouts. There's an essential invariant that says that we're never allowed to end up in a situation where the compilation phase generates more code than the scanning phase. \r\n\r\nBut consider:\r\n\r\n```csharp\r\nabstract class Base\r\n{\r\n    public abstract void Unreachable();\r\n}\r\n\r\nsealed class Derived : Base\r\n{\r\n    public override void Unreachable()\r\n    {\r\n        new Derived();\r\n    }\r\n}\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        Derived p = null;\r\n        if (args == null)\r\n            p.Unreachable();\r\n    }\r\n}\r\n```\r\n\r\nIn this example, the virtual call to `Unreachable` doesn't result in scanning any method bodies, since no type with this method in the VTable got ever allocated. Scanner doesn't do devirtualization, because it's an optimization step that the codegen may or may not do. We don't try to predict what the codegen will do. Scanning more things than what we end up compiling is harmless (although it's wasting CPU cycles, so we try hard not to do it).\r\n\r\nThe simplified devirtualization algorithm we have in CorInfoImpl.cs that RyuJIT uses however will devirtualize the virtual call into a direct call to Derived::Unreachable. Bad things happen as a result.\r\n\r\nThe devirtualization algorithm needs to take into consideration the information we collected during scanning and abort the devirtualization in this case."},{"Id":"6900174608","Type":"PullRequestEvent","CreatedAt":"2017-11-24T16:59:22","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5016","RelatedDescription":"Merged pull request \"Fix up stack trace formatter to support general purpose metadata\" (#5016) at dotnet/corert","RelatedBody":"The stack trace formatter was written to support the metadata format emitted by the stack trace metadata emitter, but it turns out it doesn't support the more general purpose constructs that I made it parse after #5004.\r\n\r\nThe general purpose signature for a method on a generic type that takes T as a parameter is `ReturnType Foo(!0)`. The formatter needs to format the parameter `!0` as `T` (i.e. we need to do substitution for formals).\r\n\r\nThe code is less than ideal, mostly because it also needs to support metadata constructs that would be illegal in ECMA-335, but are relatively compact when it comes to binary representation, so we use them in the stack trace emitter."},{"Id":"6899975517","Type":"IssuesEvent","CreatedAt":"2017-11-24T16:02:21","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5018","RelatedDescription":"Closed issue \"KeyNotFoundException in ScannedVTableProvider.GetSlice\" (#5018) at dotnet/corert","RelatedBody":"_From @dlewis-arcontech_\r\n\r\nhttps://github.com/dotnet/corert/pull/4935#issuecomment-346856941\r\n\r\nI was just trying a simple test from https://github.com/dotnet/BenchmarkDotNet, Using dotnet add package BenchmarkDotNet --version 0.10.10 then:\r\n\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\n\r\nThen put [Benchmark] around a method to benchmark and in main run the benchmark:\r\n\r\nvar summary = BenchmarkRunner.Run<DispatcherTest>();\r\n\r\nA bit more detail from the issue from the publish step:\r\n\r\nEXEC : error : Code generation failed [/home/darren/DNAStandard/ConsoleApp1/ConsoleApp1.csproj]\r\n  ILCompiler.CodeGenerationFailedException: Code generation failed ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n     at System.ThrowHelper.ThrowKeyNotFoundException()\r\n     at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n     at ILCompiler.ILScanResults.ScannedVTableProvider.GetSlice(TypeDesc type) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/ILScanner.cs:line 130\r\n     at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n     at ILCompiler.Compilation.HasFixedSlotVTable(TypeDesc type) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/Compilation.cs:line 178\r\n     at Internal.JitInterface.CorInfoImpl.getCallInfo(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoImpl.cs:line 3233\r\n     at Internal.JitInterface.CorInfoImpl._getCallInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoBase.cs:line 2232\r\n     --- End of inner exception stack trace ---\r\n     at Internal.JitInterface.CorInfoImpl.CompileMethod(IMethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoImpl.cs:line 187\r\n     at ILCompiler.RyuJitCompilation.ComputeDependencyNodeDependencies(List`1 obj) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/RyuJitCompilation.cs:line 72\r\n     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes() in /home/darren/git/corert/corert/src/ILCompiler.DependencyAnalysisFramework/src/DependencyAnalyzer.cs:line 262\r\n     at ILCompiler.RyuJitCompilation.CompileInternal(String outputFile, ObjectDumper dumper) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/RyuJitCompilation.cs:line 39\r\n     at ILCompiler.Compilation.ILCompiler.ICompilation.Compile(String outputFile, ObjectDumper dumper) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/Compilation.cs:line 307\r\n     at ILCompiler.Program.Run(String[] args) in /home/darren/git/corert/corert/src/ILCompiler/src/Program.cs:line 422\r\n     at ILCompiler.Program.Main(String[] args) in /home/darren/git/corert/corert/src/ILCompiler/src/Program.cs:line 576\r\n/home/darren/git/corert/corert/bin/Linux.x64.Release/build/Microsoft.NETCore.Native.targets(129,5): error MSB3073: The command \"\"/home/darren/git/corert/corert/bin/Linux.x64.Release/tools/ilc\" @\"obj/Release/netcoreapp2.0/linux-x64/native/ConsoleApp1.ilc.rsp\"\" exited with code 1. [/home/darren/DNAStandard/ConsoleApp1/ConsoleApp1.csproj]\r\n\r\nI'll move onto a simple test case with a StopWatch and try to work out what is taking the extra time and I'll also try to remove various sections of code to see why the dispatching thread is taking more memory in CoreRT."},{"Id":"6899965091","Type":"IssuesEvent","CreatedAt":"2017-11-24T15:59:43","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5018","RelatedDescription":"Opened issue \"KeyNotFoundException in ScannedVTableProvider.GetSlice\" (#5018) at dotnet/corert","RelatedBody":"_From @dlewis-arcontech_\r\n\r\nhttps://github.com/dotnet/corert/pull/4935#issuecomment-346856941\r\n\r\nI was just trying a simple test from https://github.com/dotnet/BenchmarkDotNet, Using dotnet add package BenchmarkDotNet --version 0.10.10 then:\r\n\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\n\r\nThen put [Benchmark] around a method to benchmark and in main run the benchmark:\r\n\r\nvar summary = BenchmarkRunner.Run<DispatcherTest>();\r\n\r\nA bit more detail from the issue from the publish step:\r\n\r\nEXEC : error : Code generation failed [/home/darren/DNAStandard/ConsoleApp1/ConsoleApp1.csproj]\r\n  ILCompiler.CodeGenerationFailedException: Code generation failed ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n     at System.ThrowHelper.ThrowKeyNotFoundException()\r\n     at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n     at ILCompiler.ILScanResults.ScannedVTableProvider.GetSlice(TypeDesc type) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/ILScanner.cs:line 130\r\n     at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)\r\n     at ILCompiler.Compilation.HasFixedSlotVTable(TypeDesc type) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/Compilation.cs:line 178\r\n     at Internal.JitInterface.CorInfoImpl.getCallInfo(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoImpl.cs:line 3233\r\n     at Internal.JitInterface.CorInfoImpl._getCallInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoBase.cs:line 2232\r\n     --- End of inner exception stack trace ---\r\n     at Internal.JitInterface.CorInfoImpl.CompileMethod(IMethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoImpl.cs:line 187\r\n     at ILCompiler.RyuJitCompilation.ComputeDependencyNodeDependencies(List`1 obj) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/RyuJitCompilation.cs:line 72\r\n     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes() in /home/darren/git/corert/corert/src/ILCompiler.DependencyAnalysisFramework/src/DependencyAnalyzer.cs:line 262\r\n     at ILCompiler.RyuJitCompilation.CompileInternal(String outputFile, ObjectDumper dumper) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/RyuJitCompilation.cs:line 39\r\n     at ILCompiler.Compilation.ILCompiler.ICompilation.Compile(String outputFile, ObjectDumper dumper) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/Compilation.cs:line 307\r\n     at ILCompiler.Program.Run(String[] args) in /home/darren/git/corert/corert/src/ILCompiler/src/Program.cs:line 422\r\n     at ILCompiler.Program.Main(String[] args) in /home/darren/git/corert/corert/src/ILCompiler/src/Program.cs:line 576\r\n/home/darren/git/corert/corert/bin/Linux.x64.Release/build/Microsoft.NETCore.Native.targets(129,5): error MSB3073: The command \"\"/home/darren/git/corert/corert/bin/Linux.x64.Release/tools/ilc\" @\"obj/Release/netcoreapp2.0/linux-x64/native/ConsoleApp1.ilc.rsp\"\" exited with code 1. [/home/darren/DNAStandard/ConsoleApp1/ConsoleApp1.csproj]\r\n\r\nI'll move onto a simple test case with a StopWatch and try to work out what is taking the extra time and I'll also try to remove various sections of code to see why the dispatching thread is taking more memory in CoreRT."},{"Id":"6899962842","Type":"IssuesEvent","CreatedAt":"2017-11-24T15:59:07","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5017","RelatedDescription":"Opened issue \"ILCompiler crash under ILCompiler.ILScanResults.ScannedVTableProvider.GetSlice\" (#5017) at dotnet/corert","RelatedBody":"From https://github.com/dotnet/corert/pull/4935#issuecomment-346856941\r\n\r\nI was just trying a simple test from https://github.com/dotnet/BenchmarkDotNet, Using dotnet add package BenchmarkDotNet --version 0.10.10 then:\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\nThen put [Benchmark] around a method to benchmark and in main run the benchmark:\r\nvar summary = BenchmarkRunner.Run();\r\nA bit more detail from the issue from the publish step:\r\nEXEC : error : Code generation failed [/home/darren/DNAStandard/ConsoleApp1/ConsoleApp1.csproj]\r\nILCompiler.CodeGenerationFailedException: Code generation failed ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\nat System.ThrowHelper.ThrowKeyNotFoundException()\r\nat System.Collections.Generic.Dictionary2.get_Item(TKey key) at ILCompiler.ILScanResults.ScannedVTableProvider.GetSlice(TypeDesc type) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/ILScanner.cs:line 130 at System.Collections.Concurrent.ConcurrentDictionary2.GetOrAdd(TKey key, Func2 valueFactory) at ILCompiler.Compilation.HasFixedSlotVTable(TypeDesc type) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/Compilation.cs:line 178 at Internal.JitInterface.CorInfoImpl.getCallInfo(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoImpl.cs:line 3233 at Internal.JitInterface.CorInfoImpl._getCallInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoBase.cs:line 2232 --- End of inner exception stack trace --- at Internal.JitInterface.CorInfoImpl.CompileMethod(IMethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL) in /home/darren/git/corert/corert/src/JitInterface/src/CorInfoImpl.cs:line 187 at ILCompiler.RyuJitCompilation.ComputeDependencyNodeDependencies(List1 obj) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/RyuJitCompilation.cs:line 72\r\nat ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes() in /home/darren/git/corert/corert/src/ILCompiler.DependencyAnalysisFramework/src/DependencyAnalyzer.cs:line 262\r\nat ILCompiler.RyuJitCompilation.CompileInternal(String outputFile, ObjectDumper dumper) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/RyuJitCompilation.cs:line 39\r\nat ILCompiler.Compilation.ILCompiler.ICompilation.Compile(String outputFile, ObjectDumper dumper) in /home/darren/git/corert/corert/src/ILCompiler.Compiler/src/Compiler/Compilation.cs:line 307\r\nat ILCompiler.Program.Run(String[] args) in /home/darren/git/corert/corert/src/ILCompiler/src/Program.cs:line 422\r\nat ILCompiler.Program.Main(String[] args) in /home/darren/git/corert/corert/src/ILCompiler/src/Program.cs:line 576\r\n/home/darren/git/corert/corert/bin/Linux.x64.Release/build/Microsoft.NETCore.Native.targets(129,5): error MSB3073: The command \"\"/home/darren/git/corert/corert/bin/Linux.x64.Release/tools/ilc\" @\"obj/Release/netcoreapp2.0/linux-x64/native/ConsoleApp1.ilc.rsp\"\" exited with code 1. [/home/darren/DNAStandard/ConsoleApp1/ConsoleApp1.csproj]\r\n"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"6898118624","Type":"PullRequestEvent","CreatedAt":"2017-11-24T08:00:50","Actor":"dotnet-bot","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1767","RelatedDescription":"Opened pull request \"Merge release/15.5 to master\" (#1767) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/15.5 into master.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/15.5-to-master-20171124-080047\ngit reset --hard upstream/master\ngit merge upstream/release/15.5\n# Fix merge conflicts\ngit commit\ngit push merges/release/15.5-to-master-20171124-080047 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6898118548","Type":"PullRequestEvent","CreatedAt":"2017-11-24T08:00:48","Actor":"dotnet-bot","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1766","RelatedDescription":"Opened pull request \"Merge release/2.0.0 to release/15.5\" (#1766) at dotnet/sdk","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/15.5.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/15.5-20171124-080045\ngit reset --hard upstream/release/15.5\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/15.5-20171124-080045 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"6893453650","Type":"IssuesEvent","CreatedAt":"2017-11-23T03:54:56","Actor":"livarcocc","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/1623","RelatedDescription":"Closed issue \"SolutionDir is not resolved during dotnet restore\" (#1623) at dotnet/sdk","RelatedBody":"See the following repository that can reproduce the error\r\n\r\nhttps://github.com/bradphelan/msbuildbug\r\n\r\nfirst reported at\r\n\r\nhttps://stackoverflow.com/questions/46526428/msbuild-solutiondir-resolves-incorrectly-to-c-when-running-msbuild-tresto"},{"Id":"6893426284","Type":"IssuesEvent","CreatedAt":"2017-11-23T03:40:34","Actor":"livarcocc","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/issues/1755","RelatedDescription":"Closed issue \".NET Standard 2.0 class library, that references a .NET Framework 4.7.1 class library with PackageReference fails\" (#1755) at dotnet/sdk","RelatedBody":"I have a .NET Standard 2.0 class library, that references a .NET Framework 4.7.1 class library (works fine)\r\n\r\nHowever, if the .NET Framework 4.7.1 adds a PackageReference (new style), I get the following error (possibly due to transitivity):\r\n\r\nError    NU1201           Project ClassLibrary2 is not compatible with netstandard2.0 (.NETStandard,Version=v2.0). Project ClassLibrary2 supports: net471 (.NETFramework,Version=v4.7.1)     \r\n\r\nThe package in question being added can be any package, packages that have support for .NET Standard or otherwise, the same error.\r\n\r\nWhat am I missing?\r\n"},{"Id":"6892887507","Type":"PullRequestEvent","CreatedAt":"2017-11-22T23:22:25","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1765","RelatedDescription":"Opened pull request \"Updating the SDK feeds\" (#1765) at dotnet/sdk","RelatedBody":""},{"Id":"6891834423","Type":"IssuesEvent","CreatedAt":"2017-11-22T18:30:16","Actor":"KirillOsenkov","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/issues/1764","RelatedDescription":"Opened issue \"Transitive Project References without respect for ReferenceOutputAssembly\" (#1764) at dotnet/sdk","RelatedBody":""}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"933058673206730752","CreatedAt":"2017-11-21T19:44:57+00:00","UserScreenname":"dotnet","Text":".NET Core Alpine Image Ready for Testing https://t.co/SsQtOGuAFD","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":206,"FavoriteCount":152,"RawContent":null},{"Id":"932677600715071488","CreatedAt":"2017-11-20T18:30:42+00:00","UserScreenname":"dotnet","Text":"Looking to migrate your existing .NET apps to the cloud but need our help? Fill out this survey and let us know: https://t.co/g6xbbWkX93","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":19,"FavoriteCount":15,"RawContent":null},{"Id":"931580871437635584","CreatedAt":"2017-11-17T17:52:42+00:00","UserScreenname":"dotnet","Text":"Check out our new ConfigurationBuilders that make it easier than ever to use Azure Key Vault, Environment Variables… https://t.co/nXoIDLCubn","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":55,"FavoriteCount":26,"RawContent":null},{"Id":"931255246872915968","CreatedAt":"2017-11-16T20:18:47+00:00","UserScreenname":"dotnet","Text":"Migrate your .NET apps to the cloud and benefit from easier deployments and scalability, without rearchitecting you… https://t.co/gNfBFe3Sbh","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":107,"FavoriteCount":61,"RawContent":null},{"Id":"931205222579318784","CreatedAt":"2017-11-16T17:00:00+00:00","UserScreenname":"dotnet","Text":"Having trouble moving to .NET Core because of missing Windows APIs? Introducing the Windows Compatibility Pack for… https://t.co/s3KKSJ467u","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":149,"FavoriteCount":85,"RawContent":null}]}},"RunOn":"2017-11-25T05:30:20.7144296Z","RunDurationInMilliseconds":7575}