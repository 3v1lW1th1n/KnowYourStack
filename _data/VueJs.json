{"Data":{"Vue":{"Events":[{"Id":"7064248886","Type":"IssuesEvent","CreatedAt":"2018-01-06T04:12:57","Actor":"yyx990803","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue/issues/7393","RelatedDescription":"Closed issue \"`component is=\"input\"` does not handle v-model bindings correctly\" (#7393) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://jsfiddle.net/ccxub2Lu/](https://jsfiddle.net/ccxub2Lu/)\r\n\r\n### Steps to reproduce\r\n- Type in first input\r\n- Type in second input\r\n- Type in third input\r\n- Type in first input again\r\n\r\n### What is expected?\r\nThe 3rd input no longer updates its value after being used once.\r\n\r\n### What is actually happening?\r\n- First input is a regular input field using v-model.\r\n- Second input is a custom component bound using `v-model` and inside has an input with `:value` and `@input`.\r\n- Third input is same as second but uses a `component` with `is='input'`.\r\n\r\nIt seems some v-model related handling of inputs is not being applied to the `component is='input'` case\r\n\r\n---\r\nI am authoring some reusable form components for my application.\r\nRan into this while treating text inputs and textareas identically, and using a `component :is='tagType'`\r\n\r\nFrom my application, it seems that the component is receiving the new `value` prop, but for some reason, it is not updating the actual value in the DOM.\r\n\r\nI am happy to try to fix it, but would appreciate someone pointing me in the right direction, as I have not looked at the internal vue code at all yet.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->\r\n  "},{"Id":"7064244830","Type":"IssuesEvent","CreatedAt":"2018-01-06T04:09:03","Actor":"yyx990803","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue/issues/7395","RelatedDescription":"Closed issue \"forceUpdate does not update computed fields\" (#7395) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://github.com/nagyzsolthun/vue-forceupdate-computed](https://github.com/nagyzsolthun/vue-forceupdate-computed)\r\n\r\n### Steps to reproduce\r\n1) build project\r\n2) open build/build.html\r\n3) wait 2 seconds\r\n\r\n### What is expected?\r\n\"last update time\" to change\r\n\r\n### What is actually happening?\r\n\"last update time\" does not change\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7064243460","Type":"IssuesEvent","CreatedAt":"2018-01-06T04:07:34","Actor":"yyx990803","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue/issues/7394","RelatedDescription":"Closed issue \"Typescript: Computed properties cannot correctly infer even simple return types\" (#7394) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://github.com/wadetandy/vue-computed-typescript-error](https://github.com/wadetandy/vue-computed-typescript-error)\r\n\r\n### Steps to reproduce\r\nAfter cloning the above repo, run `yarn install && yarn dev`.  Yarn will load webpack and attempt to build the project, at which point the typescript compilation will fail on the ErrorReproduction.vue file. Alternatively, open it up in vscode or something else with good typescript integration to see the same errors.\r\n\r\n### What is expected?\r\nIn the affected file, I would expect all of the computed methods to behave with standard type inference due to their very straightforward return types.  Indeed when I access the `this` member, it shows all data members, methods, and even the correct values for the computed properties themselves!\r\n\r\n### What is actually happening?\r\nAny time I try to return a data member from the computed properties, the method gives a type error: \r\n\r\n> `doubleNumber` implicitly has return type `any` because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\r\n\r\nand the value itself gives an error:\r\n\r\n> Property `numVal` does not exist on type `{ doubleNumber(): any; whisperedYell(): any; standalone(): string; }`.\r\n\r\n(note the above no longer includes computed properties or data members)\r\n\r\nAdditionally, hovering my type view over even the `simpleString()` method shows a return type of `any`, even though it should be trivial for vue to figure this type out from the simple string return.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->\r\n  "},{"Id":"7063949454","Type":"IssuesEvent","CreatedAt":"2018-01-06T00:35:34","Actor":"mariomenjr","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue/issues/7396","RelatedDescription":"Opened issue \"Internet Explorer 11 ~ #app div gets deleted\" (#7396) at vuejs/vue","RelatedBody":"Hello! I am new at Vue and I just made an implementation of Vue by a CDN link in a script (not using a package manager).\r\n\r\nEverything works just fine in Chrome and FF but I just cannot make it work on IE I have already try the babel-polyfill thing but nothing worked.\r\n\r\nindex.html\r\n![image](https://user-images.githubusercontent.com/1946936/34634181-6c810c1c-f236-11e7-8cad-e9ef6b7233ad.png)\r\n\r\nvue.js (controller)\r\n![image](https://user-images.githubusercontent.com/1946936/34634179-5c9eb2ae-f236-11e7-9f70-1ad8c582faad.png)\r\n\r\nWhen I open the console view of IE11 it seems that it deletes the #app div\r\n![image](https://user-images.githubusercontent.com/1946936/34634176-55a4e5a4-f236-11e7-9283-e723c06a8bff.png)\r\n\r\nHelp please."},{"Id":"7063907737","Type":"IssuesEvent","CreatedAt":"2018-01-06T00:16:18","Actor":"nagyzsolthun","Repository":"vuejs/vue","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue/issues/7395","RelatedDescription":"Opened issue \"forceUpdate does not update computed fields\" (#7395) at vuejs/vue","RelatedBody":"### Version\r\n2.5.13\r\n\r\n### Reproduction link\r\n[https://github.com/nagyzsolthun/vue-forceupdate-computed](https://github.com/nagyzsolthun/vue-forceupdate-computed)\r\n\r\n### Steps to reproduce\r\n1) build project\r\n2) open build/build.html\r\n3) wait 2 seconds\r\n\r\n### What is expected?\r\n\"last update time\" to change\r\n\r\n### What is actually happening?\r\n\"last update time\" does not change\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"},"Router":{"Events":[{"Id":"7061495472","Type":"IssuesEvent","CreatedAt":"2018-01-05T13:38:20","Actor":"posva","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1964","RelatedDescription":"Closed issue \"Programmatic navigation to the same named component with different params does not work\" (#1964) at vuejs/vue-router","RelatedBody":"### Version\r\n2.7.0\r\n\r\n### Reproduction link\r\n[https://jsfiddle.net/L7hscd8h/3388/](https://jsfiddle.net/L7hscd8h/3388/)\r\n\r\n### Steps to reproduce\r\nAfter fiddle is executed, note the initial output, click `foo`, click `bar`\r\n\r\n### What is expected?\r\nInitially, the executed fiddle will print the following:\r\n\r\n```\r\nclicks: 0\r\nfoo\r\nbar\r\n```\r\n\r\nClicking `foo`, the output will update to:\r\n\r\n```\r\nclicks: 1\r\nfoo\r\nbar\r\n\r\nname = 'foo'\r\n$route.params.name = 'foo'\r\nchangeCount = 0\r\n```\r\n\r\nClicking `bar`, only the `clicks` will be updated:\r\n\r\n```\r\nclicks: 2\r\nfoo\r\nbar\r\n\r\nname = 'bar'\r\n$route.params.name = 'bar'\r\nchangeCount = 1\r\n```\r\n\r\n### What is actually happening?\r\nInitially, the executed fiddle will print the following:\r\n\r\n```\r\nclicks: 0\r\nfoo\r\nbar\r\n```\r\n\r\nClicking `foo`, the output will update to:\r\n\r\n```\r\nclicks: 1\r\nfoo\r\nbar\r\n\r\nname = 'foo'\r\n$route.params.name = 'foo'\r\nchangeCount = 0\r\n```\r\n\r\nClicking `bar`, only the `clicks` will be updated:\r\n\r\n```\r\nclicks: 2\r\nfoo\r\nbar\r\n\r\nname = 'foo'\r\n$route.params.name = 'foo'\r\nchangeCount = 0\r\n```\r\n\r\n---\r\nIt seems that programmatic navigation to the same component with different params does not trigger guard or watcher on the route.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7060642931","Type":"IssuesEvent","CreatedAt":"2018-01-05T09:42:54","Actor":"ardoramor","Repository":"vuejs/vue-router","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vue-router/issues/1964","RelatedDescription":"Opened issue \"Programmatic navigation to the same named component with different params does not work\" (#1964) at vuejs/vue-router","RelatedBody":"### Version\r\n2.7.0\r\n\r\n### Reproduction link\r\n[https://jsfiddle.net/L7hscd8h/3388/](https://jsfiddle.net/L7hscd8h/3388/)\r\n\r\n### Steps to reproduce\r\nAfter fiddle is executed, note the initial output, click `foo`, click `bar`\r\n\r\n### What is expected?\r\nInitially, the executed fiddle will print the following:\r\n\r\n```\r\nclicks: 0\r\nfoo\r\nbar\r\n```\r\n\r\nClicking `foo`, the output will update to:\r\n\r\n```\r\nclicks: 1\r\nfoo\r\nbar\r\n\r\nname = 'foo'\r\n$route.params.name = 'foo'\r\nchangeCount = 0\r\n```\r\n\r\nClicking `bar`, only the `clicks` will be updated:\r\n\r\n```\r\nclicks: 2\r\nfoo\r\nbar\r\n\r\nname = 'bar'\r\n$route.params.name = 'bar'\r\nchangeCount = 1\r\n```\r\n\r\n### What is actually happening?\r\nInitially, the executed fiddle will print the following:\r\n\r\n```\r\nclicks: 0\r\nfoo\r\nbar\r\n```\r\n\r\nClicking `foo`, the output will update to:\r\n\r\n```\r\nclicks: 1\r\nfoo\r\nbar\r\n\r\nname = 'foo'\r\n$route.params.name = 'foo'\r\nchangeCount = 0\r\n```\r\n\r\nClicking `bar`, only the `clicks` will be updated:\r\n\r\n```\r\nclicks: 2\r\nfoo\r\nbar\r\n\r\nname = 'foo'\r\n$route.params.name = 'foo'\r\nchangeCount = 0\r\n```\r\n\r\n---\r\nIt seems that programmatic navigation to the same component with different params does not trigger guard or watcher on the route.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"}],"ResultType":"GitHubEvent"},"Vuex":{"Events":[{"Id":"7059324092","Type":"IssuesEvent","CreatedAt":"2018-01-05T00:50:08","Actor":"gdelazzari","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/1123","RelatedDescription":"Opened issue \"Getters proposal\" (#1123) at vuejs/vuex","RelatedBody":"### What problem does this feature solve?\r\nBetter API consistency, IMHO.\r\n\r\nThere are getters, mutations and actions.\r\nAs for mutations, you use the `$store.commit('mutation-name', stuff)` syntax while for actions you do `$store.dispatch('action-name', stuff)`, which is really nice. But, as for getters, the current approach is `$store.getters.getter-name`.\r\n\r\nFrom a user perspective, I think there's a nicer option that wouldn't also break backwards compatibility since both ways could coexist without any problem.\r\n\r\n### What does the proposed API look like?\r\nSimilar to mutations and actions, I think `$store.getter('getter-name')` could be a better way to call getters.\r\n\r\nThis way the syntax for getters, mutations and actions would be more similar:\r\n\r\n```js\r\n$store.getter('name')\r\n$store.commit('name', data)\r\n$store.dispatch('name', data)\r\n```\r\n\r\n**Note:** I'm not specifically proposing `.getter('name')`. It may be something else like `.fetch(...)` or `.pull(...)` or whatever (the best thing would have been `$store.get('name')` in my opinion, but `.get` is already a JavaScript method on objects so... no way I guess). What I mean is to use a function call like what happens to \"use\" mutations and actions.\r\n\r\nI understand this is totally subjective and I am not expecting everyone to agree on this proposal, but I see this approach as a much cleaner and consistent one.\r\n\r\nAlso, I understand this is just a minor \"thing\" (not even a problem) but I wanted to express my idea anyway in case someone else would find this interesting and/or having any sense.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7059180929","Type":"IssuesEvent","CreatedAt":"2018-01-04T23:53:59","Actor":"TheJaredWilcurt","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/vuejs/vuex/issues/1122","RelatedDescription":"Opened issue \"Some code examples in documentation are mentally exhausting\" (#1122) at vuejs/vuex","RelatedBody":"### What problem does this feature solve?\r\nThere are many code examples in the documentation that are mentally exhausting. The first chunk of the documentation is okay. Once you start into the \"Core Concepts\" section though, the code examples begin to wreak of \"I-am-so-clever\" syndrome. The goal of these sections (State, Getters, Mutations, etc) should be to help the reader understand the *concepts*. When doing so, there should be simple, easy to parse code examples to act as more concrete forms of the concepts being taught.\r\n\r\nBut the examples are optimized for fewest lines of code when they should be optimized for ease of readability. I'm having to mentally break down what each one is doing because they don't follow the \"one idea per line\" rule. And at some point I just get so tired and exhausted that I can't understand it anymore.\r\n\r\nSo the examples being shown end up draining me of mental energy so I can't proceed any further into the concepts I actually came for.\r\n\r\n### What does the proposed API look like?\r\nHere is an existing example I'd like to dissect:\r\n\r\n```js\r\ngetters: {\r\n    // ...\r\n    getTodoById: (state) => (id) => {\r\n        return state.todos.find(todo => todo.id === id)\r\n    }\r\n}\r\n```\r\n\r\nFirst off, why is there a `// ...`???? What is that there for? I assume it's meant to say \"In the real world, there would be other getters too\". Not needed, get rid of it.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: (state) => (id) => {\r\n        return state.todos.find(todo => todo.id === id)\r\n    }\r\n}\r\n```\r\n\r\nNext, little rocket ships going into other little rocket ships is hard to parse both visually and mentally. The problem here lies in over abuse of arrow functions. They are designed with phantom words and exformation. Let's put those phantom words (function, return) back in so we are being clear and verbose about what is trying to be conveyed.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: function (state) {\r\n        return function (id) {\r\n            return state.todos.find(function (todo) {\r\n                return todo.id === id\r\n            })\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe above is no different than before, it's just functions with all the words put back in, but suddenly it starts to look off. This is a sign of arrow function abuse.\r\n\r\nLet's try an experiment where we make the code as verbose as possible, naming every variable and having no shortcuts.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: function (state) {\r\n        function findTodoWithMatchingId (id) {\r\n            const todos = state.todos\r\n            const matchingTodo = todos.find(function (todo) {\r\n                if (todo.id === id) {\r\n                    return true\r\n                }\r\n                return false\r\n            })\r\n            return matchingTodo\r\n        }\r\n        return findTodoWithMatchingId\r\n    }\r\n}\r\n```\r\n\r\nSo, from this experiment we can see that someone thought \"I'm so clever, I bet I can squeeze 15 lines into 5!\". Now, some squeezing is fine, some usage of arrow functions can make sense. Like with `.find`, or `.filter`, or other simple similar prototype methods. So, let's squeeze that verbose version down, but only a little, to get us somewhere between the two extremes.\r\n\r\n```js\r\ngetters: {\r\n    getTodoById: (state) => {\r\n        function findTodoWithMatchingId (id) {\r\n            const todos = state.todos\r\n            const matchingTodo = todos.find(todo => todo.id === id)\r\n            return matchingTodo\r\n        }\r\n        return findTodoWithMatchingId\r\n    }\r\n}\r\n```\r\n\r\nWith this approach, we prioritize naming variables to give meaning, and separating ideas out to individual lines to make skimming/parsing easier. There's definitely wiggle room around what should/shouldn't be compressed when aiming for ease of reading.\r\n\r\nNow the downside of this approach is that you lose some hipster cred. But the upside is that it's verbose and clear, and can be skimmed to understand what is happening. You don't need to mentally unpack 15 lines of meaning out of the 5 lines given. There is no guesswork going on while trying to keep track of the obscured meaning.\r\n\r\nAnyone can look at the last example shown and see ways to compress it and write it differently. If a reader copies that code as the basis of their own code, they'll likely modify it to match the style of their existing code. Which is fine, but as a source of documentation aimed at teaching concepts, it should be the priority of the code to be easily understood.\r\n\r\nThis process of having to mentally translate the code wastes mental energy on tasks unrelated to the goal of understanding the concepts.\r\n\r\n**Note:** My point isn't \"fix this one example\", it's \"most of your examples are like this and it becomes exhausting\".\r\n\r\nI'm sure the code wasn't written by someone literally saying \"look at me, I'm clever, I can do *this*\". I'm sure there's some style guide or linter that is enforcing consistency. But my point is that following it religiously leads to hard to read code, or that it's settings are too strict in ES6 enforcement and don't lend themselves to easily parsable example snippets.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->"},{"Id":"7058622182","Type":"PullRequestEvent","CreatedAt":"2018-01-04T21:10:08","Actor":"Demivan","Repository":"vuejs/vuex","Organization":"vuejs","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/vuejs/vuex/pull/1105","RelatedDescription":"Closed pull request \"Use keyof to improve type inference in helpers\" (#1105) at vuejs/vuex","RelatedBody":"Using map helpers (`mapState`, `mapMutations`, `mapGetters` or `mapActions`) breaks type checking in Vue components.\r\nThis pull request uses `keyof` Typescript 2.1 feature to fix this.\r\nBefore change:\r\n![beforechangethis](https://user-images.githubusercontent.com/2339406/34364035-72720f58-ea8a-11e7-864e-22a3c3794946.png)\r\n![beforechange](https://user-images.githubusercontent.com/2339406/34364036-742542f2-ea8a-11e7-9cd7-151734482cdb.png)\r\nAfter change:\r\n![afterchangethis](https://user-images.githubusercontent.com/2339406/34364039-78e47f92-ea8a-11e7-99ab-72015d1e70d2.png)\r\n![afterchange](https://user-images.githubusercontent.com/2339406/34364040-7a6e293a-ea8a-11e7-888f-d82da9e6ec8f.png)\r\nBreaking change: When using functions as mappings, first parameter (`Commit`, `Dispatch`) type is not inferred, but it is type-checked only."}],"ResultType":"GitHubEvent"}},"RunOn":"2018-01-06T05:30:32.715807Z","RunDurationInMilliseconds":1945}